import {
  require_object_assign
} from "./chunk-T5TDCSU7.js";
import {
  require_jsx_runtime
} from "./chunk-AEPUSVGB.js";
import {
  require_react
} from "./chunk-TJOSTKI6.js";
import {
  __commonJS,
  __export,
  __publicField,
  __require,
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
      return value2 !== value2;
    };
    function EventEmitter3() {
      EventEmitter3.init.call(this);
    }
    module.exports = EventEmitter3;
    module.exports.once = once5;
    EventEmitter3.EventEmitter = EventEmitter3;
    EventEmitter3.prototype._events = void 0;
    EventEmitter3.prototype._eventsCount = 0;
    EventEmitter3.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter3, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter3.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter3.prototype.setMaxListeners = function setMaxListeners3(n4) {
      if (typeof n4 !== "number" || n4 < 0 || NumberIsNaN(n4)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n4 + ".");
      }
      this._maxListeners = n4;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter3.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter3.prototype.getMaxListeners = function getMaxListeners3() {
      return _getMaxListeners(this);
    };
    EventEmitter3.prototype.emit = function emit5(type) {
      var args = [];
      for (var i3 = 1; i3 < arguments.length; i3++) args.push(arguments[i3]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err2 = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err2.context = er;
        throw err2;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners3 = arrayClone3(handler, len);
        for (var i3 = 0; i3 < len; ++i3)
          ReflectApply(listeners3[i3], this, args);
      }
      return true;
    };
    function _addListener3(target, type, listener, prepend) {
      var m;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter3.prototype.addListener = function addListener5(type, listener) {
      return _addListener3(this, type, listener, false);
    };
    EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
    EventEmitter3.prototype.prependListener = function prependListener5(type, listener) {
      return _addListener3(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap3(target, type, listener) {
      var state2 = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state2);
      wrapped.listener = listener;
      state2.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter3.prototype.once = function once6(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap3(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.prependOnceListener = function prependOnceListener3(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap3(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.removeListener = function removeListener5(type, listener) {
      var list, events2, position, i3, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i3 = list.length - 1; i3 >= 0; i3--) {
          if (list[i3] === listener || list[i3].listener === listener) {
            originalListener = list[i3].listener;
            position = i3;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne3(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners5(type) {
      var listeners3, events2, i3;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events2);
        var key;
        for (i3 = 0; i3 < keys2.length; ++i3) {
          key = keys2[i3];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners3 = events2[type];
      if (typeof listeners3 === "function") {
        this.removeListener(type, listeners3);
      } else if (listeners3 !== void 0) {
        for (i3 = listeners3.length - 1; i3 >= 0; i3--) {
          this.removeListener(type, listeners3[i3]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners3(evlistener) : arrayClone3(evlistener, evlistener.length);
    }
    EventEmitter3.prototype.listeners = function listeners3(type) {
      return _listeners(this, type, true);
    };
    EventEmitter3.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter3.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount3.call(emitter, type);
      }
    };
    EventEmitter3.prototype.listenerCount = listenerCount3;
    function listenerCount3(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames3() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone3(arr, n4) {
      var copy5 = new Array(n4);
      for (var i3 = 0; i3 < n4; ++i3)
        copy5[i3] = arr[i3];
      return copy5;
    }
    function spliceOne3(list, index3) {
      for (; index3 + 1 < list.length; index3++)
        list[index3] = list[index3 + 1];
      list.pop();
    }
    function unwrapListeners3(arr) {
      var ret = new Array(arr.length);
      for (var i3 = 0; i3 < ret.length; ++i3) {
        ret[i3] = arr[i3].listener || arr[i3];
      }
      return ret;
    }
    function once5(emitter, name) {
      return new Promise(function(resolve3, reject) {
        function errorListener(err2) {
          emitter.removeListener(name, resolver);
          reject(err2);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve3([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/queue/index.js
var require_queue = __commonJS({
  "node_modules/queue/index.js"(exports, module) {
    var inherits3 = require_inherits_browser();
    var EventEmitter3 = require_events().EventEmitter;
    module.exports = Queue;
    module.exports.default = Queue;
    function Queue(options) {
      if (!(this instanceof Queue)) {
        return new Queue(options);
      }
      EventEmitter3.call(this);
      options = options || {};
      this.concurrency = options.concurrency || Infinity;
      this.timeout = options.timeout || 0;
      this.autostart = options.autostart || false;
      this.results = options.results || null;
      this.pending = 0;
      this.session = 0;
      this.running = false;
      this.jobs = [];
      this.timers = {};
    }
    inherits3(Queue, EventEmitter3);
    var arrayMethods = [
      "pop",
      "shift",
      "indexOf",
      "lastIndexOf"
    ];
    arrayMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        return Array.prototype[method].apply(this.jobs, arguments);
      };
    });
    Queue.prototype.slice = function(begin, end2) {
      this.jobs = this.jobs.slice(begin, end2);
      return this;
    };
    Queue.prototype.reverse = function() {
      this.jobs.reverse();
      return this;
    };
    var arrayAddMethods = [
      "push",
      "unshift",
      "splice"
    ];
    arrayAddMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        var methodResult = Array.prototype[method].apply(this.jobs, arguments);
        if (this.autostart) {
          this.start();
        }
        return methodResult;
      };
    });
    Object.defineProperty(Queue.prototype, "length", {
      get: function() {
        return this.pending + this.jobs.length;
      }
    });
    Queue.prototype.start = function(cb) {
      if (cb) {
        callOnErrorOrEnd.call(this, cb);
      }
      this.running = true;
      if (this.pending >= this.concurrency) {
        return;
      }
      if (this.jobs.length === 0) {
        if (this.pending === 0) {
          done3.call(this);
        }
        return;
      }
      var self2 = this;
      var job = this.jobs.shift();
      var once5 = true;
      var session = this.session;
      var timeoutId = null;
      var didTimeout = false;
      var resultIndex = null;
      var timeout = job.hasOwnProperty("timeout") ? job.timeout : this.timeout;
      function next(err2, result) {
        if (once5 && self2.session === session) {
          once5 = false;
          self2.pending--;
          if (timeoutId !== null) {
            delete self2.timers[timeoutId];
            clearTimeout(timeoutId);
          }
          if (err2) {
            self2.emit("error", err2, job);
          } else if (didTimeout === false) {
            if (resultIndex !== null) {
              self2.results[resultIndex] = Array.prototype.slice.call(arguments, 1);
            }
            self2.emit("success", result, job);
          }
          if (self2.session === session) {
            if (self2.pending === 0 && self2.jobs.length === 0) {
              done3.call(self2);
            } else if (self2.running) {
              self2.start();
            }
          }
        }
      }
      if (timeout) {
        timeoutId = setTimeout(function() {
          didTimeout = true;
          if (self2.listeners("timeout").length > 0) {
            self2.emit("timeout", next, job);
          } else {
            next();
          }
        }, timeout);
        this.timers[timeoutId] = timeoutId;
      }
      if (this.results) {
        resultIndex = this.results.length;
        this.results[resultIndex] = null;
      }
      this.pending++;
      self2.emit("start", job);
      var promise = job(next);
      if (promise && promise.then && typeof promise.then === "function") {
        promise.then(function(result) {
          return next(null, result);
        }).catch(function(err2) {
          return next(err2 || true);
        });
      }
      if (this.running && this.jobs.length > 0) {
        this.start();
      }
    };
    Queue.prototype.stop = function() {
      this.running = false;
    };
    Queue.prototype.end = function(err2) {
      clearTimers.call(this);
      this.jobs.length = 0;
      this.pending = 0;
      done3.call(this, err2);
    };
    function clearTimers() {
      for (var key in this.timers) {
        var timeoutId = this.timers[key];
        delete this.timers[key];
        clearTimeout(timeoutId);
      }
    }
    function callOnErrorOrEnd(cb) {
      var self2 = this;
      this.on("error", onerror);
      this.on("end", onend3);
      function onerror(err2) {
        self2.end(err2);
      }
      function onend3(err2) {
        self2.removeListener("error", onerror);
        self2.removeListener("end", onend3);
        cb(err2, this.results);
      }
    }
    function done3(err2) {
      this.session++;
      this.running = false;
      this.emit("end", err2);
    }
  }
});

// node_modules/is-url/index.js
var require_is_url = __commonJS({
  "node_modules/is-url/index.js"(exports, module) {
    module.exports = isUrl;
    var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
    var localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/;
    var nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;
    function isUrl(string) {
      if (typeof string !== "string") {
        return false;
      }
      var match = string.match(protocolAndDomainRE);
      if (!match) {
        return false;
      }
      var everythingAfterProtocol = match[1];
      if (!everythingAfterProtocol) {
        return false;
      }
      if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
        return true;
      }
      return false;
    }
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal3(a3, b2) {
      if (a3 === b2) return true;
      if (a3 && b2 && typeof a3 == "object" && typeof b2 == "object") {
        if (a3.constructor !== b2.constructor) return false;
        var length2, i3, keys2;
        if (Array.isArray(a3)) {
          length2 = a3.length;
          if (length2 != b2.length) return false;
          for (i3 = length2; i3-- !== 0; )
            if (!equal3(a3[i3], b2[i3])) return false;
          return true;
        }
        if (a3.constructor === RegExp) return a3.source === b2.source && a3.flags === b2.flags;
        if (a3.valueOf !== Object.prototype.valueOf) return a3.valueOf() === b2.valueOf();
        if (a3.toString !== Object.prototype.toString) return a3.toString() === b2.toString();
        keys2 = Object.keys(a3);
        length2 = keys2.length;
        if (length2 !== Object.keys(b2).length) return false;
        for (i3 = length2; i3-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys2[i3])) return false;
        for (i3 = length2; i3-- !== 0; ) {
          var key = keys2[i3];
          if (!equal3(a3[key], b2[key])) return false;
        }
        return true;
      }
      return a3 !== a3 && b2 !== b2;
    };
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength5;
    exports.toByteArray = toByteArray4;
    exports.fromByteArray = fromByteArray4;
    var lookup4 = [];
    var revLookup4 = [];
    var Arr4 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i3 = 0, len = code.length; i3 < len; ++i3) {
      lookup4[i3] = code[i3];
      revLookup4[code.charCodeAt(i3)] = i3;
    }
    var i3;
    var len;
    revLookup4["-".charCodeAt(0)] = 62;
    revLookup4["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength5(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray4(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr4(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i4;
      for (i4 = 0; i4 < len2; i4 += 4) {
        tmp = revLookup4[b64.charCodeAt(i4)] << 18 | revLookup4[b64.charCodeAt(i4 + 1)] << 12 | revLookup4[b64.charCodeAt(i4 + 2)] << 6 | revLookup4[b64.charCodeAt(i4 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup4[b64.charCodeAt(i4)] << 2 | revLookup4[b64.charCodeAt(i4 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup4[b64.charCodeAt(i4)] << 10 | revLookup4[b64.charCodeAt(i4 + 1)] << 4 | revLookup4[b64.charCodeAt(i4 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase644(num) {
      return lookup4[num >> 18 & 63] + lookup4[num >> 12 & 63] + lookup4[num >> 6 & 63] + lookup4[num & 63];
    }
    function encodeChunk4(uint82, start2, end2) {
      var tmp;
      var output = [];
      for (var i4 = start2; i4 < end2; i4 += 3) {
        tmp = (uint82[i4] << 16 & 16711680) + (uint82[i4 + 1] << 8 & 65280) + (uint82[i4 + 2] & 255);
        output.push(tripletToBase644(tmp));
      }
      return output.join("");
    }
    function fromByteArray4(uint82) {
      var tmp;
      var len2 = uint82.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i4 = 0, len22 = len2 - extraBytes; i4 < len22; i4 += maxChunkLength) {
        parts.push(encodeChunk4(uint82, i4, i4 + maxChunkLength > len22 ? len22 : i4 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint82[len2 - 1];
        parts.push(
          lookup4[tmp >> 2] + lookup4[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint82[len2 - 2] << 8) + uint82[len2 - 1];
        parts.push(
          lookup4[tmp >> 10] + lookup4[tmp >> 4 & 63] + lookup4[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/tiny-inflate/index.js
var require_tiny_inflate = __commonJS({
  "node_modules/tiny-inflate/index.js"(exports, module) {
    var TINF_OK = 0;
    var TINF_DATA_ERROR = -3;
    function Tree() {
      this.table = new Uint16Array(16);
      this.trans = new Uint16Array(288);
    }
    function Data(source, dest) {
      this.source = source;
      this.sourceIndex = 0;
      this.tag = 0;
      this.bitcount = 0;
      this.dest = dest;
      this.destLen = 0;
      this.ltree = new Tree();
      this.dtree = new Tree();
    }
    var sltree = new Tree();
    var sdtree = new Tree();
    var length_bits = new Uint8Array(30);
    var length_base = new Uint16Array(30);
    var dist_bits = new Uint8Array(30);
    var dist_base = new Uint16Array(30);
    var clcidx = new Uint8Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]);
    var code_tree = new Tree();
    var lengths = new Uint8Array(288 + 32);
    function tinf_build_bits_base(bits, base, delta, first) {
      var i3, sum;
      for (i3 = 0; i3 < delta; ++i3) bits[i3] = 0;
      for (i3 = 0; i3 < 30 - delta; ++i3) bits[i3 + delta] = i3 / delta | 0;
      for (sum = first, i3 = 0; i3 < 30; ++i3) {
        base[i3] = sum;
        sum += 1 << bits[i3];
      }
    }
    function tinf_build_fixed_trees(lt, dt) {
      var i3;
      for (i3 = 0; i3 < 7; ++i3) lt.table[i3] = 0;
      lt.table[7] = 24;
      lt.table[8] = 152;
      lt.table[9] = 112;
      for (i3 = 0; i3 < 24; ++i3) lt.trans[i3] = 256 + i3;
      for (i3 = 0; i3 < 144; ++i3) lt.trans[24 + i3] = i3;
      for (i3 = 0; i3 < 8; ++i3) lt.trans[24 + 144 + i3] = 280 + i3;
      for (i3 = 0; i3 < 112; ++i3) lt.trans[24 + 144 + 8 + i3] = 144 + i3;
      for (i3 = 0; i3 < 5; ++i3) dt.table[i3] = 0;
      dt.table[5] = 32;
      for (i3 = 0; i3 < 32; ++i3) dt.trans[i3] = i3;
    }
    var offs = new Uint16Array(16);
    function tinf_build_tree(t3, lengths2, off3, num) {
      var i3, sum;
      for (i3 = 0; i3 < 16; ++i3) t3.table[i3] = 0;
      for (i3 = 0; i3 < num; ++i3) t3.table[lengths2[off3 + i3]]++;
      t3.table[0] = 0;
      for (sum = 0, i3 = 0; i3 < 16; ++i3) {
        offs[i3] = sum;
        sum += t3.table[i3];
      }
      for (i3 = 0; i3 < num; ++i3) {
        if (lengths2[off3 + i3]) t3.trans[offs[lengths2[off3 + i3]]++] = i3;
      }
    }
    function tinf_getbit(d2) {
      if (!d2.bitcount--) {
        d2.tag = d2.source[d2.sourceIndex++];
        d2.bitcount = 7;
      }
      var bit = d2.tag & 1;
      d2.tag >>>= 1;
      return bit;
    }
    function tinf_read_bits(d2, num, base) {
      if (!num)
        return base;
      while (d2.bitcount < 24) {
        d2.tag |= d2.source[d2.sourceIndex++] << d2.bitcount;
        d2.bitcount += 8;
      }
      var val = d2.tag & 65535 >>> 16 - num;
      d2.tag >>>= num;
      d2.bitcount -= num;
      return val + base;
    }
    function tinf_decode_symbol(d2, t3) {
      while (d2.bitcount < 24) {
        d2.tag |= d2.source[d2.sourceIndex++] << d2.bitcount;
        d2.bitcount += 8;
      }
      var sum = 0, cur = 0, len = 0;
      var tag = d2.tag;
      do {
        cur = 2 * cur + (tag & 1);
        tag >>>= 1;
        ++len;
        sum += t3.table[len];
        cur -= t3.table[len];
      } while (cur >= 0);
      d2.tag = tag;
      d2.bitcount -= len;
      return t3.trans[sum + cur];
    }
    function tinf_decode_trees(d2, lt, dt) {
      var hlit, hdist, hclen;
      var i3, num, length2;
      hlit = tinf_read_bits(d2, 5, 257);
      hdist = tinf_read_bits(d2, 5, 1);
      hclen = tinf_read_bits(d2, 4, 4);
      for (i3 = 0; i3 < 19; ++i3) lengths[i3] = 0;
      for (i3 = 0; i3 < hclen; ++i3) {
        var clen = tinf_read_bits(d2, 3, 0);
        lengths[clcidx[i3]] = clen;
      }
      tinf_build_tree(code_tree, lengths, 0, 19);
      for (num = 0; num < hlit + hdist; ) {
        var sym = tinf_decode_symbol(d2, code_tree);
        switch (sym) {
          case 16:
            var prev = lengths[num - 1];
            for (length2 = tinf_read_bits(d2, 2, 3); length2; --length2) {
              lengths[num++] = prev;
            }
            break;
          case 17:
            for (length2 = tinf_read_bits(d2, 3, 3); length2; --length2) {
              lengths[num++] = 0;
            }
            break;
          case 18:
            for (length2 = tinf_read_bits(d2, 7, 11); length2; --length2) {
              lengths[num++] = 0;
            }
            break;
          default:
            lengths[num++] = sym;
            break;
        }
      }
      tinf_build_tree(lt, lengths, 0, hlit);
      tinf_build_tree(dt, lengths, hlit, hdist);
    }
    function tinf_inflate_block_data(d2, lt, dt) {
      while (1) {
        var sym = tinf_decode_symbol(d2, lt);
        if (sym === 256) {
          return TINF_OK;
        }
        if (sym < 256) {
          d2.dest[d2.destLen++] = sym;
        } else {
          var length2, dist, offs2;
          var i3;
          sym -= 257;
          length2 = tinf_read_bits(d2, length_bits[sym], length_base[sym]);
          dist = tinf_decode_symbol(d2, dt);
          offs2 = d2.destLen - tinf_read_bits(d2, dist_bits[dist], dist_base[dist]);
          for (i3 = offs2; i3 < offs2 + length2; ++i3) {
            d2.dest[d2.destLen++] = d2.dest[i3];
          }
        }
      }
    }
    function tinf_inflate_uncompressed_block(d2) {
      var length2, invlength;
      var i3;
      while (d2.bitcount > 8) {
        d2.sourceIndex--;
        d2.bitcount -= 8;
      }
      length2 = d2.source[d2.sourceIndex + 1];
      length2 = 256 * length2 + d2.source[d2.sourceIndex];
      invlength = d2.source[d2.sourceIndex + 3];
      invlength = 256 * invlength + d2.source[d2.sourceIndex + 2];
      if (length2 !== (~invlength & 65535))
        return TINF_DATA_ERROR;
      d2.sourceIndex += 4;
      for (i3 = length2; i3; --i3)
        d2.dest[d2.destLen++] = d2.source[d2.sourceIndex++];
      d2.bitcount = 0;
      return TINF_OK;
    }
    function tinf_uncompress(source, dest) {
      var d2 = new Data(source, dest);
      var bfinal, btype, res;
      do {
        bfinal = tinf_getbit(d2);
        btype = tinf_read_bits(d2, 2, 0);
        switch (btype) {
          case 0:
            res = tinf_inflate_uncompressed_block(d2);
            break;
          case 1:
            res = tinf_inflate_block_data(d2, sltree, sdtree);
            break;
          case 2:
            tinf_decode_trees(d2, d2.ltree, d2.dtree);
            res = tinf_inflate_block_data(d2, d2.ltree, d2.dtree);
            break;
          default:
            res = TINF_DATA_ERROR;
        }
        if (res !== TINF_OK)
          throw new Error("Data error");
      } while (!bfinal);
      if (d2.destLen < d2.dest.length) {
        if (typeof d2.dest.slice === "function")
          return d2.dest.slice(0, d2.destLen);
        else
          return d2.dest.subarray(0, d2.destLen);
      }
      return d2.dest;
    }
    tinf_build_fixed_trees(sltree, sdtree);
    tinf_build_bits_base(length_bits, length_base, 4, 3);
    tinf_build_bits_base(dist_bits, dist_base, 2, 1);
    length_bits[28] = 0;
    length_base[28] = 258;
    module.exports = tinf_uncompress;
  }
});

// node_modules/unicode-trie/swap.js
var require_swap = __commonJS({
  "node_modules/unicode-trie/swap.js"(exports, module) {
    var isBigEndian2 = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
    var swap4 = (b2, n4, m) => {
      let i3 = b2[n4];
      b2[n4] = b2[m];
      b2[m] = i3;
    };
    var swap324 = (array) => {
      const len = array.length;
      for (let i3 = 0; i3 < len; i3 += 4) {
        swap4(array, i3, i3 + 3);
        swap4(array, i3 + 1, i3 + 2);
      }
    };
    var swap32LE = (array) => {
      if (isBigEndian2) {
        swap324(array);
      }
    };
    module.exports = {
      swap32LE
    };
  }
});

// node_modules/unicode-trie/index.js
var require_unicode_trie = __commonJS({
  "node_modules/unicode-trie/index.js"(exports, module) {
    var inflate2 = require_tiny_inflate();
    var { swap32LE } = require_swap();
    var SHIFT_1 = 6 + 5;
    var SHIFT_2 = 5;
    var SHIFT_1_2 = SHIFT_1 - SHIFT_2;
    var OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
    var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
    var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
    var INDEX_SHIFT = 2;
    var DATA_BLOCK_LENGTH = 1 << SHIFT_2;
    var DATA_MASK = DATA_BLOCK_LENGTH - 1;
    var LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
    var LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
    var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
    var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
    var UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
    var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
    var DATA_GRANULARITY = 1 << INDEX_SHIFT;
    var UnicodeTrie = class {
      constructor(data2) {
        const isBuffer4 = typeof data2.readUInt32BE === "function" && typeof data2.slice === "function";
        if (isBuffer4 || data2 instanceof Uint8Array) {
          let uncompressedLength;
          if (isBuffer4) {
            this.highStart = data2.readUInt32LE(0);
            this.errorValue = data2.readUInt32LE(4);
            uncompressedLength = data2.readUInt32LE(8);
            data2 = data2.slice(12);
          } else {
            const view = new DataView(data2.buffer);
            this.highStart = view.getUint32(0, true);
            this.errorValue = view.getUint32(4, true);
            uncompressedLength = view.getUint32(8, true);
            data2 = data2.subarray(12);
          }
          data2 = inflate2(data2, new Uint8Array(uncompressedLength));
          data2 = inflate2(data2, new Uint8Array(uncompressedLength));
          swap32LE(data2);
          this.data = new Uint32Array(data2.buffer);
        } else {
          ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data2);
        }
      }
      get(codePoint) {
        let index3;
        if (codePoint < 0 || codePoint > 1114111) {
          return this.errorValue;
        }
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          index3 = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index3];
        }
        if (codePoint <= 65535) {
          index3 = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index3];
        }
        if (codePoint < this.highStart) {
          index3 = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
          index3 = this.data[index3 + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
          index3 = (index3 << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index3];
        }
        return this.data[this.data.length - DATA_GRANULARITY];
      }
    };
    module.exports = UnicodeTrie;
  }
});

// node_modules/dfa/index.js
var require_dfa = __commonJS({
  "node_modules/dfa/index.js"(exports, module) {
    "use strict";
    var INITIAL_STATE = 1;
    var FAIL_STATE = 0;
    var StateMachine = class {
      constructor(dfa) {
        this.stateTable = dfa.stateTable;
        this.accepting = dfa.accepting;
        this.tags = dfa.tags;
      }
      /**
       * Returns an iterable object that yields pattern matches over the input sequence.
       * Matches are of the form [startIndex, endIndex, tags].
       */
      match(str) {
        var self2 = this;
        return {
          *[Symbol.iterator]() {
            var state2 = INITIAL_STATE;
            var startRun = null;
            var lastAccepting = null;
            var lastState = null;
            for (var p2 = 0; p2 < str.length; p2++) {
              var c3 = str[p2];
              lastState = state2;
              state2 = self2.stateTable[state2][c3];
              if (state2 === FAIL_STATE) {
                if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
                  yield [startRun, lastAccepting, self2.tags[lastState]];
                }
                state2 = self2.stateTable[INITIAL_STATE][c3];
                startRun = null;
              }
              if (state2 !== FAIL_STATE && startRun == null) {
                startRun = p2;
              }
              if (self2.accepting[state2]) {
                lastAccepting = p2;
              }
              if (state2 === FAIL_STATE) {
                state2 = INITIAL_STATE;
              }
            }
            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
              yield [startRun, lastAccepting, self2.tags[state2]];
            }
          }
        };
      }
      /**
       * For each match over the input sequence, action functions matching
       * the tag definitions in the input pattern are called with the startIndex,
       * endIndex, and sub-match sequence.
       */
      apply(str, actions) {
        for (var [start2, end2, tags2] of this.match(str)) {
          for (var tag of tags2) {
            if (typeof actions[tag] === "function") {
              actions[tag](start2, end2, str.slice(start2, end2 + 1));
            }
          }
        }
      }
    };
    module.exports = StateMachine;
  }
});

// node_modules/clone/clone.js
var require_clone = __commonJS({
  "node_modules/clone/clone.js"(exports, module) {
    var clone = function() {
      "use strict";
      function _instanceof(obj, type) {
        return type != null && obj instanceof type;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = function() {
        };
      }
      function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve3, reject) {
              parent2.then(function(value2) {
                resolve3(_clone(value2, depth2 - 1));
              }, function(err2) {
                reject(_clone(err2, depth2 - 1));
              });
            });
          } else if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index3 = allParents.indexOf(parent2);
            if (index3 != -1) {
              return allChildren[index3];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value2, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value2, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value2) {
              var entryChild = _clone(value2, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i3 in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i3);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i3] = _clone(parent2[i3], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i3 = 0; i3 < symbols.length; i3++) {
              var symbol = symbols[i3];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i3 = 0; i3 < allPropertyNames.length; i3++) {
              var propertyName = allPropertyNames[i3];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c3 = function() {
        };
        c3.prototype = parent;
        return new c3();
      };
      function __objToStr(o2) {
        return Object.prototype.toString.call(o2);
      }
      clone2.__objToStr = __objToStr;
      function __isDate(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Date]";
      }
      clone2.__isDate = __isDate;
      function __isArray(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Array]";
      }
      clone2.__isArray = __isArray;
      function __isRegExp(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object RegExp]";
      }
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global) flags += "g";
        if (re.ignoreCase) flags += "i";
        if (re.multiline) flags += "m";
        return flags;
      }
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module === "object" && module.exports) {
      module.exports = clone;
    }
  }
});

// node_modules/brotli/dec/streams.js
var require_streams = __commonJS({
  "node_modules/brotli/dec/streams.js"(exports) {
    function BrotliInput(buffer) {
      this.buffer = buffer;
      this.pos = 0;
    }
    BrotliInput.prototype.read = function(buf, i3, count) {
      if (this.pos + count > this.buffer.length) {
        count = this.buffer.length - this.pos;
      }
      for (var p2 = 0; p2 < count; p2++)
        buf[i3 + p2] = this.buffer[this.pos + p2];
      this.pos += count;
      return count;
    };
    exports.BrotliInput = BrotliInput;
    function BrotliOutput(buf) {
      this.buffer = buf;
      this.pos = 0;
    }
    BrotliOutput.prototype.write = function(buf, count) {
      if (this.pos + count > this.buffer.length)
        throw new Error("Output buffer is not large enough");
      this.buffer.set(buf.subarray(0, count), this.pos);
      this.pos += count;
      return count;
    };
    exports.BrotliOutput = BrotliOutput;
  }
});

// node_modules/brotli/dec/bit_reader.js
var require_bit_reader = __commonJS({
  "node_modules/brotli/dec/bit_reader.js"(exports, module) {
    var BROTLI_READ_SIZE = 4096;
    var BROTLI_IBUF_SIZE = 2 * BROTLI_READ_SIZE + 32;
    var BROTLI_IBUF_MASK = 2 * BROTLI_READ_SIZE - 1;
    var kBitMask = new Uint32Array([
      0,
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255,
      511,
      1023,
      2047,
      4095,
      8191,
      16383,
      32767,
      65535,
      131071,
      262143,
      524287,
      1048575,
      2097151,
      4194303,
      8388607,
      16777215
    ]);
    function BrotliBitReader(input) {
      this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);
      this.input_ = input;
      this.reset();
    }
    BrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;
    BrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;
    BrotliBitReader.prototype.reset = function() {
      this.buf_ptr_ = 0;
      this.val_ = 0;
      this.pos_ = 0;
      this.bit_pos_ = 0;
      this.bit_end_pos_ = 0;
      this.eos_ = 0;
      this.readMoreInput();
      for (var i3 = 0; i3 < 4; i3++) {
        this.val_ |= this.buf_[this.pos_] << 8 * i3;
        ++this.pos_;
      }
      return this.bit_end_pos_ > 0;
    };
    BrotliBitReader.prototype.readMoreInput = function() {
      if (this.bit_end_pos_ > 256) {
        return;
      } else if (this.eos_) {
        if (this.bit_pos_ > this.bit_end_pos_)
          throw new Error("Unexpected end of input " + this.bit_pos_ + " " + this.bit_end_pos_);
      } else {
        var dst = this.buf_ptr_;
        var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);
        if (bytes_read < 0) {
          throw new Error("Unexpected end of input");
        }
        if (bytes_read < BROTLI_READ_SIZE) {
          this.eos_ = 1;
          for (var p2 = 0; p2 < 32; p2++)
            this.buf_[dst + bytes_read + p2] = 0;
        }
        if (dst === 0) {
          for (var p2 = 0; p2 < 32; p2++)
            this.buf_[(BROTLI_READ_SIZE << 1) + p2] = this.buf_[p2];
          this.buf_ptr_ = BROTLI_READ_SIZE;
        } else {
          this.buf_ptr_ = 0;
        }
        this.bit_end_pos_ += bytes_read << 3;
      }
    };
    BrotliBitReader.prototype.fillBitWindow = function() {
      while (this.bit_pos_ >= 8) {
        this.val_ >>>= 8;
        this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;
        ++this.pos_;
        this.bit_pos_ = this.bit_pos_ - 8 >>> 0;
        this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
      }
    };
    BrotliBitReader.prototype.readBits = function(n_bits) {
      if (32 - this.bit_pos_ < n_bits) {
        this.fillBitWindow();
      }
      var val = this.val_ >>> this.bit_pos_ & kBitMask[n_bits];
      this.bit_pos_ += n_bits;
      return val;
    };
    module.exports = BrotliBitReader;
  }
});

// node_modules/brotli/dec/dictionary.bin.js
var require_dictionary_bin = __commonJS({
  "node_modules/brotli/dec/dictionary.bin.js"(exports, module) {
    module.exports = "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";
  }
});

// node_modules/brotli/dec/dictionary-browser.js
var require_dictionary_browser = __commonJS({
  "node_modules/brotli/dec/dictionary-browser.js"(exports) {
    var base64 = require_base64_js();
    exports.init = function() {
      var BrotliDecompressBuffer = require_decode().BrotliDecompressBuffer;
      var compressed = base64.toByteArray(require_dictionary_bin());
      return BrotliDecompressBuffer(compressed);
    };
  }
});

// node_modules/brotli/dec/dictionary.js
var require_dictionary = __commonJS({
  "node_modules/brotli/dec/dictionary.js"(exports) {
    var data2 = require_dictionary_browser();
    exports.init = function() {
      exports.dictionary = data2.init();
    };
    exports.offsetsByLength = new Uint32Array([
      0,
      0,
      0,
      0,
      0,
      4096,
      9216,
      21504,
      35840,
      44032,
      53248,
      63488,
      74752,
      87040,
      93696,
      100864,
      104704,
      106752,
      108928,
      113536,
      115968,
      118528,
      119872,
      121280,
      122016
    ]);
    exports.sizeBitsByLength = new Uint8Array([
      0,
      0,
      0,
      0,
      10,
      10,
      11,
      11,
      10,
      10,
      10,
      10,
      10,
      9,
      9,
      8,
      7,
      7,
      8,
      7,
      7,
      6,
      6,
      5,
      5
    ]);
    exports.minDictionaryWordLength = 4;
    exports.maxDictionaryWordLength = 24;
  }
});

// node_modules/brotli/dec/huffman.js
var require_huffman = __commonJS({
  "node_modules/brotli/dec/huffman.js"(exports) {
    function HuffmanCode(bits, value2) {
      this.bits = bits;
      this.value = value2;
    }
    exports.HuffmanCode = HuffmanCode;
    var MAX_LENGTH = 15;
    function GetNextKey(key, len) {
      var step = 1 << len - 1;
      while (key & step) {
        step >>= 1;
      }
      return (key & step - 1) + step;
    }
    function ReplicateValue(table, i3, step, end2, code) {
      do {
        end2 -= step;
        table[i3 + end2] = new HuffmanCode(code.bits, code.value);
      } while (end2 > 0);
    }
    function NextTableBitSize(count, len, root_bits) {
      var left = 1 << len - root_bits;
      while (len < MAX_LENGTH) {
        left -= count[len];
        if (left <= 0) break;
        ++len;
        left <<= 1;
      }
      return len - root_bits;
    }
    exports.BrotliBuildHuffmanTable = function(root_table, table, root_bits, code_lengths, code_lengths_size) {
      var start_table = table;
      var code;
      var len;
      var symbol;
      var key;
      var step;
      var low;
      var mask;
      var table_bits;
      var table_size;
      var total_size;
      var sorted;
      var count = new Int32Array(MAX_LENGTH + 1);
      var offset2 = new Int32Array(MAX_LENGTH + 1);
      sorted = new Int32Array(code_lengths_size);
      for (symbol = 0; symbol < code_lengths_size; symbol++) {
        count[code_lengths[symbol]]++;
      }
      offset2[1] = 0;
      for (len = 1; len < MAX_LENGTH; len++) {
        offset2[len + 1] = offset2[len] + count[len];
      }
      for (symbol = 0; symbol < code_lengths_size; symbol++) {
        if (code_lengths[symbol] !== 0) {
          sorted[offset2[code_lengths[symbol]]++] = symbol;
        }
      }
      table_bits = root_bits;
      table_size = 1 << table_bits;
      total_size = table_size;
      if (offset2[MAX_LENGTH] === 1) {
        for (key = 0; key < total_size; ++key) {
          root_table[table + key] = new HuffmanCode(0, sorted[0] & 65535);
        }
        return total_size;
      }
      key = 0;
      symbol = 0;
      for (len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {
        for (; count[len] > 0; --count[len]) {
          code = new HuffmanCode(len & 255, sorted[symbol++] & 65535);
          ReplicateValue(root_table, table + key, step, table_size, code);
          key = GetNextKey(key, len);
        }
      }
      mask = total_size - 1;
      low = -1;
      for (len = root_bits + 1, step = 2; len <= MAX_LENGTH; ++len, step <<= 1) {
        for (; count[len] > 0; --count[len]) {
          if ((key & mask) !== low) {
            table += table_size;
            table_bits = NextTableBitSize(count, len, root_bits);
            table_size = 1 << table_bits;
            total_size += table_size;
            low = key & mask;
            root_table[start_table + low] = new HuffmanCode(table_bits + root_bits & 255, table - start_table - low & 65535);
          }
          code = new HuffmanCode(len - root_bits & 255, sorted[symbol++] & 65535);
          ReplicateValue(root_table, table + (key >> root_bits), step, table_size, code);
          key = GetNextKey(key, len);
        }
      }
      return total_size;
    };
  }
});

// node_modules/brotli/dec/context.js
var require_context = __commonJS({
  "node_modules/brotli/dec/context.js"(exports) {
    exports.lookup = new Uint8Array([
      /* CONTEXT_UTF8, last byte. */
      /* ASCII range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      12,
      16,
      12,
      12,
      20,
      12,
      16,
      24,
      28,
      12,
      12,
      32,
      12,
      36,
      12,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      32,
      32,
      24,
      40,
      28,
      12,
      12,
      48,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      24,
      12,
      28,
      12,
      12,
      12,
      56,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      24,
      12,
      28,
      12,
      0,
      /* UTF8 continuation byte range. */
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      /* UTF8 lead byte range. */
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      /* CONTEXT_UTF8 second last byte. */
      /* ASCII range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      1,
      1,
      1,
      1,
      0,
      /* UTF8 continuation byte range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      /* UTF8 lead byte range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      /* CONTEXT_SIGNED, second last byte. */
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      7,
      /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */
      0,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      56,
      /* CONTEXT_LSB6, last byte. */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      /* CONTEXT_MSB6, last byte. */
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      7,
      7,
      7,
      7,
      8,
      8,
      8,
      8,
      9,
      9,
      9,
      9,
      10,
      10,
      10,
      10,
      11,
      11,
      11,
      11,
      12,
      12,
      12,
      12,
      13,
      13,
      13,
      13,
      14,
      14,
      14,
      14,
      15,
      15,
      15,
      15,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      22,
      22,
      22,
      22,
      23,
      23,
      23,
      23,
      24,
      24,
      24,
      24,
      25,
      25,
      25,
      25,
      26,
      26,
      26,
      26,
      27,
      27,
      27,
      27,
      28,
      28,
      28,
      28,
      29,
      29,
      29,
      29,
      30,
      30,
      30,
      30,
      31,
      31,
      31,
      31,
      32,
      32,
      32,
      32,
      33,
      33,
      33,
      33,
      34,
      34,
      34,
      34,
      35,
      35,
      35,
      35,
      36,
      36,
      36,
      36,
      37,
      37,
      37,
      37,
      38,
      38,
      38,
      38,
      39,
      39,
      39,
      39,
      40,
      40,
      40,
      40,
      41,
      41,
      41,
      41,
      42,
      42,
      42,
      42,
      43,
      43,
      43,
      43,
      44,
      44,
      44,
      44,
      45,
      45,
      45,
      45,
      46,
      46,
      46,
      46,
      47,
      47,
      47,
      47,
      48,
      48,
      48,
      48,
      49,
      49,
      49,
      49,
      50,
      50,
      50,
      50,
      51,
      51,
      51,
      51,
      52,
      52,
      52,
      52,
      53,
      53,
      53,
      53,
      54,
      54,
      54,
      54,
      55,
      55,
      55,
      55,
      56,
      56,
      56,
      56,
      57,
      57,
      57,
      57,
      58,
      58,
      58,
      58,
      59,
      59,
      59,
      59,
      60,
      60,
      60,
      60,
      61,
      61,
      61,
      61,
      62,
      62,
      62,
      62,
      63,
      63,
      63,
      63,
      /* CONTEXT_{M,L}SB6, second last byte, */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.lookupOffsets = new Uint16Array([
      /* CONTEXT_LSB6 */
      1024,
      1536,
      /* CONTEXT_MSB6 */
      1280,
      1536,
      /* CONTEXT_UTF8 */
      0,
      256,
      /* CONTEXT_SIGNED */
      768,
      512
    ]);
  }
});

// node_modules/brotli/dec/prefix.js
var require_prefix = __commonJS({
  "node_modules/brotli/dec/prefix.js"(exports) {
    function PrefixCodeRange(offset2, nbits) {
      this.offset = offset2;
      this.nbits = nbits;
    }
    exports.kBlockLengthPrefixCode = [
      new PrefixCodeRange(1, 2),
      new PrefixCodeRange(5, 2),
      new PrefixCodeRange(9, 2),
      new PrefixCodeRange(13, 2),
      new PrefixCodeRange(17, 3),
      new PrefixCodeRange(25, 3),
      new PrefixCodeRange(33, 3),
      new PrefixCodeRange(41, 3),
      new PrefixCodeRange(49, 4),
      new PrefixCodeRange(65, 4),
      new PrefixCodeRange(81, 4),
      new PrefixCodeRange(97, 4),
      new PrefixCodeRange(113, 5),
      new PrefixCodeRange(145, 5),
      new PrefixCodeRange(177, 5),
      new PrefixCodeRange(209, 5),
      new PrefixCodeRange(241, 6),
      new PrefixCodeRange(305, 6),
      new PrefixCodeRange(369, 7),
      new PrefixCodeRange(497, 8),
      new PrefixCodeRange(753, 9),
      new PrefixCodeRange(1265, 10),
      new PrefixCodeRange(2289, 11),
      new PrefixCodeRange(4337, 12),
      new PrefixCodeRange(8433, 13),
      new PrefixCodeRange(16625, 24)
    ];
    exports.kInsertLengthPrefixCode = [
      new PrefixCodeRange(0, 0),
      new PrefixCodeRange(1, 0),
      new PrefixCodeRange(2, 0),
      new PrefixCodeRange(3, 0),
      new PrefixCodeRange(4, 0),
      new PrefixCodeRange(5, 0),
      new PrefixCodeRange(6, 1),
      new PrefixCodeRange(8, 1),
      new PrefixCodeRange(10, 2),
      new PrefixCodeRange(14, 2),
      new PrefixCodeRange(18, 3),
      new PrefixCodeRange(26, 3),
      new PrefixCodeRange(34, 4),
      new PrefixCodeRange(50, 4),
      new PrefixCodeRange(66, 5),
      new PrefixCodeRange(98, 5),
      new PrefixCodeRange(130, 6),
      new PrefixCodeRange(194, 7),
      new PrefixCodeRange(322, 8),
      new PrefixCodeRange(578, 9),
      new PrefixCodeRange(1090, 10),
      new PrefixCodeRange(2114, 12),
      new PrefixCodeRange(6210, 14),
      new PrefixCodeRange(22594, 24)
    ];
    exports.kCopyLengthPrefixCode = [
      new PrefixCodeRange(2, 0),
      new PrefixCodeRange(3, 0),
      new PrefixCodeRange(4, 0),
      new PrefixCodeRange(5, 0),
      new PrefixCodeRange(6, 0),
      new PrefixCodeRange(7, 0),
      new PrefixCodeRange(8, 0),
      new PrefixCodeRange(9, 0),
      new PrefixCodeRange(10, 1),
      new PrefixCodeRange(12, 1),
      new PrefixCodeRange(14, 2),
      new PrefixCodeRange(18, 2),
      new PrefixCodeRange(22, 3),
      new PrefixCodeRange(30, 3),
      new PrefixCodeRange(38, 4),
      new PrefixCodeRange(54, 4),
      new PrefixCodeRange(70, 5),
      new PrefixCodeRange(102, 5),
      new PrefixCodeRange(134, 6),
      new PrefixCodeRange(198, 7),
      new PrefixCodeRange(326, 8),
      new PrefixCodeRange(582, 9),
      new PrefixCodeRange(1094, 10),
      new PrefixCodeRange(2118, 24)
    ];
    exports.kInsertRangeLut = [
      0,
      0,
      8,
      8,
      0,
      16,
      8,
      16,
      16
    ];
    exports.kCopyRangeLut = [
      0,
      8,
      0,
      8,
      16,
      0,
      16,
      8,
      16
    ];
  }
});

// node_modules/brotli/dec/transform.js
var require_transform = __commonJS({
  "node_modules/brotli/dec/transform.js"(exports) {
    var BrotliDictionary = require_dictionary();
    var kIdentity = 0;
    var kOmitLast1 = 1;
    var kOmitLast2 = 2;
    var kOmitLast3 = 3;
    var kOmitLast4 = 4;
    var kOmitLast5 = 5;
    var kOmitLast6 = 6;
    var kOmitLast7 = 7;
    var kOmitLast8 = 8;
    var kOmitLast9 = 9;
    var kUppercaseFirst = 10;
    var kUppercaseAll = 11;
    var kOmitFirst1 = 12;
    var kOmitFirst2 = 13;
    var kOmitFirst3 = 14;
    var kOmitFirst4 = 15;
    var kOmitFirst5 = 16;
    var kOmitFirst6 = 17;
    var kOmitFirst7 = 18;
    var kOmitFirst9 = 20;
    function Transform3(prefix, transform, suffix) {
      this.prefix = new Uint8Array(prefix.length);
      this.transform = transform;
      this.suffix = new Uint8Array(suffix.length);
      for (var i3 = 0; i3 < prefix.length; i3++)
        this.prefix[i3] = prefix.charCodeAt(i3);
      for (var i3 = 0; i3 < suffix.length; i3++)
        this.suffix[i3] = suffix.charCodeAt(i3);
    }
    var kTransforms = [
      new Transform3("", kIdentity, ""),
      new Transform3("", kIdentity, " "),
      new Transform3(" ", kIdentity, " "),
      new Transform3("", kOmitFirst1, ""),
      new Transform3("", kUppercaseFirst, " "),
      new Transform3("", kIdentity, " the "),
      new Transform3(" ", kIdentity, ""),
      new Transform3("s ", kIdentity, " "),
      new Transform3("", kIdentity, " of "),
      new Transform3("", kUppercaseFirst, ""),
      new Transform3("", kIdentity, " and "),
      new Transform3("", kOmitFirst2, ""),
      new Transform3("", kOmitLast1, ""),
      new Transform3(", ", kIdentity, " "),
      new Transform3("", kIdentity, ", "),
      new Transform3(" ", kUppercaseFirst, " "),
      new Transform3("", kIdentity, " in "),
      new Transform3("", kIdentity, " to "),
      new Transform3("e ", kIdentity, " "),
      new Transform3("", kIdentity, '"'),
      new Transform3("", kIdentity, "."),
      new Transform3("", kIdentity, '">'),
      new Transform3("", kIdentity, "\n"),
      new Transform3("", kOmitLast3, ""),
      new Transform3("", kIdentity, "]"),
      new Transform3("", kIdentity, " for "),
      new Transform3("", kOmitFirst3, ""),
      new Transform3("", kOmitLast2, ""),
      new Transform3("", kIdentity, " a "),
      new Transform3("", kIdentity, " that "),
      new Transform3(" ", kUppercaseFirst, ""),
      new Transform3("", kIdentity, ". "),
      new Transform3(".", kIdentity, ""),
      new Transform3(" ", kIdentity, ", "),
      new Transform3("", kOmitFirst4, ""),
      new Transform3("", kIdentity, " with "),
      new Transform3("", kIdentity, "'"),
      new Transform3("", kIdentity, " from "),
      new Transform3("", kIdentity, " by "),
      new Transform3("", kOmitFirst5, ""),
      new Transform3("", kOmitFirst6, ""),
      new Transform3(" the ", kIdentity, ""),
      new Transform3("", kOmitLast4, ""),
      new Transform3("", kIdentity, ". The "),
      new Transform3("", kUppercaseAll, ""),
      new Transform3("", kIdentity, " on "),
      new Transform3("", kIdentity, " as "),
      new Transform3("", kIdentity, " is "),
      new Transform3("", kOmitLast7, ""),
      new Transform3("", kOmitLast1, "ing "),
      new Transform3("", kIdentity, "\n	"),
      new Transform3("", kIdentity, ":"),
      new Transform3(" ", kIdentity, ". "),
      new Transform3("", kIdentity, "ed "),
      new Transform3("", kOmitFirst9, ""),
      new Transform3("", kOmitFirst7, ""),
      new Transform3("", kOmitLast6, ""),
      new Transform3("", kIdentity, "("),
      new Transform3("", kUppercaseFirst, ", "),
      new Transform3("", kOmitLast8, ""),
      new Transform3("", kIdentity, " at "),
      new Transform3("", kIdentity, "ly "),
      new Transform3(" the ", kIdentity, " of "),
      new Transform3("", kOmitLast5, ""),
      new Transform3("", kOmitLast9, ""),
      new Transform3(" ", kUppercaseFirst, ", "),
      new Transform3("", kUppercaseFirst, '"'),
      new Transform3(".", kIdentity, "("),
      new Transform3("", kUppercaseAll, " "),
      new Transform3("", kUppercaseFirst, '">'),
      new Transform3("", kIdentity, '="'),
      new Transform3(" ", kIdentity, "."),
      new Transform3(".com/", kIdentity, ""),
      new Transform3(" the ", kIdentity, " of the "),
      new Transform3("", kUppercaseFirst, "'"),
      new Transform3("", kIdentity, ". This "),
      new Transform3("", kIdentity, ","),
      new Transform3(".", kIdentity, " "),
      new Transform3("", kUppercaseFirst, "("),
      new Transform3("", kUppercaseFirst, "."),
      new Transform3("", kIdentity, " not "),
      new Transform3(" ", kIdentity, '="'),
      new Transform3("", kIdentity, "er "),
      new Transform3(" ", kUppercaseAll, " "),
      new Transform3("", kIdentity, "al "),
      new Transform3(" ", kUppercaseAll, ""),
      new Transform3("", kIdentity, "='"),
      new Transform3("", kUppercaseAll, '"'),
      new Transform3("", kUppercaseFirst, ". "),
      new Transform3(" ", kIdentity, "("),
      new Transform3("", kIdentity, "ful "),
      new Transform3(" ", kUppercaseFirst, ". "),
      new Transform3("", kIdentity, "ive "),
      new Transform3("", kIdentity, "less "),
      new Transform3("", kUppercaseAll, "'"),
      new Transform3("", kIdentity, "est "),
      new Transform3(" ", kUppercaseFirst, "."),
      new Transform3("", kUppercaseAll, '">'),
      new Transform3(" ", kIdentity, "='"),
      new Transform3("", kUppercaseFirst, ","),
      new Transform3("", kIdentity, "ize "),
      new Transform3("", kUppercaseAll, "."),
      new Transform3("", kIdentity, ""),
      new Transform3(" ", kIdentity, ","),
      new Transform3("", kUppercaseFirst, '="'),
      new Transform3("", kUppercaseAll, '="'),
      new Transform3("", kIdentity, "ous "),
      new Transform3("", kUppercaseAll, ", "),
      new Transform3("", kUppercaseFirst, "='"),
      new Transform3(" ", kUppercaseFirst, ","),
      new Transform3(" ", kUppercaseAll, '="'),
      new Transform3(" ", kUppercaseAll, ", "),
      new Transform3("", kUppercaseAll, ","),
      new Transform3("", kUppercaseAll, "("),
      new Transform3("", kUppercaseAll, ". "),
      new Transform3(" ", kUppercaseAll, "."),
      new Transform3("", kUppercaseAll, "='"),
      new Transform3(" ", kUppercaseAll, ". "),
      new Transform3(" ", kUppercaseFirst, '="'),
      new Transform3(" ", kUppercaseAll, "='"),
      new Transform3(" ", kUppercaseFirst, "='")
    ];
    exports.kTransforms = kTransforms;
    exports.kNumTransforms = kTransforms.length;
    function ToUpperCase(p2, i3) {
      if (p2[i3] < 192) {
        if (p2[i3] >= 97 && p2[i3] <= 122) {
          p2[i3] ^= 32;
        }
        return 1;
      }
      if (p2[i3] < 224) {
        p2[i3 + 1] ^= 32;
        return 2;
      }
      p2[i3 + 2] ^= 5;
      return 3;
    }
    exports.transformDictionaryWord = function(dst, idx, word, len, transform) {
      var prefix = kTransforms[transform].prefix;
      var suffix = kTransforms[transform].suffix;
      var t3 = kTransforms[transform].transform;
      var skip = t3 < kOmitFirst1 ? 0 : t3 - (kOmitFirst1 - 1);
      var i3 = 0;
      var start_idx = idx;
      var uppercase;
      if (skip > len) {
        skip = len;
      }
      var prefix_pos = 0;
      while (prefix_pos < prefix.length) {
        dst[idx++] = prefix[prefix_pos++];
      }
      word += skip;
      len -= skip;
      if (t3 <= kOmitLast9) {
        len -= t3;
      }
      for (i3 = 0; i3 < len; i3++) {
        dst[idx++] = BrotliDictionary.dictionary[word + i3];
      }
      uppercase = idx - len;
      if (t3 === kUppercaseFirst) {
        ToUpperCase(dst, uppercase);
      } else if (t3 === kUppercaseAll) {
        while (len > 0) {
          var step = ToUpperCase(dst, uppercase);
          uppercase += step;
          len -= step;
        }
      }
      var suffix_pos = 0;
      while (suffix_pos < suffix.length) {
        dst[idx++] = suffix[suffix_pos++];
      }
      return idx - start_idx;
    };
  }
});

// node_modules/brotli/dec/decode.js
var require_decode = __commonJS({
  "node_modules/brotli/dec/decode.js"(exports) {
    var BrotliInput = require_streams().BrotliInput;
    var BrotliOutput = require_streams().BrotliOutput;
    var BrotliBitReader = require_bit_reader();
    var BrotliDictionary = require_dictionary();
    var HuffmanCode = require_huffman().HuffmanCode;
    var BrotliBuildHuffmanTable = require_huffman().BrotliBuildHuffmanTable;
    var Context = require_context();
    var Prefix = require_prefix();
    var Transform3 = require_transform();
    var kDefaultCodeLength = 8;
    var kCodeLengthRepeatCode = 16;
    var kNumLiteralCodes = 256;
    var kNumInsertAndCopyCodes = 704;
    var kNumBlockLengthCodes = 26;
    var kLiteralContextBits = 6;
    var kDistanceContextBits = 2;
    var HUFFMAN_TABLE_BITS = 8;
    var HUFFMAN_TABLE_MASK = 255;
    var HUFFMAN_MAX_TABLE_SIZE = 1080;
    var CODE_LENGTH_CODES = 18;
    var kCodeLengthCodeOrder = new Uint8Array([
      1,
      2,
      3,
      4,
      0,
      5,
      17,
      6,
      16,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15
    ]);
    var NUM_DISTANCE_SHORT_CODES = 16;
    var kDistanceShortCodeIndexOffset = new Uint8Array([
      3,
      2,
      1,
      0,
      3,
      3,
      3,
      3,
      3,
      3,
      2,
      2,
      2,
      2,
      2,
      2
    ]);
    var kDistanceShortCodeValueOffset = new Int8Array([
      0,
      0,
      0,
      0,
      -1,
      1,
      -2,
      2,
      -3,
      3,
      -1,
      1,
      -2,
      2,
      -3,
      3
    ]);
    var kMaxHuffmanTableSize = new Uint16Array([
      256,
      402,
      436,
      468,
      500,
      534,
      566,
      598,
      630,
      662,
      694,
      726,
      758,
      790,
      822,
      854,
      886,
      920,
      952,
      984,
      1016,
      1048,
      1080
    ]);
    function DecodeWindowBits(br) {
      var n4;
      if (br.readBits(1) === 0) {
        return 16;
      }
      n4 = br.readBits(3);
      if (n4 > 0) {
        return 17 + n4;
      }
      n4 = br.readBits(3);
      if (n4 > 0) {
        return 8 + n4;
      }
      return 17;
    }
    function DecodeVarLenUint8(br) {
      if (br.readBits(1)) {
        var nbits = br.readBits(3);
        if (nbits === 0) {
          return 1;
        } else {
          return br.readBits(nbits) + (1 << nbits);
        }
      }
      return 0;
    }
    function MetaBlockLength() {
      this.meta_block_length = 0;
      this.input_end = 0;
      this.is_uncompressed = 0;
      this.is_metadata = false;
    }
    function DecodeMetaBlockLength(br) {
      var out = new MetaBlockLength();
      var size_nibbles;
      var size_bytes;
      var i3;
      out.input_end = br.readBits(1);
      if (out.input_end && br.readBits(1)) {
        return out;
      }
      size_nibbles = br.readBits(2) + 4;
      if (size_nibbles === 7) {
        out.is_metadata = true;
        if (br.readBits(1) !== 0)
          throw new Error("Invalid reserved bit");
        size_bytes = br.readBits(2);
        if (size_bytes === 0)
          return out;
        for (i3 = 0; i3 < size_bytes; i3++) {
          var next_byte = br.readBits(8);
          if (i3 + 1 === size_bytes && size_bytes > 1 && next_byte === 0)
            throw new Error("Invalid size byte");
          out.meta_block_length |= next_byte << i3 * 8;
        }
      } else {
        for (i3 = 0; i3 < size_nibbles; ++i3) {
          var next_nibble = br.readBits(4);
          if (i3 + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0)
            throw new Error("Invalid size nibble");
          out.meta_block_length |= next_nibble << i3 * 4;
        }
      }
      ++out.meta_block_length;
      if (!out.input_end && !out.is_metadata) {
        out.is_uncompressed = br.readBits(1);
      }
      return out;
    }
    function ReadSymbol(table, index3, br) {
      var start_index = index3;
      var nbits;
      br.fillBitWindow();
      index3 += br.val_ >>> br.bit_pos_ & HUFFMAN_TABLE_MASK;
      nbits = table[index3].bits - HUFFMAN_TABLE_BITS;
      if (nbits > 0) {
        br.bit_pos_ += HUFFMAN_TABLE_BITS;
        index3 += table[index3].value;
        index3 += br.val_ >>> br.bit_pos_ & (1 << nbits) - 1;
      }
      br.bit_pos_ += table[index3].bits;
      return table[index3].value;
    }
    function ReadHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {
      var symbol = 0;
      var prev_code_len = kDefaultCodeLength;
      var repeat2 = 0;
      var repeat_code_len = 0;
      var space = 32768;
      var table = [];
      for (var i3 = 0; i3 < 32; i3++)
        table.push(new HuffmanCode(0, 0));
      BrotliBuildHuffmanTable(table, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES);
      while (symbol < num_symbols && space > 0) {
        var p2 = 0;
        var code_len;
        br.readMoreInput();
        br.fillBitWindow();
        p2 += br.val_ >>> br.bit_pos_ & 31;
        br.bit_pos_ += table[p2].bits;
        code_len = table[p2].value & 255;
        if (code_len < kCodeLengthRepeatCode) {
          repeat2 = 0;
          code_lengths[symbol++] = code_len;
          if (code_len !== 0) {
            prev_code_len = code_len;
            space -= 32768 >> code_len;
          }
        } else {
          var extra_bits = code_len - 14;
          var old_repeat;
          var repeat_delta;
          var new_len = 0;
          if (code_len === kCodeLengthRepeatCode) {
            new_len = prev_code_len;
          }
          if (repeat_code_len !== new_len) {
            repeat2 = 0;
            repeat_code_len = new_len;
          }
          old_repeat = repeat2;
          if (repeat2 > 0) {
            repeat2 -= 2;
            repeat2 <<= extra_bits;
          }
          repeat2 += br.readBits(extra_bits) + 3;
          repeat_delta = repeat2 - old_repeat;
          if (symbol + repeat_delta > num_symbols) {
            throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");
          }
          for (var x = 0; x < repeat_delta; x++)
            code_lengths[symbol + x] = repeat_code_len;
          symbol += repeat_delta;
          if (repeat_code_len !== 0) {
            space -= repeat_delta << 15 - repeat_code_len;
          }
        }
      }
      if (space !== 0) {
        throw new Error("[ReadHuffmanCodeLengths] space = " + space);
      }
      for (; symbol < num_symbols; symbol++)
        code_lengths[symbol] = 0;
    }
    function ReadHuffmanCode(alphabet_size, tables, table, br) {
      var table_size = 0;
      var simple_code_or_skip;
      var code_lengths = new Uint8Array(alphabet_size);
      br.readMoreInput();
      simple_code_or_skip = br.readBits(2);
      if (simple_code_or_skip === 1) {
        var i3;
        var max_bits_counter = alphabet_size - 1;
        var max_bits = 0;
        var symbols = new Int32Array(4);
        var num_symbols = br.readBits(2) + 1;
        while (max_bits_counter) {
          max_bits_counter >>= 1;
          ++max_bits;
        }
        for (i3 = 0; i3 < num_symbols; ++i3) {
          symbols[i3] = br.readBits(max_bits) % alphabet_size;
          code_lengths[symbols[i3]] = 2;
        }
        code_lengths[symbols[0]] = 1;
        switch (num_symbols) {
          case 1:
            break;
          case 3:
            if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[1] === symbols[2]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            break;
          case 2:
            if (symbols[0] === symbols[1]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            code_lengths[symbols[1]] = 1;
            break;
          case 4:
            if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[0] === symbols[3] || symbols[1] === symbols[2] || symbols[1] === symbols[3] || symbols[2] === symbols[3]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            if (br.readBits(1)) {
              code_lengths[symbols[2]] = 3;
              code_lengths[symbols[3]] = 3;
            } else {
              code_lengths[symbols[0]] = 2;
            }
            break;
        }
      } else {
        var i3;
        var code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES);
        var space = 32;
        var num_codes = 0;
        var huff = [
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(3, 2),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(4, 1),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(3, 2),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(4, 5)
        ];
        for (i3 = simple_code_or_skip; i3 < CODE_LENGTH_CODES && space > 0; ++i3) {
          var code_len_idx = kCodeLengthCodeOrder[i3];
          var p2 = 0;
          var v2;
          br.fillBitWindow();
          p2 += br.val_ >>> br.bit_pos_ & 15;
          br.bit_pos_ += huff[p2].bits;
          v2 = huff[p2].value;
          code_length_code_lengths[code_len_idx] = v2;
          if (v2 !== 0) {
            space -= 32 >> v2;
            ++num_codes;
          }
        }
        if (!(num_codes === 1 || space === 0))
          throw new Error("[ReadHuffmanCode] invalid num_codes or space");
        ReadHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br);
      }
      table_size = BrotliBuildHuffmanTable(tables, table, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size);
      if (table_size === 0) {
        throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
      }
      return table_size;
    }
    function ReadBlockLength(table, index3, br) {
      var code;
      var nbits;
      code = ReadSymbol(table, index3, br);
      nbits = Prefix.kBlockLengthPrefixCode[code].nbits;
      return Prefix.kBlockLengthPrefixCode[code].offset + br.readBits(nbits);
    }
    function TranslateShortCodes(code, ringbuffer, index3) {
      var val;
      if (code < NUM_DISTANCE_SHORT_CODES) {
        index3 += kDistanceShortCodeIndexOffset[code];
        index3 &= 3;
        val = ringbuffer[index3] + kDistanceShortCodeValueOffset[code];
      } else {
        val = code - NUM_DISTANCE_SHORT_CODES + 1;
      }
      return val;
    }
    function MoveToFront(v2, index3) {
      var value2 = v2[index3];
      var i3 = index3;
      for (; i3; --i3) v2[i3] = v2[i3 - 1];
      v2[0] = value2;
    }
    function InverseMoveToFrontTransform(v2, v_len) {
      var mtf = new Uint8Array(256);
      var i3;
      for (i3 = 0; i3 < 256; ++i3) {
        mtf[i3] = i3;
      }
      for (i3 = 0; i3 < v_len; ++i3) {
        var index3 = v2[i3];
        v2[i3] = mtf[index3];
        if (index3) MoveToFront(mtf, index3);
      }
    }
    function HuffmanTreeGroup(alphabet_size, num_htrees) {
      this.alphabet_size = alphabet_size;
      this.num_htrees = num_htrees;
      this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[alphabet_size + 31 >>> 5]);
      this.htrees = new Uint32Array(num_htrees);
    }
    HuffmanTreeGroup.prototype.decode = function(br) {
      var i3;
      var table_size;
      var next = 0;
      for (i3 = 0; i3 < this.num_htrees; ++i3) {
        this.htrees[i3] = next;
        table_size = ReadHuffmanCode(this.alphabet_size, this.codes, next, br);
        next += table_size;
      }
    };
    function DecodeContextMap(context_map_size, br) {
      var out = { num_htrees: null, context_map: null };
      var use_rle_for_zeros;
      var max_run_length_prefix = 0;
      var table;
      var i3;
      br.readMoreInput();
      var num_htrees = out.num_htrees = DecodeVarLenUint8(br) + 1;
      var context_map = out.context_map = new Uint8Array(context_map_size);
      if (num_htrees <= 1) {
        return out;
      }
      use_rle_for_zeros = br.readBits(1);
      if (use_rle_for_zeros) {
        max_run_length_prefix = br.readBits(4) + 1;
      }
      table = [];
      for (i3 = 0; i3 < HUFFMAN_MAX_TABLE_SIZE; i3++) {
        table[i3] = new HuffmanCode(0, 0);
      }
      ReadHuffmanCode(num_htrees + max_run_length_prefix, table, 0, br);
      for (i3 = 0; i3 < context_map_size; ) {
        var code;
        br.readMoreInput();
        code = ReadSymbol(table, 0, br);
        if (code === 0) {
          context_map[i3] = 0;
          ++i3;
        } else if (code <= max_run_length_prefix) {
          var reps = 1 + (1 << code) + br.readBits(code);
          while (--reps) {
            if (i3 >= context_map_size) {
              throw new Error("[DecodeContextMap] i >= context_map_size");
            }
            context_map[i3] = 0;
            ++i3;
          }
        } else {
          context_map[i3] = code - max_run_length_prefix;
          ++i3;
        }
      }
      if (br.readBits(1)) {
        InverseMoveToFrontTransform(context_map, context_map_size);
      }
      return out;
    }
    function DecodeBlockType(max_block_type, trees2, tree_type, block_types, ringbuffers, indexes, br) {
      var ringbuffer = tree_type * 2;
      var index3 = tree_type;
      var type_code = ReadSymbol(trees2, tree_type * HUFFMAN_MAX_TABLE_SIZE, br);
      var block_type;
      if (type_code === 0) {
        block_type = ringbuffers[ringbuffer + (indexes[index3] & 1)];
      } else if (type_code === 1) {
        block_type = ringbuffers[ringbuffer + (indexes[index3] - 1 & 1)] + 1;
      } else {
        block_type = type_code - 2;
      }
      if (block_type >= max_block_type) {
        block_type -= max_block_type;
      }
      block_types[tree_type] = block_type;
      ringbuffers[ringbuffer + (indexes[index3] & 1)] = block_type;
      ++indexes[index3];
    }
    function CopyUncompressedBlockToOutput(output, len, pos, ringbuffer, ringbuffer_mask, br) {
      var rb_size = ringbuffer_mask + 1;
      var rb_pos = pos & ringbuffer_mask;
      var br_pos = br.pos_ & BrotliBitReader.IBUF_MASK;
      var nbytes;
      if (len < 8 || br.bit_pos_ + (len << 3) < br.bit_end_pos_) {
        while (len-- > 0) {
          br.readMoreInput();
          ringbuffer[rb_pos++] = br.readBits(8);
          if (rb_pos === rb_size) {
            output.write(ringbuffer, rb_size);
            rb_pos = 0;
          }
        }
        return;
      }
      if (br.bit_end_pos_ < 32) {
        throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");
      }
      while (br.bit_pos_ < 32) {
        ringbuffer[rb_pos] = br.val_ >>> br.bit_pos_;
        br.bit_pos_ += 8;
        ++rb_pos;
        --len;
      }
      nbytes = br.bit_end_pos_ - br.bit_pos_ >> 3;
      if (br_pos + nbytes > BrotliBitReader.IBUF_MASK) {
        var tail = BrotliBitReader.IBUF_MASK + 1 - br_pos;
        for (var x = 0; x < tail; x++)
          ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
        nbytes -= tail;
        rb_pos += tail;
        len -= tail;
        br_pos = 0;
      }
      for (var x = 0; x < nbytes; x++)
        ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
      rb_pos += nbytes;
      len -= nbytes;
      if (rb_pos >= rb_size) {
        output.write(ringbuffer, rb_size);
        rb_pos -= rb_size;
        for (var x = 0; x < rb_pos; x++)
          ringbuffer[x] = ringbuffer[rb_size + x];
      }
      while (rb_pos + len >= rb_size) {
        nbytes = rb_size - rb_pos;
        if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {
          throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
        }
        output.write(ringbuffer, rb_size);
        len -= nbytes;
        rb_pos = 0;
      }
      if (br.input_.read(ringbuffer, rb_pos, len) < len) {
        throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
      }
      br.reset();
    }
    function JumpToByteBoundary(br) {
      var new_bit_pos = br.bit_pos_ + 7 & ~7;
      var pad_bits = br.readBits(new_bit_pos - br.bit_pos_);
      return pad_bits == 0;
    }
    function BrotliDecompressedSize(buffer) {
      var input = new BrotliInput(buffer);
      var br = new BrotliBitReader(input);
      DecodeWindowBits(br);
      var out = DecodeMetaBlockLength(br);
      return out.meta_block_length;
    }
    exports.BrotliDecompressedSize = BrotliDecompressedSize;
    function BrotliDecompressBuffer(buffer, output_size) {
      var input = new BrotliInput(buffer);
      if (output_size == null) {
        output_size = BrotliDecompressedSize(buffer);
      }
      var output_buffer = new Uint8Array(output_size);
      var output = new BrotliOutput(output_buffer);
      BrotliDecompress(input, output);
      if (output.pos < output.buffer.length) {
        output.buffer = output.buffer.subarray(0, output.pos);
      }
      return output.buffer;
    }
    exports.BrotliDecompressBuffer = BrotliDecompressBuffer;
    function BrotliDecompress(input, output) {
      var i3;
      var pos = 0;
      var input_end = 0;
      var window_bits = 0;
      var max_backward_distance;
      var max_distance = 0;
      var ringbuffer_size;
      var ringbuffer_mask;
      var ringbuffer;
      var ringbuffer_end;
      var dist_rb = [16, 15, 11, 4];
      var dist_rb_idx = 0;
      var prev_byte1 = 0;
      var prev_byte2 = 0;
      var hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)];
      var block_type_trees;
      var block_len_trees;
      var br;
      var kRingBufferWriteAheadSlack = 128 + BrotliBitReader.READ_SIZE;
      br = new BrotliBitReader(input);
      window_bits = DecodeWindowBits(br);
      max_backward_distance = (1 << window_bits) - 16;
      ringbuffer_size = 1 << window_bits;
      ringbuffer_mask = ringbuffer_size - 1;
      ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + BrotliDictionary.maxDictionaryWordLength);
      ringbuffer_end = ringbuffer_size;
      block_type_trees = [];
      block_len_trees = [];
      for (var x = 0; x < 3 * HUFFMAN_MAX_TABLE_SIZE; x++) {
        block_type_trees[x] = new HuffmanCode(0, 0);
        block_len_trees[x] = new HuffmanCode(0, 0);
      }
      while (!input_end) {
        var meta_block_remaining_len = 0;
        var is_uncompressed;
        var block_length = [1 << 28, 1 << 28, 1 << 28];
        var block_type = [0];
        var num_block_types = [1, 1, 1];
        var block_type_rb = [0, 1, 0, 1, 0, 1];
        var block_type_rb_index = [0];
        var distance_postfix_bits;
        var num_direct_distance_codes;
        var distance_postfix_mask;
        var num_distance_codes;
        var context_map = null;
        var context_modes = null;
        var num_literal_htrees;
        var dist_context_map = null;
        var num_dist_htrees;
        var context_offset = 0;
        var context_map_slice = null;
        var literal_htree_index = 0;
        var dist_context_offset = 0;
        var dist_context_map_slice = null;
        var dist_htree_index = 0;
        var context_lookup_offset1 = 0;
        var context_lookup_offset2 = 0;
        var context_mode;
        var htree_command;
        for (i3 = 0; i3 < 3; ++i3) {
          hgroup[i3].codes = null;
          hgroup[i3].htrees = null;
        }
        br.readMoreInput();
        var _out = DecodeMetaBlockLength(br);
        meta_block_remaining_len = _out.meta_block_length;
        if (pos + meta_block_remaining_len > output.buffer.length) {
          var tmp = new Uint8Array(pos + meta_block_remaining_len);
          tmp.set(output.buffer);
          output.buffer = tmp;
        }
        input_end = _out.input_end;
        is_uncompressed = _out.is_uncompressed;
        if (_out.is_metadata) {
          JumpToByteBoundary(br);
          for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {
            br.readMoreInput();
            br.readBits(8);
          }
          continue;
        }
        if (meta_block_remaining_len === 0) {
          continue;
        }
        if (is_uncompressed) {
          br.bit_pos_ = br.bit_pos_ + 7 & ~7;
          CopyUncompressedBlockToOutput(
            output,
            meta_block_remaining_len,
            pos,
            ringbuffer,
            ringbuffer_mask,
            br
          );
          pos += meta_block_remaining_len;
          continue;
        }
        for (i3 = 0; i3 < 3; ++i3) {
          num_block_types[i3] = DecodeVarLenUint8(br) + 1;
          if (num_block_types[i3] >= 2) {
            ReadHuffmanCode(num_block_types[i3] + 2, block_type_trees, i3 * HUFFMAN_MAX_TABLE_SIZE, br);
            ReadHuffmanCode(kNumBlockLengthCodes, block_len_trees, i3 * HUFFMAN_MAX_TABLE_SIZE, br);
            block_length[i3] = ReadBlockLength(block_len_trees, i3 * HUFFMAN_MAX_TABLE_SIZE, br);
            block_type_rb_index[i3] = 1;
          }
        }
        br.readMoreInput();
        distance_postfix_bits = br.readBits(2);
        num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits);
        distance_postfix_mask = (1 << distance_postfix_bits) - 1;
        num_distance_codes = num_direct_distance_codes + (48 << distance_postfix_bits);
        context_modes = new Uint8Array(num_block_types[0]);
        for (i3 = 0; i3 < num_block_types[0]; ++i3) {
          br.readMoreInput();
          context_modes[i3] = br.readBits(2) << 1;
        }
        var _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br);
        num_literal_htrees = _o1.num_htrees;
        context_map = _o1.context_map;
        var _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br);
        num_dist_htrees = _o2.num_htrees;
        dist_context_map = _o2.context_map;
        hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees);
        hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1]);
        hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees);
        for (i3 = 0; i3 < 3; ++i3) {
          hgroup[i3].decode(br);
        }
        context_map_slice = 0;
        dist_context_map_slice = 0;
        context_mode = context_modes[block_type[0]];
        context_lookup_offset1 = Context.lookupOffsets[context_mode];
        context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
        htree_command = hgroup[1].htrees[0];
        while (meta_block_remaining_len > 0) {
          var cmd_code;
          var range_idx;
          var insert_code;
          var copy_code;
          var insert_length;
          var copy_length;
          var distance_code;
          var distance;
          var context;
          var j;
          var copy_dst;
          br.readMoreInput();
          if (block_length[1] === 0) {
            DecodeBlockType(
              num_block_types[1],
              block_type_trees,
              1,
              block_type,
              block_type_rb,
              block_type_rb_index,
              br
            );
            block_length[1] = ReadBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br);
            htree_command = hgroup[1].htrees[block_type[1]];
          }
          --block_length[1];
          cmd_code = ReadSymbol(hgroup[1].codes, htree_command, br);
          range_idx = cmd_code >> 6;
          if (range_idx >= 2) {
            range_idx -= 2;
            distance_code = -1;
          } else {
            distance_code = 0;
          }
          insert_code = Prefix.kInsertRangeLut[range_idx] + (cmd_code >> 3 & 7);
          copy_code = Prefix.kCopyRangeLut[range_idx] + (cmd_code & 7);
          insert_length = Prefix.kInsertLengthPrefixCode[insert_code].offset + br.readBits(Prefix.kInsertLengthPrefixCode[insert_code].nbits);
          copy_length = Prefix.kCopyLengthPrefixCode[copy_code].offset + br.readBits(Prefix.kCopyLengthPrefixCode[copy_code].nbits);
          prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
          prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
          for (j = 0; j < insert_length; ++j) {
            br.readMoreInput();
            if (block_length[0] === 0) {
              DecodeBlockType(
                num_block_types[0],
                block_type_trees,
                0,
                block_type,
                block_type_rb,
                block_type_rb_index,
                br
              );
              block_length[0] = ReadBlockLength(block_len_trees, 0, br);
              context_offset = block_type[0] << kLiteralContextBits;
              context_map_slice = context_offset;
              context_mode = context_modes[block_type[0]];
              context_lookup_offset1 = Context.lookupOffsets[context_mode];
              context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
            }
            context = Context.lookup[context_lookup_offset1 + prev_byte1] | Context.lookup[context_lookup_offset2 + prev_byte2];
            literal_htree_index = context_map[context_map_slice + context];
            --block_length[0];
            prev_byte2 = prev_byte1;
            prev_byte1 = ReadSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br);
            ringbuffer[pos & ringbuffer_mask] = prev_byte1;
            if ((pos & ringbuffer_mask) === ringbuffer_mask) {
              output.write(ringbuffer, ringbuffer_size);
            }
            ++pos;
          }
          meta_block_remaining_len -= insert_length;
          if (meta_block_remaining_len <= 0) break;
          if (distance_code < 0) {
            var context;
            br.readMoreInput();
            if (block_length[2] === 0) {
              DecodeBlockType(
                num_block_types[2],
                block_type_trees,
                2,
                block_type,
                block_type_rb,
                block_type_rb_index,
                br
              );
              block_length[2] = ReadBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br);
              dist_context_offset = block_type[2] << kDistanceContextBits;
              dist_context_map_slice = dist_context_offset;
            }
            --block_length[2];
            context = (copy_length > 4 ? 3 : copy_length - 2) & 255;
            dist_htree_index = dist_context_map[dist_context_map_slice + context];
            distance_code = ReadSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br);
            if (distance_code >= num_direct_distance_codes) {
              var nbits;
              var postfix;
              var offset2;
              distance_code -= num_direct_distance_codes;
              postfix = distance_code & distance_postfix_mask;
              distance_code >>= distance_postfix_bits;
              nbits = (distance_code >> 1) + 1;
              offset2 = (2 + (distance_code & 1) << nbits) - 4;
              distance_code = num_direct_distance_codes + (offset2 + br.readBits(nbits) << distance_postfix_bits) + postfix;
            }
          }
          distance = TranslateShortCodes(distance_code, dist_rb, dist_rb_idx);
          if (distance < 0) {
            throw new Error("[BrotliDecompress] invalid distance");
          }
          if (pos < max_backward_distance && max_distance !== max_backward_distance) {
            max_distance = pos;
          } else {
            max_distance = max_backward_distance;
          }
          copy_dst = pos & ringbuffer_mask;
          if (distance > max_distance) {
            if (copy_length >= BrotliDictionary.minDictionaryWordLength && copy_length <= BrotliDictionary.maxDictionaryWordLength) {
              var offset2 = BrotliDictionary.offsetsByLength[copy_length];
              var word_id = distance - max_distance - 1;
              var shift = BrotliDictionary.sizeBitsByLength[copy_length];
              var mask = (1 << shift) - 1;
              var word_idx = word_id & mask;
              var transform_idx = word_id >> shift;
              offset2 += word_idx * copy_length;
              if (transform_idx < Transform3.kNumTransforms) {
                var len = Transform3.transformDictionaryWord(ringbuffer, copy_dst, offset2, copy_length, transform_idx);
                copy_dst += len;
                pos += len;
                meta_block_remaining_len -= len;
                if (copy_dst >= ringbuffer_end) {
                  output.write(ringbuffer, ringbuffer_size);
                  for (var _x = 0; _x < copy_dst - ringbuffer_end; _x++)
                    ringbuffer[_x] = ringbuffer[ringbuffer_end + _x];
                }
              } else {
                throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
              }
            } else {
              throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
            }
          } else {
            if (distance_code > 0) {
              dist_rb[dist_rb_idx & 3] = distance;
              ++dist_rb_idx;
            }
            if (copy_length > meta_block_remaining_len) {
              throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
            }
            for (j = 0; j < copy_length; ++j) {
              ringbuffer[pos & ringbuffer_mask] = ringbuffer[pos - distance & ringbuffer_mask];
              if ((pos & ringbuffer_mask) === ringbuffer_mask) {
                output.write(ringbuffer, ringbuffer_size);
              }
              ++pos;
              --meta_block_remaining_len;
            }
          }
          prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
          prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
        }
        pos &= 1073741823;
      }
      output.write(ringbuffer, pos & ringbuffer_mask);
    }
    exports.BrotliDecompress = BrotliDecompress;
    BrotliDictionary.init();
  }
});

// node_modules/brotli/decompress.js
var require_decompress = __commonJS({
  "node_modules/brotli/decompress.js"(exports, module) {
    module.exports = require_decode().BrotliDecompressBuffer;
  }
});

// node_modules/abs-svg-path/index.js
var require_abs_svg_path = __commonJS({
  "node_modules/abs-svg-path/index.js"(exports, module) {
    module.exports = absolutize;
    function absolutize(path) {
      var startX = 0;
      var startY = 0;
      var x = 0;
      var y2 = 0;
      return path.map(function(seg) {
        seg = seg.slice();
        var type = seg[0];
        var command = type.toUpperCase();
        if (type != command) {
          seg[0] = command;
          switch (type) {
            case "a":
              seg[6] += x;
              seg[7] += y2;
              break;
            case "v":
              seg[1] += y2;
              break;
            case "h":
              seg[1] += x;
              break;
            default:
              for (var i3 = 1; i3 < seg.length; ) {
                seg[i3++] += x;
                seg[i3++] += y2;
              }
          }
        }
        switch (command) {
          case "Z":
            x = startX;
            y2 = startY;
            break;
          case "H":
            x = seg[1];
            break;
          case "V":
            y2 = seg[1];
            break;
          case "M":
            x = startX = seg[1];
            y2 = startY = seg[2];
            break;
          default:
            x = seg[seg.length - 2];
            y2 = seg[seg.length - 1];
        }
        return seg;
      });
    }
  }
});

// node_modules/parse-svg-path/index.js
var require_parse_svg_path = __commonJS({
  "node_modules/parse-svg-path/index.js"(exports, module) {
    module.exports = parse3;
    var length2 = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
    var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function parse3(path) {
      var data2 = [];
      path.replace(segment, function(_, command, args) {
        var type = command.toLowerCase();
        args = parseValues(args);
        if (type == "m" && args.length > 2) {
          data2.push([command].concat(args.splice(0, 2)));
          type = "l";
          command = command == "m" ? "l" : "L";
        }
        while (true) {
          if (args.length == length2[type]) {
            args.unshift(command);
            return data2.push(args);
          }
          if (args.length < length2[type]) throw new Error("malformed path data");
          data2.push([command].concat(args.splice(0, length2[type])));
        }
      });
      return data2;
    }
    var number3 = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function parseValues(args) {
      var numbers = args.match(number3);
      return numbers ? numbers.map(Number) : [];
    }
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/simple-swizzle/node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/simple-swizzle/node_modules/is-arrayish/index.js"(exports, module) {
    module.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports, module) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat5 = Array.prototype.concat;
    var slice5 = Array.prototype.slice;
    var swizzle = module.exports = function swizzle2(args) {
      var results = [];
      for (var i3 = 0, len = args.length; i3 < len; i3++) {
        var arg = args[i3];
        if (isArrayish(arg)) {
          results = concat5.call(results, slice5.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports, module) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty3 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty3.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i3;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i3 = 0; i3 < 3; i3++) {
          var i22 = i3 * 2;
          rgb[i3] = parseInt(match.slice(i22, i22 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i3 = 0; i3 < 3; i3++) {
          rgb[i3] = parseInt(match[i3] + match[i3], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i3 = 0; i3 < 3; i3++) {
          rgb[i3] = parseInt(match[i3 + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i3 = 0; i3 < 3; i3++) {
          rgb[i3] = Math.round(parseFloat(match[i3 + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty3.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i3 = 0; i3 < 3; i3++) {
        rgb[i3] = clamp(rgb[i3], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var s2 = clamp(parseFloat(match[2]), 0, 100);
        var l2 = clamp(parseFloat(match[3]), 0, 100);
        var a3 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, s2, l2, a3];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b2 = clamp(parseFloat(match[3]), 0, 100);
        var a3 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, w, b2, a3];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r3 = Math.round(rgba[0] / 255 * 100);
      var g2 = Math.round(rgba[1] / 255 * 100);
      var b2 = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r3 + "%, " + g2 + "%, " + b2 + "%)" : "rgba(" + r3 + "%, " + g2 + "%, " + b2 + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a3 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a3 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a3 + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min2, max2) {
      return Math.min(Math.max(min2, num), max2);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream2() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream2;
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p2 in source) {
          if (_has(source, p2)) {
            obj[p2] = source[p2];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i3 = 0; i3 < len; i3++) {
          dest[dest_offs + i3] = src[src_offs + i3];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i3, l2, len, pos, chunk, result;
        len = 0;
        for (i3 = 0, l2 = chunks.length; i3 < l2; i3++) {
          len += chunks[i3].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i3 = 0, l2 = chunks.length; i3 < l2; i3++) {
          chunk = chunks[i3];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i3 = 0; i3 < len; i3++) {
          dest[dest_offs + i3] = src[src_offs + i3];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on3) {
      if (on3) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils2 = require_common();
    var Z_FIXED2 = 4;
    var Z_BINARY2 = 0;
    var Z_TEXT2 = 1;
    var Z_UNKNOWN2 = 2;
    function zero2(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK2 = 0;
    var STATIC_TREES2 = 1;
    var DYN_TREES2 = 2;
    var MIN_MATCH2 = 3;
    var MAX_MATCH2 = 258;
    var LENGTH_CODES2 = 29;
    var LITERALS2 = 256;
    var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
    var D_CODES2 = 30;
    var BL_CODES2 = 19;
    var HEAP_SIZE2 = 2 * L_CODES2 + 1;
    var MAX_BITS2 = 15;
    var Buf_size2 = 16;
    var MAX_BL_BITS2 = 7;
    var END_BLOCK2 = 256;
    var REP_3_62 = 16;
    var REPZ_3_102 = 17;
    var REPZ_11_1382 = 18;
    var extra_lbits2 = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits2 = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits2 = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN2 = 512;
    var static_ltree2 = new Array((L_CODES2 + 2) * 2);
    zero2(static_ltree2);
    var static_dtree2 = new Array(D_CODES2 * 2);
    zero2(static_dtree2);
    var _dist_code2 = new Array(DIST_CODE_LEN2);
    zero2(_dist_code2);
    var _length_code2 = new Array(MAX_MATCH2 - MIN_MATCH2 + 1);
    zero2(_length_code2);
    var base_length2 = new Array(LENGTH_CODES2);
    zero2(base_length2);
    var base_dist2 = new Array(D_CODES2);
    zero2(base_dist2);
    function StaticTreeDesc2(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc2;
    var static_d_desc2;
    var static_bl_desc2;
    function TreeDesc2(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code2(dist) {
      return dist < 256 ? _dist_code2[dist] : _dist_code2[256 + (dist >>> 7)];
    }
    function put_short2(s2, w) {
      s2.pending_buf[s2.pending++] = w & 255;
      s2.pending_buf[s2.pending++] = w >>> 8 & 255;
    }
    function send_bits2(s2, value2, length2) {
      if (s2.bi_valid > Buf_size2 - length2) {
        s2.bi_buf |= value2 << s2.bi_valid & 65535;
        put_short2(s2, s2.bi_buf);
        s2.bi_buf = value2 >> Buf_size2 - s2.bi_valid;
        s2.bi_valid += length2 - Buf_size2;
      } else {
        s2.bi_buf |= value2 << s2.bi_valid & 65535;
        s2.bi_valid += length2;
      }
    }
    function send_code2(s2, c3, tree) {
      send_bits2(
        s2,
        tree[c3 * 2],
        tree[c3 * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse2(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush2(s2) {
      if (s2.bi_valid === 16) {
        put_short2(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    }
    function gen_bitlen2(s2, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h2;
      var n4, m;
      var bits;
      var xbits;
      var f2;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS2; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE2; h2++) {
        n4 = s2.heap[h2];
        bits = tree[tree[n4 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n4 * 2 + 1] = bits;
        if (n4 > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n4 >= base) {
          xbits = extra[n4 - base];
        }
        f2 = tree[n4 * 2];
        s2.opt_len += f2 * (bits + xbits);
        if (has_stree) {
          s2.static_len += f2 * (stree[n4 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n4 = s2.bl_count[bits];
        while (n4 !== 0) {
          m = s2.heap[--h2];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n4--;
        }
      }
    }
    function gen_codes2(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS2 + 1);
      var code = 0;
      var bits;
      var n4;
      for (bits = 1; bits <= MAX_BITS2; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n4 = 0; n4 <= max_code; n4++) {
        var len = tree[n4 * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n4 * 2] = bi_reverse2(next_code[len]++, len);
      }
    }
    function tr_static_init2() {
      var n4;
      var bits;
      var length2;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS2 + 1);
      length2 = 0;
      for (code = 0; code < LENGTH_CODES2 - 1; code++) {
        base_length2[code] = length2;
        for (n4 = 0; n4 < 1 << extra_lbits2[code]; n4++) {
          _length_code2[length2++] = code;
        }
      }
      _length_code2[length2 - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist2[code] = dist;
        for (n4 = 0; n4 < 1 << extra_dbits2[code]; n4++) {
          _dist_code2[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES2; code++) {
        base_dist2[code] = dist << 7;
        for (n4 = 0; n4 < 1 << extra_dbits2[code] - 7; n4++) {
          _dist_code2[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS2; bits++) {
        bl_count[bits] = 0;
      }
      n4 = 0;
      while (n4 <= 143) {
        static_ltree2[n4 * 2 + 1] = 8;
        n4++;
        bl_count[8]++;
      }
      while (n4 <= 255) {
        static_ltree2[n4 * 2 + 1] = 9;
        n4++;
        bl_count[9]++;
      }
      while (n4 <= 279) {
        static_ltree2[n4 * 2 + 1] = 7;
        n4++;
        bl_count[7]++;
      }
      while (n4 <= 287) {
        static_ltree2[n4 * 2 + 1] = 8;
        n4++;
        bl_count[8]++;
      }
      gen_codes2(static_ltree2, L_CODES2 + 1, bl_count);
      for (n4 = 0; n4 < D_CODES2; n4++) {
        static_dtree2[n4 * 2 + 1] = 5;
        static_dtree2[n4 * 2] = bi_reverse2(n4, 5);
      }
      static_l_desc2 = new StaticTreeDesc2(static_ltree2, extra_lbits2, LITERALS2 + 1, L_CODES2, MAX_BITS2);
      static_d_desc2 = new StaticTreeDesc2(static_dtree2, extra_dbits2, 0, D_CODES2, MAX_BITS2);
      static_bl_desc2 = new StaticTreeDesc2(new Array(0), extra_blbits2, 0, BL_CODES2, MAX_BL_BITS2);
    }
    function init_block2(s2) {
      var n4;
      for (n4 = 0; n4 < L_CODES2; n4++) {
        s2.dyn_ltree[n4 * 2] = 0;
      }
      for (n4 = 0; n4 < D_CODES2; n4++) {
        s2.dyn_dtree[n4 * 2] = 0;
      }
      for (n4 = 0; n4 < BL_CODES2; n4++) {
        s2.bl_tree[n4 * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK2 * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.last_lit = s2.matches = 0;
    }
    function bi_windup2(s2) {
      if (s2.bi_valid > 8) {
        put_short2(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    }
    function copy_block2(s2, buf, len, header) {
      bi_windup2(s2);
      if (header) {
        put_short2(s2, len);
        put_short2(s2, ~len);
      }
      utils2.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
      s2.pending += len;
    }
    function smaller2(tree, n4, m, depth) {
      var _n2 = n4 * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n4] <= depth[m];
    }
    function pqdownheap2(s2, tree, k2) {
      var v2 = s2.heap[k2];
      var j = k2 << 1;
      while (j <= s2.heap_len) {
        if (j < s2.heap_len && smaller2(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
          j++;
        }
        if (smaller2(tree, v2, s2.heap[j], s2.depth)) {
          break;
        }
        s2.heap[k2] = s2.heap[j];
        k2 = j;
        j <<= 1;
      }
      s2.heap[k2] = v2;
    }
    function compress_block2(s2, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s2.last_lit !== 0) {
        do {
          dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
          lc = s2.pending_buf[s2.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code2(s2, lc, ltree);
          } else {
            code = _length_code2[lc];
            send_code2(s2, code + LITERALS2 + 1, ltree);
            extra = extra_lbits2[code];
            if (extra !== 0) {
              lc -= base_length2[code];
              send_bits2(s2, lc, extra);
            }
            dist--;
            code = d_code2(dist);
            send_code2(s2, code, dtree);
            extra = extra_dbits2[code];
            if (extra !== 0) {
              dist -= base_dist2[code];
              send_bits2(s2, dist, extra);
            }
          }
        } while (lx < s2.last_lit);
      }
      send_code2(s2, END_BLOCK2, ltree);
    }
    function build_tree2(s2, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n4, m;
      var max_code = -1;
      var node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE2;
      for (n4 = 0; n4 < elems; n4++) {
        if (tree[n4 * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n4;
          s2.depth[n4] = 0;
        } else {
          tree[n4 * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n4 = s2.heap_len >> 1; n4 >= 1; n4--) {
        pqdownheap2(s2, tree, n4);
      }
      node = elems;
      do {
        n4 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[
          1
          /*SMALLEST*/
        ] = s2.heap[s2.heap_len--];
        pqdownheap2(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
        m = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[--s2.heap_max] = n4;
        s2.heap[--s2.heap_max] = m;
        tree[node * 2] = tree[n4 * 2] + tree[m * 2];
        s2.depth[node] = (s2.depth[n4] >= s2.depth[m] ? s2.depth[n4] : s2.depth[m]) + 1;
        tree[n4 * 2 + 1] = tree[m * 2 + 1] = node;
        s2.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap2(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen2(s2, desc);
      gen_codes2(tree, max_code, s2.bl_count);
    }
    function scan_tree2(s2, tree, max_code) {
      var n4;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n4 = 0; n4 <= max_code; n4++) {
        curlen = nextlen;
        nextlen = tree[(n4 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_62 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_102 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_1382 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree2(s2, tree, max_code) {
      var n4;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n4 = 0; n4 <= max_code; n4++) {
        curlen = nextlen;
        nextlen = tree[(n4 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code2(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code2(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code2(s2, REP_3_62, s2.bl_tree);
          send_bits2(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code2(s2, REPZ_3_102, s2.bl_tree);
          send_bits2(s2, count - 3, 3);
        } else {
          send_code2(s2, REPZ_11_1382, s2.bl_tree);
          send_bits2(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree2(s2) {
      var max_blindex;
      scan_tree2(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree2(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree2(s2, s2.bl_desc);
      for (max_blindex = BL_CODES2 - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order2[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees2(s2, lcodes, dcodes, blcodes) {
      var rank2;
      send_bits2(s2, lcodes - 257, 5);
      send_bits2(s2, dcodes - 1, 5);
      send_bits2(s2, blcodes - 4, 4);
      for (rank2 = 0; rank2 < blcodes; rank2++) {
        send_bits2(s2, s2.bl_tree[bl_order2[rank2] * 2 + 1], 3);
      }
      send_tree2(s2, s2.dyn_ltree, lcodes - 1);
      send_tree2(s2, s2.dyn_dtree, dcodes - 1);
    }
    function detect_data_type2(s2) {
      var black_mask = 4093624447;
      var n4;
      for (n4 = 0; n4 <= 31; n4++, black_mask >>>= 1) {
        if (black_mask & 1 && s2.dyn_ltree[n4 * 2] !== 0) {
          return Z_BINARY2;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT2;
      }
      for (n4 = 32; n4 < LITERALS2; n4++) {
        if (s2.dyn_ltree[n4 * 2] !== 0) {
          return Z_TEXT2;
        }
      }
      return Z_BINARY2;
    }
    var static_init_done2 = false;
    function _tr_init2(s2) {
      if (!static_init_done2) {
        tr_static_init2();
        static_init_done2 = true;
      }
      s2.l_desc = new TreeDesc2(s2.dyn_ltree, static_l_desc2);
      s2.d_desc = new TreeDesc2(s2.dyn_dtree, static_d_desc2);
      s2.bl_desc = new TreeDesc2(s2.bl_tree, static_bl_desc2);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block2(s2);
    }
    function _tr_stored_block2(s2, buf, stored_len, last2) {
      send_bits2(s2, (STORED_BLOCK2 << 1) + (last2 ? 1 : 0), 3);
      copy_block2(s2, buf, stored_len, true);
    }
    function _tr_align2(s2) {
      send_bits2(s2, STATIC_TREES2 << 1, 3);
      send_code2(s2, END_BLOCK2, static_ltree2);
      bi_flush2(s2);
    }
    function _tr_flush_block2(s2, buf, stored_len, last2) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN2) {
          s2.strm.data_type = detect_data_type2(s2);
        }
        build_tree2(s2, s2.l_desc);
        build_tree2(s2, s2.d_desc);
        max_blindex = build_bl_tree2(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block2(s2, buf, stored_len, last2);
      } else if (s2.strategy === Z_FIXED2 || static_lenb === opt_lenb) {
        send_bits2(s2, (STATIC_TREES2 << 1) + (last2 ? 1 : 0), 3);
        compress_block2(s2, static_ltree2, static_dtree2);
      } else {
        send_bits2(s2, (DYN_TREES2 << 1) + (last2 ? 1 : 0), 3);
        send_all_trees2(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block2(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block2(s2);
      if (last2) {
        bi_windup2(s2);
      }
    }
    function _tr_tally2(s2, dist, lc) {
      s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
      s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
      s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
      s2.last_lit++;
      if (dist === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code2[lc] + LITERALS2 + 1) * 2]++;
        s2.dyn_dtree[d_code2(dist) * 2]++;
      }
      return s2.last_lit === s2.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init2;
    exports._tr_stored_block = _tr_stored_block2;
    exports._tr_flush_block = _tr_flush_block2;
    exports._tr_tally = _tr_tally2;
    exports._tr_align = _tr_align2;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    function adler322(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n4 = 0;
      while (len !== 0) {
        n4 = len > 2e3 ? 2e3 : len;
        len -= n4;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n4);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module.exports = adler322;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    function makeTable2() {
      var c3, table = [];
      for (var n4 = 0; n4 < 256; n4++) {
        c3 = n4;
        for (var k2 = 0; k2 < 8; k2++) {
          c3 = c3 & 1 ? 3988292384 ^ c3 >>> 1 : c3 >>> 1;
        }
        table[n4] = c3;
      }
      return table;
    }
    var crcTable2 = makeTable2();
    function crc322(crc, buf, len, pos) {
      var t3 = crcTable2, end2 = pos + len;
      crc ^= -1;
      for (var i3 = pos; i3 < end2; i3++) {
        crc = crc >>> 8 ^ t3[(crc ^ buf[i3]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc322;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils2 = require_common();
    var trees2 = require_trees();
    var adler322 = require_adler32();
    var crc322 = require_crc32();
    var msg2 = require_messages();
    var Z_NO_FLUSH2 = 0;
    var Z_PARTIAL_FLUSH2 = 1;
    var Z_FULL_FLUSH2 = 3;
    var Z_FINISH2 = 4;
    var Z_BLOCK2 = 5;
    var Z_OK2 = 0;
    var Z_STREAM_END2 = 1;
    var Z_STREAM_ERROR2 = -2;
    var Z_DATA_ERROR2 = -3;
    var Z_BUF_ERROR2 = -5;
    var Z_DEFAULT_COMPRESSION2 = -1;
    var Z_FILTERED2 = 1;
    var Z_HUFFMAN_ONLY2 = 2;
    var Z_RLE2 = 3;
    var Z_FIXED2 = 4;
    var Z_DEFAULT_STRATEGY2 = 0;
    var Z_UNKNOWN2 = 2;
    var Z_DEFLATED2 = 8;
    var MAX_MEM_LEVEL2 = 9;
    var MAX_WBITS2 = 15;
    var DEF_MEM_LEVEL2 = 8;
    var LENGTH_CODES2 = 29;
    var LITERALS2 = 256;
    var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
    var D_CODES2 = 30;
    var BL_CODES2 = 19;
    var HEAP_SIZE2 = 2 * L_CODES2 + 1;
    var MAX_BITS2 = 15;
    var MIN_MATCH2 = 3;
    var MAX_MATCH2 = 258;
    var MIN_LOOKAHEAD2 = MAX_MATCH2 + MIN_MATCH2 + 1;
    var PRESET_DICT2 = 32;
    var INIT_STATE2 = 42;
    var EXTRA_STATE2 = 69;
    var NAME_STATE2 = 73;
    var COMMENT_STATE2 = 91;
    var HCRC_STATE2 = 103;
    var BUSY_STATE2 = 113;
    var FINISH_STATE2 = 666;
    var BS_NEED_MORE2 = 1;
    var BS_BLOCK_DONE2 = 2;
    var BS_FINISH_STARTED2 = 3;
    var BS_FINISH_DONE2 = 4;
    var OS_CODE2 = 3;
    function err2(strm, errorCode) {
      strm.msg = msg2[errorCode];
      return errorCode;
    }
    function rank2(f2) {
      return (f2 << 1) - (f2 > 4 ? 9 : 0);
    }
    function zero2(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending2(strm) {
      var s2 = strm.state;
      var len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils2.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    }
    function flush_block_only2(s2, last2) {
      trees2._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last2);
      s2.block_start = s2.strstart;
      flush_pending2(s2.strm);
    }
    function put_byte2(s2, b2) {
      s2.pending_buf[s2.pending++] = b2;
    }
    function putShortMSB2(s2, b2) {
      s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b2 & 255;
    }
    function read_buf2(strm, buf, start2, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils2.arraySet(buf, strm.input, strm.next_in, len, start2);
      if (strm.state.wrap === 1) {
        strm.adler = adler322(strm.adler, buf, len, start2);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc322(strm.adler, buf, len, start2);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match2(s2, cur_match) {
      var chain_length = s2.max_chain_length;
      var scan = s2.strstart;
      var match;
      var len;
      var best_len = s2.prev_length;
      var nice_match = s2.nice_match;
      var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD2 ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD2) : 0;
      var _win = s2.window;
      var wmask = s2.w_mask;
      var prev = s2.prev;
      var strend = s2.strstart + MAX_MATCH2;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH2 - (strend - scan);
        scan = strend - MAX_MATCH2;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    }
    function fill_window2(s2) {
      var _w_size = s2.w_size;
      var p2, n4, m, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD2)) {
          utils2.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          n4 = s2.hash_size;
          p2 = n4;
          do {
            m = s2.head[--p2];
            s2.head[p2] = m >= _w_size ? m - _w_size : 0;
          } while (--n4);
          n4 = _w_size;
          p2 = n4;
          do {
            m = s2.prev[--p2];
            s2.prev[p2] = m >= _w_size ? m - _w_size : 0;
          } while (--n4);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n4 = read_buf2(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n4;
        if (s2.lookahead + s2.insert >= MIN_MATCH2) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
          while (s2.insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH2 - 1]) & s2.hash_mask;
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH2) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD2 && s2.strm.avail_in !== 0);
    }
    function deflate_stored2(s2, flush) {
      var max_block_size = 65535;
      if (max_block_size > s2.pending_buf_size - 5) {
        max_block_size = s2.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s2.lookahead <= 1) {
          fill_window2(s2);
          if (s2.lookahead === 0 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.strstart += s2.lookahead;
        s2.lookahead = 0;
        var max_start = s2.block_start + max_block_size;
        if (s2.strstart === 0 || s2.strstart >= max_start) {
          s2.lookahead = s2.strstart - max_start;
          s2.strstart = max_start;
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
        if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD2) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.strstart > s2.block_start) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_NEED_MORE2;
    }
    function deflate_fast2(s2, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD2) {
          fill_window2(s2);
          if (s2.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH2) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD2) {
          s2.match_length = longest_match2(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH2) {
          bflush = trees2._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH2);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH2) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
          }
        } else {
          bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH2 - 1 ? s2.strstart : MIN_MATCH2 - 1;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    function deflate_slow2(s2, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD2) {
          fill_window2(s2);
          if (s2.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH2) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH2 - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD2) {
          s2.match_length = longest_match2(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED2 || s2.match_length === MIN_MATCH2 && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH2 - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH2 && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH2;
          bflush = trees2._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH2);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH2 - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only2(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE2;
            }
          }
        } else if (s2.match_available) {
          bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only2(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH2 - 1 ? s2.strstart : MIN_MATCH2 - 1;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    function deflate_rle2(s2, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH2) {
          fill_window2(s2);
          if (s2.lookahead <= MAX_MATCH2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH2 && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH2;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH2 - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH2) {
          bflush = trees2._tr_tally(s2, 1, s2.match_length - MIN_MATCH2);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    function deflate_huff2(s2, flush) {
      var bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window2(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH2) {
              return BS_NEED_MORE2;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    function Config2(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table2;
    configuration_table2 = [
      /*      good lazy nice chain */
      new Config2(0, 0, 0, 0, deflate_stored2),
      /* 0 store only */
      new Config2(4, 4, 8, 4, deflate_fast2),
      /* 1 max speed, no lazy matches */
      new Config2(4, 5, 16, 8, deflate_fast2),
      /* 2 */
      new Config2(4, 6, 32, 32, deflate_fast2),
      /* 3 */
      new Config2(4, 4, 16, 16, deflate_slow2),
      /* 4 lazy matches */
      new Config2(8, 16, 32, 32, deflate_slow2),
      /* 5 */
      new Config2(8, 16, 128, 128, deflate_slow2),
      /* 6 */
      new Config2(8, 32, 128, 256, deflate_slow2),
      /* 7 */
      new Config2(32, 128, 258, 1024, deflate_slow2),
      /* 8 */
      new Config2(32, 258, 258, 4096, deflate_slow2)
      /* 9 max compression */
    ];
    function lm_init2(s2) {
      s2.window_size = 2 * s2.w_size;
      zero2(s2.head);
      s2.max_lazy_match = configuration_table2[s2.level].max_lazy;
      s2.good_match = configuration_table2[s2.level].good_length;
      s2.nice_match = configuration_table2[s2.level].nice_length;
      s2.max_chain_length = configuration_table2[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH2 - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    }
    function DeflateState2() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED2;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils2.Buf16(HEAP_SIZE2 * 2);
      this.dyn_dtree = new utils2.Buf16((2 * D_CODES2 + 1) * 2);
      this.bl_tree = new utils2.Buf16((2 * BL_CODES2 + 1) * 2);
      zero2(this.dyn_ltree);
      zero2(this.dyn_dtree);
      zero2(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils2.Buf16(MAX_BITS2 + 1);
      this.heap = new utils2.Buf16(2 * L_CODES2 + 1);
      zero2(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils2.Buf16(2 * L_CODES2 + 1);
      zero2(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep2(strm) {
      var s2;
      if (!strm || !strm.state) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN2;
      s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = s2.wrap ? INIT_STATE2 : BUSY_STATE2;
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = Z_NO_FLUSH2;
      trees2._tr_init(s2);
      return Z_OK2;
    }
    function deflateReset2(strm) {
      var ret = deflateResetKeep2(strm);
      if (ret === Z_OK2) {
        lm_init2(strm.state);
      }
      return ret;
    }
    function deflateSetHeader2(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR2;
      }
      strm.state.gzhead = head;
      return Z_OK2;
    }
    function deflateInit22(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR2;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION2) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL2 || method !== Z_DEFLATED2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED2) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s2 = new DeflateState2();
      strm.state = s2;
      s2.strm = strm;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH2 - 1) / MIN_MATCH2);
      s2.window = new utils2.Buf8(s2.w_size * 2);
      s2.head = new utils2.Buf16(s2.hash_size);
      s2.prev = new utils2.Buf16(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new utils2.Buf8(s2.pending_buf_size);
      s2.d_buf = 1 * s2.lit_bufsize;
      s2.l_buf = (1 + 2) * s2.lit_bufsize;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset2(strm);
    }
    function deflateInit3(strm, level) {
      return deflateInit22(strm, level, Z_DEFLATED2, MAX_WBITS2, DEF_MEM_LEVEL2, Z_DEFAULT_STRATEGY2);
    }
    function deflate2(strm, flush) {
      var old_flush, s2;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK2 || flush < 0) {
        return strm ? err2(strm, Z_STREAM_ERROR2) : Z_STREAM_ERROR2;
      }
      s2 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE2 && flush !== Z_FINISH2) {
        return err2(strm, strm.avail_out === 0 ? Z_BUF_ERROR2 : Z_STREAM_ERROR2);
      }
      s2.strm = strm;
      old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.status === INIT_STATE2) {
        if (s2.wrap === 2) {
          strm.adler = 0;
          put_byte2(s2, 31);
          put_byte2(s2, 139);
          put_byte2(s2, 8);
          if (!s2.gzhead) {
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2 ? 4 : 0);
            put_byte2(s2, OS_CODE2);
            s2.status = BUSY_STATE2;
          } else {
            put_byte2(
              s2,
              (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
            );
            put_byte2(s2, s2.gzhead.time & 255);
            put_byte2(s2, s2.gzhead.time >> 8 & 255);
            put_byte2(s2, s2.gzhead.time >> 16 & 255);
            put_byte2(s2, s2.gzhead.time >> 24 & 255);
            put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2 ? 4 : 0);
            put_byte2(s2, s2.gzhead.os & 255);
            if (s2.gzhead.extra && s2.gzhead.extra.length) {
              put_byte2(s2, s2.gzhead.extra.length & 255);
              put_byte2(s2, s2.gzhead.extra.length >> 8 & 255);
            }
            if (s2.gzhead.hcrc) {
              strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending, 0);
            }
            s2.gzindex = 0;
            s2.status = EXTRA_STATE2;
          }
        } else {
          var header = Z_DEFLATED2 + (s2.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2) {
            level_flags = 0;
          } else if (s2.level < 6) {
            level_flags = 1;
          } else if (s2.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s2.strstart !== 0) {
            header |= PRESET_DICT2;
          }
          header += 31 - header % 31;
          s2.status = BUSY_STATE2;
          putShortMSB2(s2, header);
          if (s2.strstart !== 0) {
            putShortMSB2(s2, strm.adler >>> 16);
            putShortMSB2(s2, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s2.status === EXTRA_STATE2) {
        if (s2.gzhead.extra) {
          beg = s2.pending;
          while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                break;
              }
            }
            put_byte2(s2, s2.gzhead.extra[s2.gzindex] & 255);
            s2.gzindex++;
          }
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (s2.gzindex === s2.gzhead.extra.length) {
            s2.gzindex = 0;
            s2.status = NAME_STATE2;
          }
        } else {
          s2.status = NAME_STATE2;
        }
      }
      if (s2.status === NAME_STATE2) {
        if (s2.gzhead.name) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte2(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.gzindex = 0;
            s2.status = COMMENT_STATE2;
          }
        } else {
          s2.status = COMMENT_STATE2;
        }
      }
      if (s2.status === COMMENT_STATE2) {
        if (s2.gzhead.comment) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte2(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.status = HCRC_STATE2;
          }
        } else {
          s2.status = HCRC_STATE2;
        }
      }
      if (s2.status === HCRC_STATE2) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending2(strm);
          }
          if (s2.pending + 2 <= s2.pending_buf_size) {
            put_byte2(s2, strm.adler & 255);
            put_byte2(s2, strm.adler >> 8 & 255);
            strm.adler = 0;
            s2.status = BUSY_STATE2;
          }
        } else {
          s2.status = BUSY_STATE2;
        }
      }
      if (s2.pending !== 0) {
        flush_pending2(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK2;
        }
      } else if (strm.avail_in === 0 && rank2(flush) <= rank2(old_flush) && flush !== Z_FINISH2) {
        return err2(strm, Z_BUF_ERROR2);
      }
      if (s2.status === FINISH_STATE2 && strm.avail_in !== 0) {
        return err2(strm, Z_BUF_ERROR2);
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH2 && s2.status !== FINISH_STATE2) {
        var bstate = s2.strategy === Z_HUFFMAN_ONLY2 ? deflate_huff2(s2, flush) : s2.strategy === Z_RLE2 ? deflate_rle2(s2, flush) : configuration_table2[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED2 || bstate === BS_FINISH_DONE2) {
          s2.status = FINISH_STATE2;
        }
        if (bstate === BS_NEED_MORE2 || bstate === BS_FINISH_STARTED2) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK2;
        }
        if (bstate === BS_BLOCK_DONE2) {
          if (flush === Z_PARTIAL_FLUSH2) {
            trees2._tr_align(s2);
          } else if (flush !== Z_BLOCK2) {
            trees2._tr_stored_block(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH2) {
              zero2(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending2(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK2;
          }
        }
      }
      if (flush !== Z_FINISH2) {
        return Z_OK2;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END2;
      }
      if (s2.wrap === 2) {
        put_byte2(s2, strm.adler & 255);
        put_byte2(s2, strm.adler >> 8 & 255);
        put_byte2(s2, strm.adler >> 16 & 255);
        put_byte2(s2, strm.adler >> 24 & 255);
        put_byte2(s2, strm.total_in & 255);
        put_byte2(s2, strm.total_in >> 8 & 255);
        put_byte2(s2, strm.total_in >> 16 & 255);
        put_byte2(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB2(s2, strm.adler >>> 16);
        putShortMSB2(s2, strm.adler & 65535);
      }
      flush_pending2(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK2 : Z_STREAM_END2;
    }
    function deflateEnd2(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      status = strm.state.status;
      if (status !== INIT_STATE2 && status !== EXTRA_STATE2 && status !== NAME_STATE2 && status !== COMMENT_STATE2 && status !== HCRC_STATE2 && status !== BUSY_STATE2 && status !== FINISH_STATE2) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      strm.state = null;
      return status === BUSY_STATE2 ? err2(strm, Z_DATA_ERROR2) : Z_OK2;
    }
    function deflateSetDictionary2(strm, dictionary) {
      var dictLength = dictionary.length;
      var s2;
      var str, n4;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      s2 = strm.state;
      wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE2 || s2.lookahead) {
        return Z_STREAM_ERROR2;
      }
      if (wrap === 1) {
        strm.adler = adler322(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero2(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        tmpDict = new utils2.Buf8(s2.w_size);
        utils2.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window2(s2);
      while (s2.lookahead >= MIN_MATCH2) {
        str = s2.strstart;
        n4 = s2.lookahead - (MIN_MATCH2 - 1);
        do {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH2 - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n4);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH2 - 1;
        fill_window2(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH2 - 1;
      s2.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK2;
    }
    exports.deflateInit = deflateInit3;
    exports.deflateInit2 = deflateInit22;
    exports.deflateReset = deflateReset2;
    exports.deflateResetKeep = deflateResetKeep2;
    exports.deflateSetHeader = deflateSetHeader2;
    exports.deflate = deflate2;
    exports.deflateEnd = deflateEnd2;
    exports.deflateSetDictionary = deflateSetDictionary2;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD2 = 30;
    var TYPE2 = 12;
    module.exports = function inflate_fast3(strm, start2) {
      var state2;
      var _in;
      var last2;
      var _out;
      var beg;
      var end2;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from4;
      var from_source;
      var input, output;
      state2 = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last2 = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start2 - strm.avail_out);
      end2 = _out + (strm.avail_out - 257);
      dmax = state2.dmax;
      wsize = state2.wsize;
      whave = state2.whave;
      wnext = state2.wnext;
      s_window = state2.window;
      hold = state2.hold;
      bits = state2.bits;
      lcode = state2.lencode;
      dcode = state2.distcode;
      lmask = (1 << state2.lenbits) - 1;
      dmask = (1 << state2.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state2.mode = BAD2;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state2.sane) {
                            strm.msg = "invalid distance too far back";
                            state2.mode = BAD2;
                            break top;
                          }
                        }
                        from4 = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from4 += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from4 += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from4++];
                              } while (--op);
                              from4 = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from4 += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from4++];
                          output[_out++] = from_source[from4++];
                          output[_out++] = from_source[from4++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from4++];
                          if (len > 1) {
                            output[_out++] = from_source[from4++];
                          }
                        }
                      } else {
                        from4 = _out - dist;
                        do {
                          output[_out++] = output[from4++];
                          output[_out++] = output[from4++];
                          output[_out++] = output[from4++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from4++];
                          if (len > 1) {
                            output[_out++] = output[from4++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state2.mode = BAD2;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state2.mode = TYPE2;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state2.mode = BAD2;
                break top;
              }
              break;
            }
        } while (_in < last2 && _out < end2);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
      strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
      state2.hold = hold;
      state2.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var utils2 = require_common();
    var MAXBITS2 = 15;
    var ENOUGH_LENS2 = 852;
    var ENOUGH_DISTS2 = 592;
    var CODES2 = 0;
    var LENS2 = 1;
    var DISTS2 = 2;
    var lbase2 = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext2 = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase2 = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext2 = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table3(type, lens, lens_index, codes2, table, table_index, work, opts2) {
      var bits = opts2.bits;
      var len = 0;
      var sym = 0;
      var min2 = 0, max2 = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill4;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end2;
      var count = new utils2.Buf16(MAXBITS2 + 1);
      var offs = new utils2.Buf16(MAXBITS2 + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS2; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes2; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max2 = MAXBITS2; max2 >= 1; max2--) {
        if (count[max2] !== 0) {
          break;
        }
      }
      if (root > max2) {
        root = max2;
      }
      if (max2 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts2.bits = 1;
        return 0;
      }
      for (min2 = 1; min2 < max2; min2++) {
        if (count[min2] !== 0) {
          break;
        }
      }
      if (root < min2) {
        root = min2;
      }
      left = 1;
      for (len = 1; len <= MAXBITS2; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES2 || max2 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS2; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes2; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES2) {
        base = extra = work;
        end2 = 19;
      } else if (type === LENS2) {
        base = lbase2;
        base_index -= 257;
        extra = lext2;
        extra_index -= 257;
        end2 = 256;
      } else {
        base = dbase2;
        extra = dext2;
        end2 = -1;
      }
      huff = 0;
      sym = 0;
      len = min2;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS2 && used > ENOUGH_LENS2 || type === DISTS2 && used > ENOUGH_DISTS2) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end2) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end2) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill4 = 1 << curr;
        min2 = fill4;
        do {
          fill4 -= incr;
          table[next + (huff >> drop) + fill4] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill4 !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max2) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min2;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max2) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS2 && used > ENOUGH_LENS2 || type === DISTS2 && used > ENOUGH_DISTS2) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts2.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils2 = require_common();
    var adler322 = require_adler32();
    var crc322 = require_crc32();
    var inflate_fast3 = require_inffast();
    var inflate_table3 = require_inftrees();
    var CODES2 = 0;
    var LENS2 = 1;
    var DISTS2 = 2;
    var Z_FINISH2 = 4;
    var Z_BLOCK2 = 5;
    var Z_TREES2 = 6;
    var Z_OK2 = 0;
    var Z_STREAM_END2 = 1;
    var Z_NEED_DICT2 = 2;
    var Z_STREAM_ERROR2 = -2;
    var Z_DATA_ERROR2 = -3;
    var Z_MEM_ERROR2 = -4;
    var Z_BUF_ERROR2 = -5;
    var Z_DEFLATED2 = 8;
    var HEAD2 = 1;
    var FLAGS2 = 2;
    var TIME2 = 3;
    var OS2 = 4;
    var EXLEN2 = 5;
    var EXTRA2 = 6;
    var NAME2 = 7;
    var COMMENT2 = 8;
    var HCRC2 = 9;
    var DICTID2 = 10;
    var DICT2 = 11;
    var TYPE2 = 12;
    var TYPEDO2 = 13;
    var STORED2 = 14;
    var COPY_2 = 15;
    var COPY2 = 16;
    var TABLE2 = 17;
    var LENLENS2 = 18;
    var CODELENS2 = 19;
    var LEN_2 = 20;
    var LEN2 = 21;
    var LENEXT2 = 22;
    var DIST2 = 23;
    var DISTEXT2 = 24;
    var MATCH2 = 25;
    var LIT2 = 26;
    var CHECK2 = 27;
    var LENGTH2 = 28;
    var DONE2 = 29;
    var BAD2 = 30;
    var MEM2 = 31;
    var SYNC2 = 32;
    var ENOUGH_LENS2 = 852;
    var ENOUGH_DISTS2 = 592;
    var MAX_WBITS2 = 15;
    var DEF_WBITS2 = MAX_WBITS2;
    function zswap322(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState2() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils2.Buf16(320);
      this.work = new utils2.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep2(strm) {
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      strm.total_in = strm.total_out = state2.total = 0;
      strm.msg = "";
      if (state2.wrap) {
        strm.adler = state2.wrap & 1;
      }
      state2.mode = HEAD2;
      state2.last = 0;
      state2.havedict = 0;
      state2.dmax = 32768;
      state2.head = null;
      state2.hold = 0;
      state2.bits = 0;
      state2.lencode = state2.lendyn = new utils2.Buf32(ENOUGH_LENS2);
      state2.distcode = state2.distdyn = new utils2.Buf32(ENOUGH_DISTS2);
      state2.sane = 1;
      state2.back = -1;
      return Z_OK2;
    }
    function inflateReset3(strm) {
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      state2.wsize = 0;
      state2.whave = 0;
      state2.wnext = 0;
      return inflateResetKeep2(strm);
    }
    function inflateReset22(strm, windowBits) {
      var wrap;
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR2;
      }
      if (state2.window !== null && state2.wbits !== windowBits) {
        state2.window = null;
      }
      state2.wrap = wrap;
      state2.wbits = windowBits;
      return inflateReset3(strm);
    }
    function inflateInit22(strm, windowBits) {
      var ret;
      var state2;
      if (!strm) {
        return Z_STREAM_ERROR2;
      }
      state2 = new InflateState2();
      strm.state = state2;
      state2.window = null;
      ret = inflateReset22(strm, windowBits);
      if (ret !== Z_OK2) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit3(strm) {
      return inflateInit22(strm, DEF_WBITS2);
    }
    var virgin2 = true;
    var lenfix2;
    var distfix2;
    function fixedtables2(state2) {
      if (virgin2) {
        var sym;
        lenfix2 = new utils2.Buf32(512);
        distfix2 = new utils2.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state2.lens[sym++] = 8;
        }
        while (sym < 256) {
          state2.lens[sym++] = 9;
        }
        while (sym < 280) {
          state2.lens[sym++] = 7;
        }
        while (sym < 288) {
          state2.lens[sym++] = 8;
        }
        inflate_table3(LENS2, state2.lens, 0, 288, lenfix2, 0, state2.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state2.lens[sym++] = 5;
        }
        inflate_table3(DISTS2, state2.lens, 0, 32, distfix2, 0, state2.work, { bits: 5 });
        virgin2 = false;
      }
      state2.lencode = lenfix2;
      state2.lenbits = 9;
      state2.distcode = distfix2;
      state2.distbits = 5;
    }
    function updatewindow2(strm, src, end2, copy5) {
      var dist;
      var state2 = strm.state;
      if (state2.window === null) {
        state2.wsize = 1 << state2.wbits;
        state2.wnext = 0;
        state2.whave = 0;
        state2.window = new utils2.Buf8(state2.wsize);
      }
      if (copy5 >= state2.wsize) {
        utils2.arraySet(state2.window, src, end2 - state2.wsize, state2.wsize, 0);
        state2.wnext = 0;
        state2.whave = state2.wsize;
      } else {
        dist = state2.wsize - state2.wnext;
        if (dist > copy5) {
          dist = copy5;
        }
        utils2.arraySet(state2.window, src, end2 - copy5, dist, state2.wnext);
        copy5 -= dist;
        if (copy5) {
          utils2.arraySet(state2.window, src, end2 - copy5, copy5, 0);
          state2.wnext = copy5;
          state2.whave = state2.wsize;
        } else {
          state2.wnext += dist;
          if (state2.wnext === state2.wsize) {
            state2.wnext = 0;
          }
          if (state2.whave < state2.wsize) {
            state2.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate2(strm, flush) {
      var state2;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy5;
      var from4;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils2.Buf8(4);
      var opts2;
      var n4;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (state2.mode === TYPE2) {
        state2.mode = TYPEDO2;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state2.hold;
      bits = state2.bits;
      _in = have;
      _out = left;
      ret = Z_OK2;
      inf_leave:
        for (; ; ) {
          switch (state2.mode) {
            case HEAD2:
              if (state2.wrap === 0) {
                state2.mode = TYPEDO2;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.wrap & 2 && hold === 35615) {
                state2.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state2.mode = FLAGS2;
                break;
              }
              state2.flags = 0;
              if (state2.head) {
                state2.head.done = false;
              }
              if (!(state2.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state2.mode = BAD2;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED2) {
                strm.msg = "unknown compression method";
                state2.mode = BAD2;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state2.wbits === 0) {
                state2.wbits = len;
              } else if (len > state2.wbits) {
                strm.msg = "invalid window size";
                state2.mode = BAD2;
                break;
              }
              state2.dmax = 1 << len;
              strm.adler = state2.check = 1;
              state2.mode = hold & 512 ? DICTID2 : TYPE2;
              hold = 0;
              bits = 0;
              break;
            case FLAGS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.flags = hold;
              if ((state2.flags & 255) !== Z_DEFLATED2) {
                strm.msg = "unknown compression method";
                state2.mode = BAD2;
                break;
              }
              if (state2.flags & 57344) {
                strm.msg = "unknown header flags set";
                state2.mode = BAD2;
                break;
              }
              if (state2.head) {
                state2.head.text = hold >> 8 & 1;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = TIME2;
            /* falls through */
            case TIME2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.head) {
                state2.head.time = hold;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state2.check = crc322(state2.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = OS2;
            /* falls through */
            case OS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.head) {
                state2.head.xflags = hold & 255;
                state2.head.os = hold >> 8;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = EXLEN2;
            /* falls through */
            case EXLEN2:
              if (state2.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.length = hold;
                if (state2.head) {
                  state2.head.extra_len = hold;
                }
                if (state2.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state2.check = crc322(state2.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state2.head) {
                state2.head.extra = null;
              }
              state2.mode = EXTRA2;
            /* falls through */
            case EXTRA2:
              if (state2.flags & 1024) {
                copy5 = state2.length;
                if (copy5 > have) {
                  copy5 = have;
                }
                if (copy5) {
                  if (state2.head) {
                    len = state2.head.extra_len - state2.length;
                    if (!state2.head.extra) {
                      state2.head.extra = new Array(state2.head.extra_len);
                    }
                    utils2.arraySet(
                      state2.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy5,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state2.flags & 512) {
                    state2.check = crc322(state2.check, input, copy5, next);
                  }
                  have -= copy5;
                  next += copy5;
                  state2.length -= copy5;
                }
                if (state2.length) {
                  break inf_leave;
                }
              }
              state2.length = 0;
              state2.mode = NAME2;
            /* falls through */
            case NAME2:
              if (state2.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy5 = 0;
                do {
                  len = input[next + copy5++];
                  if (state2.head && len && state2.length < 65536) {
                    state2.head.name += String.fromCharCode(len);
                  }
                } while (len && copy5 < have);
                if (state2.flags & 512) {
                  state2.check = crc322(state2.check, input, copy5, next);
                }
                have -= copy5;
                next += copy5;
                if (len) {
                  break inf_leave;
                }
              } else if (state2.head) {
                state2.head.name = null;
              }
              state2.length = 0;
              state2.mode = COMMENT2;
            /* falls through */
            case COMMENT2:
              if (state2.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy5 = 0;
                do {
                  len = input[next + copy5++];
                  if (state2.head && len && state2.length < 65536) {
                    state2.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy5 < have);
                if (state2.flags & 512) {
                  state2.check = crc322(state2.check, input, copy5, next);
                }
                have -= copy5;
                next += copy5;
                if (len) {
                  break inf_leave;
                }
              } else if (state2.head) {
                state2.head.comment = null;
              }
              state2.mode = HCRC2;
            /* falls through */
            case HCRC2:
              if (state2.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state2.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state2.head) {
                state2.head.hcrc = state2.flags >> 9 & 1;
                state2.head.done = true;
              }
              strm.adler = state2.check = 0;
              state2.mode = TYPE2;
              break;
            case DICTID2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state2.check = zswap322(hold);
              hold = 0;
              bits = 0;
              state2.mode = DICT2;
            /* falls through */
            case DICT2:
              if (state2.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state2.hold = hold;
                state2.bits = bits;
                return Z_NEED_DICT2;
              }
              strm.adler = state2.check = 1;
              state2.mode = TYPE2;
            /* falls through */
            case TYPE2:
              if (flush === Z_BLOCK2 || flush === Z_TREES2) {
                break inf_leave;
              }
            /* falls through */
            case TYPEDO2:
              if (state2.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state2.mode = CHECK2;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state2.mode = STORED2;
                  break;
                case 1:
                  fixedtables2(state2);
                  state2.mode = LEN_2;
                  if (flush === Z_TREES2) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state2.mode = TABLE2;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state2.mode = BAD2;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED2:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state2.mode = BAD2;
                break;
              }
              state2.length = hold & 65535;
              hold = 0;
              bits = 0;
              state2.mode = COPY_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            /* falls through */
            case COPY_2:
              state2.mode = COPY2;
            /* falls through */
            case COPY2:
              copy5 = state2.length;
              if (copy5) {
                if (copy5 > have) {
                  copy5 = have;
                }
                if (copy5 > left) {
                  copy5 = left;
                }
                if (copy5 === 0) {
                  break inf_leave;
                }
                utils2.arraySet(output, input, next, copy5, put);
                have -= copy5;
                next += copy5;
                left -= copy5;
                put += copy5;
                state2.length -= copy5;
                break;
              }
              state2.mode = TYPE2;
              break;
            case TABLE2:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state2.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state2.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state2.nlen > 286 || state2.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state2.mode = BAD2;
                break;
              }
              state2.have = 0;
              state2.mode = LENLENS2;
            /* falls through */
            case LENLENS2:
              while (state2.have < state2.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.lens[order[state2.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state2.have < 19) {
                state2.lens[order[state2.have++]] = 0;
              }
              state2.lencode = state2.lendyn;
              state2.lenbits = 7;
              opts2 = { bits: state2.lenbits };
              ret = inflate_table3(CODES2, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts2);
              state2.lenbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state2.mode = BAD2;
                break;
              }
              state2.have = 0;
              state2.mode = CODELENS2;
            /* falls through */
            case CODELENS2:
              while (state2.have < state2.nlen + state2.ndist) {
                for (; ; ) {
                  here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state2.lens[state2.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n4 = here_bits + 2;
                    while (bits < n4) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state2.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state2.mode = BAD2;
                      break;
                    }
                    len = state2.lens[state2.have - 1];
                    copy5 = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n4 = here_bits + 3;
                    while (bits < n4) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy5 = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n4 = here_bits + 7;
                    while (bits < n4) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy5 = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state2.have + copy5 > state2.nlen + state2.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state2.mode = BAD2;
                    break;
                  }
                  while (copy5--) {
                    state2.lens[state2.have++] = len;
                  }
                }
              }
              if (state2.mode === BAD2) {
                break;
              }
              if (state2.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state2.mode = BAD2;
                break;
              }
              state2.lenbits = 9;
              opts2 = { bits: state2.lenbits };
              ret = inflate_table3(LENS2, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts2);
              state2.lenbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state2.mode = BAD2;
                break;
              }
              state2.distbits = 6;
              state2.distcode = state2.distdyn;
              opts2 = { bits: state2.distbits };
              ret = inflate_table3(DISTS2, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts2);
              state2.distbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state2.mode = BAD2;
                break;
              }
              state2.mode = LEN_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            /* falls through */
            case LEN_2:
              state2.mode = LEN2;
            /* falls through */
            case LEN2:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state2.hold = hold;
                state2.bits = bits;
                inflate_fast3(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state2.hold;
                bits = state2.bits;
                if (state2.mode === TYPE2) {
                  state2.back = -1;
                }
                break;
              }
              state2.back = 0;
              for (; ; ) {
                here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state2.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state2.back += here_bits;
              state2.length = here_val;
              if (here_op === 0) {
                state2.mode = LIT2;
                break;
              }
              if (here_op & 32) {
                state2.back = -1;
                state2.mode = TYPE2;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state2.mode = BAD2;
                break;
              }
              state2.extra = here_op & 15;
              state2.mode = LENEXT2;
            /* falls through */
            case LENEXT2:
              if (state2.extra) {
                n4 = state2.extra;
                while (bits < n4) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.length += hold & (1 << state2.extra) - 1;
                hold >>>= state2.extra;
                bits -= state2.extra;
                state2.back += state2.extra;
              }
              state2.was = state2.length;
              state2.mode = DIST2;
            /* falls through */
            case DIST2:
              for (; ; ) {
                here = state2.distcode[hold & (1 << state2.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state2.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state2.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state2.mode = BAD2;
                break;
              }
              state2.offset = here_val;
              state2.extra = here_op & 15;
              state2.mode = DISTEXT2;
            /* falls through */
            case DISTEXT2:
              if (state2.extra) {
                n4 = state2.extra;
                while (bits < n4) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.offset += hold & (1 << state2.extra) - 1;
                hold >>>= state2.extra;
                bits -= state2.extra;
                state2.back += state2.extra;
              }
              if (state2.offset > state2.dmax) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD2;
                break;
              }
              state2.mode = MATCH2;
            /* falls through */
            case MATCH2:
              if (left === 0) {
                break inf_leave;
              }
              copy5 = _out - left;
              if (state2.offset > copy5) {
                copy5 = state2.offset - copy5;
                if (copy5 > state2.whave) {
                  if (state2.sane) {
                    strm.msg = "invalid distance too far back";
                    state2.mode = BAD2;
                    break;
                  }
                }
                if (copy5 > state2.wnext) {
                  copy5 -= state2.wnext;
                  from4 = state2.wsize - copy5;
                } else {
                  from4 = state2.wnext - copy5;
                }
                if (copy5 > state2.length) {
                  copy5 = state2.length;
                }
                from_source = state2.window;
              } else {
                from_source = output;
                from4 = put - state2.offset;
                copy5 = state2.length;
              }
              if (copy5 > left) {
                copy5 = left;
              }
              left -= copy5;
              state2.length -= copy5;
              do {
                output[put++] = from_source[from4++];
              } while (--copy5);
              if (state2.length === 0) {
                state2.mode = LEN2;
              }
              break;
            case LIT2:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state2.length;
              left--;
              state2.mode = LEN2;
              break;
            case CHECK2:
              if (state2.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state2.total += _out;
                if (_out) {
                  strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
                  state2.flags ? crc322(state2.check, output, _out, put - _out) : adler322(state2.check, output, _out, put - _out);
                }
                _out = left;
                if ((state2.flags ? hold : zswap322(hold)) !== state2.check) {
                  strm.msg = "incorrect data check";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state2.mode = LENGTH2;
            /* falls through */
            case LENGTH2:
              if (state2.wrap && state2.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state2.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state2.mode = DONE2;
            /* falls through */
            case DONE2:
              ret = Z_STREAM_END2;
              break inf_leave;
            case BAD2:
              ret = Z_DATA_ERROR2;
              break inf_leave;
            case MEM2:
              return Z_MEM_ERROR2;
            case SYNC2:
            /* falls through */
            default:
              return Z_STREAM_ERROR2;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state2.hold = hold;
      state2.bits = bits;
      if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD2 && (state2.mode < CHECK2 || flush !== Z_FINISH2)) {
        if (updatewindow2(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state2.mode = MEM2;
          return Z_MEM_ERROR2;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state2.total += _out;
      if (state2.wrap && _out) {
        strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state2.flags ? crc322(state2.check, output, _out, strm.next_out - _out) : adler322(state2.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE2 ? 128 : 0) + (state2.mode === LEN_2 || state2.mode === COPY_2 ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH2) && ret === Z_OK2) {
        ret = Z_BUF_ERROR2;
      }
      return ret;
    }
    function inflateEnd2(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      var state2 = strm.state;
      if (state2.window) {
        state2.window = null;
      }
      strm.state = null;
      return Z_OK2;
    }
    function inflateGetHeader2(strm, head) {
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if ((state2.wrap & 2) === 0) {
        return Z_STREAM_ERROR2;
      }
      state2.head = head;
      head.done = false;
      return Z_OK2;
    }
    function inflateSetDictionary2(strm, dictionary) {
      var dictLength = dictionary.length;
      var state2;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (state2.wrap !== 0 && state2.mode !== DICT2) {
        return Z_STREAM_ERROR2;
      }
      if (state2.mode === DICT2) {
        dictid = 1;
        dictid = adler322(dictid, dictionary, dictLength, 0);
        if (dictid !== state2.check) {
          return Z_DATA_ERROR2;
        }
      }
      ret = updatewindow2(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state2.mode = MEM2;
        return Z_MEM_ERROR2;
      }
      state2.havedict = 1;
      return Z_OK2;
    }
    exports.inflateReset = inflateReset3;
    exports.inflateReset2 = inflateReset22;
    exports.inflateResetKeep = inflateResetKeep2;
    exports.inflateInit = inflateInit3;
    exports.inflateInit2 = inflateInit22;
    exports.inflate = inflate2;
    exports.inflateEnd = inflateEnd2;
    exports.inflateGetHeader = inflateGetHeader2;
    exports.inflateSetDictionary = inflateSetDictionary2;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS2 = CryptoJS2 || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof __require === "function") {
          try {
            crypto = require_crypto();
          } catch (err2) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err2) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err2) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base2 = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i3 = 0; i3 < thatSigBytes; i3++) {
                var thatByte = thatWords[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
                thisWords[thisSigBytes + i3 >>> 2] |= thatByte << 24 - (thisSigBytes + i3) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i3 = 0; i3 < nBytes; i3 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i3 = 0; i3 < sigBytes; i3++) {
              var bite = words[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i3 = 0; i3 < hexStrLength; i3 += 2) {
              words[i3 >>> 3] |= parseInt(hexStr.substr(i3, 2), 16) << 24 - i3 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3++) {
              var bite = words[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i3 = 0; i3 < latin1StrLength; i3++) {
              words[i3 >>> 2] |= (latin1Str.charCodeAt(i3) & 255) << 24 - i3 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e3) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base2.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data2) {
            if (typeof data2 == "string") {
              data2 = Utf8.parse(data2);
            }
            this._data.concat(data2);
            this._nDataBytes += data2.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data2 = this._data;
            var dataWords = data2.words;
            var dataSigBytes = data2.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset2 = 0; offset2 < nWordsReady; offset2 += blockSize) {
                this._doProcessBlock(dataWords, offset2);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data2.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base2.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS2;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i3 = 0; i3 < 64; i3++) {
            T[i3] = Math2.abs(Math2.sin(i3 + 1)) * 4294967296 | 0;
          }
        })();
        var MD52 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset2) {
            for (var i3 = 0; i3 < 16; i3++) {
              var offset_i = offset2 + i3;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset2 + 0];
            var M_offset_1 = M[offset2 + 1];
            var M_offset_2 = M[offset2 + 2];
            var M_offset_3 = M[offset2 + 3];
            var M_offset_4 = M[offset2 + 4];
            var M_offset_5 = M[offset2 + 5];
            var M_offset_6 = M[offset2 + 6];
            var M_offset_7 = M[offset2 + 7];
            var M_offset_8 = M[offset2 + 8];
            var M_offset_9 = M[offset2 + 9];
            var M_offset_10 = M[offset2 + 10];
            var M_offset_11 = M[offset2 + 11];
            var M_offset_12 = M[offset2 + 12];
            var M_offset_13 = M[offset2 + 13];
            var M_offset_14 = M[offset2 + 14];
            var M_offset_15 = M[offset2 + 15];
            var a3 = H[0];
            var b2 = H[1];
            var c3 = H[2];
            var d2 = H[3];
            a3 = FF(a3, b2, c3, d2, M_offset_0, 7, T[0]);
            d2 = FF(d2, a3, b2, c3, M_offset_1, 12, T[1]);
            c3 = FF(c3, d2, a3, b2, M_offset_2, 17, T[2]);
            b2 = FF(b2, c3, d2, a3, M_offset_3, 22, T[3]);
            a3 = FF(a3, b2, c3, d2, M_offset_4, 7, T[4]);
            d2 = FF(d2, a3, b2, c3, M_offset_5, 12, T[5]);
            c3 = FF(c3, d2, a3, b2, M_offset_6, 17, T[6]);
            b2 = FF(b2, c3, d2, a3, M_offset_7, 22, T[7]);
            a3 = FF(a3, b2, c3, d2, M_offset_8, 7, T[8]);
            d2 = FF(d2, a3, b2, c3, M_offset_9, 12, T[9]);
            c3 = FF(c3, d2, a3, b2, M_offset_10, 17, T[10]);
            b2 = FF(b2, c3, d2, a3, M_offset_11, 22, T[11]);
            a3 = FF(a3, b2, c3, d2, M_offset_12, 7, T[12]);
            d2 = FF(d2, a3, b2, c3, M_offset_13, 12, T[13]);
            c3 = FF(c3, d2, a3, b2, M_offset_14, 17, T[14]);
            b2 = FF(b2, c3, d2, a3, M_offset_15, 22, T[15]);
            a3 = GG(a3, b2, c3, d2, M_offset_1, 5, T[16]);
            d2 = GG(d2, a3, b2, c3, M_offset_6, 9, T[17]);
            c3 = GG(c3, d2, a3, b2, M_offset_11, 14, T[18]);
            b2 = GG(b2, c3, d2, a3, M_offset_0, 20, T[19]);
            a3 = GG(a3, b2, c3, d2, M_offset_5, 5, T[20]);
            d2 = GG(d2, a3, b2, c3, M_offset_10, 9, T[21]);
            c3 = GG(c3, d2, a3, b2, M_offset_15, 14, T[22]);
            b2 = GG(b2, c3, d2, a3, M_offset_4, 20, T[23]);
            a3 = GG(a3, b2, c3, d2, M_offset_9, 5, T[24]);
            d2 = GG(d2, a3, b2, c3, M_offset_14, 9, T[25]);
            c3 = GG(c3, d2, a3, b2, M_offset_3, 14, T[26]);
            b2 = GG(b2, c3, d2, a3, M_offset_8, 20, T[27]);
            a3 = GG(a3, b2, c3, d2, M_offset_13, 5, T[28]);
            d2 = GG(d2, a3, b2, c3, M_offset_2, 9, T[29]);
            c3 = GG(c3, d2, a3, b2, M_offset_7, 14, T[30]);
            b2 = GG(b2, c3, d2, a3, M_offset_12, 20, T[31]);
            a3 = HH(a3, b2, c3, d2, M_offset_5, 4, T[32]);
            d2 = HH(d2, a3, b2, c3, M_offset_8, 11, T[33]);
            c3 = HH(c3, d2, a3, b2, M_offset_11, 16, T[34]);
            b2 = HH(b2, c3, d2, a3, M_offset_14, 23, T[35]);
            a3 = HH(a3, b2, c3, d2, M_offset_1, 4, T[36]);
            d2 = HH(d2, a3, b2, c3, M_offset_4, 11, T[37]);
            c3 = HH(c3, d2, a3, b2, M_offset_7, 16, T[38]);
            b2 = HH(b2, c3, d2, a3, M_offset_10, 23, T[39]);
            a3 = HH(a3, b2, c3, d2, M_offset_13, 4, T[40]);
            d2 = HH(d2, a3, b2, c3, M_offset_0, 11, T[41]);
            c3 = HH(c3, d2, a3, b2, M_offset_3, 16, T[42]);
            b2 = HH(b2, c3, d2, a3, M_offset_6, 23, T[43]);
            a3 = HH(a3, b2, c3, d2, M_offset_9, 4, T[44]);
            d2 = HH(d2, a3, b2, c3, M_offset_12, 11, T[45]);
            c3 = HH(c3, d2, a3, b2, M_offset_15, 16, T[46]);
            b2 = HH(b2, c3, d2, a3, M_offset_2, 23, T[47]);
            a3 = II(a3, b2, c3, d2, M_offset_0, 6, T[48]);
            d2 = II(d2, a3, b2, c3, M_offset_7, 10, T[49]);
            c3 = II(c3, d2, a3, b2, M_offset_14, 15, T[50]);
            b2 = II(b2, c3, d2, a3, M_offset_5, 21, T[51]);
            a3 = II(a3, b2, c3, d2, M_offset_12, 6, T[52]);
            d2 = II(d2, a3, b2, c3, M_offset_3, 10, T[53]);
            c3 = II(c3, d2, a3, b2, M_offset_10, 15, T[54]);
            b2 = II(b2, c3, d2, a3, M_offset_1, 21, T[55]);
            a3 = II(a3, b2, c3, d2, M_offset_8, 6, T[56]);
            d2 = II(d2, a3, b2, c3, M_offset_15, 10, T[57]);
            c3 = II(c3, d2, a3, b2, M_offset_6, 15, T[58]);
            b2 = II(b2, c3, d2, a3, M_offset_13, 21, T[59]);
            a3 = II(a3, b2, c3, d2, M_offset_4, 6, T[60]);
            d2 = II(d2, a3, b2, c3, M_offset_11, 10, T[61]);
            c3 = II(c3, d2, a3, b2, M_offset_2, 15, T[62]);
            b2 = II(b2, c3, d2, a3, M_offset_9, 21, T[63]);
            H[0] = H[0] + a3 | 0;
            H[1] = H[1] + b2 | 0;
            H[2] = H[2] + c3 | 0;
            H[3] = H[3] + d2 | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i3 = 0; i3 < 4; i3++) {
              var H_i = H[i3];
              H[i3] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a3, b2, c3, d2, x, s2, t3) {
          var n4 = a3 + (b2 & c3 | ~b2 & d2) + x + t3;
          return (n4 << s2 | n4 >>> 32 - s2) + b2;
        }
        function GG(a3, b2, c3, d2, x, s2, t3) {
          var n4 = a3 + (b2 & d2 | c3 & ~d2) + x + t3;
          return (n4 << s2 | n4 >>> 32 - s2) + b2;
        }
        function HH(a3, b2, c3, d2, x, s2, t3) {
          var n4 = a3 + (b2 ^ c3 ^ d2) + x + t3;
          return (n4 << s2 | n4 >>> 32 - s2) + b2;
        }
        function II(a3, b2, c3, d2, x, s2, t3) {
          var n4 = a3 + (c3 ^ (b2 | ~d2)) + x + t3;
          return (n4 << s2 | n4 >>> 32 - s2) + b2;
        }
        C.MD5 = Hasher._createHelper(MD52);
        C.HmacMD5 = Hasher._createHmacHelper(MD52);
      })(Math);
      return CryptoJS2.MD5;
    });
  }
});

// node_modules/linebreak/node_modules/base64-js/lib/b64.js
var require_b64 = __commonJS({
  "node_modules/linebreak/node_modules/base64-js/lib/b64.js"(exports) {
    var lookup4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    (function(exports2) {
      "use strict";
      var Arr4 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var PLUS = "+".charCodeAt(0);
      var SLASH = "/".charCodeAt(0);
      var NUMBER = "0".charCodeAt(0);
      var LOWER = "a".charCodeAt(0);
      var UPPER = "A".charCodeAt(0);
      var PLUS_URL_SAFE = "-".charCodeAt(0);
      var SLASH_URL_SAFE = "_".charCodeAt(0);
      function decode2(elt) {
        var code = elt.charCodeAt(0);
        if (code === PLUS || code === PLUS_URL_SAFE)
          return 62;
        if (code === SLASH || code === SLASH_URL_SAFE)
          return 63;
        if (code < NUMBER)
          return -1;
        if (code < NUMBER + 10)
          return code - NUMBER + 26 + 26;
        if (code < UPPER + 26)
          return code - UPPER;
        if (code < LOWER + 26)
          return code - LOWER + 26;
      }
      function b64ToByteArray(b64) {
        var i3, j, l2, tmp, placeHolders, arr;
        if (b64.length % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var len = b64.length;
        placeHolders = "=" === b64.charAt(len - 2) ? 2 : "=" === b64.charAt(len - 1) ? 1 : 0;
        arr = new Arr4(b64.length * 3 / 4 - placeHolders);
        l2 = placeHolders > 0 ? b64.length - 4 : b64.length;
        var L = 0;
        function push(v2) {
          arr[L++] = v2;
        }
        for (i3 = 0, j = 0; i3 < l2; i3 += 4, j += 3) {
          tmp = decode2(b64.charAt(i3)) << 18 | decode2(b64.charAt(i3 + 1)) << 12 | decode2(b64.charAt(i3 + 2)) << 6 | decode2(b64.charAt(i3 + 3));
          push((tmp & 16711680) >> 16);
          push((tmp & 65280) >> 8);
          push(tmp & 255);
        }
        if (placeHolders === 2) {
          tmp = decode2(b64.charAt(i3)) << 2 | decode2(b64.charAt(i3 + 1)) >> 4;
          push(tmp & 255);
        } else if (placeHolders === 1) {
          tmp = decode2(b64.charAt(i3)) << 10 | decode2(b64.charAt(i3 + 1)) << 4 | decode2(b64.charAt(i3 + 2)) >> 2;
          push(tmp >> 8 & 255);
          push(tmp & 255);
        }
        return arr;
      }
      function uint8ToBase64(uint82) {
        var i3, extraBytes = uint82.length % 3, output = "", temp, length2;
        function encode(num) {
          return lookup4.charAt(num);
        }
        function tripletToBase644(num) {
          return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63);
        }
        for (i3 = 0, length2 = uint82.length - extraBytes; i3 < length2; i3 += 3) {
          temp = (uint82[i3] << 16) + (uint82[i3 + 1] << 8) + uint82[i3 + 2];
          output += tripletToBase644(temp);
        }
        switch (extraBytes) {
          case 1:
            temp = uint82[uint82.length - 1];
            output += encode(temp >> 2);
            output += encode(temp << 4 & 63);
            output += "==";
            break;
          case 2:
            temp = (uint82[uint82.length - 2] << 8) + uint82[uint82.length - 1];
            output += encode(temp >> 10);
            output += encode(temp >> 4 & 63);
            output += encode(temp << 2 & 63);
            output += "=";
            break;
        }
        return output;
      }
      exports2.toByteArray = b64ToByteArray;
      exports2.fromByteArray = uint8ToBase64;
    })(typeof exports === "undefined" ? exports.base64js = {} : exports);
  }
});

// node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "node_modules/crypto-js/x64-core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base2.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        var X64WordArray = C_x64.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i3 = 0; i3 < x64WordsLength; i3++) {
              var x64Word = x64Words[i3];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i3 = 0; i3 < wordsLength; i3++) {
              words[i3] = words[i3].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS2;
    });
  }
});

// node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i3 = 0; i3 < typedArrayByteLength; i3++) {
              words[i3 >>> 2] |= typedArray[i3] << 24 - i3 % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS2.lib.WordArray;
    });
  }
});

// node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "node_modules/crypto-js/enc-utf16.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3 += 2) {
              var codePoint = words[i3 >>> 2] >>> 16 - i3 % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i3 = 0; i3 < utf16StrLength; i3++) {
              words[i3 >>> 1] |= utf16Str.charCodeAt(i3) << 16 - i3 % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3 += 2) {
              var codePoint = swapEndian(words[i3 >>> 2] >>> 16 - i3 % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i3 = 0; i3 < utf16StrLength; i3++) {
              words[i3 >>> 1] |= swapEndian(utf16Str.charCodeAt(i3) << 16 - i3 % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS2.enc.Utf16;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3 += 3) {
              var byte1 = words[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              var byte2 = words[i3 + 1 >>> 2] >>> 24 - (i3 + 1) % 4 * 8 & 255;
              var byte3 = words[i3 + 2 >>> 2] >>> 24 - (i3 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i3 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i3 = 0; i3 < base64StrLength; i3++) {
            if (i3 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i3 - 1)] << i3 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i3)] >>> 6 - i3 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64;
    });
  }
});

// node_modules/crypto-js/enc-base64url.js
var require_enc_base64url = __commonJS({
  "node_modules/crypto-js/enc-base64url.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64url = C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(wordArray, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3 += 3) {
              var byte1 = words[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              var byte2 = words[i3 + 1 >>> 2] >>> 24 - (i3 + 1) % 4 * 8 & 255;
              var byte3 = words[i3 + 2 >>> 2] >>> 24 - (i3 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i3 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(base64Str, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i3 = 0; i3 < base64StrLength; i3++) {
            if (i3 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i3 - 1)] << i3 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i3)] >>> 6 - i3 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64url;
    });
  }
});

// node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/crypto-js/sha1.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset2) {
            var H = this._hash.words;
            var a3 = H[0];
            var b2 = H[1];
            var c3 = H[2];
            var d2 = H[3];
            var e3 = H[4];
            for (var i3 = 0; i3 < 80; i3++) {
              if (i3 < 16) {
                W[i3] = M[offset2 + i3] | 0;
              } else {
                var n4 = W[i3 - 3] ^ W[i3 - 8] ^ W[i3 - 14] ^ W[i3 - 16];
                W[i3] = n4 << 1 | n4 >>> 31;
              }
              var t3 = (a3 << 5 | a3 >>> 27) + e3 + W[i3];
              if (i3 < 20) {
                t3 += (b2 & c3 | ~b2 & d2) + 1518500249;
              } else if (i3 < 40) {
                t3 += (b2 ^ c3 ^ d2) + 1859775393;
              } else if (i3 < 60) {
                t3 += (b2 & c3 | b2 & d2 | c3 & d2) - 1894007588;
              } else {
                t3 += (b2 ^ c3 ^ d2) - 899497514;
              }
              e3 = d2;
              d2 = c3;
              c3 = b2 << 30 | b2 >>> 2;
              b2 = a3;
              a3 = t3;
            }
            H[0] = H[0] + a3 | 0;
            H[1] = H[1] + b2 | 0;
            H[2] = H[2] + c3 | 0;
            H[3] = H[3] + d2 | 0;
            H[4] = H[4] + e3 | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS2.SHA1;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n5) {
            var sqrtN = Math2.sqrt(n5);
            for (var factor2 = 2; factor2 <= sqrtN; factor2++) {
              if (!(n5 % factor2)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n5) {
            return (n5 - (n5 | 0)) * 4294967296 | 0;
          }
          var n4 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n4)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n4, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n4, 1 / 3));
              nPrime++;
            }
            n4++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset2) {
            var H2 = this._hash.words;
            var a3 = H2[0];
            var b2 = H2[1];
            var c3 = H2[2];
            var d2 = H2[3];
            var e3 = H2[4];
            var f2 = H2[5];
            var g2 = H2[6];
            var h2 = H2[7];
            for (var i3 = 0; i3 < 64; i3++) {
              if (i3 < 16) {
                W[i3] = M[offset2 + i3] | 0;
              } else {
                var gamma0x = W[i3 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i3 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i3] = gamma0 + W[i3 - 7] + gamma1 + W[i3 - 16];
              }
              var ch = e3 & f2 ^ ~e3 & g2;
              var maj = a3 & b2 ^ a3 & c3 ^ b2 & c3;
              var sigma0 = (a3 << 30 | a3 >>> 2) ^ (a3 << 19 | a3 >>> 13) ^ (a3 << 10 | a3 >>> 22);
              var sigma1 = (e3 << 26 | e3 >>> 6) ^ (e3 << 21 | e3 >>> 11) ^ (e3 << 7 | e3 >>> 25);
              var t1 = h2 + sigma1 + ch + K[i3] + W[i3];
              var t22 = sigma0 + maj;
              h2 = g2;
              g2 = f2;
              f2 = e3;
              e3 = d2 + t1 | 0;
              d2 = c3;
              c3 = b2;
              b2 = a3;
              a3 = t1 + t22 | 0;
            }
            H2[0] = H2[0] + a3 | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c3 | 0;
            H2[3] = H2[3] + d2 | 0;
            H2[4] = H2[4] + e3 | 0;
            H2[5] = H2[5] + f2 | 0;
            H2[6] = H2[6] + g2 | 0;
            H2[7] = H2[7] + h2 | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS2.SHA256;
    });
  }
});

// node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/crypto-js/sha224.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS2.SHA224;
    });
  }
});

// node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/crypto-js/sha512.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i3 = 0; i3 < 80; i3++) {
            W[i3] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset2) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i3 = 0; i3 < 80; i3++) {
              var Wil;
              var Wih;
              var Wi = W[i3];
              if (i3 < 16) {
                Wih = Wi.high = M[offset2 + i3 * 2] | 0;
                Wil = Wi.low = M[offset2 + i3 * 2 + 1] | 0;
              } else {
                var gamma0x = W[i3 - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i3 - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i3 - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i3 - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i3];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS2.SHA512;
    });
  }
});

// node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/crypto-js/sha384.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS2.SHA384;
    });
  }
});

// node_modules/crypto-js/sha3.js
var require_sha3 = __commonJS({
  "node_modules/crypto-js/sha3.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y2 = 0;
          for (var t3 = 0; t3 < 24; t3++) {
            RHO_OFFSETS[x + 5 * y2] = (t3 + 1) * (t3 + 2) / 2 % 64;
            var newX = y2 % 5;
            var newY = (2 * x + 3 * y2) % 5;
            x = newX;
            y2 = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y2 = 0; y2 < 5; y2++) {
              PI_INDEXES[x + 5 * y2] = y2 + (2 * x + 3 * y2) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i3 = 0; i3 < 24; i3++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i3] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i3 = 0; i3 < 25; i3++) {
            T[i3] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state2 = this._state = [];
            for (var i3 = 0; i3 < 25; i3++) {
              state2[i3] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset2) {
            var state2 = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i3 = 0; i3 < nBlockSizeLanes; i3++) {
              var M2i = M[offset2 + 2 * i3];
              var M2i1 = M[offset2 + 2 * i3 + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state2[i3];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y2 = 0; y2 < 5; y2++) {
                  var lane = state2[x + 5 * y2];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y2 = 0; y2 < 5; y2++) {
                  var lane = state2[x + 5 * y2];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state2[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state2[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y2 = 0; y2 < 5; y2++) {
                  var laneIndex = x + 5 * y2;
                  var lane = state2[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y2];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y2];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state2[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            var state2 = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i3 = 0; i3 < outputLengthLanes; i3++) {
              var lane = state2[i3];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state2 = clone._state = this._state.slice(0);
            for (var i3 = 0; i3 < 25; i3++) {
              state2[i3] = state2[i3].clone();
            }
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS2.SHA3;
    });
  }
});

// node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/crypto-js/ripemd160.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset2) {
            for (var i3 = 0; i3 < 16; i3++) {
              var offset_i = offset2 + i3;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t3;
            for (var i3 = 0; i3 < 80; i3 += 1) {
              t3 = al + M[offset2 + zl[i3]] | 0;
              if (i3 < 16) {
                t3 += f1(bl, cl, dl) + hl[0];
              } else if (i3 < 32) {
                t3 += f2(bl, cl, dl) + hl[1];
              } else if (i3 < 48) {
                t3 += f3(bl, cl, dl) + hl[2];
              } else if (i3 < 64) {
                t3 += f4(bl, cl, dl) + hl[3];
              } else {
                t3 += f5(bl, cl, dl) + hl[4];
              }
              t3 = t3 | 0;
              t3 = rotl(t3, sl[i3]);
              t3 = t3 + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t3;
              t3 = ar + M[offset2 + zr[i3]] | 0;
              if (i3 < 16) {
                t3 += f5(br, cr, dr) + hr[0];
              } else if (i3 < 32) {
                t3 += f4(br, cr, dr) + hr[1];
              } else if (i3 < 48) {
                t3 += f3(br, cr, dr) + hr[2];
              } else if (i3 < 64) {
                t3 += f2(br, cr, dr) + hr[3];
              } else {
                t3 += f1(br, cr, dr) + hr[4];
              }
              t3 = t3 | 0;
              t3 = rotl(t3, sr[i3]);
              t3 = t3 + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t3;
            }
            t3 = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t3;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i3 = 0; i3 < 5; i3++) {
              var H_i = H[i3];
              H[i3] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y2, z) {
          return x ^ y2 ^ z;
        }
        function f2(x, y2, z) {
          return x & y2 | ~x & z;
        }
        function f3(x, y2, z) {
          return (x | ~y2) ^ z;
        }
        function f4(x, y2, z) {
          return x & z | y2 & ~z;
        }
        function f5(x, y2, z) {
          return x ^ (y2 | ~z);
        }
        function rotl(x, n4) {
          return x << n4 | x >>> 32 - n4;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS2.RIPEMD160;
    });
  }
});

// node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "node_modules/crypto-js/hmac.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base2.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i3 = 0; i3 < hasherBlockSize; i3++) {
              oKeyWords[i3] ^= 1549556828;
              iKeyWords[i3] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/crypto-js/pbkdf2.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Base2.extend({
            keySize: 128 / 32,
            hasher: SHA256,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i3 = 1; i3 < iterations; i3++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.PBKDF2;
    });
  }
});

// node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "node_modules/crypto-js/evpkdf.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD52 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base2.extend({
            keySize: 128 / 32,
            hasher: MD52,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i3 = 1; i3 < iterations; i3++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.EvpKDF;
    });
  }
});

// node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "node_modules/crypto-js/cipher-core.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.lib.Cipher || function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base2.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base2.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset2) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset2, blockSize);
              cipher.encryptBlock(words, offset2);
              this._prevBlock = words.slice(offset2, offset2 + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset2) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset2, offset2 + blockSize);
              cipher.decryptBlock(words, offset2);
              xorBlock.call(this, words, offset2, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset2, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined2;
            } else {
              block = this._prevBlock;
            }
            for (var i3 = 0; i3 < blockSize; i3++) {
              words[offset2 + i3] ^= block[i3];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data2, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i3 = 0; i3 < nPaddingBytes; i3 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data2.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data2) {
            var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
            data2.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset2) {
            this._mode.processBlock(words, offset2);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base2.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base2.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format3) {
            if (typeof ciphertext == "string") {
              return format3.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt, hasher) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            if (!hasher) {
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            } else {
              var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
            }
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "node_modules/crypto-js/mode-cfb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CFB = function() {
        var CFB = CryptoJS2.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset2, blockSize, cipher);
            this._prevBlock = words.slice(offset2, offset2 + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset2, offset2 + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset2, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset2, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i3 = 0; i3 < blockSize; i3++) {
            words[offset2 + i3] ^= keystream[i3];
          }
        }
        return CFB;
      }();
      return CryptoJS2.mode.CFB;
    });
  }
});

// node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "node_modules/crypto-js/mode-ctr.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CTR = function() {
        var CTR = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i3 = 0; i3 < blockSize; i3++) {
              words[offset2 + i3] ^= keystream[i3];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS2.mode.CTR;
    });
  }
});

// node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS2.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i3 = 0; i3 < blockSize; i3++) {
              words[offset2 + i3] ^= keystream[i3];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS2.mode.CTRGladman;
    });
  }
});

// node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "node_modules/crypto-js/mode-ofb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.OFB = function() {
        var OFB = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i3 = 0; i3 < blockSize; i3++) {
              words[offset2 + i3] ^= keystream[i3];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS2.mode.OFB;
    });
  }
});

// node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "node_modules/crypto-js/mode-ecb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.ECB = function() {
        var ECB = CryptoJS2.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset2) {
            this._cipher.encryptBlock(words, offset2);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset2) {
            this._cipher.decryptBlock(words, offset2);
          }
        });
        return ECB;
      }();
      return CryptoJS2.mode.ECB;
    });
  }
});

// node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.AnsiX923 = {
        pad: function(data2, blockSize) {
          var dataSigBytes = data2.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data2.clamp();
          data2.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data2.sigBytes += nPaddingBytes;
        },
        unpad: function(data2) {
          var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
          data2.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Ansix923;
    });
  }
});

// node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.Iso10126 = {
        pad: function(data2, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
          data2.concat(CryptoJS2.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS2.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data2) {
          var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
          data2.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Iso10126;
    });
  }
});

// node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.Iso97971 = {
        pad: function(data2, blockSize) {
          data2.concat(CryptoJS2.lib.WordArray.create([2147483648], 1));
          CryptoJS2.pad.ZeroPadding.pad(data2, blockSize);
        },
        unpad: function(data2) {
          CryptoJS2.pad.ZeroPadding.unpad(data2);
          data2.sigBytes--;
        }
      };
      return CryptoJS2.pad.Iso97971;
    });
  }
});

// node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.ZeroPadding = {
        pad: function(data2, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data2.clamp();
          data2.sigBytes += blockSizeBytes - (data2.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data2) {
          var dataWords = data2.words;
          var i3 = data2.sigBytes - 1;
          for (var i3 = data2.sigBytes - 1; i3 >= 0; i3--) {
            if (dataWords[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255) {
              data2.sigBytes = i3 + 1;
              break;
            }
          }
        }
      };
      return CryptoJS2.pad.ZeroPadding;
    });
  }
});

// node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS2.pad.NoPadding;
    });
  }
});

// node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "node_modules/crypto-js/format-hex.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        var HexFormatter = C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS2.format.Hex;
    });
  }
});

// node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "node_modules/crypto-js/aes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d2 = [];
          for (var i3 = 0; i3 < 256; i3++) {
            if (i3 < 128) {
              d2[i3] = i3 << 1;
            } else {
              d2[i3] = i3 << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i3 = 0; i3 < 256; i3++) {
            var sx2 = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx2 = sx2 >>> 8 ^ sx2 & 255 ^ 99;
            SBOX[x] = sx2;
            INV_SBOX[sx2] = x;
            var x2 = d2[x];
            var x4 = d2[x2];
            var x8 = d2[x4];
            var t3 = d2[sx2] * 257 ^ sx2 * 16843008;
            SUB_MIX_0[x] = t3 << 24 | t3 >>> 8;
            SUB_MIX_1[x] = t3 << 16 | t3 >>> 16;
            SUB_MIX_2[x] = t3 << 8 | t3 >>> 24;
            SUB_MIX_3[x] = t3;
            var t3 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx2] = t3 << 24 | t3 >>> 8;
            INV_SUB_MIX_1[sx2] = t3 << 16 | t3 >>> 16;
            INV_SUB_MIX_2[sx2] = t3 << 8 | t3 >>> 24;
            INV_SUB_MIX_3[sx2] = t3;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d2[d2[d2[x8 ^ x2]]];
              xi ^= d2[d2[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t3;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t3 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t3 = t3 << 8 | t3 >>> 24;
                  t3 = SBOX[t3 >>> 24] << 24 | SBOX[t3 >>> 16 & 255] << 16 | SBOX[t3 >>> 8 & 255] << 8 | SBOX[t3 & 255];
                  t3 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t3 = SBOX[t3 >>> 24] << 24 | SBOX[t3 >>> 16 & 255] << 16 | SBOX[t3 >>> 8 & 255] << 8 | SBOX[t3 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t3;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t3 = keySchedule[ksRow];
              } else {
                var t3 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t3;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t3 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t3 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t3 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t3 & 255]];
              }
            }
          },
          encryptBlock: function(M, offset2) {
            this._doCryptBlock(M, offset2, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M, offset2) {
            var t3 = M[offset2 + 1];
            M[offset2 + 1] = M[offset2 + 3];
            M[offset2 + 3] = t3;
            this._doCryptBlock(M, offset2, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t3 = M[offset2 + 1];
            M[offset2 + 1] = M[offset2 + 3];
            M[offset2 + 3] = t3;
          },
          _doCryptBlock: function(M, offset2, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset2] ^ keySchedule[0];
            var s1 = M[offset2 + 1] ^ keySchedule[1];
            var s2 = M[offset2 + 2] ^ keySchedule[2];
            var s3 = M[offset2 + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t22 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t22;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t22 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset2] = t0;
            M[offset2 + 1] = t1;
            M[offset2 + 2] = t22;
            M[offset2 + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS2.AES;
    });
  }
});

// node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "node_modules/crypto-js/tripledes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i3 = 0; i3 < 56; i3++) {
              var keyBitPos = PC1[i3] - 1;
              keyBits[i3] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i3 = 0; i3 < 24; i3++) {
                subKey[i3 / 6 | 0] |= keyBits[(PC2[i3] - 1 + bitShift) % 28] << 31 - i3 % 6;
                subKey[4 + (i3 / 6 | 0)] |= keyBits[28 + (PC2[i3 + 24] - 1 + bitShift) % 28] << 31 - i3 % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i3 = 1; i3 < 7; i3++) {
                subKey[i3] = subKey[i3] >>> (i3 - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i3 = 0; i3 < 16; i3++) {
              invSubKeys[i3] = subKeys[15 - i3];
            }
          },
          encryptBlock: function(M, offset2) {
            this._doCryptBlock(M, offset2, this._subKeys);
          },
          decryptBlock: function(M, offset2) {
            this._doCryptBlock(M, offset2, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset2, subKeys) {
            this._lBlock = M[offset2];
            this._rBlock = M[offset2 + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f2 = 0;
              for (var i3 = 0; i3 < 8; i3++) {
                f2 |= SBOX_P[i3][((rBlock ^ subKey[i3]) & SBOX_MASK[i3]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f2;
            }
            var t3 = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t3;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset2] = this._lBlock;
            M[offset2 + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset2, mask) {
          var t3 = (this._lBlock >>> offset2 ^ this._rBlock) & mask;
          this._rBlock ^= t3;
          this._lBlock ^= t3 << offset2;
        }
        function exchangeRL(offset2, mask) {
          var t3 = (this._rBlock >>> offset2 ^ this._lBlock) & mask;
          this._lBlock ^= t3;
          this._rBlock ^= t3 << offset2;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M, offset2) {
            this._des1.encryptBlock(M, offset2);
            this._des2.decryptBlock(M, offset2);
            this._des3.encryptBlock(M, offset2);
          },
          decryptBlock: function(M, offset2) {
            this._des3.decryptBlock(M, offset2);
            this._des2.encryptBlock(M, offset2);
            this._des1.decryptBlock(M, offset2);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS2.TripleDES;
    });
  }
});

// node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "node_modules/crypto-js/rc4.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S2 = this._S = [];
            for (var i3 = 0; i3 < 256; i3++) {
              S2[i3] = i3;
            }
            for (var i3 = 0, j = 0; i3 < 256; i3++) {
              var keyByteIndex = i3 % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S2[i3] + keyByte) % 256;
              var t3 = S2[i3];
              S2[i3] = S2[j];
              S2[j] = t3;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset2) {
            M[offset2] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S2 = this._S;
          var i3 = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n4 = 0; n4 < 4; n4++) {
            i3 = (i3 + 1) % 256;
            j = (j + S2[i3]) % 256;
            var t3 = S2[i3];
            S2[i3] = S2[j];
            S2[j] = t3;
            keystreamWord |= S2[(S2[i3] + S2[j]) % 256] << 24 - n4 * 8;
          }
          this._i = i3;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i3 = this.cfg.drop; i3 > 0; i3--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS2.RC4;
    });
  }
});

// node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "node_modules/crypto-js/rabbit.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S2 = [];
        var C_ = [];
        var G2 = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i3 = 0; i3 < 4; i3++) {
              K[i3] = (K[i3] << 8 | K[i3] >>> 24) & 16711935 | (K[i3] << 24 | K[i3] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i3 = 0; i3 < 4; i3++) {
              nextState.call(this);
            }
            for (var i3 = 0; i3 < 8; i3++) {
              C2[i3] ^= X[i3 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i32 = i22 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i22;
              C2[3] ^= i32;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i22;
              C2[7] ^= i32;
              for (var i3 = 0; i3 < 4; i3++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset2) {
            var X = this._X;
            nextState.call(this);
            S2[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S2[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S2[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S2[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i3 = 0; i3 < 4; i3++) {
              S2[i3] = (S2[i3] << 8 | S2[i3] >>> 24) & 16711935 | (S2[i3] << 24 | S2[i3] >>> 8) & 4278255360;
              M[offset2 + i3] ^= S2[i3];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i3 = 0; i3 < 8; i3++) {
            C_[i3] = C2[i3];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i3 = 0; i3 < 8; i3++) {
            var gx = X[i3] + C2[i3];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i3] = gh ^ gl;
          }
          X[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS2.Rabbit;
    });
  }
});

// node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S2 = [];
        var C_ = [];
        var G2 = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i3 = 0; i3 < 4; i3++) {
              nextState.call(this);
            }
            for (var i3 = 0; i3 < 8; i3++) {
              C2[i3] ^= X[i3 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i32 = i22 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i22;
              C2[3] ^= i32;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i22;
              C2[7] ^= i32;
              for (var i3 = 0; i3 < 4; i3++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset2) {
            var X = this._X;
            nextState.call(this);
            S2[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S2[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S2[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S2[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i3 = 0; i3 < 4; i3++) {
              S2[i3] = (S2[i3] << 8 | S2[i3] >>> 24) & 16711935 | (S2[i3] << 24 | S2[i3] >>> 8) & 4278255360;
              M[offset2 + i3] ^= S2[i3];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i3 = 0; i3 < 8; i3++) {
            C_[i3] = C2[i3];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i3 = 0; i3 < 8; i3++) {
            var gx = X[i3] + C2[i3];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i3] = gh ^ gl;
          }
          X[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS2.RabbitLegacy;
    });
  }
});

// node_modules/crypto-js/blowfish.js
var require_blowfish = __commonJS({
  "node_modules/crypto-js/blowfish.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        const N = 16;
        const ORIG_P = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ];
        const ORIG_S = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var BLOWFISH_CTX = {
          pbox: [],
          sbox: []
        };
        function F(ctx, x) {
          let a3 = x >> 24 & 255;
          let b2 = x >> 16 & 255;
          let c3 = x >> 8 & 255;
          let d2 = x & 255;
          let y2 = ctx.sbox[0][a3] + ctx.sbox[1][b2];
          y2 = y2 ^ ctx.sbox[2][c3];
          y2 = y2 + ctx.sbox[3][d2];
          return y2;
        }
        function BlowFish_Encrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i3 = 0; i3 < N; ++i3) {
            Xl = Xl ^ ctx.pbox[i3];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[N];
          Xl = Xl ^ ctx.pbox[N + 1];
          return { left: Xl, right: Xr };
        }
        function BlowFish_Decrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i3 = N + 1; i3 > 1; --i3) {
            Xl = Xl ^ ctx.pbox[i3];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[1];
          Xl = Xl ^ ctx.pbox[0];
          return { left: Xl, right: Xr };
        }
        function BlowFishInit(ctx, key, keysize) {
          for (let Row = 0; Row < 4; Row++) {
            ctx.sbox[Row] = [];
            for (let Col = 0; Col < 256; Col++) {
              ctx.sbox[Row][Col] = ORIG_S[Row][Col];
            }
          }
          let keyIndex = 0;
          for (let index3 = 0; index3 < N + 2; index3++) {
            ctx.pbox[index3] = ORIG_P[index3] ^ key[keyIndex];
            keyIndex++;
            if (keyIndex >= keysize) {
              keyIndex = 0;
            }
          }
          let Data1 = 0;
          let Data2 = 0;
          let res = 0;
          for (let i3 = 0; i3 < N + 2; i3 += 2) {
            res = BlowFish_Encrypt(ctx, Data1, Data2);
            Data1 = res.left;
            Data2 = res.right;
            ctx.pbox[i3] = Data1;
            ctx.pbox[i3 + 1] = Data2;
          }
          for (let i3 = 0; i3 < 4; i3++) {
            for (let j = 0; j < 256; j += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.sbox[i3][j] = Data1;
              ctx.sbox[i3][j + 1] = Data2;
            }
          }
          return true;
        }
        var Blowfish = C_algo.Blowfish = BlockCipher.extend({
          _doReset: function() {
            if (this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          },
          encryptBlock: function(M, offset2) {
            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset2], M[offset2 + 1]);
            M[offset2] = res.left;
            M[offset2 + 1] = res.right;
          },
          decryptBlock: function(M, offset2) {
            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset2], M[offset2 + 1]);
            M[offset2] = res.left;
            M[offset2 + 1] = res.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        C.Blowfish = BlockCipher._createHelper(Blowfish);
      })();
      return CryptoJS2.Blowfish;
    });
  }
});

// node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "node_modules/crypto-js/index.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_enc_base64url(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha3(), require_ripemd160(), require_hmac(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy(), require_blowfish());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy", "./blowfish"], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      return CryptoJS2;
    });
  }
});

// node_modules/media-engine/src/queries.js
var require_queries = __commonJS({
  "node_modules/media-engine/src/queries.js"(exports, module) {
    function MaxHeight(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value >= options.height;
      };
    }
    function MinHeight(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value < options.height;
      };
    }
    function MaxWidth(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value >= options.width;
      };
    }
    function MinWidth(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value < options.width;
      };
    }
    function Orientation(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value === options.orientation;
      };
    }
    module.exports = function Query(type, value2) {
      switch (type) {
        case "max-height":
          return new MaxHeight(value2);
        case "min-height":
          return new MinHeight(value2);
        case "max-width":
          return new MaxWidth(value2);
        case "min-width":
          return new MinWidth(value2);
        case "orientation":
          return new Orientation(value2);
        default:
          throw new Error(value2);
      }
    };
  }
});

// node_modules/media-engine/src/operators.js
var require_operators = __commonJS({
  "node_modules/media-engine/src/operators.js"(exports, module) {
    function And(left, right) {
      this.left = left;
      this.right = right;
      this.match = function(options) {
        return left.match(options) && right.match(options);
      };
    }
    function Or(left, right) {
      this.left = left;
      this.right = right;
      this.match = function(options) {
        return left.match(options) || right.match(options);
      };
    }
    module.exports = function Operator(type, left, right) {
      switch (type) {
        case "and":
          return new And(left, right);
        case ",":
          return new Or(left, right);
        default:
          throw new Error(value);
      }
    };
  }
});

// node_modules/media-engine/src/parser.js
var require_parser = __commonJS({
  "node_modules/media-engine/src/parser.js"(exports, module) {
    var Query = require_queries();
    var Operator = require_operators();
    var NUMBERS = /[0-9]/;
    var LETTERS = /[a-z|\-]/i;
    var WHITESPACE = /\s/;
    var COLON = /:/;
    var COMMA = /,/;
    var AND = /and$/;
    var AT = /@/;
    function tokenizer(input) {
      var current = 0;
      var tokens = [];
      while (current < input.length) {
        var char = input[current];
        if (AT.test(char)) {
          char = input[++current];
          while (LETTERS.test(char) && char !== void 0) {
            char = input[++current];
          }
        }
        if (WHITESPACE.test(char) || char === ")" || char === "(") {
          current++;
          continue;
        }
        if (COLON.test(char) || COMMA.test(char)) {
          current++;
          tokens.push({ type: "operator", value: char });
          continue;
        }
        if (NUMBERS.test(char)) {
          var value2 = "";
          while (NUMBERS.test(char)) {
            value2 += char;
            char = input[++current];
          }
          tokens.push({ type: "number", value: value2 });
          continue;
        }
        if (LETTERS.test(char)) {
          var value2 = "";
          while (LETTERS.test(char) && char !== void 0) {
            value2 += char;
            char = input[++current];
          }
          if (AND.test(value2)) {
            tokens.push({ type: "operator", value: value2 });
          } else {
            tokens.push({ type: "literal", value: value2 });
          }
          continue;
        }
        throw new TypeError(
          "Tokenizer: I dont know what this character is: " + char
        );
      }
      return tokens;
    }
    function parser(tokens) {
      var output = [];
      var stack = [];
      while (tokens.length > 0) {
        var token = tokens.shift();
        if (token.type === "number" || token.type === "literal") {
          output.push(token);
          continue;
        }
        if (token.type === "operator") {
          if (COLON.test(token.value)) {
            token = { type: "query", key: output.pop(), value: tokens.shift() };
            output.push(token);
            continue;
          }
          while (stack.length > 0) {
            output.unshift(stack.pop());
          }
          stack.push(token);
        }
      }
      while (stack.length > 0) {
        output.unshift(stack.pop());
      }
      function walk() {
        var head = output.shift();
        if (head.type === "number") {
          return parseInt(head.value);
        }
        if (head.type === "literal") {
          return head.value;
        }
        if (head.type === "operator") {
          var l2 = walk();
          var r3 = walk();
          return Operator(head.value, l2, r3);
        }
        if (head.type === "query") {
          var l2 = head.key.value;
          var r3 = head.value.value;
          return Query(l2, r3);
        }
      }
      return walk();
    }
    module.exports = {
      parse: function(query) {
        var tokens = tokenizer(query);
        var ast = parser(tokens);
        return ast;
      }
    };
  }
});

// node_modules/media-engine/src/index.js
var require_src = __commonJS({
  "node_modules/media-engine/src/index.js"(exports, module) {
    var Parser = require_parser();
    module.exports = function(queries, options) {
      var result = {};
      Object.keys(queries).forEach(function(query) {
        if (Parser.parse(query).match(options)) {
          Object.assign(result, queries[query]);
        }
      });
      return result;
    };
  }
});

// node_modules/hsl-to-rgb-for-reals/converter.js
var require_converter = __commonJS({
  "node_modules/hsl-to-rgb-for-reals/converter.js"(exports, module) {
    var hslToRgb = function(hue, saturation, lightness) {
      if (hue == void 0) {
        return [0, 0, 0];
      }
      var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
      var huePrime = hue / 60;
      var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
      huePrime = Math.floor(huePrime);
      var red;
      var green;
      var blue;
      if (huePrime === 0) {
        red = chroma;
        green = secondComponent;
        blue = 0;
      } else if (huePrime === 1) {
        red = secondComponent;
        green = chroma;
        blue = 0;
      } else if (huePrime === 2) {
        red = 0;
        green = chroma;
        blue = secondComponent;
      } else if (huePrime === 3) {
        red = 0;
        green = secondComponent;
        blue = chroma;
      } else if (huePrime === 4) {
        red = secondComponent;
        green = 0;
        blue = chroma;
      } else if (huePrime === 5) {
        red = chroma;
        green = 0;
        blue = secondComponent;
      }
      var lightnessAdjustment = lightness - chroma / 2;
      red += lightnessAdjustment;
      green += lightnessAdjustment;
      blue += lightnessAdjustment;
      return [
        Math.abs(Math.round(red * 255)),
        Math.abs(Math.round(green * 255)),
        Math.abs(Math.round(blue * 255))
      ];
    };
    module.exports = hslToRgb;
  }
});

// node_modules/hsl-to-hex/index.js
var require_hsl_to_hex = __commonJS({
  "node_modules/hsl-to-hex/index.js"(exports, module) {
    var toRgb = require_converter();
    function max2(val, n4) {
      return val > n4 ? n4 : val;
    }
    function min2(val, n4) {
      return val < n4 ? n4 : val;
    }
    function cycle(val) {
      val = max2(val, 1e7);
      val = min2(val, -1e7);
      while (val < 0) {
        val += 360;
      }
      while (val > 359) {
        val -= 360;
      }
      return val;
    }
    function hsl(hue, saturation, luminosity) {
      hue = cycle(hue);
      saturation = min2(max2(saturation, 100), 0);
      luminosity = min2(max2(luminosity, 100), 0);
      saturation /= 100;
      luminosity /= 100;
      var rgb = toRgb(hue, saturation, luminosity);
      return "#" + rgb.map(function(n4) {
        return (256 + n4).toString(16).substr(-2);
      }).join("");
    }
    module.exports = hsl;
  }
});

// node_modules/postcss-value-parser/lib/parse.js
var require_parse = __commonJS({
  "node_modules/postcss-value-parser/lib/parse.js"(exports, module) {
    var openParentheses = "(".charCodeAt(0);
    var closeParentheses = ")".charCodeAt(0);
    var singleQuote = "'".charCodeAt(0);
    var doubleQuote = '"'.charCodeAt(0);
    var backslash = "\\".charCodeAt(0);
    var slash = "/".charCodeAt(0);
    var comma = ",".charCodeAt(0);
    var colon = ":".charCodeAt(0);
    var star = "*".charCodeAt(0);
    var uLower = "u".charCodeAt(0);
    var uUpper = "U".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var isUnicodeRange = /^[a-f0-9?-]+$/i;
    module.exports = function(input) {
      var tokens = [];
      var value2 = input;
      var next, quote, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
      var pos = 0;
      var code = value2.charCodeAt(pos);
      var max2 = value2.length;
      var stack = [{ nodes: tokens }];
      var balanced = 0;
      var parent;
      var name = "";
      var before = "";
      var after = "";
      while (pos < max2) {
        if (code <= 32) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          token = value2.slice(pos, next);
          prev = tokens[tokens.length - 1];
          if (code === closeParentheses && balanced) {
            after = token;
          } else if (prev && prev.type === "div") {
            prev.after = token;
            prev.sourceEndIndex += token.length;
          } else if (code === comma || code === colon || code === slash && value2.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        } else if (code === singleQuote || code === doubleQuote) {
          next = pos;
          quote = code === singleQuote ? "'" : '"';
          token = {
            type: "string",
            sourceIndex: pos,
            quote
          };
          do {
            escape2 = false;
            next = value2.indexOf(quote, next + 1);
            if (~next) {
              escapePos = next;
              while (value2.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape2 = !escape2;
              }
            } else {
              value2 += quote;
              next = value2.length - 1;
              token.unclosed = true;
            }
          } while (escape2);
          token.value = value2.slice(pos + 1, next);
          token.sourceEndIndex = token.unclosed ? next : next + 1;
          tokens.push(token);
          pos = next + 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash && value2.charCodeAt(pos + 1) === star) {
          next = value2.indexOf("*/", pos);
          token = {
            type: "comment",
            sourceIndex: pos,
            sourceEndIndex: next + 2
          };
          if (next === -1) {
            token.unclosed = true;
            next = value2.length;
            token.sourceEndIndex = next;
          }
          token.value = value2.slice(pos + 2, next);
          tokens.push(token);
          pos = next + 2;
          code = value2.charCodeAt(pos);
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
          token = value2[pos];
          tokens.push({
            type: "word",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token
          });
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash || code === comma || code === colon) {
          token = value2[pos];
          tokens.push({
            type: "div",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token,
            before,
            after: ""
          });
          before = "";
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (openParentheses === code) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          parenthesesOpenPos = pos;
          token = {
            type: "function",
            sourceIndex: pos - name.length,
            value: name,
            before: value2.slice(parenthesesOpenPos + 1, next)
          };
          pos = next;
          if (name === "url" && code !== singleQuote && code !== doubleQuote) {
            next -= 1;
            do {
              escape2 = false;
              next = value2.indexOf(")", next + 1);
              if (~next) {
                escapePos = next;
                while (value2.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value2 += ")";
                next = value2.length - 1;
                token.unclosed = true;
              }
            } while (escape2);
            whitespacePos = next;
            do {
              whitespacePos -= 1;
              code = value2.charCodeAt(whitespacePos);
            } while (code <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos !== whitespacePos + 1) {
                token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: whitespacePos + 1,
                    value: value2.slice(pos, whitespacePos + 1)
                  }
                ];
              } else {
                token.nodes = [];
              }
              if (token.unclosed && whitespacePos + 1 !== next) {
                token.after = "";
                token.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  sourceEndIndex: next,
                  value: value2.slice(whitespacePos + 1, next)
                });
              } else {
                token.after = value2.slice(whitespacePos + 1, next);
                token.sourceEndIndex = next;
              }
            } else {
              token.after = "";
              token.nodes = [];
            }
            pos = next + 1;
            token.sourceEndIndex = token.unclosed ? next : pos;
            code = value2.charCodeAt(pos);
            tokens.push(token);
          } else {
            balanced += 1;
            token.after = "";
            token.sourceEndIndex = pos + 1;
            tokens.push(token);
            stack.push(token);
            tokens = token.nodes = [];
            parent = token;
          }
          name = "";
        } else if (closeParentheses === code && balanced) {
          pos += 1;
          code = value2.charCodeAt(pos);
          parent.after = after;
          parent.sourceEndIndex += after.length;
          after = "";
          balanced -= 1;
          stack[stack.length - 1].sourceEndIndex = pos;
          stack.pop();
          parent = stack[balanced];
          tokens = parent.nodes;
        } else {
          next = pos;
          do {
            if (code === backslash) {
              next += 1;
            }
            next += 1;
            code = value2.charCodeAt(next);
          } while (next < max2 && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
          token = value2.slice(pos, next);
          if (openParentheses === code) {
            name = token;
          } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        }
      }
      for (pos = stack.length - 1; pos; pos -= 1) {
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value2.length;
      }
      return stack[0].nodes;
    };
  }
});

// node_modules/postcss-value-parser/lib/unit.js
var require_unit = __commonJS({
  "node_modules/postcss-value-parser/lib/unit.js"(exports, module) {
    var minus = "-".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var dot = ".".charCodeAt(0);
    var exp = "e".charCodeAt(0);
    var EXP = "E".charCodeAt(0);
    function likeNumber(value2) {
      var code = value2.charCodeAt(0);
      var nextCode;
      if (code === plus || code === minus) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        var nextNextCode = value2.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code === dot) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code >= 48 && code <= 57) {
        return true;
      }
      return false;
    }
    module.exports = function(value2) {
      var pos = 0;
      var length2 = value2.length;
      var code;
      var nextCode;
      var nextNextCode;
      if (length2 === 0 || !likeNumber(value2)) {
        return false;
      }
      code = value2.charCodeAt(pos);
      if (code === plus || code === minus) {
        pos++;
      }
      while (pos < length2) {
        code = value2.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while (pos < length2) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      nextNextCode = value2.charCodeAt(pos + 2);
      if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while (pos < length2) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      return {
        number: value2.slice(0, pos),
        unit: value2.slice(pos)
      };
    };
  }
});

// node_modules/hyphen/hyphen.js
var require_hyphen = __commonJS({
  "node_modules/hyphen/hyphen.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.createHyphenator = factory();
      }
    })(exports, function() {
      function createTextReader(setup) {
        var char1 = "";
        var char2 = "";
        var i3 = 0;
        var verifier = setup();
        return function(text) {
          while (i3 < text.length) {
            char1 = text.charAt(i3++);
            char2 = text.charAt(i3);
            var verified = verifier(char1, char2);
            if (verified !== void 0) {
              return verified;
            }
          }
        };
      }
      var isNotLetter = RegExp.prototype.test.bind(
        /\s|(?![\'])[\!-\@\[-\`\{-\~\u2013-\u203C]/
      );
      function createHTMLVerifier() {
        var skip = false;
        return function(accumulate, chars) {
          if (skip) {
            if (chars[0] === ">") {
              accumulate();
              skip = false;
            }
          } else if (chars[0] === "<" && (!isNotLetter(chars[1]) || chars[1] === "/")) {
            skip = true;
          }
          return skip;
        };
      }
      function createHyphenCharVerifier(hyphenChar) {
        var skip = false;
        return function(accumulate, chars) {
          if (skip) {
            if (!isNotLetter(chars[0]) && isNotLetter(chars[1])) {
              accumulate();
              skip = false;
            }
          } else if (!isNotLetter(chars[0]) && chars[1] === hyphenChar) {
            skip = true;
          }
          return skip;
        };
      }
      function createHyphenationVerifier(verifiers, minWordLength) {
        return function() {
          var accum0 = "";
          var accum = "";
          function accumulate() {
            accum0 += accum;
            accum = "";
          }
          function resolveWith(value2) {
            accum0 = "";
            accum = "";
            return value2;
          }
          return function(char1, char2) {
            accum += char1;
            var skip = verifiers.reduce(function(skip2, verify) {
              return skip2 || verify(accumulate, [char1, char2]);
            }, false);
            if (!skip) {
              if (isNotLetter(char1) && !isNotLetter(char2)) {
                accumulate();
              }
              if (!isNotLetter(char1) && isNotLetter(char2)) {
                if (accum.length >= minWordLength) {
                  return resolveWith([accum0, accum]);
                } else {
                  accumulate();
                }
              }
            }
            if (char2 === "") {
              if (accum.length < minWordLength || skip) {
                accumulate();
              }
              return resolveWith([accum0, accum]);
            }
          };
        };
      }
      function createCharIterator(str) {
        var i3 = 0;
        function nextChar() {
          return str[i3++];
        }
        return nextChar;
      }
      function createStringSlicer(str) {
        var i3 = 0, slice5 = str;
        function next() {
          slice5 = str.slice(i3++);
          if (slice5.length < 3) {
            return;
          }
          return slice5;
        }
        function isFirstCharacter() {
          return i3 === 2;
        }
        return [next, isFirstCharacter];
      }
      function hyphenateWord(text, levelsTable, patternTrie, debug3, hyphenChar) {
        var levels = new Array(text.length + 1), loweredText = ("." + text.toLocaleLowerCase() + ".").split(""), wordSlice, letter, triePtr, trieNode, patternLevelsIndex, patternLevels, patternEntityIndex = -1, slicer, nextSlice, isFirstCharacter, nextLetter;
        for (var i3 = levels.length; i3--; ) levels[i3] = 0;
        slicer = createStringSlicer(loweredText);
        nextSlice = slicer[0];
        isFirstCharacter = slicer[1];
        while (wordSlice = nextSlice()) {
          patternEntityIndex++;
          if (isFirstCharacter()) {
            patternEntityIndex--;
          }
          triePtr = patternTrie;
          nextLetter = createCharIterator(wordSlice);
          while (letter = nextLetter()) {
            if ((trieNode = triePtr[letter]) === void 0) {
              break;
            }
            triePtr = {};
            patternLevelsIndex = -1;
            switch (Object.prototype.toString.call(trieNode)) {
              case "[object Array]":
                triePtr = trieNode[0];
                patternLevelsIndex = trieNode[1];
                break;
              case "[object Object]":
                triePtr = trieNode;
                break;
              case "[object Number]":
                patternLevelsIndex = trieNode;
                break;
            }
            if (patternLevelsIndex < 0) {
              continue;
            }
            if (!levelsTable[patternLevelsIndex].splice) {
              levelsTable[patternLevelsIndex] = levelsTable[patternLevelsIndex].slice("");
            }
            patternLevels = levelsTable[patternLevelsIndex];
            for (var k2 = 0; k2 < patternLevels.length; k2++)
              levels[patternEntityIndex + k2] = Math.max(
                patternLevels[k2],
                levels[patternEntityIndex + k2]
              );
          }
        }
        levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;
        var hyphenatedText = "";
        for (var i3 = 0; i3 < levels.length; i3++) {
          hyphenatedText += (levels[i3] % 2 === 1 ? hyphenChar : "") + text.charAt(i3);
        }
        return hyphenatedText;
      }
      function start2(text, levelsTable, patterns, cache2, debug3, hyphenChar, skipHTML, minWordLength, isAsync) {
        function done3() {
          resolveNewText(newText);
        }
        var newText = "", fragments, readText = createTextReader(
          createHyphenationVerifier(
            (skipHTML ? [createHTMLVerifier()] : []).concat(
              createHyphenCharVerifier(hyphenChar)
            ),
            minWordLength
          )
        ), resolveNewText = function() {
        };
        function nextTick3() {
          var loopStart = /* @__PURE__ */ new Date();
          while ((!isAsync || /* @__PURE__ */ new Date() - loopStart < 10) && (fragments = readText(text))) {
            if (fragments[1]) {
              var cacheKey = fragments[1].length ? "~" + fragments[1] : "";
              if (cache2[cacheKey] === void 0) {
                cache2[cacheKey] = hyphenateWord(
                  fragments[1],
                  levelsTable,
                  patterns,
                  debug3,
                  hyphenChar
                );
              }
              fragments[1] = cache2[cacheKey];
            }
            newText += fragments[0] + fragments[1];
          }
          if (!fragments) {
            done3();
          } else {
            setTimeout(nextTick3);
          }
        }
        if (isAsync) {
          setTimeout(nextTick3);
          return new Promise(function(resolve3) {
            resolveNewText = resolve3;
          });
        } else {
          nextTick3();
          return newText;
        }
      }
      var SETTING_DEFAULT_ASYNC = false;
      var SETTING_DEFAULT_DEBUG = false;
      var SETTING_DEFAULT_EXCEPTIONS = [];
      var SETTING_DEFAULT_HTML = true;
      var SETTING_DEFAULT_HYPH_CHAR = "";
      var SETTING_DEFAULT_MIN_WORD_LENGTH = 5;
      var SETTING_NAME_ASYNC = "async";
      var SETTING_NAME_DEBUG = "debug";
      var SETTING_NAME_EXCEPTIONS = "exceptions";
      var SETTING_NAME_HTML = "html";
      var SETTING_NAME_HYPH_CHAR = "hyphenChar";
      var SETTING_NAME_MIN_WORD_LENGTH = "minWordLength";
      var _global = typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : false ? void 0 : {};
      function extend(target, source) {
        target = target || {};
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
      function validateArray(value2) {
        return value2 instanceof Array;
      }
      function keyOrDefault(object, key, defaultValue, test) {
        if (key in object && (test ? test(object[key]) : true)) {
          return object[key];
        }
        return defaultValue;
      }
      function exceptionsFromDefinition(excetionsList, hyphenChar) {
        return excetionsList.reduce(function(exceptions, exception) {
          exceptions["~" + exception.replace(/\-/g, "")] = exception.replace(
            /\-/g,
            hyphenChar
          );
          return exceptions;
        }, {});
      }
      function createHyphenator(patternsDefinition, options) {
        options = options || {};
        var asyncMode = keyOrDefault(
          options,
          SETTING_NAME_ASYNC,
          SETTING_DEFAULT_ASYNC
        ), caches = {}, debug3 = keyOrDefault(options, SETTING_NAME_DEBUG, SETTING_DEFAULT_DEBUG), exceptions = {}, hyphenChar = keyOrDefault(
          options,
          SETTING_NAME_HYPH_CHAR,
          SETTING_DEFAULT_HYPH_CHAR
        ), levelsTable = patternsDefinition[0].split(","), patterns = JSON.parse(patternsDefinition[1]), minWordLength = keyOrDefault(
          options,
          SETTING_NAME_MIN_WORD_LENGTH,
          SETTING_DEFAULT_MIN_WORD_LENGTH
        ) >> 0, skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML), userExceptions = keyOrDefault(
          options,
          SETTING_NAME_EXCEPTIONS,
          SETTING_DEFAULT_EXCEPTIONS,
          validateArray
        );
        var cacheKey = hyphenChar + minWordLength;
        exceptions[cacheKey] = {};
        if (patternsDefinition[2]) {
          exceptions[cacheKey] = exceptionsFromDefinition(
            patternsDefinition[2],
            hyphenChar
          );
        }
        if (userExceptions && userExceptions.length) {
          exceptions[cacheKey] = extend(
            exceptions[cacheKey],
            exceptionsFromDefinition(userExceptions, hyphenChar)
          );
        }
        caches[cacheKey] = extend({}, exceptions[cacheKey]);
        if (asyncMode && !("Promise" in _global)) {
          throw new Error(
            "Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode"
          );
        }
        return function(text, options2) {
          options2 = options2 || {};
          var localDebug = keyOrDefault(options2, SETTING_NAME_DEBUG, debug3), localHyphenChar = keyOrDefault(
            options2,
            SETTING_NAME_HYPH_CHAR,
            hyphenChar
          ), localMinWordLength = keyOrDefault(options2, SETTING_NAME_MIN_WORD_LENGTH, minWordLength) >> 0, localUserExceptions = keyOrDefault(
            options2,
            SETTING_NAME_EXCEPTIONS,
            SETTING_DEFAULT_EXCEPTIONS,
            validateArray
          ), cacheKey2 = localHyphenChar + localMinWordLength;
          if (!exceptions[cacheKey2] && patternsDefinition[2]) {
            exceptions[cacheKey2] = exceptionsFromDefinition(
              patternsDefinition[2],
              localHyphenChar
            );
            caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);
          }
          if (localUserExceptions && localUserExceptions.length) {
            exceptions[cacheKey2] = extend(
              exceptions[cacheKey2],
              exceptionsFromDefinition(localUserExceptions, localHyphenChar)
            );
            caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);
          }
          return start2(
            text,
            levelsTable,
            patterns,
            caches[cacheKey2],
            localDebug,
            localHyphenChar,
            skipHTML,
            localMinWordLength,
            asyncMode
          );
        };
      }
      return createHyphenator;
    });
  }
});

// node_modules/hyphen/patterns/en-us.js
var require_en_us = __commonJS({
  "node_modules/hyphen/patterns/en-us.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.hyphenationPatternsEnUs = factory();
      }
    })(exports, function() {
      return [
        "0004,004,001,003,005,0005,00005,000005,0002,002,0000005,0003,00003,00505,00034,0001,00055,00004,4,05,0055,04,42,03,02,2,404,3,044,01,0505,55,5,045,041,0033,000004,22,00504,5504,0042,1,21,41,402,405,4004,43,23,000054,303,3005,022,5004,000003,252,45,25,2004,000505,054,403,401,3002,0025,144,432,00054,34,12,234,0022,014,0304,012,143,503,0403,101,052,414,212,011,043,00002,0041,0024,05005,03003,00102,0404,04303,01004,0034,025,0044,00404,00025,0103,042,0205,412,104,54,344,433,5005,253,055,0402,3004,0043,204,505,454,0000004,00303,04004,552,201,4005,0255,52,444,14,44,02004,033,05004,00045,00013,0021,0405,00044,0054,50055,000303,00001,304,0204,11,301,232,122,00305,504,000043,0104,00052,000045,50004,0023,00033,00032,00202,5003,202,0401,0000505,214,102,032,000161,004101,00501,00301,0036,0052,00023,006101,006,00401,000521,0014,0063,00012,000501,000006,000604,000601,005001,005005,0010305,00006,003012,003005,0003011,0061,013,000021,000022,000105,00211,00062,00051,000112,006013,000011,0200306,1021,0050001,003003,2102,305,000015,01030005,000035,001011,00021,16330001,0234,030006,5020001,000001,00016,0031,021,21431,002305,0350014,0000012,000063,00101,106,105,00435,00063,0300061,00041,100306,003602,023,0503,0010011,10003,1005,30011,00031,0001001,0000061,0030003,30305,001201,0301,5000101,500101,00015,000401,000065,000016,0000402,0500002,000205,030201,500301,00014,5001,000002,00030011,01034,0300006,030213,00400304,050001,05003,000311,0634,00061,0006,00000604,00050013,00213,0030001,100003,000033,30002,00003632,0003004,050003,0000021,006303,0000006,00005005,30451,03001,00231,00056,00011,6,001001,00500001,03005,503005,0000010001,1002,003001,001065,300001,32011,32,0000003,0213001,0500053,021005,10001,0000011,0001041,0020016,100032,50011,0606,5002,3001,03002,0015001,0102,00003001,000000033,0000001,300101,300015,0101003,00000101,0100501,0101,0010033,00000362,000014,0005001,031",
        '{".":{"a":{"c":{"h":0},"d":{"d":{"e":{"r":1}}},"f":{"t":2},"l":{"t":3},"m":{"a":{"t":4}},"n":{"c":4,"g":0,"i":{"m":5},"t":[{"e":3,"i":{"s":6}},0]},"r":{"s":4,"t":{"i":{"e":1},"y":1}},"s":{"c":3,"p":2,"s":2,"t":{"e":{"r":7}}},"t":{"o":{"m":6}},"u":{"d":2},"v":{"i":1},"w":{"n":0}},"b":{"a":{"g":1,"n":{"a":4},"s":{"e":0}},"e":{"r":[{"a":4},0],"s":{"m":3,"t":{"o":4}}},"r":{"i":8},"u":{"t":{"t":{"i":0}}}},"c":{"a":{"m":{"p":{"e":0}},"n":{"c":5},"p":{"a":{"b":6}},"r":{"o":{"l":5}},"t":1},"e":{"l":{"a":1}},"h":[{"i":{"l":{"l":{"i":7}}}},1],"i":[{"t":{"r":5}},9],"o":{"e":3,"r":[{"n":{"e":{"r":5}}},1],"n":{"g":{"r":5}}}},"d":{"e":{"m":{"o":{"i":1}},"o":3,"r":{"a":3,"i":[{"v":{"a":4}},3]},"s":{"c":0}},"i":{"c":{"t":{"i":{"o":10}}}},"o":{"t":1},"u":{"c":1,"m":{"b":6}},"r":{"i":{"v":67}}},"e":{"a":{"r":{"t":{"h":7}},"s":{"i":11}},"b":1,"e":{"r":0},"g":9,"l":{"d":4,"e":{"m":3}},"n":{"a":{"m":12},"g":3,"s":3},"q":{"u":{"i":{"t":13}}},"r":{"r":{"i":1}},"s":3,"u":[{"l":{"e":{"r":1}}},3],"y":{"e":5},"t":{"h":{"y":{"l":162}}},"v":[{"e":{"r":{"s":{"i":{"b":158}}}}},9]},"f":{"e":{"s":11},"o":{"r":{"m":{"e":{"r":5}}}}},"g":{"a":[{"s":{"o":{"m":163}}},9],"e":[{"n":{"t":14},"o":{"g":4,"m":{"e":1},"t":164}},9],"i":{"a":4,"b":1},"o":{"r":1}},"h":{"a":{"n":{"d":{"i":6},"k":5}},"e":[{"r":{"o":{"i":6,"e":3}},"s":11,"t":11,"m":{"o":165},"p":{"a":166}},9],"i":{"b":3,"e":{"r":3}},"o":{"n":{"e":{"y":5},"o":11},"v":5}},"i":{"d":{"l":1,"o":{"l":12}},"m":{"m":3,"p":{"i":{"n":4}}},"n":[{"c":{"i":3},"e":8,"k":9,"s":3,"u":{"t":167}},2],"r":{"r":4},"s":{"i":1}},"j":{"u":{"r":3}},"l":{"a":{"c":{"y":1},"m":1,"t":{"e":{"r":5},"h":6}},"e":[{"g":{"e":5},"n":0,"p":5,"v":15,"i":{"c":{"e":{"s":170}}}},9],"i":{"g":[{"a":5},1],"n":9,"o":3,"t":1}},"m":{"a":{"g":{"a":16},"l":{"o":5},"n":{"a":5},"r":{"t":{"i":5}}},"e":[{"r":{"c":11},"t":{"e":{"r":4},"a":{"l":{"a":0}}},"g":{"a":{"l":171}}},9],"i":{"s":[{"t":{"i":6},"e":{"r":{"s":173}}},15],"m":{"i":{"c":172}}},"o":{"n":{"e":11},"r":{"o":3}},"u":{"t":{"a":[{"b":6},4]}}},"n":{"i":{"c":1},"e":{"o":{"f":174}},"o":{"e":{"t":{"h":15}},"n":{"e":{"m":175}}}},"o":{"d":[{"d":5},9],"f":{"t":{"e":4}},"r":{"a":{"t":{"o":4}},"c":3,"d":2,"t":3},"s":[{"t":{"l":1}},3],"t":{"h":11},"u":{"t":11}},"p":{"e":{"d":{"a":{"l":5}},"t":{"e":4,"i":{"t":4}}},"i":{"e":1,"o":{"n":5},"t":9},"r":{"e":{"m":11,"a":{"m":15}}},"o":{"l":{"y":{"s":137}},"s":{"t":{"a":{"m":137}}}}},"r":{"a":{"c":1,"n":{"t":0},"t":{"i":{"o":{"n":{"a":7}}}},"v":{"e":{"n":{"o":176}}}},"e":{"e":[{"c":173},8],"m":{"i":{"t":4}},"s":[{"t":{"a":{"t":4}}},8]},"i":{"g":1,"t":{"u":5}},"o":{"q":1,"s":{"t":5},"w":{"d":5}},"u":{"d":1}},"s":{"c":{"i":{"e":11}},"e":{"l":{"f":6,"l":6},"n":9,"r":{"i":{"e":4}},"m":{"i":[{"c":0,"d":177,"p":36,"r":36,"s":178,"v":36},6]}},"h":9,"i":[{"n":{"g":17}},9],"t":[{"a":{"b":{"l":5}}},1],"y":9,"p":{"h":{"i":{"n":179}},"i":{"n":{"o":137}}}},"t":{"a":[{"p":{"e":{"s":{"t":{"r":180}}}}},1],"e":[{"n":{"a":{"n":5}},"l":{"e":{"g":{"r":3}}}},1],"h":9,"i":[{"l":0,"m":{"o":16},"n":{"g":17,"k":5}},9],"o":{"n":{"a":0},"p":[{"i":5,"o":{"g":170}},1],"u":{"s":5},"q":9},"r":{"i":{"b":{"u":{"t":6}}}}},"u":{"n":{"a":[{"t":{"t":144}},2],"c":{"e":3},"d":{"e":{"r":7}},"e":[{"r":{"r":181}},2],"k":4,"o":4,"u":3},"p":3,"r":{"e":11},"s":{"a":4}},"v":{"e":{"n":{"d":{"e":0}},"r":{"a":4}},"i":{"c":{"a":{"r":151}}}},"w":{"i":{"l":{"i":5}},"e":{"b":{"l":131}}},"y":{"e":1},"k":{"i":{"l":{"n":{"i":168}}},"o":{"r":{"t":{"e":169}}}}},"a":{"b":{".":18,"a":{"l":19,"n":19},"e":[{"r":{"d":4}},8],"i":{"a":5,"t":{"a":{"b":13}}},"l":{"a":{"t":4}},"o":{"l":{"i":{"z":20,"c":19}}},"r":[{"o":{"g":4}},18],"u":{"l":3}},"c":{"a":{"r":[{"d":4,"o":4},21],"b":{"l":24}},"e":{"o":{"u":19},"r":2},"h":{"e":{"t":19}},"i":[{"e":23,"n":2,"o":23},22],"r":{"o":{"b":4}},"t":{"i":{"f":5}},"u":{"l":3,"m":1}},"d":[{"d":{"i":{"n":1}},"e":{"r":{".":4}},"i":[{"a":23,"c":{"a":3},"e":{"r":0},"o":23,"t":23,"u":19},25],"l":{"e":1},"o":{"w":3},"r":{"a":{"n":4}},"s":{"u":1},"u":[{"c":23,"m":4},18]},24],"e":{"r":[{"i":{"e":17}},1]},"f":[{"f":[{"i":{"s":{"h":170}}},0]},24],"g":{"a":{"b":21,"n":0},"e":{"l":{"l":4},"o":0,"u":18},"i":2,"l":26,"n":2,"o":[{"g":27,"n":{"i":3}},24],"u":{"e":{"r":19},"l":4},"y":21},"h":{"a":23,"e":23,"l":1,"o":23},"i":[{"a":19,"c":{".":23},"l":{"y":4},"n":[{"i":{"n":5},"o":5},28],"t":{"e":{"n":5}}},9],"j":29,"k":{"e":{"n":2}},"l":{"a":{"b":4,"d":3,"r":21},"d":{"i":18},"e":[{"n":{"d":3,"t":{"i":21}},"o":30},25],"i":[{"a":{".":1},"e":0},2],"l":{"e":{"v":4},"i":{"c":18}},"m":18,"o":{"g":{".":19}},"y":{".":21,"s":[{"t":31},18],"t":32,"z":27}},"m":{"a":[{"b":4,"g":3,"r":{"a":5},"s":{"c":4},"t":{"i":{"s":21},"o":33}},18],"e":{"r":{"a":4},"n":{"t":{"a":{"b":182}}}},"i":{"c":3,"f":4,"l":{"y":4},"n":[{"o":0},2]},"o":[{"n":19,"r":{"i":6}},24],"p":{"e":{"n":5}}},"n":[{"a":{"g":{"e":3},"l":{"y":[{"s":183},27]},"r":[{"c":3,"i":17},23],"t":{"i":23}},"d":[{"e":{"s":17},"i":{"s":3},"l":2,"o":{"w":1}},18],"e":{"e":19,"n":23,"s":{"t":{".":4}},"u":23},"g":[{"i":{"e":5},"l":2},25],"i":{"c":34,"e":{"s":23},"f":35,"m":{"e":1,"i":19},"n":{"e":19},"o":3,"p":23,"s":{"h":3},"t":3,"u":23},"k":{"l":{"i":1}},"n":{"i":{"z":32}},"o":[{"t":[{"h":7},4],"a":{"c":148}},0],"s":{"a":9,"c":{"o":1},"n":1,"p":[{"o":11},9],"t":1,"u":{"r":1},"g":{"r":5},"v":11},"t":{"a":{"l":36},"i":{"e":1,"d":137,"n":184,"r":{"e":137}},"o":18,"r":9,"w":1},"u":{"a":3,"l":3,"r":19}},24],"o":18,"p":{"a":{"r":17,"t":4},"e":{"r":{"o":4},"a":{"b":{"l":{"e":132}}}},"h":{"e":{"r":23},"i":18},"i":{"l":{"l":{"a":[{"r":4},21]}},"n":3,"t":{"a":3,"u":23}},"l":24,"o":{"c":6,"l":{"a":4},"r":{"i":6},"s":{"t":12}},"s":{"e":{"s":5}},"u":23},"q":{"u":{"e":6}},"r":[{"a":{"c":{"t":3},"d":{"e":19,"i":{"s":4}},"l":3,"m":{"e":{"t":{"e":19}}},"n":{"g":17},"p":11,"t":[{"i":{"o":19,"v":4}},1],"u":19,"v":38,"w":17},"b":{"a":{"l":36}},"c":{"h":{"a":{"n":1},"e":{"t":185}}},"d":{"i":{"n":{"e":4}},"r":1},"e":{"a":{"s":4},"e":23,"n":{"t":3},"s":{"s":19}},"f":{"i":1,"l":1},"i":[{"a":{"l":4,"n":3},"e":{"t":23},"m":1,"n":{"a":{"t":4}},"o":3,"z":9},2],"m":{"i":9},"o":{"d":20,"n":{"i":19},"o":23},"p":9,"q":3,"r":{"e":17,"a":{"n":{"g":{"e":9}}}},"s":{"a":1,"h":9}},37],"s":{".":18,"a":{"b":1,"n":{"t":3}},"h":{"i":17},"i":{"a":{".":19},"b":23,"c":23,"t":39},"k":{"i":11},"l":1,"o":{"c":21},"p":{"h":4},"s":{"h":1},"t":{"e":{"n":3},"r":2},"u":{"r":{"a":6}},"y":{"m":{"p":{"t":{"o":{"t":4}}}}}},"t":{"a":[{"b":{"l":3},"c":4,"l":{"o":3},"p":4},24],"e":{"c":[{"h":4},5],"g":{"o":3},"n":{".":3},"r":{"a":3,"n":[{"a":19},6]},"s":{"t":3},"v":4},"h":[{"e":{"m":5,"n":19,"r":{"o":{"s":186}}},"o":[{"m":5},1]},18],"i":{".":18,"a":19,"b":20,"c":2,"f":3,"o":{"n":{"a":{"r":7}}},"t":{"u":3}},"o":{"g":21,"m":[{"i":{"z":4}},24],"p":21,"s":21},"r":[{"o":{"p":4}},29],"s":{"k":1},"t":{"a":{"g":1},"e":[{"s":{".":170}},4],"h":1},"u":[{"a":4,"e":4,"l":3,"r":{"a":3}},24],"y":24},"u":{"b":1,"g":{"h":[{"t":{"l":17}},12],"u":3},"l":[{"i":{"f":13}},40],"n":{"d":5},"r":3,"s":{"i":{"b":4}},"t":{"e":{"n":5},"h":2}},"v":{"a":[{"g":3,"n":19},24],"e":{"n":{"o":0},"r":{"a":3,"n":4,"y":4}},"i":[{"e":{"r":0},"g":3,"o":{"u":3}},2],"o":{"c":4,"r":29}},"w":{"a":{"y":27},"i":3,"l":{"y":1},"s":0},"x":{"i":{"c":1,"d":1}},"y":{"a":{"l":4},"e":0,"s":0},"z":{"i":{"e":{"r":0}},"z":{"i":5}}},"b":{"a":{".":32,"d":{"g":{"e":{"r":5}}},"g":{"e":1},"l":{"a":15},"n":{"d":{"a":{"g":5}},"e":0,"i":11},"r":{"b":{"i":7},"i":{"a":17},"o":{"n":{"i":{"e":187}}}},"s":{"s":{"i":0}},"t":[{"h":{"y":2}},41],"z":1,"c":{"k":{"e":{"r":{".":84}}}}},"b":[{"e":[{"r":23},24],"i":{"n":{"a":0},"t":0}},42],"d":43,"e":{".":18,"a":{"k":17,"t":12},"d":[{"a":3,"e":3,"i":3},44],"g":{"i":3,"u":4},"l":[{"i":2,"o":3},41],"m":45,"n":{"i":{"g":4},"u":4},"s":[{"p":3,"t":{"r":4}},46],"t":[{"i":{"z":5},"r":4,"w":3},27],"w":3,"y":{"o":4},"v":{"i":{"e":9}}},"f":25,"h":47,"i":{"b":9,"d":[{"i":{"f":167}},1],"e":[{"n":4,"r":1},27],"f":48,"l":[{"i":{"z":3},"l":{"a":{"b":8}}},41],"n":{"a":{"r":49},"d":0,"e":{"t":4}},"o":{"g":{"r":3},"u":4,"m":5,"r":{"b":2,"h":15}},"t":[{"i":{"o":50,"v":{"e":188}},"r":3,"u":{"a":51},"z":19},9]},"j":29,"k":1,"l":[{"a":{"t":{"h":7},"n":{"d":189}},"e":{".":21,"n":17,"s":{"p":32}},"i":{"s":23,"n":{"d":189}},"o":[{"n":{"d":190}},21],"u":{"n":{"t":17}}},52],"m":43,"n":[{"e":{"g":5}},47],"o":{"d":[{"i":11},27],"e":1,"l":{"i":{"c":11}},"m":{"b":{"i":0}},"n":{"a":[{"t":5},0]},"o":27,"r":{".":32,"a":43,"d":5,"e":32,"i":32,"n":{"o":191}},"s":53,"t":{"a":19,"h":6,"o":1,"u":{"l":192}},"u":{"n":{"d":54}}},"p":18,"r":{"i":{"t":18},"o":{"t":{"h":54}},"u":{"s":{"q":17}}},"s":[{"o":{"r":17}},55],"t":[{"l":1,"o":21,"r":23},25],"u":{"f":{"f":{"e":{"r":0}}},"g":{"a":1},"l":{"i":3},"m":{"i":17},"n":[{"t":{"i":17}},1],"r":{"e":3},"s":{"i":{"e":[{"r":193,"s":193},5]},"s":{"e":17,"i":{"n":{"g":17}}},"t":32},"t":{"a":18,"i":{"o":27},"o":19,"e":{"d":{".":8}},"t":{"e":{"d":0}}}},"v":29,"w":56,"y":{".":32,"s":0}},"c":{"a":[{"b":{"i":{"n":11},"l":2},"c":{"h":17},"d":{"e":{"n":4,"m":194}},"g":46,"h":57,"l":{"a":{"t":3},"l":{"a":0,"i":{"n":6}},"o":18},"n":{"d":5,"e":0,"i":{"c":0,"s":5,"z":11},"t":{"y":0},"y":17},"p":{"e":{"r":4}},"r":{"o":{"m":5}},"s":{"t":{"e":{"r":6},"i":{"g":5}},"y":18},"t":{"h":1,"i":{"v":18},"a":{"s":195}},"v":{"a":{"l":5}}},41],"c":[{"h":{"a":6},"i":{"a":0},"o":{"m":{"p":{"a":10}},"n":17,"u":{"t":12}}},23],"e":{".":25,"d":{".":18,"e":{"n":18}},"i":27,"l":{".":32,"l":27},"n":[{"c":27,"e":58,"i":18,"t":27},41],"p":27,"r":{"a":{"m":4}},"s":{"a":18,"s":{"i":[{"b":59},27]},"t":5},"t":[{"a":60},0],"w":0},"h":[{".":18,"a":{"b":61,"n":{"i":{"c":32,"s":20}}},"e":[{"a":{"p":54},"d":18,"l":{"o":5},"m":{"i":27},"n":{"e":4},"r":{".":3,"s":3}},8],"i":{"n":[{"e":{".":32,"s":{"s":4}},"i":32},62],"o":32,"t":27,"z":8,"e":{"v":{"o":6}}},"o":63,"t":{"i":1},"s":{".":18,"h":{"u":11}}},25],"i":[{"a":[{"b":64,"r":5},27],"c":4,"e":{"r":18},"f":{"i":{"c":{".":32}}},"i":18,"l":{"a":1,"i":27},"m":25,"n":[{"a":[{"t":27},21],"e":{"m":11},"g":[{".":19},29],"o":32,"q":8},25],"o":{"n":17},"p":{"e":18,"h":3,"i":{"c":18}},"s":{"t":{"a":18,"i":18}},"t":[{"i":{"z":11}},42],"z":32,"g":{"a":{"r":152}}},41],"k":[{"i":3},2],"l":[{"a":{"r":[{"a":{"t":{"i":{"o":19}}},"e":32},18]},"e":{"m":0,"a":{"r":0}},"i":{"c":18,"m":17},"y":0},65],"n":19,"o":[{"a":{"g":4},"e":8,"g":[{"r":1},25],"i":[{"n":{"c":3}},0],"l":{"i":5,"o":[{"r":11},32]},"m":{"e":{"r":5}},"n":{"a":0,"e":21,"g":11,"t":5},"p":{"a":3,"i":{"c":11},"l":1,"h":{"o":{"n":196}}},"r":{"b":18,"o":{"n":12}},"s":{"e":0},"v":[{"e":17},15],"w":{"a":5},"z":{"e":5,"i":4},"u":{"s":{"t":{"i":84}}}},41],"q":29,"r":{"a":{"s":{"t":6},"t":{".":32,"i":{"c":32}}},"e":{"a":{"t":11},"d":32,"t":{"a":47},"v":0},"i":[{"f":5,"n":21,"s":17,"t":{"i":[{"e":11},32]}},8],"o":{"p":{"l":0,"o":6},"s":{"e":17},"c":{"o":{"d":197}},"e":{"c":{"o":148}}},"u":{"d":0}},"s":66,"t":[{"a":{"b":0,"n":{"g":4,"t":19}},"e":[{"r":23},24],"i":{"c":{"u":21},"m":{"i":12}},"u":{"r":0},"w":21,"r":{"o":{"m":{"e":{"c":198}}}}},42],"u":{"d":5,"f":21,"i":[{"t":{"y":4}},21],"l":{"i":32,"t":{"i":{"s":0},"u":27}},"m":{"a":9,"e":23,"i":1},"n":27,"p":{"i":3,"y":4},"r":{"a":{"b":67,"n":{"c":{"e":199}}},"i":{"a":4}},"s":[{"s":{"i":17}},41],"t":[{"i":{"e":1,"v":56},"r":18},68]},"y":41,"z":{"e":0}},"d":{"a":[{".":32,"b":70,"c":{"h":17},"f":18,"g":25,"m":71,"n":{"g":11},"r":{"d":6,"k":6,"y":18},"t":[{"i":{"v":18},"o":18,"a":{"b":137}},27],"v":[{"e":5},53],"y":32,"l":{"o":{"n":{"e":48}}}},69],"b":29,"c":19,"d":[{"a":{"b":20},"i":{"b":94}},72],"e":{".":25,"a":{"f":6,"l":{"s":{".":1}}},"b":{"i":{"t":5},"o":{"n":1}},"c":{"a":{"n":36},"i":{"l":1},"o":{"m":4},"l":{"a":{"r":200},"i":{"n":{"a":64}}}},"d":42,"e":{".":18},"i":{"f":4},"l":{"i":{"e":17,"q":16},"o":4},"m":[{".":32,"i":{"c":[{".":5},27],"l":4},"o":{"n":{"s":1},"r":7,"s":9}},21],"n":[{"a":{"r":1},"o":3,"t":{"i":{"f":7}},"u":3},41],"p":[{"a":3,"i":17,"u":9},2],"q":23,"r":{"h":21,"m":32,"n":{"i":{"z":6}},"s":5},"s":[{".":24,"c":2,"o":64,"t":{"i":11,"r":3},"u":1,"i":{"c":11}},8],"t":[{"o":9,"i":{"c":9}},2],"v":[{"i":{"l":11}},2],"y":18,"f":{"i":{"n":{"i":{"t":{"i":201}}}}}},"f":43,"g":{"a":21,"e":{"t":73},"i":2,"y":24},"h":74,"i":{".":32,"a":[{"b":5},75],"c":{"a":{"m":1,"i":{"d":15}},"e":21,"t":27},"d":27,"e":{"n":76},"f":[{"f":{"r":{"a":5}}},29],"g":{"e":3},"l":{"a":{"t":{"o":1}}},"n":[{"a":41,"e":{".":27},"i":[{"z":4},32]},29],"o":[{"g":5},41],"p":{"l":1},"r":[{"e":[{"n":9,"r":9},2],"t":{"i":6}},8],"s":[{"i":32,"t":77},15],"t":{"i":24},"v":78,"m":{"e":{"t":{"h":{"y":141}}}}},"j":29,"k":79,"l":{"a":56,"e":{".":27,"d":27,"s":{".":27,"s":18},"a":{"d":42}},"o":48,"u":56,"y":25,"i":{"e":202}},"m":29,"n":80,"o":[{".":27,"d":{"e":4},"e":32,"f":57,"g":21,"l":{"a":1,"i":17,"o":{"r":4}},"m":{"i":{"z":5}},"n":{"a":{"t":3},"i":17},"o":{"d":11},"p":{"p":0},"r":21,"s":27,"u":{"t":56},"v":1,"x":27,"w":{"o":{"r":{"d":203}}}},41],"p":29,"r":[{"a":{"g":{"o":{"n":6}},"i":18},"e":[{"a":{"r":6},"n":[{"a":{"l":204}},32]},0],"i":{"b":0,"l":17,"f":{"t":{"a":189}},"p":{"l":{"e":{"g":205}}}},"o":{"p":0,"w":18,"m":{"e":{"d":206}}},"u":{"p":{"l":{"i":32}}},"y":18},41],"s":[{"p":1,"w":21,"y":21},81],"t":{"h":24,"a":{"b":23}},"u":[{"a":[{"l":{".":9}},82],"c":[{"a":29,"e":{"r":5},"t":{".":18,"s":18}},9],"e":{"l":4},"g":1,"l":{"e":23},"m":{"b":{"e":0}},"n":1,"p":[{"e":1},18],"o":{"p":{"o":{"l":207}}}},41],"v":29,"w":29,"y":[{"n":32,"s":{"e":1,"p":5}},24]},"e":{"a":{"b":72,"c":{"t":23},"d":[{"i":{"e":5}},15],"g":{"e":[{"r":4},1]},"l":[{"e":{"r":5},"o":{"u":11}},1],"m":{"e":{"r":11}},"n":{"d":19,"i":{"e":{"s":111}}},"r":{"a":11,"c":0,"e":{"s":5},"i":{"c":0,"l":0},"k":5,"t":[{"e":12},8]},"s":{"p":4,"s":23,"t":12},"t":[{"e":{"n":5},"h":{"i":12},"i":{"f":19},"u":83},9],"v":[{"e":{"n":11},"i":5,"o":5},9]},"b":[{"e":{"l":{".":21,"s":21},"n":21},"i":{"t":21},"r":23},42],"c":{"a":{"d":21,"n":{"c":6}},"c":{"a":6},"e":[{"s":{"s":{"a":4}}},29],"i":[{"b":21,"f":{"i":{"c":{"a":{"t":4}},"e":4},"y":4},"m":3,"t":[{"e":19},0]},9],"l":{"a":{"m":21},"u":{"s":21}},"o":{"l":24,"m":{"m":21,"p":{"e":21}},"n":{"c":21},"r":[{"a":3,"o":5},24]},"r":[{"e":{"m":21}},29],"t":{"a":{"n":1},"e":1},"u":[{"l":[{"a":3},21]},29],"h":{"a":{"s":23}}},"d":{"a":37,"d":61,"e":{"r":34,"s":0},"i":[{"a":23,"b":3,"c":{"a":3},"m":3,"t":2,"z":5},18],"o":[{"l":21,"n":84},18],"r":{"i":21},"u":{"l":[{"o":4,"i":{"n":{"g":2}}},21]},"g":{"l":15}},"e":{"c":9,"d":{"i":11},"f":9,"l":{"i":11,"y":1},"m":9,"n":{"a":1},"p":85,"s":[{"t":17},86],"t":{"y":1},"x":19},"f":[{"e":{"r":{"e":83}},"f":41,"i":{"c":[{"i":32},21],"l":17,"n":{"e":23,"i":{"t":{"e":20}}},"t":27},"o":{"r":{"e":{"s":6}}},"u":{"s":{"e":{".":21}}}},29],"g":{"a":{"l":18},"e":{"r":17},"i":{"b":4,"c":1,"n":{"g":4},"t":87},"n":4,"o":{".":21,"s":21},"u":{"l":2,"r":19},"y":32},"h":[{"e":{"r":17}},72],"i":[{"c":19,"d":4,"g":[{"l":4},8],"m":{"b":23},"n":{"f":23,"g":29,"s":{"t":19}},"r":{"d":0},"t":{"e":11,"h":3,"y":19}},9],"j":[{"u":{"d":[{"i":4},21]}},29],"k":{"i":{"n":0},"l":{"a":1}},"l":{"a":[{".":21,"c":21,"n":{"d":17},"t":{"i":{"v":4}},"w":21,"x":{"a":36}},29],"e":{"a":23,"b":{"r":{"a":4}},"c":32,"d":21,"g":{"a":3},"n":19,"r":34,"s":29},"f":9,"i":[{"b":{"e":23},"c":{".":33,"a":3},"e":{"r":23},"g":{"i":{"b":4}},"m":19,"n":{"g":83},"o":23,"s":[{"h":4},24],"v":88,"t":{"i":{"s":208}}},9],"l":{"a":[{"b":1},18],"o":17},"o":{"c":19,"g":4,"p":{".":3},"a":29},"s":{"h":9},"t":{"a":1},"u":{"d":19,"g":4}},"m":{"a":{"c":21,"g":21,"n":[{"a":4},19]},"b":4,"e":[{"l":24,"t":21},29],"i":{"c":{"a":3},"e":0,"g":{"r":{"a":4}},"n":[{"e":4,"i":35},89],"s":[{"h":4,"s":19},21],"z":3},"n":{"i":{"z":32}},"o":{"g":0,"n":{"i":{"o":7}}},"p":{"i":3},"u":{"l":[{"a":4},21],"n":11},"y":23},"n":{"a":{"m":{"o":4},"n":{"t":21}},"c":{"h":{"e":{"r":17}}},"d":{"i":{"c":3,"x":2}},"e":{"a":19,"e":19,"m":3,"r":{"o":4},"s":{"i":4,"t":4},"t":{"r":3},"w":23},"i":{"c":{"s":4},"e":19,"l":19,"o":23,"s":{"h":3},"t":3,"u":19,"z":32},"n":18,"o":[{"g":0,"s":21,"v":3},18],"s":{"w":1},"t":{"a":{"g":{"e":5}},"h":{"e":{"s":18}}},"u":{"a":3,"f":4},"y":{".":23},"z":61},"o":{"f":19,"g":[{"r":{"a":{"p":3}}},9],"i":90,"l":23,"p":{"a":{"r":11}},"r":[{"e":3,"o":{"l":4}},29],"s":0,"t":[{"o":1},21],"u":{"t":19},"w":19},"p":{"a":[{"i":23,"n":{"c":4}},24],"e":{"l":19,"n":{"t":23},"t":{"i":{"t":{"i":{"o":4}}}}},"h":{"e":17},"l":{"i":21},"o":29,"r":{"e":{"c":[{"a":4},21],"d":21,"h":3},"o":[{"b":21},23]},"s":{"h":1},"t":{"i":{"b":13}},"u":{"t":[{"a":4},21]},"i":{"n":{"e":{"p":{"h":209}}}}},"q":[{"u":{"i":{"l":12,"s":91}}},29],"r":{"a":[{"b":0,"n":{"d":18},"r":3,"t":{"i":{".":18}}},2],"b":[{"l":1},25],"c":{"h":[{"e":1},3]},"e":{".":25,"a":{"l":23},"c":{"o":5},"i":{"n":11},"l":{".":4},"m":{"o":3},"n":{"a":4,"c":{"e":4},"e":18,"t":3},"q":0,"s":{"s":4,"t":3},"t":17},"h":2,"i":[{"a":[{"n":{".":210}},92],"c":{"k":32},"e":{"n":23,"r":0},"n":{"e":3},"o":29,"t":18,"u":1,"v":[{"a":21},0]},2],"m":93,"n":{"i":{"s":1,"t":18,"z":32},"o":3},"o":[{"b":4,"c":19,"r":0,"u":2},25],"s":[{"e":{"t":3}},2],"t":{"e":{"r":11},"l":18,"w":3},"u":[{"t":0},18],"w":{"a":{"u":32}}},"s":{"a":[{"g":{"e":{".":21,"s":21}}},72],"c":[{"a":[{"n":4},24],"r":23,"u":4},9],"e":[{"c":[{"r":4},24],"n":{"c":4},"r":{"t":{".":21,"s":21},"v":{"a":21}}},74],"h":[{"a":23,"e":{"n":5}},18],"i":[{"c":24,"d":[{"e":{"n":4}},24],"g":{"n":{"a":4}},"m":94,"n":95,"s":{"t":{"e":17}},"u":0},29],"k":{"i":{"n":19}},"m":{"i":1},"o":{"l":[{"u":3},24],"n":[{"a":4},24]},"p":[{"e":{"r":3},"i":{"r":{"a":4}},"r":{"e":1},"a":{"c":{"i":211}}},29],"s":[{"i":{"b":96}},25],"t":{"a":{"n":36},"i":{"g":3,"m":4},"o":[{"n":23},44],"r":[{"o":19,"u":{"c":10}},25]},"u":{"r":[{"r":4},24]},"w":1},"t":{"a":{"b":0},"e":{"n":{"d":17},"o":23},"h":{"o":{"d":54},"y":{"l":{"e":{"n":{"e":162}}}}},"i":{"c":2,"d":{"e":19},"n":[{"o":0},17],"r":19,"t":{"i":{"o":19,"v":4}}},"n":18,"o":{"n":{"a":4}},"r":{"a":23,"e":23,"i":{"c":3,"f":4},"o":{"g":3,"s":4}},"u":{"a":3},"y":{"m":4},"z":4},"u":[{"n":19,"p":23,"r":{"o":3},"s":0,"t":{"e":17,"i":{"l":6},"r":4},"c":{"l":{"i":{"d":212}}}},18],"v":{"a":{"p":97,"s":[{"t":4},24]},"e":{"a":19,"l":{"l":3,"o":12},"n":{"g":19,"i":17},"r":[{"b":19},2]},"i":[{"d":3,"l":0,"n":21,"v":0},29],"o":{"c":19},"u":19},"w":{"a":[{"g":21},29],"e":{"e":19},"h":23,"i":{"l":6,"n":{"g":3},"t":23}},"x":{"p":41},"y":{"c":32,"e":{".":32},"s":0}},"f":{"a":[{"b":{"l":3,"r":11},"c":{"e":1},"g":18,"i":{"n":17},"l":{"l":{"e":6}},"m":{"a":26,"i":{"s":5}},"r":[{"t":{"h":5}},32],"t":{"a":3,"h":{"e":3},"o":18},"u":{"l":{"t":7}}},41],"b":56,"d":18,"e":{".":18,"a":{"s":17,"t":{"h":54}},"b":[{"r":{"u":{"a":15}}},1],"c":{"a":18,"t":32},"d":25,"l":{"i":3},"m":{"o":1},"n":{"d":[{"e":6},8]},"r":[{"r":32,"m":{"i":{"o":213}}},15],"v":0},"f":[{"e":{"s":21},"i":{"e":21,"n":{".":19},"s":94},"l":{"y":21},"y":24},43],"h":18,"i":[{"a":3,"c":{".":48,"a":{"l":47,"n":23,"t":{"e":18}},"e":{"n":23,"r":3},"i":[{"a":32,"e":32},0],"s":18,"u":3,"h":27},"d":{"e":{"l":4}},"g":{"h":{"t":7}},"l":{"i":5,"l":{"i":{"n":6}},"y":18},"n":[{"a":32,"d":97,"e":9,"g":98,"n":0},25],"s":{"t":{"i":0}},"t":{"t":{"e":{"d":{".":5}}}}},41],"l":[{"e":{"s":{"s":19}},"i":{"n":17},"o":{"r":{"e":11},"w":{"e":{"r":{".":84}}}},"y":100,"a":{"g":{"e":{"l":214}}},"u":{"o":{"r":27}}},99],"m":18,"n":18,"o":[{"n":[{"d":{"e":0},"t":0},32],"r":[{"a":{"t":4,"y":5},"e":{"t":6},"i":0,"t":{"a":6}},9],"s":5},41],"p":56,"r":{"a":{"t":0},"e":{"a":19,"s":{"c":6}},"i":[{"l":17},8],"o":{"l":6}},"s":48,"t":[{"o":21,"y":24},25],"u":[{"e":{"l":4},"g":18,"m":{"i":{"n":1}},"n":{"e":4},"r":{"i":3},"s":{"i":17,"s":0},"t":{"a":18}},27],"y":41},"g":{"a":[{"f":0,"l":{".":32,"i":27,"o":3},"m":[{"e":{"t":4},"o":19},25],"n":{"i":{"s":5,"z":[{"a":6},3]},"o":18},"r":{"n":67},"s":{"s":17},"t":{"h":12,"i":{"v":18}},"z":18},41],"b":23,"d":1,"e":{".":25,"d":25,"e":{"z":17},"l":{"i":{"n":0,"s":4,"z":4},"y":18},"n":[{"a":{"t":1},"i":{"z":4},"o":18,"y":18,"c":{"y":{".":8}}},41],"o":[{"m":3,"d":215},41],"r":{"y":21},"s":{"i":32},"t":{"h":6,"o":18,"y":1,"i":{"c":{".":8}}},"v":1},"g":[{"e":[{"r":23},24],"l":{"u":6},"o":0},101],"h":{"i":{"n":3},"o":{"u":{"t":4}},"t":{"o":1,"w":{"e":15}}},"i":{".":32,"a":[{"r":5},102],"c":[{"i":{"a":32},"o":21},29],"e":{"n":6,"s":{".":32}},"l":0,"m":{"e":{"n":23}},"n":{".":68,"g":{"e":5},"s":103},"o":32,"r":[{"l":0},27],"s":{"l":23},"u":1,"v":32,"z":27},"l":[{"a":[{"d":{"i":6},"s":32},0],"e":[{"a":{"d":29}},41],"i":{"b":0,"g":23,"s":{"h":43}},"o":[{"r":11,"b":{"i":{"n":106}}},27]},9],"m":[{"y":21},29],"n":{"a":[{".":21,"c":69},1],"e":{"t":{"t":17,"i":{"s":{"m":137}}}},"i":[{"n":24,"o":21},29],"o":[{"n":21,"m":{"o":5},"r":{".":216,"e":{"s":{"p":24}}}},29]},"o":[{".":27,"b":5,"e":32,"g":104,"i":{"s":3},"n":[{"a":105,"d":{"o":7},"i":[{"z":{"a":217}},3]},8],"o":32,"r":{"i":{"z":4},"o":{"u":5}},"s":{".":32},"v":15},41],"p":23,"r":[{"a":{"d":{"a":18},"i":21,"n":84,"p":{"h":{".":32,"e":{"r":[{".":7},19]},"i":{"c":32},"y":18}},"y":18},"e":{"n":0,"s":{"s":{".":18}}},"i":{"t":18,"e":{"v":213}},"o":21,"u":{"f":17}},41],"s":[{"t":{"e":19}},9],"t":{"h":11},"u":{"a":[{"r":{"d":27}},1],"e":25,"i":{"t":106},"n":27,"s":27,"t":[{"a":{"n":29}},26]},"w":23,"y":[{"n":107,"r":{"a":4}},41]},"h":{"a":{"b":{"l":73},"c":{"h":17},"e":{"m":0,"t":0},"g":{"u":19},"l":{"a":[{"m":12},3]},"m":1,"n":{"c":{"i":0,"y":0},"d":{".":32},"g":[{"e":{"r":6},"o":6},0],"i":{"z":108},"k":0,"t":{"e":0}},"p":{"l":11,"t":5,"a":{"r":{"r":218}}},"r":{"a":{"n":3,"s":4},"d":[{"e":12},8],"l":{"e":0},"p":{"e":{"n":6}},"t":{"e":{"r":5}}},"s":{"s":5},"u":{"n":17},"z":[{"a":11},32],"i":{"r":{"s":137}},"t":{"c":{"h":213}}},"b":29,"e":{"a":{"d":41,"r":27},"c":{"a":{"n":1,"t":19}},"d":[{"o":13},21],"l":{"i":93,"l":{"i":{"s":0},"y":0},"o":19},"m":{"p":0},"n":[{"a":[{"t":5},17]},9],"o":{"r":5},"p":5,"r":{"a":[{"p":12},21],"b":{"a":0},"e":{"a":6},"n":23,"o":{"u":19},"y":23},"s":[{"p":64},29],"t":[{"e":{"d":0}},1],"u":0,"x":{"a":168}},"f":29,"h":29,"i":{"a":{"n":4},"c":{"o":1},"g":{"h":6},"l":109,"m":{"e":{"r":36}},"n":{"a":21},"o":{"n":{"e":17}},"p":[{"e":{"l":{"a":219}}},1],"r":{"l":0,"o":3,"p":0,"r":0},"s":{"e":{"l":11},"s":0},"t":{"h":{"e":{"r":6}},"e":{"s":{"i":{"d":12}}}},"v":9},"k":18,"l":[{"a":{"n":17},"o":[{"r":{"i":11}},24]},80],"m":[{"e":{"t":17}},43],"n":[{"a":{"u":{"z":12}}},42],"o":{"d":{"i":{"z":19},"s":19},"g":[{"e":17},1],"l":{"a":{"r":5},"e":110},"m":{"a":1,"e":12},"n":{"a":0,"y":4},"o":{"d":27,"n":17},"r":{"a":{"t":5},"i":{"s":4,"c":{".":187}},"t":{"e":12},"u":4},"s":{"e":[{"n":4},0],"p":15},"u":{"s":[{"e":54},41]},"v":{"e":{"l":5}}},"p":56,"r":[{"e":{"e":6},"o":{"n":{"i":{"z":5}},"p":{"o":11}}},26],"s":[{"h":21},101],"t":{"a":{"r":21},"e":{"n":2,"s":4,"o":{"u":216}},"y":21},"u":{"g":1,"m":{"i":{"n":1}},"n":{"k":{"e":5},"t":0},"s":{"t":14},"t":1},"w":[{"a":{"r":{"t":21}}},29],"y":{"p":{"e":3,"h":3,"o":{"t":{"h":{"a":137}}}},"s":9}},"i":{"a":[{"l":24,"m":[{"e":{"t":{"e":5}}},0],"n":[{"c":18,"i":11,"t":46},24],"p":{"e":4},"s":{"s":17},"t":{"i":{"v":21},"r":{"i":{"c":1}},"u":21}},42],"b":{"e":[{"r":{"a":3,"t":4}},0],"i":{"a":4,"n":3,"t":{".":4,"e":4}},"l":[{"i":3},29],"o":19,"r":[{"i":94},29],"u":{"n":19}},"c":{"a":{"m":18,"p":32,"r":[{".":21,"a":21},18],"s":6,"y":21},"c":{"u":17},"e":{"o":18},"h":18,"i":[{"d":19,"n":{"a":4},"p":[{"a":3},24]},25],"l":{"y":21},"o":{"c":94},"r":[{"a":32,"y":21},43],"t":{"e":1,"u":[{"a":111},84]},"u":{"l":{"a":3},"m":1,"o":4,"r":23}},"d":[{"a":{"i":21,"n":{"c":4}},"d":4,"e":{"a":{"l":11},"s":0},"i":[{"a":{"n":4,"r":0},"e":19,"o":[{"u":5,"s":1},3],"t":2,"u":4},24],"l":{"e":23},"o":{"m":21,"w":3},"r":21,"u":[{"o":4},24]},25],"e":[{"d":{"e":0},"g":{"a":113},"l":{"d":12},"n":{"a":67,"e":0,"n":19,"t":{"i":23}},"r":{".":29},"s":{"c":23,"t":29},"t":23},112],"f":{".":18,"e":{"r":{"o":4}},"f":{"e":{"n":5},"r":1},"i":{"c":{".":18},"e":23},"l":23,"t":18,"a":{"c":{"e":{"t":137}}}},"g":[{"a":{"b":5},"e":{"r":{"a":3}},"h":{"t":{"i":12}},"i":[{"b":23,"l":3,"n":3,"t":3},18],"l":28,"o":[{"r":3,"t":4},24],"r":{"e":19},"u":{"i":5,"r":2},"n":{"i":{"t":[{"e":{"r":213}},0]}}},25],"h":23,"i":114,"j":[{"k":21},23],"k":18,"l":{"a":[{"b":93,"d":{"e":21},"m":94,"r":{"a":5}},29],"e":{"g":23,"r":2,"v":17},"f":4,"i":[{"a":3,"b":9,"o":3,"s":{"t":1},"t":25,"z":9},2],"l":{"a":{"b":5}},"n":18,"o":{"q":3},"t":{"y":1},"u":{"r":4},"v":3},"m":{"a":{"g":[{"e":3},21],"r":{"y":5}},"e":{"n":{"t":{"a":{"r":10}}},"t":18},"i":[{"d":{"a":4},"l":{"e":5},"n":{"i":19},"t":18},2],"n":{"i":1},"o":{"n":23},"u":[{"l":{"a":3}},24],"p":{"e":{"d":{"a":201}}}},"n":{".":25,"a":{"u":83,"v":18},"c":{"e":{"l":36,"r":3}},"d":[{"l":{"i":{"n":{"g":4}}}},18],"e":[{"e":23,"r":{"a":{"r":17}},"s":{"s":19}},25],"g":{"a":18,"e":[{"n":4},18],"i":18,"l":{"i":{"n":{"g":4}}},"o":18,"u":18},"i":[{".":19,"a":21,"o":3,"s":2,"t":{"e":{".":19,"l":{"y":{".":19}}},"i":{"o":32},"y":3}},25],"k":18,"l":18,"n":25,"o":[{"c":90,"s":0,"t":21},42],"s":[{"e":3,"u":{"r":{"a":7}}},25],"t":{".":25,"h":112},"u":[{"s":19},2],"y":18,"f":{"r":{"a":{"s":220}}}},"o":[{".":18,"g":{"e":17,"r":9},"l":29,"m":1,"n":{"a":{"t":11},"e":{"r":{"y":0}},"i":11},"p":{"h":4},"r":{"i":11},"s":21,"t":{"h":4,"i":19,"o":1},"u":{"r":21}},25],"p":[{"e":0,"h":{"r":{"a":{"s":115}}},"i":[{"c":1},3],"r":{"e":96},"u":{"l":3}},25],"q":{"u":{"a":23,"e":{"f":4},"i":{"d":3,"t":116}}},"r":[{"a":[{"b":0,"c":21},29],"d":{"e":5},"e":{"d":{"e":0},"f":21,"l":117,"s":21},"g":{"i":4},"i":[{"d":{"e":5},"s":1,"t":{"u":11},"z":118},2],"m":{"i":{"n":1}},"o":{"g":0,"n":{".":32}},"u":{"l":4},"r":{"e":{"v":{"o":{"c":221}}}}},18],"s":{".":25,"a":{"g":4,"r":3,"s":6},"c":[{"h":3},119],"e":[{"r":3},18],"f":27,"h":{"a":{"n":4},"o":{"n":3,"p":5}},"i":{"b":3,"d":0,"s":19,"t":{"i":{"v":4}}},"k":26,"l":{"a":{"n":36}},"m":{"s":18},"o":[{"m":{"e":{"r":5}}},24],"p":[{"i":9,"y":1},2],"s":[{"a":{"l":1},"e":{"n":36,"s":1}},62],"t":{"a":{".":1},"e":2,"i":2,"l":{"y":0},"r":{"a":{"l":18}}},"u":[{"s":4},24]},"t":{"a":{".":18,"b":{"i":0},"g":21,"m":120,"n":23,"t":23},"e":[{"r":{"a":3,"i":19},"s":[{"i":{"m":{"a":29}}},1]},25],"h":[{"i":{"l":148}},25],"i":[{"a":18,"c":[{"a":3,"k":31},22],"g":3,"l":{"l":4},"m":24,"o":25,"s":[{"m":21},18],"n":{"e":{"r":{"a":{"r":158}}}}},29],"o":{"m":121,"n":18},"r":{"a":{"m":21},"y":4},"t":18,"u":{"a":{"t":3},"d":19,"l":3},"z":{".":18}},"u":29,"v":[{"e":{"l":{"l":3},"n":{".":3},"r":{".":83,"s":{".":21}}},"i":{"l":{".":4},"o":4,"t":2},"o":{"r":{"e":19,"o":35},"t":83}},25],"w":56,"x":{"o":1},"y":18,"z":{"a":{"r":18},"i":0,"o":{"n":{"t":32}}}},"j":{"a":[{"c":{"q":0},"p":[{"a":{"n":{"e":{"s":220}}}},1],"n":{"u":{"a":12}}},32],"e":[{"r":{"s":5,"e":{"m":222}},"s":{"t":{"i":{"e":18},"y":18}},"w":11},41],"o":{"p":1},"u":{"d":{"g":32}}},"k":{"a":{".":27,"b":23,"g":19,"i":{"s":17},"l":0},"b":29,"e":{"d":24,"e":41,"g":1,"l":{"i":[{"n":{"g":223}},4]},"n":{"d":73},"r":29,"s":[{"t":{".":23}},0],"t":{"y":1}},"f":23,"h":1,"i":[{".":32,"c":122,"l":{"l":21,"o":6},"m":21,"n":{".":21,"d":{"e":0},"e":{"s":{"s":19},"t":{"i":{"c":224}}},"g":0},"p":1,"s":[{"h":19},0]},29],"k":1,"l":[{"e":{"y":18},"y":18},29],"m":29,"n":{"e":{"s":19},"o":69},"o":{"r":4,"s":{"h":17},"u":23,"v":{"i":{"a":{"n":41}}}},"r":{"o":{"n":5}},"s":[{"c":21,"l":1,"y":21,"h":{"a":23}},101],"t":19,"w":29},"l":{"a":{"b":{"i":{"c":11},"o":21},"c":{"i":[{"e":225},17]},"d":{"e":21,"y":3},"g":{"n":0},"m":{"o":11},"n":{"d":[{"l":0},27],"e":{"t":5},"t":{"e":0}},"r":{"g":0,"i":11,"c":{"e":{"n":176}}},"s":{"e":0},"t":{"a":{"n":4},"e":{"l":{"i":18}},"i":{"v":18}},"v":[{"a":95},18],"i":{"n":{"e":{"s":{"s":226}}}}},"b":[{"i":{"n":17}},42],"c":[{"e":0,"i":23,"h":{"a":{"i":23},"i":{"l":{"d":227}}}},101],"d":[{"e":[{"r":{"e":1,"i":1}},24],"i":[{"s":4},0],"r":[{"i":21},23]},25],"e":{"a":[{"d":{"e":{"r":{".":183}}},"s":{"a":228}},9],"b":{"i":1},"f":{"t":6},"g":{".":32,"g":32,"e":{"n":{"d":{"r":{"e":230}}}}},"m":{"a":{"t":[{"i":{"c":5}},1]}},"n":{".":18,"c":27,"e":{".":32},"t":41,"o":{"i":{"d":78}}},"p":{"h":3,"r":1},"r":{"a":{"b":6},"e":0,"g":27,"i":68,"o":21},"s":[{"c":{"o":4},"q":32,"s":[{".":32},27]},8],"v":{"a":23,"e":{"r":{".":0,"a":0,"s":0}}},"y":[{"e":18},27],"c":{"t":{"a":{"b":229}}}},"f":[{"r":19},25],"g":[{"a":[{"r":12},19],"e":{"s":21},"o":11},80],"h":48,"i":{"a":{"g":1,"m":9,"r":{"i":{"z":6}},"s":1,"t":{"o":1}},"b":{"i":4},"c":{"i":{"o":32},"o":{"r":1},"s":18,"t":{".":18},"u":21,"y":23},"d":{"a":23,"e":{"r":5},"i":27},"f":{"e":{"r":11},"f":21,"l":1},"g":{"a":{"t":{"e":32}},"h":27,"r":{"a":1}},"k":27,"l":123,"m":{"b":{"l":0},"i":11,"o":1,"p":90},"n":{"a":21,"e":[{"a":11},124],"i":11,"k":{"e":{"r":6}}},"o":{"g":4},"q":125,"s":{"p":0},"t":[{".":24,"i":{"c":{"a":32,"s":108}},"h":{"o":{"g":204}}},29],"v":{"e":{"r":11}},"z":29},"j":18,"k":{"a":[{"l":23,"t":0},11]},"l":[{"a":{"w":21},"e":[{"a":19,"c":23,"g":23,"l":23,"n":73,"t":73},24],"i":[{"n":[{"a":19},126],"s":{"h":231}},9],"o":[{"q":{"u":{"i":10}},"u":{"t":4},"w":19},1],"f":{"l":2}},29],"m":[{"e":{"t":19},"i":{"n":{"g":3}},"o":{"d":21,"n":[{"e":{"l":{"l":232}}},17]}},25],"n":81,"o":{".":27,"b":{"a":{"l":5},"o":{"t":{"o":233}}},"c":{"i":1},"f":18,"g":{"i":{"c":27},"o":19,"u":27,"e":{"s":{".":9}}},"m":{"e":{"r":11}},"n":{"g":32,"i":[{"z":127},0]},"o":{"d":6},"p":{"e":{".":32},"i":11,"m":23},"r":{"a":[{"t":{"o":1}},17],"i":{"e":4},"o":{"u":5}},"s":{".":32,"e":{"t":5},"o":{"p":{"h":{"i":{"z":32},"y":32}}},"t":0},"t":{"a":1},"u":{"n":{"d":6},"t":25},"v":18,"a":{"d":{"e":{"d":{".":17},"r":{".":183}}}}},"p":[{"a":{"b":5},"h":{"a":23,"i":19},"i":{"n":{"g":4},"t":23},"l":21,"r":19},25],"r":43,"s":[{"c":21,"e":24,"i":{"e":21}},81],"t":[{"a":{"g":4,"n":{"e":7}},"e":[{"n":17,"r":{"a":36},"a":23},29],"h":{"i":[{"l":{"y":148}},11]},"i":{"e":{"s":{".":19}},"s":17},"r":29,"u":[{"r":{"a":12}},8]},18],"u":{"a":4,"b":{"r":3},"c":{"h":17,"i":3},"e":{"n":3,"p":15},"f":0,"i":{"d":4},"m":{"a":1,"i":32,"n":{".":19,"i":{"a":32}},"b":{"i":{"a":{".":235}}}},"o":[{"r":11},3],"p":18,"s":{"s":17,"t":{"e":11}},"t":41,"n":{"k":{"e":{"r":234}}}},"v":{"e":{"n":19,"t":128}},"w":42,"y":[{"a":18,"b":18,"m":{"e":4},"n":{"o":3},"s":[{"e":19,"t":{"y":{"r":4}}},58],"g":{"a":{"m":{"i":236}}}},41]},"m":{"a":[{"b":25,"c":{"a":9,"h":{"i":{"n":{"e":4}}},"l":1},"g":{"i":{"n":5},"n":32},"h":25,"i":{"d":6},"l":{"d":18,"i":{"g":3,"n":4},"l":{"i":0},"t":{"y":0},"a":{"p":222}},"n":{"i":{"a":32,"s":5,"z":11},".":24,"u":{"s":{"c":237}}},"p":[{"h":{"r":{"o":244}}},18],"r":{"i":{"n":{"e":{".":4}},"z":4},"l":{"y":0},"v":11,"g":{"i":{"n":238}}},"s":{"c":{"e":4},"e":0,"t":15},"t":{"e":32,"h":12,"i":{"s":3,"z":{"a":18}}}},41],"b":[{"a":{"t":129},"i":{"l":19,"n":{"g":83},"v":0}},43],"c":56,"e":{".":18,"d":[{".":18,"i":{"a":32,"e":3,"c":[{"i":{"n":152}},84],"o":{"c":239}},"y":108},25],"g":[{"r":{"a":{"n":240}}},9],"l":{"o":{"n":5},"t":0},"m":[{"o":130},9],"n":[{"a":[{"c":5},0],"d":{"e":0},"e":18,"i":0,"s":[{"u":7},17],"t":[{"e":0},27],".":24},41],"o":{"n":4},"r":{"s":{"a":19}},"s":[{"t":{"i":27}},25],"t":{"a":[{"l":11},1],"e":2,"h":{"i":4},"r":[{"i":{"c":32,"e":4},"y":3},21]},"v":1},"f":43,"h":25,"i":{".":32,"a":3,"d":{"a":[{"b":241},0],"g":0},"g":0,"l":{"i":{"a":27,"e":108,"t":{"a":27}},"l":[{"a":{"g":208},"i":{"l":{"i":59}}},21]},"n":{"a":0,"d":27,"e":{"e":19},"g":{"l":[{"i":5,"y":19},21]},"t":0,"u":[{"t":{"e":{"r":242,"s":{"t":242}}}},21],"i":{"s":{".":174}}},"o":{"t":17},"s":[{"e":{"r":{".":0}},"l":5,"t":{"i":0,"r":{"y":19}}},24],"t":{"h":18},"z":24},"k":18,"l":43,"m":[{"a":{"r":{"y":5},"b":243}},29],"n":[{"a":1,"i":{"n":21},"o":1},43],"o":[{"c":{"r":[{"a":{"t":[{"i":{"z":32}},245]}},18]},"d":131,"g":{"o":1},"i":{"s":[{"e":5},84]},"k":18,"l":{"e":{"s":{"t":4},"c":246}},"m":{"e":3},"n":{"e":{"t":5,"y":{"l":247}},"g":{"e":5},"i":{"a":12,"s":{"m":0,"t":0},"z":3},"o":{"l":36,"c":{"h":12},"e":{"n":171},"s":249},"y":{".":3}},"r":[{"a":{".":18},"o":{"n":{"i":{"s":248}}}},9],"s":[{"e":{"y":4},"p":3},8],"t":{"h":[{"e":{"t":250}},12]},"u":{"f":19,"s":[{"i":{"n":98}},27]},"v":9,"e":{"l":{"a":{"s":167}}}},41],"p":[{"a":{"r":{"a":[{"b":5},7],"i":6}},"e":{"t":23},"h":{"a":{"s":36}},"i":[{"a":0,"e":{"s":4},"n":34,"r":19,"s":4},24],"o":{"r":{"i":11},"s":{"i":{"t":{"e":6}}},"u":{"s":21},"v":6},"t":{"r":1},"y":24},43],"r":47,"s":[{"h":[{"a":{"c":{"k":251}}},21],"i":19},101],"t":18,"u":[{"l":{"a":{"r":49},"t":[{"i":[{"u":252},54]},32]},"m":27,"n":8,"p":18,"u":1,"d":{"r":{"o":9}}},41],"w":18},"n":{"a":[{"b":[{"u":21},81],"c":{".":18,"a":1,"t":19},"g":{"e":{"r":{".":5}}},"k":0,"l":{"i":[{"a":4},1],"t":18},"m":{"i":{"t":4}},"n":[{"c":{"i":36},"i":{"t":0},"k":17},24],"r":{"c":[{"h":{"s":{".":73}}},11],"e":18,"i":11,"l":0,"m":19},"s":[{"c":0,"t":{"i":5}},21],"t":[{"a":{"l":3},"o":{"m":{"i":{"z":6}}}},24],"u":[{"s":{"e":11},"t":27},24],"v":{"e":0}},41],"b":80,"c":{"a":{"r":6},"e":{"s":{".":21}},"h":{"a":23,"e":{"o":19,"s":{"t":253}},"i":{"l":19,"s":23}},"i":{"n":2,"t":1},"o":{"u":{"r":{"a":7}}},"r":29,"u":29},"d":{"a":{"i":21,"n":19},"e":[{"s":{"t":{".":4}}},29],"i":{"b":0,"f":79,"t":29,"z":23,"e":{"c":{"k":29}}},"u":{"c":19,"r":0},"w":{"e":9},"t":{"h":{"r":3}}},"e":{".":25,"a":{"r":23},"b":[{"u":11,"a":{"c":{"k":3}}},9],"c":[{"k":32},9],"d":25,"g":{"a":{"t":[{"i":{"v":5}},1]},"e":32},"l":{"a":1,"i":{"z":5}},"m":{"i":4,"o":1},"n":[{"e":18},41],"o":27,"p":{"o":1},"q":9,"r":[{"a":{"b":6,"r":21},"e":24,"i":132,"r":0},29],"s":[{".":25,"p":18,"t":25,"w":18,"k":{"i":119}},41],"t":{"i":{"c":27}},"v":[{"e":19},1],"w":1},"f":[{"i":{"n":{"i":{"t":{"e":{"s":226}}}}}},23],"g":{"a":{"b":21},"e":{"l":23,"n":{"e":[{"s":5},133]},"r":{"e":19,"i":23}},"h":{"a":4,"o":2},"i":{"b":23,"n":2,"t":19},"l":{"a":21},"o":{"v":17},"s":{"h":4,"p":{"r":2}},"u":[{"m":21},29],"y":24},"h":[{"a":[{"b":12},0],"e":0},80],"i":{"a":[{"n":[{".":114},3],"p":1},68],"b":{"a":3,"l":1},"d":[{"i":4},1],"e":{"r":1},"f":{"i":[{"c":{"a":{"t":4}}},9]},"g":{"r":19},"k":0,"m":[{"i":{"z":3}},29],"n":[{"e":{".":32},"g":0},29],"o":1,"s":{".":32,"t":{"a":0}},"t":[{"h":21,"i":{"o":27},"o":{"r":23},"r":3},24]},"j":29,"k":[{"e":{"r":{"o":19},"t":23},"i":{"n":3},"l":29,"r":{"u":{"p":3}}},44],"l":[{"e":{"s":{"s":19}}},43],"m":[{"e":[{"t":17},0]},19],"n":[{"e":0,"i":{"a":{"l":11},"v":0}},101],"o":{"b":{"l":[{"e":3},0]},"c":{"l":19,"e":{"r":{"o":{"s":254}}}},"d":66,"e":27,"g":[{"e":17},18],"i":{"s":{"i":6}},"l":{"i":134,"o":{"g":{"i":{"s":32}}}},"m":{"i":{"c":27,"z":108,"s":{"t":82}},"o":1,"y":3,"a":{"l":214},"e":{"n":{"o":194}}},"n":[{"a":{"g":0},"i":[{"z":19,"s":{"o":255}},5],"e":{"q":15}},1],"p":[{"o":{"l":{"i":135,"y":{".":256}}}},18],"r":{"a":{"b":5,"r":{"y":1}}},"s":{"c":18,"e":0,"t":5},"t":{"a":4},"u":[{"n":27},41],"v":{"e":{"l":136,"m":{"b":2}}},"w":{"l":12}},"p":[{"i":0,"r":{"e":{"c":17}}},72],"q":29,"r":[{"u":0},29],"s":[{"a":{"b":4,"t":{"i":36}},"c":[{"e":{"i":{"v":4}}},1],"e":[{"s":83},24],"i":{"d":137,"g":17},"l":24,"m":[{"o":{"o":1}},3],"o":{"c":21},"p":{"e":1,"i":19},"t":{"a":{"b":{"l":6}}}},81],"t":[{"a":{"b":0},"e":{"r":{"s":12}},"i":[{"b":19,"e":{"r":0},"f":8,"n":{"e":23,"g":83},"p":0},9],"r":{"o":{"l":{"l":{"i":7}}},"e":{"p":137}},"s":1,"u":{"m":{"e":11}}},29],"u":{"a":2,"d":1,"e":{"n":4},"f":{"f":{"e":0}},"i":{"n":23,"t":50},"m":[{"e":2,"i":19},21],"n":138,"o":23,"t":{"r":3}},"v":74,"w":72,"y":{"m":0,"p":0},"z":[{"a":23},18]},"o":{"a":[{"d":11,"l":{"e":{"s":108}},"r":{"d":12},"s":{"e":0,"t":{"e":6}},"t":{"i":5}},18],"b":{"a":{"b":35,"r":19},"e":{"l":0},"i":[{"n":[{"g":4},24]},29],"r":23,"u":{"l":3},"l":{"i":{"g":189}}},"c":{"e":29,"h":[{"e":{"t":23},"a":{"s":23}},0],"i":{"f":12,"l":21},"l":{"a":{"m":21}},"o":{"d":21},"r":{"a":{"c":3,"t":{"i":{"z":4}}},"e":12,"i":{"t":32}},"t":{"o":{"r":{"a":7}}},"u":{"l":{"a":3},"r":{"e":19}}},"d":{"d":{"e":{"d":4}},"i":{"c":3,"o":11,"t":{"i":{"c":137}}},"o":[{"r":12},139],"u":{"c":{"t":{".":4,"s":4}}},"e":{"l":{"l":{"i":12}}}},"e":{"l":21,"n":{"g":19},"r":[{"s":{"t":257}},23],"t":{"a":1},"v":23},"f":{"i":[{"t":{"e":4,"t":17}},24]},"g":{"a":{"r":121,"t":{"i":{"v":4},"o":21}},"e":[{"n":{"e":19},"o":19,"r":21},29],"i":{"e":23,"s":140,"t":3},"l":[{"y":79},21],"n":{"i":{"z":27}},"r":{"o":21},"u":{"i":5},"y":[{"n":25},41]},"h":[{"a":{"b":6}},74],"i":[{"c":{"e":{"s":11}},"d":{"e":{"r":3}},"f":{"f":17},"g":0,"l":{"e":{"t":4}},"n":{"g":23,"t":{"e":{"r":6}}},"s":{"m":19,"o":{"n":4},"t":{"e":{"n":6}}},"t":{"e":{"r":3}}},9],"j":19,"k":[{"e":{"n":23,"s":{"t":15}},"i":{"e":4}},25],"l":{"a":[{"n":21,"s":{"s":36}},29],"d":[{"e":15},9],"e":{"r":3,"s":{"c":23,"t":{"e":{"r":88}}},"t":23},"f":{"i":1},"i":[{"a":23,"c":{"e":23},"d":{".":4},"f":73,"l":19,"n":{"g":3},"o":19,"s":{".":19,"h":3},"t":{"e":19,"i":{"o":19}},"v":19,"g":{"o":{"p":{"o":258}}}},9],"l":{"i":{"e":17}},"o":{"g":{"i":{"z":4}},"r":0,"n":{"o":{"m":259}}},"p":{"l":4},"t":9,"u":{"b":3,"m":{"e":3},"n":3,"s":19},"v":9,"y":24},"m":{"a":{"h":4,"l":5,"t":{"i":{"z":4}}},"b":{"e":9,"l":1},"e":[{"n":{"a":3},"r":{"s":{"e":4}},"t":[{"r":{"y":4}},21],"c":{"h":{"a":260}}},24],"i":{"a":23,"c":{".":3,"a":3},"d":19,"n":[{"i":19},2]},"m":{"e":{"n":{"d":32}}},"o":{"g":{"e":0},"n":21},"p":{"i":3,"r":{"o":7}}},"n":[{"a":[{"c":1,"n":23},2],"c":[{"i":{"l":27}},2],"d":[{"o":4},25],"e":{"n":23,"s":{"t":4}},"g":{"u":1},"i":{"c":2,"o":23,"s":2,"u":19},"k":{"e":{"y":3}},"o":{"d":{"i":1},"m":{"y":3,"i":{"c":137}},"r":{"m":{"a":23}},"t":{"o":{"n":261}},"u":23},"s":[{"p":{"i":[{"r":{"a":10}},36]},"u":17},3],"t":{"e":{"n":36},"i":[{"f":7},93]},"u":{"m":4},"v":{"a":6}},24],"o":[{"d":{"e":5,"i":5},"k":1,"p":{"i":11},"r":{"d":23},"s":{"t":6}},9],"p":{"a":24,"e":{"d":5,"r":[{"a":[{"g":18},27]},2]},"h":[{"a":{"n":19},"e":{"r":19}},25],"i":{"n":{"g":3},"t":23,"s":{"m":{".":2}}},"o":{"n":19,"s":{"i":21}},"r":29,"u":2,"y":5},"q":29,"r":{"a":[{".":19,"g":83,"l":{"i":{"z":4}},"n":{"g":{"e":4}}},29],"e":{"a":[{"l":19},5],"i":3,"s":{"h":5,"t":{".":4}},"w":17},"g":{"u":1},"i":{"a":56,"c":{"a":3},"l":19,"n":2,"o":29,"t":{"y":3},"u":23},"m":{"i":9},"n":{"e":8},"o":{"f":19,"u":{"g":3}},"p":{"e":4},"r":{"h":27},"s":{"e":[{"n":5},1],"t":17},"t":{"h":{"i":3,"y":3,"o":{"n":{"i":{"t":262}}},"r":{"i":137}},"y":1,"i":{"v":{"e":{"l":{"y":4}}}}},"u":{"m":19},"y":29},"s":{"a":{"l":3},"c":[{"e":1,"o":{"p":[{"i":18},23]},"r":19},9],"i":{"e":95,"t":{"i":{"v":4},"o":3,"y":3},"u":0},"l":1,"o":24,"p":{"a":1,"o":1,"h":{"e":{"r":83}}},"t":{"a":[{"t":{"i":19}},9],"i":{"l":4,"t":4}}},"t":{"a":{"n":21},"e":{"l":{"e":{"g":36}},"r":{".":3,"s":4},"s":[{"t":{"e":{"r":263},"o":{"r":264}}},21]},"h":[{"e":{"s":{"i":5},"o":{"s":265}},"i":14},18],"i":{"c":{".":3,"a":4,"e":23},"f":23,"s":23},"o":{"s":5}},"u":[{"b":{"l":3,"a":{"d":{"o":116}}},"c":{"h":{"i":6}},"e":{"t":4},"l":1,"n":{"c":{"e":{"r":6}},"d":8},"v":4},9],"v":{"e":{"n":1,"r":{"n":{"e":17},"s":12,"t":1}},"i":{"s":23,"t":{"i":36},"a":{"n":{".":266}}},"o":{"l":60}},"w":{"d":{"e":{"r":3}},"e":{"l":3,"s":{"t":4}},"i":2,"n":{"i":5},"o":21},"y":{"a":2},"x":{"i":{"d":{"i":{"c":267}}}}},"p":{"a":[{"c":{"a":1,"e":1,"t":0},"d":21,"g":{"a":{"n":32,"t":23}},"i":[{"n":17},21],"l":[{"m":{"a":{"t":268}}},21],"n":{"a":0,"e":{"l":11},"t":{"y":0},"y":3},"p":[{"u":1},2],"r":{"a":{"b":{"l":6},"g":{"e":5,"r":{"a":269}},"l":{"e":228},"m":[{"e":12},36]},"d":{"i":5},"e":[{"l":5},27],"i":[{"s":0},28]},"t":{"e":[{"r":4},9],"h":{"i":{"c":32},"y":4},"r":{"i":{"c":1}}},"v":0,"y":27},41],"b":43,"d":1,"e":{".":18,"a":[{"r":{"l":17}},138],"c":9,"d":[{"e":27,"i":[{"a":36,"c":0},27]},37],"e":[{"d":0,"v":208},21],"k":0,"l":{"a":1,"i":{"e":17}},"n":{"a":{"n":1},"c":21,"t":{"h":0}},"o":{"n":4},"r":{"a":{".":21,"b":{"l":6},"g":21},"i":[{"s":{"t":6}},21],"m":{"a":{"l":0},"e":7},"n":21,"o":11,"t":{"i":11},"u":4,"v":15},"t":[{"e":{"n":4},"i":{"z":4}},9]},"f":18,"g":18,"h":{".":18,"a":{"r":{"i":6}},"e":{"n":{"o":11},"r":1,"s":{".":1}},"i":{"c":2,"e":32,"n":{"g":4},"s":{"t":{"i":32}},"z":27,"l":{"a":{"n":{"t":168},"t":{"e":{"l":270}}}}},"l":9,"o":{"b":27,"n":{"e":27,"i":32},"r":0},"s":18,"t":3,"u":32,"y":41},"i":{"a":[{"n":17},3],"c":{"i":{"e":1},"y":1,"a":{"d":271}},"d":[{"a":19,"e":3,"i":32},21],"e":{"c":27,"n":3},"g":{"r":{"a":{"p":1}}},"l":{"o":3},"n":[{".":21,"d":17,"o":21},9],"o":[{"n":17},141],"t":{"h":[{"a":4},23],"u":9}},"k":142,"l":[{"a":{"n":27,"s":{"t":6}},"i":{"a":11,"e":{"r":5},"g":18,"n":[{"a":{"r":5}},0],"c":{"a":{"b":208}}},"o":{"i":17},"u":{"m":[{"b":17},0]}},143],"m":43,"n":48,"o":{"c":1,"d":{".":32},"e":{"m":4,"t":144},"g":145,"i":{"n":[{"t":32,"c":{"a":12}},84]},"l":{"y":{"t":6,"e":137,"p":{"h":{"o":{"n":{"o":272}}}}},"e":{".":41}},"n":{"i":1},"p":1,"r":[{"y":1},124],"s":[{"s":15},41],"t":[{"a":1},21],"u":{"n":32}},"p":[{"a":{"r":{"a":5}},"e":[{"d":21,"l":19,"n":23,"r":23,"t":23},24],"o":{"s":{"i":{"t":{"e":5}}}}},43],"r":[{"a":{"y":{"e":17}},"e":{"c":{"i":32,"o":5},"e":{"m":11},"f":{"a":{"c":6}},"l":{"a":0},"r":11,"s":{"e":23,"s":27,"p":{"l":{"i":84}}},"t":{"e":{"n":5}},"v":11,"m":{"a":{"c":273}},"n":{"e":{"u":15}}},"i":{"e":53,"n":{"t":146},"s":[{"o":12},0]},"o":{"c":{"a":23,"e":{"s":{"s":8}},"i":{"t":{"y":{".":274}}}},"f":{"i":{"t":6}},"l":11,"s":{"e":12},"t":15,"g":{"e":208}}},9],"s":[{"e":[{"u":{"d":[{"o":{"d":276,"f":276}},275]}},24],"h":1,"i":{"b":21}},81],"t":[{"a":{"b":134},"e":24,"h":24,"i":{"m":11},"u":{"r":0},"w":21,"o":{"m":{"a":{"t":277}}},"r":{"o":{"l":278}}},42],"u":{"b":[{"e":{"s":{"c":181}}},11],"e":0,"f":0,"l":{"c":11},"m":1,"n":9,"r":{"r":0},"s":32,"t":[{"e":[{"r":11},32],"r":3,"t":{"e":{"d":0},"i":{"n":0}}},9]},"w":23},"q":{"u":[{"a":{"v":5,"i":{"n":{"t":{"e":279}}},"s":{"i":[{"r":281,"s":281},280]}},"e":{".":25,"r":27,"t":27},"i":{"n":{"t":{"e":{"s":{"s":282}}}},"v":{"a":{"r":14}}}},9]},"r":{"a":{"b":[{"i":3,"o":{"l":{"i":{"c":29},"o":{"i":236}}}},25],"c":{"h":{"e":17,"u":3},"l":19},"f":{"f":{"i":5},"t":0},"i":24,"l":{"o":1},"m":{"e":{"t":[{"r":{"i":{"z":283}}},11],"n":24},"i":24,"o":{"u":3}},"n":{"e":{"o":6},"g":{"e":0},"i":21,"o":4,"h":{"a":{"s":167}}},"p":{"e":{"r":11},"h":{"y":27}},"r":{"c":5,"e":[{"f":5},17],"i":{"l":18}},"s":24,"t":{"i":{"o":{"n":115}}},"u":{"t":0},"v":{"a":{"i":4},"e":{"l":11}},"z":{"i":{"e":4}},"d":{"i":{"g":127,"o":{"g":249}}},"o":{"r":2}},"b":[{"a":{"b":21,"g":21},"i":[{"f":0,"n":[{"e":19,"g":{".":4,"e":284}},24]},8],"o":1},29],"c":[{"e":[{"n":17},24],"h":{"a":23,"e":{"r":0}},"i":{"b":90,"t":1},"u":{"m":12}},29],"d":{"a":{"l":21},"i":[{"a":0,"e":{"r":0},"n":[{"g":3},17]},9]},"e":{".":25,"a":{"l":2,"n":3,"r":{"r":4},"v":32,"w":1},"b":{"r":{"a":{"t":19}}},"c":{"o":{"l":{"l":5},"m":{"p":{"e":5}}},"r":{"e":1},"i":{"p":{"r":285}},"t":{"a":{"n":{"g":286}}}},"d":[{"e":2,"i":{"s":3,"t":5}},37],"f":{"a":{"c":1},"e":[{"r":{".":4}},9],"i":3,"y":1},"g":{"i":{"s":11}},"i":{"t":4},"l":{"i":2,"u":4},"n":{"t":{"a":90,"e":0}},"o":2,"p":{"i":{"n":4},"o":{"s":{"i":1}},"u":2},"r":[{"i":21,"o":17,"u":4},147],"s":{".":21,"p":{"i":1},"s":{"i":{"b":6}},"t":[{"a":{"l":4},"r":3},8]},"t":{"e":{"r":1},"i":{"z":96},"r":{"i":[{"b":{"u":85}},3]}},"u":[{"t":{"i":4}},8],"v":[{"a":{"l":1},"e":{"l":11,"r":{".":30,"s":4,"t":4}},"i":{"l":4},"o":{"l":{"u":5}}},8],"w":{"h":1}},"f":[{"u":0,"y":21},29],"g":[{"e":{"r":3,"t":23},"i":{"c":23,"n":[{"g":3},0],"s":19,"t":19},"l":29,"o":{"n":0},"u":23},9],"h":[{".":18,"a":{"l":18}},1],"i":{"a":[{"b":0,"g":1,"l":{".":23}},3],"b":[{"a":11},21],"c":{"a":{"s":5},"e":21,"i":[{"d":32,"e":1},18],"o":21},"d":{"e":{"r":5}},"e":{"n":{"c":3,"t":3},"r":2,"t":4},"g":{"a":{"n":5},"i":32},"l":{"i":{"z":11}},"m":{"a":{"n":32},"i":5,"o":27,"p":{"e":0}},"n":{"a":[{".":32},24],"d":0,"e":0,"g":0},"o":2,"p":{"h":[{"e":6},32],"l":[{"i":{"c":5}},9]},"q":21,"s":[{".":21,"c":0,"h":23,"p":0},24],"t":{"a":{"b":116},"e":{"d":{".":19},"r":{".":5,"s":5}},"i":{"c":11},"u":[{"r":5},9]},"v":{"e":{"l":5,"t":11},"i":11,"o":{"l":287}}},"j":23,"k":{"e":{"t":23},"l":{"e":1,"i":{"n":1}},".":288,"h":{"o":2},"r":{"a":{"u":29}},"s":{".":288}},"l":[{"e":[{"d":24,"q":{"u":30}},0],"i":{"g":21,"s":[{"h":4},21]},"o":73},29],"m":[{"a":{"c":5},"e":[{"n":23,"r":{"s":4}},24],"i":{"n":{"g":[{".":21},3]},"o":21,"t":23},"y":21},29],"n":{"a":{"r":21},"e":{"l":23,"r":21,"t":19,"y":23},"i":{"c":19,"s":92,"t":23,"v":23},"o":[{"u":21},0],"u":23},"o":{"b":{"l":11,"o":{"t":289}},"c":[{"r":3},24],"e":[{"l":{"a":{"s":167}},"p":{"i":{"d":{"e":290}}}},1],"f":{"e":2,"i":{"l":4}},"k":[{"e":{"r":4}},8],"l":{"e":{".":32}},"m":{"e":{"t":{"e":5},"s":{"h":3}},"i":0,"p":0},"n":{"a":{"l":0},"e":0,"i":{"s":134},"t":{"a":0}},"o":{"m":41,"t":32},"p":{"e":{"l":3},"i":{"c":11}},"r":{"i":11,"o":4},"s":{"p":{"e":{"r":5}},"s":0},"t":{"h":{"e":1},"y":1,"r":{"o":{"n":2}}},"v":{"a":1,"e":{"l":5}},"x":5},"p":[{"e":{"a":21,"n":{"t":19},"r":{".":4},"t":23},"h":95,"i":{"n":{"g":3}},"o":23,"a":{"u":{"l":{"i":291}}}},29],"r":[{"e":{"c":0,"f":0,"o":21,"s":{"t":0}},"i":{"o":0,"v":0},"o":{"n":17,"s":17},"y":{"s":17}},72],"s":[{"a":[{"t":{"i":5}},29],"c":1,"e":[{"c":[{"r":0},23],"r":{".":4,"a":{"d":{"i":238}}},"s":3,"v":148},24],"h":[{"a":19},29],"i":[{"b":90},29],"o":{"n":12},"p":29,"w":19},44],"t":{"a":{"c":{"h":36},"g":21},"e":{"b":23,"n":{"d":17},"o":5},"i":[{"b":4,"d":0,"e":{"r":21},"g":23,"l":{"i":12,"l":17,"y":21},"s":{"t":21},"v":21},29],"r":{"i":23,"o":{"p":{"h":115}},"e":{"u":29}},"s":{"h":1},"h":{"o":{"u":29}}},"u":{"a":3,"e":{"l":93,"n":3},"g":{"l":1},"i":{"n":3},"m":{"p":{"l":11}},"n":[{"k":6,"t":{"y":0}},9],"s":{"c":19},"t":{"i":{"n":6}}},"v":{"e":[{"l":{"i":17},"n":23,"r":{".":4},"s":{"t":19},"y":23,"i":{"l":29}},1],"i":{"c":23,"v":0},"o":23},"w":29,"y":{"c":1,"n":{"g":{"e":32}},"t":3},"z":{"s":{"c":2}}},"s":{"a":[{"b":42,"c":{"k":32,"r":{"i":11},"t":23},"i":32,"l":{"a":{"r":36},"m":0,"o":4,"t":0,"e":{"s":{"c":54,"w":7}}},"n":{"c":27,"d":{"e":0}},"p":[{"a":{"r":{"i":{"l":292}}}},29],"t":{"a":4,"i":{"o":76},"u":11},"u":0,"v":{"o":{"r":4}},"w":32},9],"b":56,"c":{"a":{"n":{"t":149},"p":[{"e":{"r":267}},0],"v":6,"t":{"o":{"l":208}}},"e":{"d":21,"i":18,"s":21},"h":[{"o":21,"i":{"t":{"z":21}},"r":{"o":{"d":{"i":{"n":{"g":293}}}}}},8],"i":{"e":68,"n":{"d":150},"u":{"t":{"t":294}}},"l":{"e":6,"i":21},"o":{"f":17,"p":{"y":18},"u":{"r":{"a":7}}},"u":29,"r":{"a":{"p":{"e":{"r":{".":36}}}}},"y":{"t":{"h":247}}},"d":56,"e":{".":18,"a":[{"s":17,"w":5},1],"c":{"o":151,"t":27},"d":[{"e":95,"l":19},125],"g":[{"r":11},9],"i":32,"l":{"e":2,"f":32,"v":32},"m":{"e":[{"s":{"t":295}},18],"o":{"l":1},"a":{"p":{"h":287}},"i":{"t":{"i":{"c":296}}}},"n":{"a":{"t":5},"c":18,"d":0,"e":{"d":19},"g":5,"i":{"n":19},"t":{"d":18,"l":18}},"p":{"a":152,"t":{"e":{"m":{"b":11}}}},"r":{".":43,"l":21,"o":0,"v":{"o":18}},"s":[{"h":4,"t":5},72],"u":{"m":113},"v":[{"e":{"n":11}},32],"w":{"i":0},"x":32},"f":47,"g":48,"h":[{".":25,"e":{"r":2,"v":32},"i":{"n":2,"o":3,"p":27,"v":6},"o":[{"l":{"d":4},"n":12,"r":[{"t":7},17],"e":{"s":{"t":137}}},0],"w":18},24],"i":{"b":2,"c":{"c":19},"d":{"e":{".":27,"s":[{"t":6,"w":6},32],"d":{".":8}},"i":[{"z":4},32]},"g":{"n":{"a":18}},"l":{"e":0,"y":18},"n":[{"a":24,"e":{".":32},"g":23},42],"o":[{"n":[{"a":6},32]},41],"r":[{"a":5,"e":{"s":{"i":{"d":4}}}},9],"s":41,"t":{"i":{"o":27}},"u":32,"v":41,"z":32},"k":[{"e":[{"t":23},18],"i":{"n":{"e":4,"g":4}},"y":{"s":{"c":15}}},9],"l":[{"a":{"t":23},"e":24,"i":{"t":{"h":7}},"o":{"v":{"a":{"k":{"i":{"a":297}}}}}},74],"m":[{"a":[{"l":{"l":54},"n":12},23],"e":{"l":17,"n":19},"i":{"t":{"h":32}},"o":{"l":{"d":49}}},42],"n":72,"o":[{"c":{"e":1},"f":{"t":12},"l":{"a":{"b":1},"d":153,"i":{"c":3},"v":32,"u":{"t":{"e":9}}},"m":27,"n":{".":68,"a":17,"g":0},"p":[{"h":{"i":{"c":32,"z":19},"y":19}},21],"r":{"c":5,"d":5},"v":[{"i":4},18],"g":{"a":{"m":{"y":298}}}},41],"p":{"a":[{"i":32,"n":0,"c":{"e":299,"i":{"n":69}}},25],"e":{"n":{"d":17},"o":57,"r":25,"c":{"i":{"o":11}}},"h":{"e":[{"r":[{"o":213},27]},24],"o":6},"i":{"l":17,"n":{"g":4},"o":18,"c":{"i":{"l":208}}},"l":{"y":21},"o":{"n":21,"r":[{"t":{"s":{"c":300,"w":300}}},17],"t":18,"k":{"e":{"s":{"w":10}}}}},"q":{"u":{"a":{"l":{"l":36}},"i":{"t":{"o":88}}}},"r":29,"s":[{"a":[{"s":12,"c":{"h":{"u":301}}},29],"c":94,"e":{"l":23,"n":{"g":19},"s":{".":21},"t":19},"i":[{"e":[{"r":0},21],"l":{"y":4},"a":{"n":{".":210}},"g":{"n":{"a":{"b":302}}}},29],"l":[{"i":1},21],"n":21,"p":{"e":{"n":{"d":115}}},"t":9,"u":{"r":{"a":6}},"w":4,"h":{"a":{"t":3}}},25],"t":{".":25,"a":{"g":24,"l":24,"m":{"i":17,"p":69},"n":{"d":32,"t":{"s":{"h":{"i":303}}}},"p":90,"t":{".":32,"i":15},"r":{"t":{"l":{"i":12}}}},"e":{"d":21,"r":{"n":{"i":7},"o":19},"w":[{"a":6},8]},"h":{"e":23},"i":[{".":21,"a":19,"c":[{"k":32},29],"e":21,"f":23,"n":{"g":3},"r":32},9],"l":{"e":29},"o":{"c":{"k":32},"m":{"a":12},"n":{"e":32},"p":21,"r":{"e":27,"a":{"b":304}}},"r":[{"a":{"d":21,"t":{"u":32,"a":{"g":305}},"y":21},"i":{"d":21,"b":{"u":{"t":7}}},"y":18},1],"w":61,"y":[{"l":{"i":{"s":137}}},24],"b":4,"s":{"c":{"r":4}},"u":{"p":{"i":{"d":306}}}},"u":[{"a":{"l":2},"b":111,"g":151,"i":{"s":4,"t":12},"l":21,"m":[{"i":11},9],"n":9,"r":9,"p":{"e":{"r":{"e":307}}}},41],"v":18,"w":[{"o":18,"i":{"m":{"m":177}}},9],"y":[{"c":18,"l":27,"n":{"o":5,"c":41},"r":{"i":{"n":4}},"t":{"h":{"i":308}}},21]},"t":{"a":[{".":27,"b":[{"l":{"e":{"s":4}},"o":{"l":{"i":{"z":32,"s":{"m":309}}}}},25],"c":{"i":18},"d":{"o":4},"f":46,"i":{"l":{"o":5}},"l":[{"a":4,"e":{"n":5},"i":11,"k":[{"a":204},18],"l":{"i":{"s":0}},"o":{"g":4}},9],"m":{"o":4,"i":{"n":82}},"n":{"d":{"e":0},"t":{"a":54}},"p":{"e":{"r":4},"l":4,"a":{"t":{"h":310}}},"r":{"a":0,"c":18,"e":18,"i":{"z":3},"r":{"h":311}},"s":{"e":0,"y":4},"t":{"i":{"c":18},"u":{"r":1}},"u":{"n":17},"v":0,"w":25,"x":{"i":{"s":0}},"g":{"o":{"n":{".":3}}}},41],"b":42,"c":[{"h":[{"e":{"t":5},"c":15,"i":{"e":{"r":237}}},21],"r":29},18],"d":43,"e":{".":18,"a":{"d":{"i":17},"t":18,"c":{"h":{"e":{"r":{".":36}}}}},"c":{"e":17,"t":32},"d":[{"i":4},42],"e":41,"g":[{"e":{"r":4},"i":4},0],"l":{".":27,"i":17,"s":32,"e":{"g":84,"r":{"o":249}}},"m":{"a":[{"t":11},154]},"n":{"a":{"n":27},"c":27,"d":27,"e":{"s":18},"t":[{"a":{"g":0}},41]},"o":41,"p":[{"e":4},1],"r":{"c":11,"d":155,"i":[{"e":{"s":5},"s":11,"z":{"a":6},"c":{".":8}},41],"n":{"i":{"t":32}},"v":5,"g":{"e":{"i":312}}},"s":{".":18,"s":[{".":23,"e":{"s":313}},18]},"t":{"h":{"e":6}},"u":27,"x":27,"y":18},"f":42,"g":43,"h":{".":25,"a":{"n":17,"l":{"a":{"m":228}}},"e":[{"a":[{"s":3,"t":5},18],"i":{"s":11},"t":27},9],"i":{"c":{".":4,"a":4},"l":18,"n":{"k":32}},"l":18,"o":{"d":{"e":4,"i":{"c":32},"o":{"n":11}},"o":18,"r":{"i":{"t":6,"z":5}},"g":{"e":{"n":{"i":314}}},"k":{"e":{"r":175}}},"s":25,"y":{"l":{"a":{"n":228}},"s":{"c":11}}},"i":{"a":[{"b":1,"t":{"o":1},"n":{".":70}},41],"b":156,"c":{"k":18,"o":21,"u":157},"d":{"i":32},"e":{"n":27},"f":[{"y":4},8],"g":[{"u":32},25],"l":{"l":{"i":{"n":6}}},"m":[{"p":18,"u":{"l":5}},41],"n":[{"a":24,"e":{".":27},"i":27,"o":{"m":285}},42],"o":[{"c":4,"n":{"e":{"e":6}}},41],"q":32,"s":{"a":3,"e":27,"m":0,"o":4,"p":0,"t":{"i":{"c":{"a":32}}}},"t":{"l":3},"u":1,"v":[{"a":0},41],"z":[{"a":3,"e":{"n":3}},41]},"l":[{"a":[{"n":17},19],"e":{".":27,"d":27,"s":{".":27},"t":{".":19}},"o":19,"i":{"e":{"r":315}}},25],"m":[{"e":0},43],"n":81,"o":[{"b":3,"c":{"r":{"a":{"t":4}}},"d":{"o":18},"f":25,"g":{"r":9},"i":{"c":4},"m":{"a":9,"b":0,"y":3},"n":{"a":{"l":{"i":0},"t":3},"o":18,"y":18},"r":{"a":9,"i":{"e":3,"z":5}},"s":8,"u":{"r":32,"t":18},"w":{"a":{"r":3}},"l":{"o":{"g":{"y":84}}},"t":{"i":{"c":11}}},41],"p":43,"r":{"a":[{"b":11,"c":{"h":5,"i":[{"t":17},36],"t":{"e":17}},"s":17,"v":{"e":{"n":5,"s":158,"r":{"s":[{"a":{"b":317}},15]}}},"i":{"t":{"o":{"r":316}}}},41],"e":{"f":5,"m":[{"i":6},0],"a":{"c":{"h":{"e":318}}}},"i":{"a":[{"l":{".":1}},32],"c":{"e":{"s":5},"i":{"a":32},"s":18},"m":25,"v":0},"o":{"m":{"i":5},"n":{"i":6,"y":18},"p":{"h":{"e":5},"i":{"s":175},"o":{"l":{"e":{"s":320},"i":{"s":320,"t":321}}}},"s":{"p":11},"v":11,"l":{"e":{"u":{"m":319}}},"f":{"i":{"c":{".":17},"t":11}}},"u":{"i":5,"s":17}},"s":[{"c":[{"h":{"i":{"e":12}}},21],"h":0,"w":21},101],"t":[{"e":{"s":21},"o":19,"u":0,"r":{"i":{"b":{"u":{"t":322}}}}},66],"u":[{"a":[{"r":3},2],"b":{"i":1},"d":8,"e":18,"f":46,"i":76,"m":27,"n":{"i":{"s":1}},"p":{".":48},"r":{"e":27,"i":[{"s":11},32],"o":5,"y":4,"n":{"a":{"r":12}}},"s":27},41],"v":18,"w":[{"a":43,"i":{"s":17},"o":18,"h":29},1],"y":[{"a":18,"l":25,"p":{"e":12,"h":4,"a":{"l":64}}},41],"z":[{"e":1},18]},"u":{"a":{"b":18,"c":0,"n":{"a":4,"i":0},"r":{"a":{"n":{"t":5}},"d":8,"i":11,"t":11},"t":29,"v":0,"d":{"r":{"a":{"t":{"i":3,"u":15}}}}},"b":{"e":[{"l":21,"r":[{"o":21},23]},1],"i":[{"n":{"g":33}},72],"l":{"e":{".":23}}},"c":{"a":23,"i":{"b":0,"t":1},"l":{"e":12},"r":23,"u":23,"y":21},"d":{"d":4,"e":{"r":3,"s":{"t":4},"v":17},"i":{"c":29,"e":{"d":3,"s":3},"s":4,"t":19},"o":{"n":[{"y":232},21]},"s":{"i":1},"u":21},"e":{"n":{"e":21,"s":17,"t":{"e":0}},"r":{"i":{"l":0}},"a":{"m":15}},"f":{"a":27,"l":23},"g":{"h":{"e":{"n":11}},"i":{"n":4}},"i":[{"l":{"i":{"z":5}},"n":[{"g":29},1],"r":{"m":0},"t":{"a":17},"v":[{"e":{"r":{".":0}}},11]},156],"j":19,"k":18,"l":{"a":[{"b":5,"t":{"i":19}},29],"c":{"h":[{"e":32},17]},"d":{"e":{"r":3}},"e":[{"n":29},1],"g":{"i":1},"i":[{"a":19,"n":{"g":3},"s":{"h":4}},9],"l":{"a":{"r":1},"i":{"b":96,"s":1}},"m":61,"o":72,"s":[{"e":{"s":5}},18],"t":{"i":2,"r":{"a":54},"u":18},"u":[{"l":4},23],"v":4},"m":{"a":{"b":4},"b":{"i":1,"l":{"y":1}},"i":[{"n":{"g":83}},29],"o":{"r":{"o":6}},"p":9},"n":{"a":{"t":17},"e":[{"r":1},24],"i":[{"m":1,"n":24,"s":{"h":4},"v":11},29],"s":[{"w":1},93],"t":{"a":{"b":11},"e":{"r":{".":1},"s":1}},"u":0,"y":4,"z":4},"o":{"r":{"s":21},"s":19,"u":29},"p":{"e":[{"r":{"s":6}},29],"i":{"a":19,"n":{"g":3}},"l":23,"p":[{"o":{"r":{"t":10}}},3],"t":{"i":{"b":5},"u":17}},"r":{"a":[{".":18,"g":21,"s":21,"l":{".":216}},29],"b":{"e":1},"c":0,"d":2,"e":{"a":{"t":5}},"f":{"e":{"r":1},"r":1},"i":{"f":[{"i":{"c":0}},23],"n":2,"o":23,"t":29,"z":3,"a":{"l":{".":0}}},"l":[{"i":{"n":{"g":{".":5}}}},9],"n":{"o":1},"o":{"s":17},"p":{"e":1,"i":1},"s":{"e":{"r":5}},"t":{"e":{"s":4},"h":{"e":3},"i":[{"e":1},17]},"u":23},"s":[{"a":{"d":19,"n":19,"p":1},"c":[{"i":3},8],"e":{"a":5,"r":{".":9}},"i":{"a":19,"c":23},"l":{"i":{"n":1}},"p":2,"s":{"l":4},"t":{"e":{"r":{"e":4}},"r":2},"u":[{"r":17},24]},25],"t":{"a":{"b":0,"t":23},"e":{".":18,"l":18,"n":[{"i":17},18]},"i":[{"l":{"i":{"z":5}},"n":{"e":23,"g":3},"o":{"n":{"a":7}},"s":21,"z":31},101],"l":34,"o":{"f":4,"g":5,"m":{"a":{"t":{"i":{"c":5}}}},"n":19,"u":21},"s":0},"u":[{"m":1},23],"v":74,"x":{"u":11},"z":{"e":1}},"v":{"a":[{".":32,"b":159,"c":{"i":{"l":5},"u":11},"g":[{"e":1,"u":{"e":{"r":170}}},0],"l":{"i":{"e":4},"o":5,"u":15},"m":{"o":4},"n":{"i":{"z":4}},"p":{"i":4},"r":{"i":{"e":{"d":5}}},"t":[{"i":{"v":29}},27],"u":{"d":{"e":{"v":54}}}},41],"e":{".":18,"d":18,"g":11,"l":{".":23,"l":{"i":11},"o":1,"y":21},"n":{"o":{"m":11},"u":{"e":19}},"r":{"d":21,"e":{".":32,"l":[{"y":{".":41}},21],"n":[{"c":5},23],"s":21,"i":{"g":324}},"i":{"e":11},"m":{"i":{"n":36}},"s":{"e":27},"t":{"h":11}},"s":[{".":18,"t":{"e":0,"i":{"t":{"e":15}}}},99],"t":{"e":[{"r":11},1],"y":1}},"i":{"a":{"l":{"i":4},"n":32},"d":{"e":{".":32,"d":32,"n":47,"s":32},"i":32},"f":23,"g":{"n":4},"k":0,"l":[{"i":{"t":32,"z":127}},25],"n":[{"a":26,"c":24,"d":5,"g":18},29],"o":{"l":11,"r":73,"u":2},"p":1,"r":{"o":4},"s":{"i":{"t":11},"o":3,"u":3},"t":{"i":18,"r":11,"y":18},"v":[{"i":{"p":{"a":{"r":325}}}},27]},"o":{".":32,"i":[{"r":{"d":{"u":323}},"c":{"e":{"p":213}}},0],"k":27,"l":{"a":1,"e":19,"t":32,"v":27},"m":{"i":5},"r":{"a":{"b":5},"i":17,"y":1},"t":{"a":1,"e":{"e":18}}},"v":26,"y":21},"w":{"a":{"b":{"l":19},"c":25,"g":{"e":{"r":4},"o":5},"i":{"t":6},"l":{".":19},"m":0,"r":{"t":0},"s":{"t":[{"e":{"w":{"a":326}}},0]},"t":{"e":2},"v":{"e":{"r":4,"g":327}}},"b":29,"e":{"a":{"r":{"i":{"e":5}},"t":{"h":54}},"d":{"n":0},"e":{"t":12,"v":5,"k":{"n":137}},"l":{"l":0},"r":29,"s":{"t":12},"v":23},"h":{"i":0},"i":[{"l":[{"l":{"i":{"n":6}}},8],"n":{"d":{"e":0},"g":0},"r":0,"s":{"e":27},"t":{"h":12},"z":5,"d":{"e":{"s":{"p":6}}}},9],"k":21,"l":{"e":{"s":1},"i":{"n":3}},"n":{"o":21},"o":[{"m":15,"v":{"e":{"n":4}},"k":{"e":{"n":85}}},160],"p":19,"r":{"a":[{"p":{"a":{"r":{"o":12}}}},0],"i":[{"t":{"a":36,"e":{"r":{".":183}}}},0]},"s":{"h":23,"l":1,"p":{"e":1},"t":60},"t":18,"y":1,"c":23},"x":{"a":[{"c":{"e":5},"g":{"o":21},"m":11,"p":21,"s":5},29],"c":161,"e":[{"c":{"u":{"t":{"o":1}}},"d":24,"r":{"i":0,"o":4}},29],"h":[{"i":[{"l":6},8],"u":0},29],"i":[{"a":4,"c":4,"d":{"i":4},"m":{"e":21,"i":{"z":4}}},23],"o":[{"b":21},23],"p":[{"a":{"n":{"d":17}},"e":{"c":{"t":{"o":10}},"d":11}},23],"t":[{"i":23},74],"u":[{"a":3},29],"x":1,"q":[{"u":{"i":{"s":54}}},29]},"y":{"a":{"c":19,"r":110,"t":19},"b":29,"c":[{"e":[{"r":4},24],"h":[{"e":[{"d":264},0]},23],"o":{"m":17,"t":17}},29],"d":29,"e":{"e":19,"r":[{"f":21},29],"s":[{"t":{"e":{"r":{"y":328}}}},0],"t":1},"g":{"i":19},"h":47,"i":29,"l":{"a":23,"l":{"a":{"b":{"l":6}}},"o":23,"u":19},"m":{"b":{"o":{"l":7}},"e":[{"t":{"r":{"y":20}}},0],"p":{"a":12}},"n":{"c":{"h":{"r":3}},"d":4,"g":4,"i":{"c":4},"x":32},"o":[{"d":4,"g":33,"m":0,"n":{"e":{"t":4},"s":21},"s":21},72],"p":{"e":{"d":21,"r":6},"i":3,"o":[{"c":21},23],"t":{"a":9},"u":19},"r":{"a":{"m":5},"i":{"a":4},"o":23,"r":1},"s":{"c":1,"e":161,"i":{"c":{"a":3},"o":3,"s":27},"o":21,"s":0,"t":[{"a":3,"r":{"o":29}},2],"u":{"r":17}},"t":{"h":{"i":{"n":23}},"i":{"c":3}},"w":29},"z":{"a":[{"b":79,"r":8},2],"b":18,"e":[{"n":1,"p":1,"r":[{"o":3},29],"t":0},25],"i":[{"l":21,"s":21,"a":{"n":{".":23}}},42],"l":32,"m":18,"o":[{"m":1,"o":{"l":4},"p":{"h":{"r":329}}},41],"t":{"e":0},"z":[{"y":21,"w":231},101]}}',
        [
          "as-so-ciate",
          "as-so-ciates",
          "dec-li-na-tion",
          "oblig-a-tory",
          "phil-an-thropic",
          "present",
          "presents",
          "project",
          "projects",
          "reci-procity",
          "re-cog-ni-zance",
          "ref-or-ma-tion",
          "ret-ri-bu-tion",
          "ta-ble"
        ]
      ];
    });
  }
});

// node_modules/@react-pdf/reconciler/node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/@react-pdf/reconciler/node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    (function() {
      function performWorkUntilDeadline() {
        if (isMessageLoopRunning) {
          var currentTime = exports.unstable_now();
          startTime3 = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      function push(heap, node) {
        var index3 = heap.length;
        heap.push(node);
        a: for (; 0 < index3; ) {
          var parentIndex = index3 - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare9(parent, node))
            heap[parentIndex] = node, heap[index3] = parent, index3 = parentIndex;
          else break a;
        }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last2 = heap.pop();
        if (last2 !== first) {
          heap[0] = last2;
          a: for (var index3 = 0, length2 = heap.length, halfLength = length2 >>> 1; index3 < halfLength; ) {
            var leftIndex = 2 * (index3 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare9(left, last2))
              rightIndex < length2 && 0 > compare9(right, left) ? (heap[index3] = right, heap[rightIndex] = last2, index3 = rightIndex) : (heap[index3] = left, heap[leftIndex] = last2, index3 = leftIndex);
            else if (rightIndex < length2 && 0 > compare9(right, last2))
              heap[index3] = right, heap[rightIndex] = last2, index3 = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare9(a3, b2) {
        var diff = a3.sortIndex - b2.sortIndex;
        return 0 !== diff ? diff : a3.id - b2.id;
      }
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else break;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            isHostCallbackScheduled = true, requestHostCallback();
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(
              handleTimeout,
              firstTimer.startTime - currentTime
            );
          }
      }
      function shouldYieldToHost() {
        return exports.unstable_now() - startTime3 < frameInterval ? false : true;
      }
      function requestHostCallback() {
        isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
      }
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      exports.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime3 = -1;
      if ("function" === typeof localSetImmediate)
        var schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports.unstable_continueExecution = function() {
        isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback());
      };
      exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return peek(taskQueue);
      };
      exports.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = function() {
      };
      exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback()));
        return priorityLevel;
      };
      exports.unstable_shouldYield = shouldYieldToHost;
      exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/@react-pdf/reconciler/node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/@react-pdf/reconciler/node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_scheduler_development();
    }
  }
});

// node_modules/@react-pdf/primitives/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  Canvas: () => Canvas,
  Checkbox: () => Checkbox,
  Circle: () => Circle,
  ClipPath: () => ClipPath,
  Defs: () => Defs,
  Document: () => Document,
  Ellipse: () => Ellipse,
  FieldSet: () => FieldSet,
  G: () => G,
  Image: () => Image,
  Line: () => Line,
  LinearGradient: () => LinearGradient,
  Link: () => Link,
  List: () => List,
  Note: () => Note,
  Page: () => Page,
  Path: () => Path,
  Polygon: () => Polygon,
  Polyline: () => Polyline,
  RadialGradient: () => RadialGradient,
  Rect: () => Rect,
  Select: () => Select,
  Stop: () => Stop,
  Svg: () => Svg,
  Text: () => Text,
  TextInput: () => TextInput,
  TextInstance: () => TextInstance,
  Tspan: () => Tspan,
  View: () => View
});
var G = "G";
var Svg = "SVG";
var View = "VIEW";
var Text = "TEXT";
var Link = "LINK";
var Page = "PAGE";
var Note = "NOTE";
var Path = "PATH";
var Rect = "RECT";
var Line = "LINE";
var FieldSet = "FIELD_SET";
var TextInput = "TEXT_INPUT";
var Select = "SELECT";
var Checkbox = "CHECKBOX";
var List = "LIST";
var Stop = "STOP";
var Defs = "DEFS";
var Image = "IMAGE";
var Tspan = "TSPAN";
var Canvas = "CANVAS";
var Circle = "CIRCLE";
var Ellipse = "ELLIPSE";
var Polygon = "POLYGON";
var Document = "DOCUMENT";
var Polyline = "POLYLINE";
var ClipPath = "CLIP_PATH";
var TextInstance = "TEXT_INSTANCE";
var LinearGradient = "LINEAR_GRADIENT";
var RadialGradient = "RADIAL_GRADIENT";

// node_modules/@react-pdf/renderer/lib/react-pdf.browser.js
var import_queue = __toESM(require_queue());
var import_react4 = __toESM(require_react());

// node_modules/@react-pdf/font/lib/index.browser.js
var import_is_url = __toESM(require_is_url());

// node_modules/restructure/src/DecodeStream.js
var ENCODING_MAPPING = {
  utf16le: "utf-16le",
  ucs2: "utf-16le",
  utf16be: "utf-16be"
};
var DecodeStream = class {
  constructor(buffer) {
    this.buffer = buffer;
    this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    this.pos = 0;
    this.length = this.buffer.length;
  }
  readString(length2, encoding = "ascii") {
    encoding = ENCODING_MAPPING[encoding] || encoding;
    let buf = this.readBuffer(length2);
    try {
      let decoder2 = new TextDecoder(encoding);
      return decoder2.decode(buf);
    } catch (err2) {
      return buf;
    }
  }
  readBuffer(length2) {
    return this.buffer.slice(this.pos, this.pos += length2);
  }
  readUInt24BE() {
    return (this.readUInt16BE() << 8) + this.readUInt8();
  }
  readUInt24LE() {
    return this.readUInt16LE() + (this.readUInt8() << 16);
  }
  readInt24BE() {
    return (this.readInt16BE() << 8) + this.readUInt8();
  }
  readInt24LE() {
    return this.readUInt16LE() + (this.readInt8() << 16);
  }
};
DecodeStream.TYPES = {
  UInt8: 1,
  UInt16: 2,
  UInt24: 3,
  UInt32: 4,
  Int8: 1,
  Int16: 2,
  Int24: 3,
  Int32: 4,
  Float: 4,
  Double: 8
};
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "get") {
    let type = key.slice(3).replace("Ui", "UI");
    if (type === "Float32") {
      type = "Float";
    } else if (type === "Float64") {
      type = "Double";
    }
    let bytes = DecodeStream.TYPES[type];
    DecodeStream.prototype["read" + type + (bytes === 1 ? "" : "BE")] = function() {
      const ret = this.view[key](this.pos, false);
      this.pos += bytes;
      return ret;
    };
    if (bytes !== 1) {
      DecodeStream.prototype["read" + type + "LE"] = function() {
        const ret = this.view[key](this.pos, true);
        this.pos += bytes;
        return ret;
      };
    }
  }
}

// node_modules/restructure/src/EncodeStream.js
var textEncoder = new TextEncoder();
var isBigEndian = new Uint8Array(new Uint16Array([4660]).buffer)[0] == 18;
var EncodeStream = class {
  constructor(buffer) {
    this.buffer = buffer;
    this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
    this.pos = 0;
  }
  writeBuffer(buffer) {
    this.buffer.set(buffer, this.pos);
    this.pos += buffer.length;
  }
  writeString(string, encoding = "ascii") {
    let buf;
    switch (encoding) {
      case "utf16le":
      case "utf16-le":
      case "ucs2":
        buf = stringToUtf16(string, isBigEndian);
        break;
      case "utf16be":
      case "utf16-be":
        buf = stringToUtf16(string, !isBigEndian);
        break;
      case "utf8":
        buf = textEncoder.encode(string);
        break;
      case "ascii":
        buf = stringToAscii(string);
        break;
      default:
        throw new Error(`Unsupported encoding: ${encoding}`);
    }
    this.writeBuffer(buf);
  }
  writeUInt24BE(val) {
    this.buffer[this.pos++] = val >>> 16 & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val & 255;
  }
  writeUInt24LE(val) {
    this.buffer[this.pos++] = val & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val >>> 16 & 255;
  }
  writeInt24BE(val) {
    if (val >= 0) {
      this.writeUInt24BE(val);
    } else {
      this.writeUInt24BE(val + 16777215 + 1);
    }
  }
  writeInt24LE(val) {
    if (val >= 0) {
      this.writeUInt24LE(val);
    } else {
      this.writeUInt24LE(val + 16777215 + 1);
    }
  }
  fill(val, length2) {
    if (length2 < this.buffer.length) {
      this.buffer.fill(val, this.pos, this.pos + length2);
      this.pos += length2;
    } else {
      const buf = new Uint8Array(length2);
      buf.fill(val);
      this.writeBuffer(buf);
    }
  }
};
function stringToUtf16(string, swap4) {
  let buf = new Uint16Array(string.length);
  for (let i3 = 0; i3 < string.length; i3++) {
    let code = string.charCodeAt(i3);
    if (swap4) {
      code = code >> 8 | (code & 255) << 8;
    }
    buf[i3] = code;
  }
  return new Uint8Array(buf.buffer);
}
function stringToAscii(string) {
  let buf = new Uint8Array(string.length);
  for (let i3 = 0; i3 < string.length; i3++) {
    buf[i3] = string.charCodeAt(i3);
  }
  return buf;
}
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "set") {
    let type = key.slice(3).replace("Ui", "UI");
    if (type === "Float32") {
      type = "Float";
    } else if (type === "Float64") {
      type = "Double";
    }
    let bytes = DecodeStream.TYPES[type];
    EncodeStream.prototype["write" + type + (bytes === 1 ? "" : "BE")] = function(value2) {
      this.view[key](this.pos, value2, false);
      this.pos += bytes;
    };
    if (bytes !== 1) {
      EncodeStream.prototype["write" + type + "LE"] = function(value2) {
        this.view[key](this.pos, value2, true);
        this.pos += bytes;
      };
    }
  }
}

// node_modules/restructure/src/Base.js
var Base = class {
  fromBuffer(buffer) {
    let stream2 = new DecodeStream(buffer);
    return this.decode(stream2);
  }
  toBuffer(value2) {
    let size = this.size(value2);
    let buffer = new Uint8Array(size);
    let stream2 = new EncodeStream(buffer);
    this.encode(stream2, value2);
    return buffer;
  }
};

// node_modules/restructure/src/Number.js
var NumberT = class extends Base {
  constructor(type, endian = "BE") {
    super();
    this.type = type;
    this.endian = endian;
    this.fn = this.type;
    if (this.type[this.type.length - 1] !== "8") {
      this.fn += this.endian;
    }
  }
  size() {
    return DecodeStream.TYPES[this.type];
  }
  decode(stream2) {
    return stream2[`read${this.fn}`]();
  }
  encode(stream2, val) {
    return stream2[`write${this.fn}`](val);
  }
};
var uint8 = new NumberT("UInt8");
var uint16be = new NumberT("UInt16", "BE");
var uint16 = uint16be;
var uint16le = new NumberT("UInt16", "LE");
var uint24be = new NumberT("UInt24", "BE");
var uint24 = uint24be;
var uint24le = new NumberT("UInt24", "LE");
var uint32be = new NumberT("UInt32", "BE");
var uint32 = uint32be;
var uint32le = new NumberT("UInt32", "LE");
var int8 = new NumberT("Int8");
var int16be = new NumberT("Int16", "BE");
var int16 = int16be;
var int16le = new NumberT("Int16", "LE");
var int24be = new NumberT("Int24", "BE");
var int24le = new NumberT("Int24", "LE");
var int32be = new NumberT("Int32", "BE");
var int32 = int32be;
var int32le = new NumberT("Int32", "LE");
var floatbe = new NumberT("Float", "BE");
var floatle = new NumberT("Float", "LE");
var doublebe = new NumberT("Double", "BE");
var doublele = new NumberT("Double", "LE");
var Fixed = class extends NumberT {
  constructor(size, endian, fracBits = size >> 1) {
    super(`Int${size}`, endian);
    this._point = 1 << fracBits;
  }
  decode(stream2) {
    return super.decode(stream2) / this._point;
  }
  encode(stream2, val) {
    return super.encode(stream2, val * this._point | 0);
  }
};
var fixed16be = new Fixed(16, "BE");
var fixed16 = fixed16be;
var fixed16le = new Fixed(16, "LE");
var fixed32be = new Fixed(32, "BE");
var fixed32 = fixed32be;
var fixed32le = new Fixed(32, "LE");

// node_modules/restructure/src/utils.js
function resolveLength(length2, stream2, parent) {
  let res;
  if (typeof length2 === "number") {
    res = length2;
  } else if (typeof length2 === "function") {
    res = length2.call(parent, parent);
  } else if (parent && typeof length2 === "string") {
    res = parent[length2];
  } else if (stream2 && length2 instanceof NumberT) {
    res = length2.decode(stream2);
  }
  if (isNaN(res)) {
    throw new Error("Not a fixed size");
  }
  return res;
}
var PropertyDescriptor = class {
  constructor(opts2 = {}) {
    this.enumerable = true;
    this.configurable = true;
    for (let key in opts2) {
      const val = opts2[key];
      this[key] = val;
    }
  }
};

// node_modules/restructure/src/Array.js
var ArrayT = class extends Base {
  constructor(type, length2, lengthType = "count") {
    super();
    this.type = type;
    this.length = length2;
    this.lengthType = lengthType;
  }
  decode(stream2, parent) {
    let length2;
    const { pos } = stream2;
    const res = [];
    let ctx = parent;
    if (this.length != null) {
      length2 = resolveLength(this.length, stream2, parent);
    }
    if (this.length instanceof NumberT) {
      Object.defineProperties(res, {
        parent: { value: parent },
        _startOffset: { value: pos },
        _currentOffset: { value: 0, writable: true },
        _length: { value: length2 }
      });
      ctx = res;
    }
    if (length2 == null || this.lengthType === "bytes") {
      const target = length2 != null ? stream2.pos + length2 : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream2.length;
      while (stream2.pos < target) {
        res.push(this.type.decode(stream2, ctx));
      }
    } else {
      for (let i3 = 0, end2 = length2; i3 < end2; i3++) {
        res.push(this.type.decode(stream2, ctx));
      }
    }
    return res;
  }
  size(array, ctx, includePointers = true) {
    if (!array) {
      return this.type.size(null, ctx) * resolveLength(this.length, null, ctx);
    }
    let size = 0;
    if (this.length instanceof NumberT) {
      size += this.length.size();
      ctx = { parent: ctx, pointerSize: 0 };
    }
    for (let item of array) {
      size += this.type.size(item, ctx);
    }
    if (ctx && includePointers && this.length instanceof NumberT) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, array, parent) {
    let ctx = parent;
    if (this.length instanceof NumberT) {
      ctx = {
        pointers: [],
        startOffset: stream2.pos,
        parent
      };
      ctx.pointerOffset = stream2.pos + this.size(array, ctx, false);
      this.length.encode(stream2, array.length);
    }
    for (let item of array) {
      this.type.encode(stream2, item, ctx);
    }
    if (this.length instanceof NumberT) {
      let i3 = 0;
      while (i3 < ctx.pointers.length) {
        const ptr = ctx.pointers[i3++];
        ptr.type.encode(stream2, ptr.val, ptr.parent);
      }
    }
  }
};

// node_modules/restructure/src/LazyArray.js
var LazyArray = class extends ArrayT {
  decode(stream2, parent) {
    const { pos } = stream2;
    const length2 = resolveLength(this.length, stream2, parent);
    if (this.length instanceof NumberT) {
      parent = {
        parent,
        _startOffset: pos,
        _currentOffset: 0,
        _length: length2
      };
    }
    const res = new LazyArrayValue(this.type, length2, stream2, parent);
    stream2.pos += length2 * this.type.size(null, parent);
    return res;
  }
  size(val, ctx) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.size(val, ctx);
  }
  encode(stream2, val, ctx) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.encode(stream2, val, ctx);
  }
};
var LazyArrayValue = class {
  constructor(type, length2, stream2, ctx) {
    this.type = type;
    this.length = length2;
    this.stream = stream2;
    this.ctx = ctx;
    this.base = this.stream.pos;
    this.items = [];
  }
  get(index3) {
    if (index3 < 0 || index3 >= this.length) {
      return void 0;
    }
    if (this.items[index3] == null) {
      const { pos } = this.stream;
      this.stream.pos = this.base + this.type.size(null, this.ctx) * index3;
      this.items[index3] = this.type.decode(this.stream, this.ctx);
      this.stream.pos = pos;
    }
    return this.items[index3];
  }
  toArray() {
    const result = [];
    for (let i3 = 0, end2 = this.length; i3 < end2; i3++) {
      result.push(this.get(i3));
    }
    return result;
  }
};

// node_modules/restructure/src/Bitfield.js
var Bitfield = class extends Base {
  constructor(type, flags = []) {
    super();
    this.type = type;
    this.flags = flags;
  }
  decode(stream2) {
    const val = this.type.decode(stream2);
    const res = {};
    for (let i3 = 0; i3 < this.flags.length; i3++) {
      const flag = this.flags[i3];
      if (flag != null) {
        res[flag] = !!(val & 1 << i3);
      }
    }
    return res;
  }
  size() {
    return this.type.size();
  }
  encode(stream2, keys2) {
    let val = 0;
    for (let i3 = 0; i3 < this.flags.length; i3++) {
      const flag = this.flags[i3];
      if (flag != null) {
        if (keys2[flag]) {
          val |= 1 << i3;
        }
      }
    }
    return this.type.encode(stream2, val);
  }
};

// node_modules/restructure/src/Buffer.js
var BufferT = class extends Base {
  constructor(length2) {
    super();
    this.length = length2;
  }
  decode(stream2, parent) {
    const length2 = resolveLength(this.length, stream2, parent);
    return stream2.readBuffer(length2);
  }
  size(val, parent) {
    if (!val) {
      return resolveLength(this.length, null, parent);
    }
    let len = val.length;
    if (this.length instanceof NumberT) {
      len += this.length.size();
    }
    return len;
  }
  encode(stream2, buf, parent) {
    if (this.length instanceof NumberT) {
      this.length.encode(stream2, buf.length);
    }
    return stream2.writeBuffer(buf);
  }
};

// node_modules/restructure/src/Optional.js
var Optional = class extends Base {
  constructor(type, condition = true) {
    super();
    this.type = type;
    this.condition = condition;
  }
  decode(stream2, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.decode(stream2, parent);
    }
  }
  size(val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.size(val, parent);
    } else {
      return 0;
    }
  }
  encode(stream2, val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.encode(stream2, val, parent);
    }
  }
};

// node_modules/restructure/src/Reserved.js
var Reserved = class extends Base {
  constructor(type, count = 1) {
    super();
    this.type = type;
    this.count = count;
  }
  decode(stream2, parent) {
    stream2.pos += this.size(null, parent);
    return void 0;
  }
  size(data2, parent) {
    const count = resolveLength(this.count, null, parent);
    return this.type.size() * count;
  }
  encode(stream2, val, parent) {
    return stream2.fill(0, this.size(val, parent));
  }
};

// node_modules/restructure/src/String.js
var StringT = class extends Base {
  constructor(length2, encoding = "ascii") {
    super();
    this.length = length2;
    this.encoding = encoding;
  }
  decode(stream2, parent) {
    let length2, pos;
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent, parent) || "ascii";
    }
    let width = encodingWidth(encoding);
    if (this.length != null) {
      length2 = resolveLength(this.length, stream2, parent);
    } else {
      let buffer;
      ({ buffer, length: length2, pos } = stream2);
      while (pos < length2 - width + 1 && (buffer[pos] !== 0 || width === 2 && buffer[pos + 1] !== 0)) {
        pos += width;
      }
      length2 = pos - stream2.pos;
    }
    const string = stream2.readString(length2, encoding);
    if (this.length == null && stream2.pos < stream2.length) {
      stream2.pos += width;
    }
    return string;
  }
  size(val, parent) {
    if (val === void 0 || val === null) {
      return resolveLength(this.length, null, parent);
    }
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (encoding === "utf16be") {
      encoding = "utf16le";
    }
    let size = byteLength(val, encoding);
    if (this.length instanceof NumberT) {
      size += this.length.size();
    }
    if (this.length == null) {
      size += encodingWidth(encoding);
    }
    return size;
  }
  encode(stream2, val, parent) {
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (this.length instanceof NumberT) {
      this.length.encode(stream2, byteLength(val, encoding));
    }
    stream2.writeString(val, encoding);
    if (this.length == null) {
      return encodingWidth(encoding) == 2 ? stream2.writeUInt16LE(0) : stream2.writeUInt8(0);
    }
  }
};
function encodingWidth(encoding) {
  switch (encoding) {
    case "ascii":
    case "utf8":
      return 1;
    case "utf16le":
    case "utf16-le":
    case "utf-16be":
    case "utf-16le":
    case "utf16be":
    case "utf16-be":
    case "ucs2":
      return 2;
    default:
      return 1;
  }
}
function byteLength(string, encoding) {
  switch (encoding) {
    case "ascii":
      return string.length;
    case "utf8":
      let len = 0;
      for (let i3 = 0; i3 < string.length; i3++) {
        let c3 = string.charCodeAt(i3);
        if (c3 >= 55296 && c3 <= 56319 && i3 < string.length - 1) {
          let c22 = string.charCodeAt(++i3);
          if ((c22 & 64512) === 56320) {
            c3 = ((c3 & 1023) << 10) + (c22 & 1023) + 65536;
          } else {
            i3--;
          }
        }
        if ((c3 & 4294967168) === 0) {
          len++;
        } else if ((c3 & 4294965248) === 0) {
          len += 2;
        } else if ((c3 & 4294901760) === 0) {
          len += 3;
        } else if ((c3 & 4292870144) === 0) {
          len += 4;
        }
      }
      return len;
    case "utf16le":
    case "utf16-le":
    case "utf16be":
    case "utf16-be":
    case "ucs2":
      return string.length * 2;
    default:
      throw new Error("Unknown encoding " + encoding);
  }
}

// node_modules/restructure/src/Struct.js
var Struct = class extends Base {
  constructor(fields = {}) {
    super();
    this.fields = fields;
  }
  decode(stream2, parent, length2 = 0) {
    const res = this._setup(stream2, parent, length2);
    this._parseFields(stream2, res, this.fields);
    if (this.process != null) {
      this.process.call(res, stream2);
    }
    return res;
  }
  _setup(stream2, parent, length2) {
    const res = {};
    Object.defineProperties(res, {
      parent: { value: parent },
      _startOffset: { value: stream2.pos },
      _currentOffset: { value: 0, writable: true },
      _length: { value: length2 }
    });
    return res;
  }
  _parseFields(stream2, res, fields) {
    for (let key in fields) {
      var val;
      const type = fields[key];
      if (typeof type === "function") {
        val = type.call(res, res);
      } else {
        val = type.decode(stream2, res);
      }
      if (val !== void 0) {
        if (val instanceof PropertyDescriptor) {
          Object.defineProperty(res, key, val);
        } else {
          res[key] = val;
        }
      }
      res._currentOffset = stream2.pos - res._startOffset;
    }
  }
  size(val, parent, includePointers = true) {
    if (val == null) {
      val = {};
    }
    const ctx = {
      parent,
      val,
      pointerSize: 0
    };
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    let size = 0;
    for (let key in this.fields) {
      const type = this.fields[key];
      if (type.size != null) {
        size += type.size(val[key], ctx);
      }
    }
    if (includePointers) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, val, parent) {
    let type;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream2);
    }
    const ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
    for (let key in this.fields) {
      type = this.fields[key];
      if (type.encode != null) {
        type.encode(stream2, val[key], ctx);
      }
    }
    let i3 = 0;
    while (i3 < ctx.pointers.length) {
      const ptr = ctx.pointers[i3++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
  }
};

// node_modules/restructure/src/VersionedStruct.js
var getPath = (object, pathArray) => {
  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);
};
var VersionedStruct = class _VersionedStruct extends Struct {
  constructor(type, versions3 = {}) {
    super();
    this.type = type;
    this.versions = versions3;
    if (typeof type === "string") {
      this.versionPath = type.split(".");
    }
  }
  decode(stream2, parent, length2 = 0) {
    const res = this._setup(stream2, parent, length2);
    if (typeof this.type === "string") {
      res.version = getPath(parent, this.versionPath);
    } else {
      res.version = this.type.decode(stream2);
    }
    if (this.versions.header) {
      this._parseFields(stream2, res, this.versions.header);
    }
    const fields = this.versions[res.version];
    if (fields == null) {
      throw new Error(`Unknown version ${res.version}`);
    }
    if (fields instanceof _VersionedStruct) {
      return fields.decode(stream2, parent);
    }
    this._parseFields(stream2, res, fields);
    if (this.process != null) {
      this.process.call(res, stream2);
    }
    return res;
  }
  size(val, parent, includePointers = true) {
    let key, type;
    if (!val) {
      throw new Error("Not a fixed size");
    }
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    const ctx = {
      parent,
      val,
      pointerSize: 0
    };
    let size = 0;
    if (typeof this.type !== "string") {
      size += this.type.size(val.version, ctx);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type = this.versions.header[key];
        if (type.size != null) {
          size += type.size(val[key], ctx);
        }
      }
    }
    const fields = this.versions[val.version];
    if (fields == null) {
      throw new Error(`Unknown version ${val.version}`);
    }
    for (key in fields) {
      type = fields[key];
      if (type.size != null) {
        size += type.size(val[key], ctx);
      }
    }
    if (includePointers) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, val, parent) {
    let key, type;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream2);
    }
    const ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
    if (typeof this.type !== "string") {
      this.type.encode(stream2, val.version);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type = this.versions.header[key];
        if (type.encode != null) {
          type.encode(stream2, val[key], ctx);
        }
      }
    }
    const fields = this.versions[val.version];
    for (key in fields) {
      type = fields[key];
      if (type.encode != null) {
        type.encode(stream2, val[key], ctx);
      }
    }
    let i3 = 0;
    while (i3 < ctx.pointers.length) {
      const ptr = ctx.pointers[i3++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
  }
};

// node_modules/restructure/src/Pointer.js
var Pointer = class extends Base {
  constructor(offsetType, type, options = {}) {
    super();
    this.offsetType = offsetType;
    this.type = type;
    this.options = options;
    if (this.type === "void") {
      this.type = null;
    }
    if (this.options.type == null) {
      this.options.type = "local";
    }
    if (this.options.allowNull == null) {
      this.options.allowNull = true;
    }
    if (this.options.nullValue == null) {
      this.options.nullValue = 0;
    }
    if (this.options.lazy == null) {
      this.options.lazy = false;
    }
    if (this.options.relativeTo) {
      if (typeof this.options.relativeTo !== "function") {
        throw new Error("relativeTo option must be a function");
      }
      this.relativeToGetter = options.relativeTo;
    }
  }
  decode(stream2, ctx) {
    const offset2 = this.offsetType.decode(stream2, ctx);
    if (offset2 === this.options.nullValue && this.options.allowNull) {
      return null;
    }
    let relative;
    switch (this.options.type) {
      case "local":
        relative = ctx._startOffset;
        break;
      case "immediate":
        relative = stream2.pos - this.offsetType.size();
        break;
      case "parent":
        relative = ctx.parent._startOffset;
        break;
      default:
        var c3 = ctx;
        while (c3.parent) {
          c3 = c3.parent;
        }
        relative = c3._startOffset || 0;
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(ctx);
    }
    const ptr = offset2 + relative;
    if (this.type != null) {
      let val = null;
      const decodeValue = () => {
        if (val != null) {
          return val;
        }
        const { pos } = stream2;
        stream2.pos = ptr;
        val = this.type.decode(stream2, ctx);
        stream2.pos = pos;
        return val;
      };
      if (this.options.lazy) {
        return new PropertyDescriptor({
          get: decodeValue
        });
      }
      return decodeValue();
    } else {
      return ptr;
    }
  }
  size(val, ctx) {
    const parent = ctx;
    switch (this.options.type) {
      case "local":
      case "immediate":
        break;
      case "parent":
        ctx = ctx.parent;
        break;
      default:
        while (ctx.parent) {
          ctx = ctx.parent;
        }
    }
    let { type } = this;
    if (type == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type } = val);
      val = val.value;
    }
    if (val && ctx) {
      let size = type.size(val, parent);
      ctx.pointerSize += size;
    }
    return this.offsetType.size();
  }
  encode(stream2, val, ctx) {
    let relative;
    const parent = ctx;
    if (val == null) {
      this.offsetType.encode(stream2, this.options.nullValue);
      return;
    }
    switch (this.options.type) {
      case "local":
        relative = ctx.startOffset;
        break;
      case "immediate":
        relative = stream2.pos + this.offsetType.size(val, parent);
        break;
      case "parent":
        ctx = ctx.parent;
        relative = ctx.startOffset;
        break;
      default:
        relative = 0;
        while (ctx.parent) {
          ctx = ctx.parent;
        }
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(parent.val);
    }
    this.offsetType.encode(stream2, ctx.pointerOffset - relative);
    let { type } = this;
    if (type == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type } = val);
      val = val.value;
    }
    ctx.pointers.push({
      type,
      val,
      parent
    });
    return ctx.pointerOffset += type.size(val, parent);
  }
};
var VoidPointer = class {
  constructor(type, value2) {
    this.type = type;
    this.value = value2;
  }
};

// node_modules/@swc/helpers/esm/_define_property.js
function _define_property(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else obj[key] = value2;
  return obj;
}

// node_modules/tslib/tslib.es6.mjs
function __decorate(decorators, target, key, desc) {
  var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d2 = decorators[i3]) r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
}

// node_modules/fontkit/dist/browser-module.mjs
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);

// node_modules/unicode-properties/dist/module.mjs
var import_base64_js = __toESM(require_base64_js(), 1);
var import_unicode_trie = __toESM(require_unicode_trie(), 1);
function $parcel$interopDefault(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $f4087201da764553$exports = {};
$f4087201da764553$exports = JSON.parse('{"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Osage","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Hanifi_Rohingya","Old_Sogdian","Sogdian","Elymaic","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Newa","Tirhuta","Siddham","Modi","Takri","Ahom","Dogra","Warang_Citi","Nandinagari","Zanabazar_Square","Soyombo","Pau_Cin_Hau","Bhaiksuki","Marchen","Masaram_Gondi","Gunjala_Gondi","Makasar","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Medefaidrin","Miao","Tangut","Nushu","Duployan","SignWriting","Nyiakeng_Puachue_Hmong","Wancho","Mende_Kikakui","Adlam"],"eaw":["N","Na","A","W","H","F"]}');
var $747425b437e121da$var$trie = new (0, import_unicode_trie.default)((0, import_base64_js.default).toByteArray("AAARAAAAAADwfAEAZXl5ONRt+/5bPVFZimRfKoTQJNm37CGE7Iw0j3UsTWKsoyI7kwyyTiEUzSD7NiEzhWYijH0wMVkHE4Mx49fzfo+3nuP4/fdZjvv+XNd5n/d9nef1WZvmKhTxiZndzDQBSEYQqxqKwnsKvGQucFh+6t6cJ792ePQBZv5S9yXSwkyjf/P4T7mTNnIAv1dOVhMlR9lflbUL9JeJguqsjvG9NTj/wLb566VAURnLo2vvRi89S3gW/33ihh2eXpDn40BIW7REl/7coRKIhAFlAiOtbLDTt6mMb4GzMF1gNnvX/sBxtbsAIjfztCNcQjcNDtLThRvuXu5M5g/CBjaLBE4lJm4qy/oZD97+IJryApcXfgWYlkvWbhfXgujOJKVu8B+ozqTLbxyJ5kNiR75CxDqfBM9eOlDMmGeoZ0iQbbS5VUplIwI+ZNXEKQVJxlwqjhOY7w3XwPesbLK5JZE+Tt4X8q8km0dzInsPPzbscrjBMVjF5mOHSeRdJVgKUjLTHiHqXSPkep8N/zFk8167KLp75f6RndkvzdfB6Uz3MmqvRArzdCbs1/iRZjYPLLF3U8Qs+H+Rb8iK51a6NIV2V9+07uJsTGFWpPz8J++7iRu2B6eAKlK/kujrLthwaD/7a6J5w90TusnH1JMAc+gNrql4aspOUG/RrsxUKmPzhHgP4Bleru+6Vfc/MBjgXVx7who94nPn7MPFrnwQP7g0k0Dq0h2GSKO6fTZ8nLodN1SiOUj/5EL/Xo1DBvRm0wmrh3x6phcJ20/9CuMr5h8WPqXMSasLoLHoufTmE7mzYrs6B0dY7KjuCogKqsvxnxAwXWvd9Puc9PnE8DOHT2INHxRlIyVHrqZahtfV2E/A2PDdtA3ewlRHMtFIBKO/T4IozWTQZ+mb+gdKuk/ZHrqloucKdsOSJmlWTSntWjcxVMjUmroXLM10I6TwDLnBq4LP69TxgVeyGsd8yHvhF8ydPlrNRSNs9EP7WmeuSE7Lu10JbOuQcJw/63sDp68wB9iwP5AO+mBpV0R5VDDeyQUFCel1G+4KHBgEVFS0YK+m2sXLWLuGTlkVAd97WwKKdacjWElRCuDRauf33l/yVcDF6sVPKeTes99FC1NpNWcpieGSV/IbO8PCTy5pbUR1U8lxzf4T+y6fZMxOz3LshkQLeeDSd0WmUrQgajmbktrxsb2AZ0ACw2Vgni+gV/m+KvCRWLg08Clx7uhql+v9XySGcjjOHlsp8vBw/e8HS7dtiqF6T/XcSXuaMW66GF1g4q9YyBadHqy3Y5jin1c7yZos6BBr6dsomSHxiUHanYtcYQwnMMZhRhOnaYJeyJzaRuukyCUh48+e/BUvk/aEfDp8ag+jD64BHxNnQ5v/E7WRk7eLjGV13I3oqy45YNONi/1op1oDr7rPjkhPsTXgUpQtGDPlIs55KhQaic9kSGs/UrZ2QKQOflB8MTEQxRF9pullToWO7Eplan6mcMRFnUu2441yxi23x+KqKlr7RWWsi9ZXMWlr8vfP3llk1m2PRj0yudccxBuoa7VfIgRmnFPGX6Pm1WIfMm/Rm4n/xTn8IGqA0GWuqgu48pEUO0U9nN+ZdIvFpPb7VDPphIfRZxznlHeVFebkd9l+raXy9BpTMcIUIvBfgHEb6ndGo8VUkxpief14KjzFOcaANfgvFpvyY8lE8lE4raHizLpluPzMks1hx/e1Hok5yV0p7qQH7GaYeMzzZTFvRpv6k6iaJ4yNqzBvN8J7B430h2wFm1IBPcqbou33G7/NWPgopl4Mllla6e24L3TOTVNkza2zv3QKuDWTeDpClCEYgTQ+5vEBSQZs/rMF50+sm4jofTgWLqgX1x3TkrDEVaRqfY/xZizFZ3Y8/DFEFD31VSfBQ5raEB6nHnZh6ddehtclQJ8fBrldyIh99LNnV32HzKEej04hk6SYjdauCa4aYW0ru/QxvQRGzLKOAQszf3ixJypTW3WWL6BLSF2EMCMIw7OUvWBC6A/gDc2D1jvBapMCc7ztx6jYczwTKsRLL6dMNXb83HS8kdD0pTMMj161zbVHkU0mhSHo9SlBDDXdN6hDvRGizmohtIyR3ot8tF5iUG4GLNcXeGvBudSFrHu+bVZb9jirNVG+rQPI51A7Hu8/b0UeaIaZ4UgDO68PkYx3PE2HWpKapJ764Kxt5TFYpywMy4DLQqVRy11I7SOLhxUFmqiEK52NaijWArIfCg6qG8q5eSiwRCJb1R7GDJG74TrYgx/lVq7w9++Kh929xSJEaoSse5fUOQg9nMAnIZv+7fwVRcNv3gOHI46Vb5jYUC66PYHO6lS+TOmvEQjuYmx4RkffYGxqZIp/DPWNHAixbRBc+XKE3JEOgs4jIwu/dSAwhydruOGF39co91aTs85JJ3Z/LpXoF43hUwJsb/M1Chzdn8HX8vLXnqWUKvRhNLpfAF4PTFqva1sBQG0J+59HyYfmQ3oa4/sxZdapVLlo/fooxSXi/dOEQWIWq8E0FkttEyTFXR2aNMPINMIzZwCNEheYTVltsdaLkMyKoEUluPNAYCM2IG3br0DLy0fVNWKHtbSKbBjfiw7Lu06gQFalC7RC9BwRMSpLYDUo9pDtDfzwUiPJKLJ2LGcSphWBadOI/iJjNqUHV7ucG8yC6+iNM9QYElqBR7ECFXrcTgWQ3eG/tCWacT9bxIkfmxPmi3vOd36KxihAJA73vWNJ+Y9oapXNscVSVqS5g15xOWND/WuUCcA9YAAg6WFbjHamrblZ5c0L6Zx1X58ZittGcfDKU697QRSqW/g+RofNRyvrWMrBn44cPvkRe2HdTu/Cq01C5/riWPHZyXPKHuSDDdW8c1XPgd6ogvLh20qEIu8c19sqr4ufyHrwh37ZN5MkvY1dsGmEz9pUBTxWrvvhNyODyX2Q1k/fbX/T/vbHNcBrmjgDtvBdtZrVtiIg5iXQuzO/DEMvRX8Mi1zymSlt92BGILeKItjoShJXE/H7xwnf0Iewb8BFieJ9MflEBCQYEDm8eZniiEPfGoaYiiEdhQxHQNr2AuRdmbL9mcl18Kumh+HEZLp6z+j35ML9zTbUwahUZCyQQOgQrGfdfQtaR/OYJ/9dYXb2TWZFMijfCA8Nov4sa5FFDUe1T68h4q08WDE7JbbDiej4utRMR9ontevxlXv6LuJTXt1YEv8bDzEt683PuSsIN0afvu0rcBu9AbXZbkOG3K3AhtqQ28N23lXm7S3Yn6KXmAhBhz+GeorJJ4XxO/b3vZk2LXp42+QvsVxGSNVpfSctIFMTR1bD9t70i6sfNF3WKz/uKDEDCpzzztwhL45lsw89H2IpWN10sXHRlhDse9KCdpP5qNNpU84cTY+aiqswqR8XZ9ea0KbVRwRuOGQU3csAtV2fSbnq47U6es6rKlWLWhg3s/B9C9g+oTyp6RtIldR51OOkP5/6nSy6itUVPcMNOp4M/hDdKOz3uK6srbdxOrc2cJgr1Sg02oBxxSky6V7JaG+ziNwlfqnjnvh2/uq1lKfbp+qpwq/D/5OI5gkFl5CejKGxfc2YVJfGqc4E0x5e9PHK2ukbHNI7/RZV6LNe65apbTGjoCaQls0txPPbmQbCQn+/upCoXRZy9yzorWJvZ0KWcbXlBxU/d5I4ERUTxMuVWhSMmF677LNN7NnLwsmKawXkCgbrpcluOl0WChR1qhtSrxGXHu251dEItYhYX3snvn1gS2uXuzdTxCJjZtjsip0iT2sDC0qMS7Bk9su2NyXjFK5/f5ZoWwofg3DtTyjaFqspnOOTSh8xK/CKUFS57guVEkw9xoQuRCwwEO9Lu9z2vYxSa9NFV8DvSxv2C4WYLYF8Nrc4DzWkzNsk81JJOlZ/LYJrGCoj4MmZpnf3AXmzxT4rtl9jsqljEyedz468SGKdBiQzyz/qWKEhFg45ZczlZZ3KGL3l6sn+3TTa3zMVMhPa1obGp/z+fvY0QXTrJTf1XAT3EtQdUfYYlmWZyvPZ/6rWwU7UOQei7pVE0osgN94Iy+T1+omE6z4Rh2O20FjgBeK2y1mcoFiMDOJvuZPn5Moy9fmFH3wyfKvn4+TwfLvt/lHTTVnvrtoUWRBiQXhiNM8nE6ZoWeux/Z0b2unRcdUzdDpmL7CAgd1ToRXwgmHTZOgiGtVT+xr1QH9ObebRTT4NzL+XSpLuuWp62GqQvJVTPoZOeJCb6gIwd9XHMftQ+Kc08IKKdKQANSJ1a2gve3JdRhO0+tNiYzWAZfd7isoeBu67W7xuK8WX7nhJURld98Inb0t/dWOSau/kDvV4DJo/cImw9AO2Gvq0F2n0M7yIZKL8amMbjYld+qFls7hq8Acvq97K2PrCaomuUiesu7qNanGupEl6J/iem8lyr/NMnsTr6o41PO0yhQh3hPFN0wJP7S830je9iTBLzUNgYH+gUZpROo3rN2qgCI+6GewpX8w8CH+ro6QrWiStqmcMzVa3vEel+3/dDxMp0rDv1Q6wTMS3K64zTT6RWzK1y643im25Ja7X2ePCV2mTswd/4jshZPo4bLnerqIosq/hy2bKUAmVn9n4oun1+a0DIZ56UhVwmZHdUNpLa8gmPvxS1eNvCF1T0wo1wKPdCJi0qOrWz7oYRTzgTtkzEzZn308XSLwUog4OWGKJzCn/3FfF9iA32dZHSv30pRCM3KBY9WZoRhtdK/ChHk6DEQBsfV6tN2o1Cn0mLtPBfnkS+qy1L2xfFe9TQPtDE1Be44RTl82E9hPT2rS2+93LFbzhQQO3C/hD2jRFH3BWWbasAfuMhRJFcTri73eE835y016s22DjoFJ862WvLj69fu2TgSF3RHia9D5DSitlQAXYCnbdqjPkR287Lh6dCHDapos+eFDvcZPP2edPmTFxznJE/EBLoQQ0Qmn9EkZOyJmHxMbvKYb8o21ZHmv5YLqgsEPk9gWZwYQY9wLqGXuax/8QlV5qDaPbq9pLPT1yp+zOWKmraEy1OUJI7zdEcEmvBpbdwLrDCgEb2xX8S/nxZgjK4bRi+pbOmbh8bEeoPvU/L9ndx9kntlDALbdAvp0O8ZC3zSUnFg4cePsw7jxewWvL7HRSBLUn6J7vTH9uld5N76JFPgBCdXGF221oEJk++XfRwXplLSyrVO7HFWBEs99nTazKveW3HpbD4dH/YmdAl+lwbSt8BQWyTG7jAsACI7bPPUU9hI9XUHWqQOuezHzUjnx5Qqs6T1qNHfTTHleDtmqK7flA9a0gz2nycIpz1FHBuWxKNtUeTdqP29Fb3tv+tl5JyBqXoR+vCsdzZwZUhf6Lu8bvkB9yQP4x7GGegB0ym0Lpl03Q7e+C0cDsm9GSDepCDji7nUslLyYyluPfvLyKaDSX4xpR+nVYQjQQn5F8KbY1gbIVLiK1J3mW90zTyR1bqApX2BlWh7KG8LAY9/S9nWC0XXh9pZZo6xuir12T43rkaGfQssbQyIslA7uJnSHOV22NhlNtUo0czxPAsXhh8tIQYaTM4l/yAlZlydTcXhlG22Gs/n3BxKBd/3ZjYwg3NaUurVXhNB+afVnFfNr9TbC9ksNdvwpNfeHanyJ8M6GrIVfLlYAPv0ILe4dn0Z+BJSbJkN7eZY/c6+6ttDYcIDeUKIDXqUSE42Xdh5nRbuaObozjht0HJ5H1e+em+NJi/+8kQlyjCbJpPckwThZeIF9/u7lrVIKNeJLCN/TpPAeXxvd31/CUDWHK9MuP1V1TJgngzi4V0qzS3SW3Qy5UiGHqg02wQa5tsEl9s/X9nNMosgLlUgZSfCBj1DiypLfhr9/r0nR0XY2tmhDOcUS4E7cqa4EJBhzqvpbZa35Q5Iz5EqmhYiOGDAYk606Tv74+KGfPjKVuP15rIzgW0I7/niOu9el/sn2bRye0gV+GrePDRDMHjwO1lEdeXH8N+UTO3IoN18kpI3tPxz+fY+n2MGMSGFHAx/83tKeJOl+2i+f1O9v6FfEDBbqrw+lpM8Anav7zHNr7hE78nXUtPNodMbCnITWA7Ma/IHlZ50F9hWge/wzOvSbtqFVFtkS8Of2nssjZwbSFdU+VO8z6tCEc9UA9ACxT5zIUeSrkBB/v1krOpm7bVMrGxEKfI6LcnpB4D8bvn2hDKGqKrJaVAJuDaBEY3F7eXyqnFWlOoFV/8ZLspZiZd7orXLhd4mhHQgbuKbHjJWUzrnm0Dxw/LJLzXCkh7slMxKo8uxZIWZfdKHlfI7uj3LP6ARAuWdF7ZmZ7daOKqKGbz5LxOggTgS39oEioYmrqkCeUDvbxkBYKeHhcLmMN8dMF01ZMb32IpL/cH8R7VHQSI5I0YfL14g9d7P/6cjB1JXXxbozEDbsrPdmL8ph7QW10jio+v7YsqHKQ6xrBbOVtxU0/nFfzUGZwIBLwyUvg49ii+54nv9FyECBpURnQK4Ox6N7lw5fsjdd5l/2SwBcAHMJoyjO1Pifye2dagaOwCVMqdJWAo77pvBe0zdJcTWu5fdzPNfV2p1pc7/JKQ8zhKkwsOELUDhXygPJ5oR8Vpk2lsCen3D3QOQp2zdrSZHjVBstDF/wWO98rrkQ6/7zt/Drip7OHIug1lomNdmRaHRrjmqeodn22sesQQPgzimPOMqC60a5+i/UYh51uZm+ijWkkaI2xjrBO2558DZNZMiuDQlaVAvBy2wLn/bR3FrNzfnO/9oDztYqxZrr7JMIhqmrochbqmQnKowxW29bpqTaJu7kW1VotC72QkYX8OoDDdMDwV1kJRk3mufgJBzf+iwFRJ7XWQwO5ujVglgFgHtycWiMLx5N+6XU+TulLabWjOzoao03fniUW0xvIJNPbk7CQlFZd/RCOPvgQbLjh5ITE8NVJeKt3HGr6JTnFdIzcVOlEtwqbIIX0IM7saC+4N5047MTJ9+Wn11EhyEPIlwsHE5utCeXRjQzlrR+R1Cf/qDzcNbqLXdk3J7gQ39VUrrEkS/VMWjjg+t2oYrqB0tUZClcUF6+LBC3EQ7KnGIwm/qjZX4GKPtjTX1zQKV6nPAb2t/Rza5IqKRf8i2DFEhV/YSifX0YwsiF6TQnp48Gr65TFq0zUe6LGjiY7fq0LSGKL1VnC6ESI2yxvt3XqBx53B3gSlGFeJcPbUbonW1E9E9m4NfuwPh+t5QjRxX34lvBPVxwQd7aeTd+r9dw5CiP1pt8wMZoMdni7GapYdo6KPgeQKcmlFfq4UYhvV0IBgeiR3RnTMBaqDqpZrTRyLdsp4l0IXZTdErfH0sN3dqBG5vRIx3VgCYcHmmkqJ8Hyu3s9K9uBD1d8cZUEx3qYcF5vsqeRpF1GOg8emeWM2OmBlWPdZ6qAXwm3nENFyh+kvXk132PfWAlN0kb7yh4fz2T7VWUY/hEXX5DvxGABC03XRpyOG8t/u3Gh5tZdpsSV9AWaxJN7zwhVglgII1gV28tUViyqn4UMdIh5t+Ea2zo7PO48oba0TwQbiSZOH4YhD578kPF3reuaP7LujPMsjHmaDuId9XEaZBCJhbXJbRg5VCk3KJpryH/+8S3wdhR47pdFcmpZG2p0Bpjp/VbvalgIZMllYX5L31aMPdt1J7r/7wbixt0Mnz2ZvNGTARHPVD+2O1D8SGpWXlVnP2ekgon55YiinADDynyaXtZDXueVqbuTi8z8cHHK325pgqM+mWZwzHeEreMvhZopAScXM14SJHpGwZyRljMlDvcMm9FZ/1e9+r/puOnpXOtc9Iu2fmgBfEP9cGW1Fzb1rGlfJ08pACtq1ZW18bf2cevebzVeHbaA50G9qoUp39JWdPHbYkPCRXjt4gzlq3Cxge28Mky8MoS/+On72kc+ZI2xBtgJytpAQHQ1zrEddMIVyR5urX6yBNu8v5lKC8eLdGKTJtbgIZ3ZyTzSfWmx9f+cvcJe8yM39K/djkp2aUTE/9m2Lj5jg7b8vdRAer7DO3SyLNHs1CAm5x5iAdh2yGJYivArZbCBNY88Tw+w+C1Tbt7wK3zl2rzTHo/D8/gb3c3mYrnEIEipYqPUcdWjnTsSw471O3EUN7Gtg4NOAs9PJrxm03VuZKa5xwXAYCjt7Gs01Km6T2DhOYUMoFcCSu7Hk1p3yP1eG+M3v3Q5luAze6WwBnZIYO0TCucPWK+UJ36KoJ8Y+vpavhLO8g5ed704IjlQdfemrMu//EvPYXTQSGIPPfiagJS9nMqP5IvkxN9pvuJz7h8carPXTKMq8jnTeL0STan6dnLTAqwIswcIwWDR2KwbGddAVN8SYWRB7kfBfBRkSXzvHlIF8D6jo64kUzYk5o/n8oLjKqat0rdXvQ86MkwQGMnnlcasqPPT2+mVtUGb32KuH6cyZQenrRG11TArcAl27+nvOMBDe++EKHf4YdyGf7mznzOz33cFFGEcv329p4qG2hoaQ8ULiMyVz6ENcxhoqGnFIdupcn7GICQWuw3yO3W8S33mzCcMYJ8ywc7U7rmaQf/W5K63Gr4bVTpXOyOp4tbaPyIaatBNpXqlmQUTSZXjxPr19+73PSaT+QnI35YsWn6WpfJjRtK8vlJZoTSgjaRU39AGCkWOZtifJrnefCrqwTKDFmuWUCukEsYcRrMzCoit28wYpP7kSVjMD8WJYQiNc2blMjuqYegmf6SsfC1jqz8XzghMlOX+gn/MKZmgljszrmehEa4V98VreJDxYvHr3j7IeJB9/sBZV41BWT/AZAjuC5XorlIPnZgBAniBEhanp0/0+qZmEWDpu8ige1hUPIyTo6T6gDEcFhWSoduNh8YSu65KgMOGBw7VlNYzNIgwHtq9KP2yyTVysqX5v12sf7D+vQUdR2dRDvCV40rIInXSLWT/yrC6ExOQxBJwIDbeZcl3z1yR5Rj3l8IGpxspapnvBL+fwupA3b6fkFceID9wgiM1ILB0cHVdvo/R4xg8yqKXT8efl0GnGX1/27FUYeUW2L/GNRGGWVGp3i91oaJkb4rybENHre9a2P5viz/yqk8ngWUUS+Kv+fu+9BLFnfLiLXOFcIeBJLhnayCiuDRSqcx0Qu68gVsGYc6EHD500Fkt+gpDj6gvr884n8wZ5o6q7xtL5wA0beXQnffWYkZrs2NGIRgQbsc5NB302SVx+R4ROvmgZaR8wBcji128BMfJ9kcvJ4DC+bQ57kRmv5yxgU4ngZfn0/JNZ8JBwxjTqS+s9kjJFG1unGUGLwMiIuXUD9EFhNIJuyCEAmVZSIGKH4G6v1gRR1LyzQKH2ZqiI1DnHMoDEZspbDjTeaFIAbSvjSq3A+n46y9hhVM8wIpnARSXyzmOD96d9UXvFroSPgGw1dq2vdEqDq9fJN1EbL2WulNmHkFDvxSO9ZT/RX/Bw2gA/BrF90XrJACereVfbV/YXaKfp77Nmx5NjEIUlxojsy7iN7nBHSZigfsbFyVOX1ZTeCCxvqnRSExP4lk5ZeYlRu9caaa743TWNdchRIhEWwadsBIe245C8clpaZ4zrPsk+OwXzxWCvRRumyNSLW5KWaSJyJU95cwheK76gr7228spZ3hmTtLyrfM2QRFqZFMR8/Q6yWfVgwTdfX2Ry4w3+eAO/5VT5nFb5NlzXPvBEAWrNZ6Q3jbH0RF4vcbp+fDngf/ywpoyNQtjrfvcq93AVb1RDWRghvyqgI2BkMr1rwYi8gizZ0G9GmPpMeqPerAQ0dJbzx+KAFM4IBq6iSLpZHUroeyfd9o5o+4fR2EtsZBoJORQEA4SW0CmeXSnblx2e9QkCHIodyqV6+g5ETEpZsLqnd/Na60EKPX/tQpPEcO+COIBPcQdszDzSiHGyQFPly/7KciUh1u+mFfxTCHGv9nn2WqndGgeGjQ/kr02qmTBX7Hc1qiEvgiSz1Tz/sy7Es29wvn6FrDGPP7asXlhOaiHxOctPvTptFA1kHFUk8bME7SsTSnGbFbUrssxrq70LhoSh5OwvQna+w84XdXhZb2sloJ4ZsCg3j+PrjJL08/JBi5zGd6ud/ZxhmcGKLOXPcNunQq5ESW92iJvfsuRrNYtawWwSmNhPYoFj2QqWNF0ffLpGt/ad24RJ8vkb5sXkpyKXmvFG5Vcdzf/44k3PBL/ojJ52+kWGzOArnyp5f969oV3J2c4Li27Nkova9VwRNVKqN0V+gV+mTHitgkXV30aWd3A1RSildEleiNPA+5cp+3+T7X+xfHiRZXQ1s4FA9TxIcnveQs9JSZ5r5qNmgqlW4zMtZ6rYNvgmyVcywKtu8ZxnSbS5vXlBV+NXdIfi3+xzrnJ0TkFL+Un8v1PWOC2PPFCjVPq7qTH7mOpzOYj/b4h0ceT+eHgr97Jqhb1ziVfeANzfN8bFUhPKBi7hJBCukQnB0aGjFTYLJPXL26lQ2b80xrOD5cFWgA8hz3St0e69kwNnD3+nX3gy12FjrjO+ddRvvvfyV3SWbXcxqNHfmsb9u1TV+wHTb9B07/L2sB8WUHJ9eeNomDyysEWZ0deqEhH/oWI2oiEh526gvAK1Nx2kIhNvkYR+tPYHEa9j+nd1VBpQP1uzSjIDO+fDDB7uy029rRjDC5Sk6aKczyz1D5uA9Lu+Rrrapl8JXNL3VRllNQH2K1ZFxOpX8LprttfqQ56MbPM0IttUheXWD/mROOeFqGUbL+kUOVlXLTFX/525g4faLEFO4qWWdmOXMNvVjpIVTWt650HfQjX9oT3Dg5Au6+v1/Ci78La6ZOngYCFPT1AUwxQuZ0yt5xKdNXLaDTISMTeCj16XTryhM36K2mfGRIgot71voWs8tTpL/f1rvcwv3LSDf+/G8THCT7NpfHWcW+lsF/ol8q9Bi6MezNTqp0rpp/kJRiVfNrX/w27cRRTu8RIIqtUblBMkxy4jwAVqCjUJkiPBj2cAoVloG8B2/N5deLdMhDb7xs5nhd3dubJhuj8WbaFRyu1L678DHhhA+rMimNo4C1kGpp0tD/qnCfCFHejpf0LJX43OTr578PY0tnIIrlWyNYyuR/ie6j2xNb1OV6u0dOX/1Dtcd7+ya9W+rY2LmnyQMtk8SMLTon8RAdwOaN2tNg5zVnDKlmVeOxPV2vhHIo9QEPV7jc3f+zVDquiNg1OaHX3cZXJDRY5MJpo+VanAcmqp4oasYLG+wrXUL5vJU0kqk2hGEskhP+Jjigrz1l6QnEwp6n8PMVeJp70Ii6ppeaK9GhF6fJE00ceLyxv08tKiPat4QdxZFgSbQknnEiCLD8Qc1rjazVKM3r3gXnnMeONgdz/yFV1q+haaN+wnF3Fn4uYCI9XsKOuVwDD0LsCO/f0gj5cmxCFcr7sclIcefWjvore+3aSU474cyqDVxH7w1RX3CHsaqsMRX17ZLgjsDXws3kLm2XJdM3Ku383UXqaHqsywzPhx7NFir0Fqjym/w6cxD2U9ypa3dx7Z12w/fi3Jps8sqJ8f8Ah8aZAvkHXvIRyrsxK7rrFaNNdNvjI8+3Emri195DCNa858anj2Qdny6Czshkn4N2+1m+k5S8sunX3Ja7I+JutRzg1mc2e9Yc0Zv9PZn1SwhxIdU9sXwZRTd/J5FoUm0e+PYREeHg3oc2YYzGf2xfJxXExt4pT3RfDRHvMXLUmoXOy63xv5pLuhOEax0dRgSywZ/GH+YBXFgCeTU0hZ8SPEFsn8punp1Kurd1KgXxUZ+la3R5+4ePGR4ZF5UQtOa83+Vj8zh80dfzbhxWCeoJnQ4dkZJM4drzknZOOKx2n3WrvJnzFIS8p0xeic+M3ZRVXIp10tV2DyYKwRxLzulPwzHcLlYTxl4PF7v8l106Azr+6wBFejbq/3P72C/0j78cepY9990/d4eAurn2lqdGKLU8FffnMw7cY7pVeXJRMU73Oxwi2g2vh/+4gX8dvbjfojn/eLVhhYl8GthwCQ50KcZq4z2JeW5eeOnJWFQEnVxDoG459TaC4zXybECEoJ0V5q1tXrQbDMtUxeTV6Pdt1/zJuc7TJoV/9YZFWxUtCf6Ou3Vd/vR/vG0138hJQrHkNeoep5dLe+6umcSquKvMaFpm3EZHDBOvCi0XYyIFHMgX7Cqp3JVXlxJFwQfHSaIUEbI2u1lBVUdlNw4Qa9UsLPEK94Qiln3pyKxQVCeNlx8yd7EegVNQBkFLabKvnietYVB4IPZ1fSor82arbgYec8aSdFMaIluYTYuNx32SxfrjKUdPGq+UNp5YpydoEG3xVLixtmHO9zXxKAnHnPuH2fPGrjx0GcuCDEU+yXUtXh6nfUL+cykws1gJ5vkfYFaFBr9PdCXvVf35OJQxzUMmWjv0W6uGJK11uAGDqSpOwCf6rouSIjPVgw57cJCOQ4b9tkI/Y5WNon9Swe72aZryKo8d+HyHBEdWJKrkary0LIGczA4Irq353Wc0Zga3om7UQiAGCvIl8GGyaqz5zH+1gMP5phWUCpKtttWIyicz09vXg76GxkmiGSMQ06Z9X8BUwqOtauDbPIf4rpK/yYoeAHxJ9soXS9VDe1Aw+awOOxaN8foLrif0TXBvQ55dtRtulRq9emFDBxlQcqKCaD8NeTSE7FOHvcjf/+oKbbtRqz9gbofoc2EzQ3pL6W5JdfJzAWmOk8oeoECe90lVMruwl/ltM015P/zIPazqvdvFmLNVHMIZrwiQ2tIKtGh6PDVH+85ew3caqVt2BsDv5rOcu3G9srQWd7NmgtzCRUXLYknYRSwtH9oUtkqyN3CfP20xQ1faXQl4MEmjQehWR6GmGnkdpYNQYeIG408yAX7uCZmYUic9juOfb+Re28+OVOB+scYK4DaPcBe+5wmji9gymtkMpKo4UKqCz7yxzuN8VIlx9yNozpRJpNaWHtaZVEqP45n2JemTlYBSmNIK1FuSYAUQ1yBLnKxevrjayd+h2i8PjdB3YY6b0nr3JuOXGpPMyh4V2dslpR3DFEvgpsBLqhqLDOWP4yEvIL6f21PpA7/8B"));
var $747425b437e121da$var$log2 = Math.log2 || ((n4) => Math.log(n4) / Math.LN2);
var $747425b437e121da$var$bits = (n4) => $747425b437e121da$var$log2(n4) + 1 | 0;
var $747425b437e121da$var$CATEGORY_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).categories.length - 1);
var $747425b437e121da$var$COMBINING_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).combiningClasses.length - 1);
var $747425b437e121da$var$SCRIPT_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).scripts.length - 1);
var $747425b437e121da$var$EAW_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).eaw.length - 1);
var $747425b437e121da$var$NUMBER_BITS = 10;
var $747425b437e121da$var$CATEGORY_SHIFT = $747425b437e121da$var$COMBINING_BITS + $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$COMBINING_SHIFT = $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$SCRIPT_SHIFT = $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$EAW_SHIFT = $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$CATEGORY_MASK = (1 << $747425b437e121da$var$CATEGORY_BITS) - 1;
var $747425b437e121da$var$COMBINING_MASK = (1 << $747425b437e121da$var$COMBINING_BITS) - 1;
var $747425b437e121da$var$SCRIPT_MASK = (1 << $747425b437e121da$var$SCRIPT_BITS) - 1;
var $747425b437e121da$var$EAW_MASK = (1 << $747425b437e121da$var$EAW_BITS) - 1;
var $747425b437e121da$var$NUMBER_MASK = (1 << $747425b437e121da$var$NUMBER_BITS) - 1;
function $747425b437e121da$export$410364bbb673ddbc(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).categories[val >> $747425b437e121da$var$CATEGORY_SHIFT & $747425b437e121da$var$CATEGORY_MASK];
}
function $747425b437e121da$export$c03b919c6651ed55(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).combiningClasses[val >> $747425b437e121da$var$COMBINING_SHIFT & $747425b437e121da$var$COMBINING_MASK];
}
function $747425b437e121da$export$941569448d136665(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).scripts[val >> $747425b437e121da$var$SCRIPT_SHIFT & $747425b437e121da$var$SCRIPT_MASK];
}
function $747425b437e121da$export$92f6187db8ca6d26(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).eaw[val >> $747425b437e121da$var$EAW_SHIFT & $747425b437e121da$var$EAW_MASK];
}
function $747425b437e121da$export$7d1258ebb7625a0d(codePoint) {
  let val = $747425b437e121da$var$trie.get(codePoint);
  let num = val & $747425b437e121da$var$NUMBER_MASK;
  if (num === 0) return null;
  else if (num <= 50) return num - 1;
  else if (num < 480) {
    const numerator = (num >> 4) - 12;
    const denominator = (num & 15) + 1;
    return numerator / denominator;
  } else if (num < 768) {
    val = (num >> 5) - 14;
    let exp = (num & 31) + 2;
    while (exp > 0) {
      val *= 10;
      exp--;
    }
    return val;
  } else {
    val = (num >> 2) - 191;
    let exp = (num & 3) + 1;
    while (exp > 0) {
      val *= 60;
      exp--;
    }
    return val;
  }
}
function $747425b437e121da$export$52c8ea63abd07594(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Nl";
}
function $747425b437e121da$export$727d9dbc4fbb948f(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Nd";
}
function $747425b437e121da$export$a5b49f4dc6a07d2c(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Pc" || category === "Pd" || category === "Pe" || category === "Pf" || category === "Pi" || category === "Po" || category === "Ps";
}
function $747425b437e121da$export$7b6804e8df61fcf5(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Ll";
}
function $747425b437e121da$export$aebd617640818cda(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lu";
}
function $747425b437e121da$export$de8b4ee23b2cf823(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lt";
}
function $747425b437e121da$export$3c52dd84024ae72c(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Zs" || category === "Zl" || category === "Zp";
}
function $747425b437e121da$export$a11bdcffe109e74b(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Nd" || category === "No" || category === "Nl" || category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Me" || category === "Mc";
}
function $747425b437e121da$export$e33ad6871e762338(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Mn" || category === "Me" || category === "Mc";
}
var $747425b437e121da$export$2e2bcd8739ae039 = {
  getCategory: $747425b437e121da$export$410364bbb673ddbc,
  getCombiningClass: $747425b437e121da$export$c03b919c6651ed55,
  getScript: $747425b437e121da$export$941569448d136665,
  getEastAsianWidth: $747425b437e121da$export$92f6187db8ca6d26,
  getNumericValue: $747425b437e121da$export$7d1258ebb7625a0d,
  isAlphabetic: $747425b437e121da$export$52c8ea63abd07594,
  isDigit: $747425b437e121da$export$727d9dbc4fbb948f,
  isPunctuation: $747425b437e121da$export$a5b49f4dc6a07d2c,
  isLowerCase: $747425b437e121da$export$7b6804e8df61fcf5,
  isUpperCase: $747425b437e121da$export$aebd617640818cda,
  isTitleCase: $747425b437e121da$export$de8b4ee23b2cf823,
  isWhiteSpace: $747425b437e121da$export$3c52dd84024ae72c,
  isBaseForm: $747425b437e121da$export$a11bdcffe109e74b,
  isMark: $747425b437e121da$export$e33ad6871e762338
};

// node_modules/fontkit/dist/browser-module.mjs
var import_unicode_trie2 = __toESM(require_unicode_trie(), 1);
var import_dfa = __toESM(require_dfa(), 1);
var import_clone = __toESM(require_clone(), 1);
var import_tiny_inflate = __toESM(require_tiny_inflate(), 1);
var import_decompress = __toESM(require_decompress(), 1);
function $parcel$export(e3, n4, v2, s2) {
  Object.defineProperty(e3, n4, { get: v2, set: s2, enumerable: true, configurable: true });
}
function $parcel$interopDefault2(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $d636bc798e7178db$exports = {};
$parcel$export($d636bc798e7178db$exports, "logErrors", () => $d636bc798e7178db$export$bd5c5d8b8dcafd78);
$parcel$export($d636bc798e7178db$exports, "registerFormat", () => $d636bc798e7178db$export$36b2f24e97d43be);
$parcel$export($d636bc798e7178db$exports, "create", () => $d636bc798e7178db$export$185802fd694ee1f5);
$parcel$export($d636bc798e7178db$exports, "defaultLanguage", () => $d636bc798e7178db$export$42940898df819940);
$parcel$export($d636bc798e7178db$exports, "setDefaultLanguage", () => $d636bc798e7178db$export$5157e7780d44cc36);
var $d636bc798e7178db$export$bd5c5d8b8dcafd78 = false;
var $d636bc798e7178db$var$formats = [];
function $d636bc798e7178db$export$36b2f24e97d43be(format3) {
  $d636bc798e7178db$var$formats.push(format3);
}
function $d636bc798e7178db$export$185802fd694ee1f5(buffer, postscriptName) {
  for (let i3 = 0; i3 < $d636bc798e7178db$var$formats.length; i3++) {
    let format3 = $d636bc798e7178db$var$formats[i3];
    if (format3.probe(buffer)) {
      let font = new format3(new (0, DecodeStream)(buffer));
      if (postscriptName) return font.getFont(postscriptName);
      return font;
    }
  }
  throw new Error("Unknown font format");
}
var $d636bc798e7178db$export$42940898df819940 = "en";
function $d636bc798e7178db$export$5157e7780d44cc36(lang = "en") {
  $d636bc798e7178db$export$42940898df819940 = lang;
}
function $e71565f2ce09cb6b$export$69a3209f1a06c04d(target, key, descriptor) {
  if (descriptor.get) {
    let get15 = descriptor.get;
    descriptor.get = function() {
      let value2 = get15.call(this);
      Object.defineProperty(this, key, {
        value: value2
      });
      return value2;
    };
  } else if (typeof descriptor.value === "function") {
    let fn = descriptor.value;
    return {
      get() {
        let cache2 = /* @__PURE__ */ new Map();
        function memoized(...args) {
          let key2 = args.length > 0 ? args[0] : "value";
          if (cache2.has(key2)) return cache2.get(key2);
          let result = fn.apply(this, args);
          cache2.set(key2, result);
          return result;
        }
        Object.defineProperty(this, key, {
          value: memoized
        });
        return memoized;
      }
    };
  }
}
var $26a62205ad06574e$var$SubHeader = new Struct({
  firstCode: uint16,
  entryCount: uint16,
  idDelta: int16,
  idRangeOffset: uint16
});
var $26a62205ad06574e$var$CmapGroup = new Struct({
  startCharCode: uint32,
  endCharCode: uint32,
  glyphID: uint32
});
var $26a62205ad06574e$var$UnicodeValueRange = new Struct({
  startUnicodeValue: uint24,
  additionalCount: uint8
});
var $26a62205ad06574e$var$UVSMapping = new Struct({
  unicodeValue: uint24,
  glyphID: uint16
});
var $26a62205ad06574e$var$DefaultUVS = new ArrayT($26a62205ad06574e$var$UnicodeValueRange, uint32);
var $26a62205ad06574e$var$NonDefaultUVS = new ArrayT($26a62205ad06574e$var$UVSMapping, uint32);
var $26a62205ad06574e$var$VarSelectorRecord = new Struct({
  varSelector: uint24,
  defaultUVS: new Pointer(uint32, $26a62205ad06574e$var$DefaultUVS, {
    type: "parent"
  }),
  nonDefaultUVS: new Pointer(uint32, $26a62205ad06574e$var$NonDefaultUVS, {
    type: "parent"
  })
});
var $26a62205ad06574e$var$CmapSubtable = new VersionedStruct(uint16, {
  0: {
    length: uint16,
    language: uint16,
    codeMap: new LazyArray(uint8, 256)
  },
  2: {
    length: uint16,
    language: uint16,
    subHeaderKeys: new ArrayT(uint16, 256),
    subHeaderCount: (t3) => Math.max.apply(Math, t3.subHeaderKeys),
    subHeaders: new LazyArray($26a62205ad06574e$var$SubHeader, "subHeaderCount"),
    glyphIndexArray: new LazyArray(uint16, "subHeaderCount")
  },
  4: {
    length: uint16,
    language: uint16,
    segCountX2: uint16,
    segCount: (t3) => t3.segCountX2 >> 1,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    endCode: new LazyArray(uint16, "segCount"),
    reservedPad: new Reserved(uint16),
    startCode: new LazyArray(uint16, "segCount"),
    idDelta: new LazyArray(int16, "segCount"),
    idRangeOffset: new LazyArray(uint16, "segCount"),
    glyphIndexArray: new LazyArray(uint16, (t3) => (t3.length - t3._currentOffset) / 2)
  },
  6: {
    length: uint16,
    language: uint16,
    firstCode: uint16,
    entryCount: uint16,
    glyphIndices: new LazyArray(uint16, "entryCount")
  },
  8: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint16,
    is32: new LazyArray(uint8, 8192),
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  10: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    firstCode: uint32,
    entryCount: uint32,
    glyphIndices: new LazyArray(uint16, "numChars")
  },
  12: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  13: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  14: {
    length: uint32,
    numRecords: uint32,
    varSelectors: new LazyArray($26a62205ad06574e$var$VarSelectorRecord, "numRecords")
  }
});
var $26a62205ad06574e$var$CmapEntry = new Struct({
  platformID: uint16,
  encodingID: uint16,
  table: new Pointer(uint32, $26a62205ad06574e$var$CmapSubtable, {
    type: "parent",
    lazy: true
  })
});
var $26a62205ad06574e$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numSubtables: uint16,
  tables: new ArrayT($26a62205ad06574e$var$CmapEntry, "numSubtables")
});
var $f2612a29f92ac062$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  revision: int32,
  checkSumAdjustment: uint32,
  magicNumber: uint32,
  flags: uint16,
  unitsPerEm: uint16,
  created: new ArrayT(int32, 2),
  modified: new ArrayT(int32, 2),
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  macStyle: new Bitfield(uint16, [
    "bold",
    "italic",
    "underline",
    "outline",
    "shadow",
    "condensed",
    "extended"
  ]),
  lowestRecPPEM: uint16,
  fontDirectionHint: int16,
  indexToLocFormat: int16,
  glyphDataFormat: int16
  // 0 for current format
});
var $2c179dd593583073$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceWidthMax: uint16,
  minLeftSideBearing: int16,
  minRightSideBearing: int16,
  xMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance widths in 'hmtx' table
});
var $bdc9060542264b85$var$HmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
});
var $bdc9060542264b85$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($bdc9060542264b85$var$HmtxEntry, (t3) => t3.parent.hhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t3) => t3.parent.maxp.numGlyphs - t3.parent.hhea.numberOfMetrics)
});
var $dbf51cb3d3fe409d$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  numGlyphs: uint16,
  maxPoints: uint16,
  maxContours: uint16,
  maxComponentPoints: uint16,
  maxComponentContours: uint16,
  maxZones: uint16,
  maxTwilightPoints: uint16,
  maxStorage: uint16,
  maxFunctionDefs: uint16,
  maxInstructionDefs: uint16,
  maxStackElements: uint16,
  maxSizeOfInstructions: uint16,
  maxComponentElements: uint16,
  maxComponentDepth: uint16
  // Maximum levels of recursion; 1 for simple components
});
function $e449ad78d50845fe$export$badc544e0651b6b1(platformID, encodingID, languageID = 0) {
  if (platformID === 1 && $e449ad78d50845fe$export$479e671907f486d1[languageID]) return $e449ad78d50845fe$export$479e671907f486d1[languageID];
  return $e449ad78d50845fe$export$6fef87b7618bdf0b[platformID][encodingID];
}
var $e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS = /* @__PURE__ */ new Set([
  "x-mac-roman",
  "x-mac-cyrillic",
  "iso-8859-6",
  "iso-8859-8"
]);
var $e449ad78d50845fe$var$MAC_ENCODINGS = {
  "x-mac-croatian": " ",
  "x-mac-gaelic": " ",
  "x-mac-greek": " ",
  "x-mac-icelandic": " ",
  "x-mac-inuit": " ",
  "x-mac-ce": " ",
  "x-mac-romanian": " ",
  "x-mac-turkish": " "
};
var $e449ad78d50845fe$var$encodingCache = /* @__PURE__ */ new Map();
function $e449ad78d50845fe$export$1dceb3c14ed68bee(encoding) {
  let cached = $e449ad78d50845fe$var$encodingCache.get(encoding);
  if (cached) return cached;
  let mapping = $e449ad78d50845fe$var$MAC_ENCODINGS[encoding];
  if (mapping) {
    let res = /* @__PURE__ */ new Map();
    for (let i3 = 0; i3 < mapping.length; i3++) res.set(mapping.charCodeAt(i3), 128 + i3);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
  if ($e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS.has(encoding)) {
    let decoder2 = new TextDecoder(encoding);
    let mapping2 = new Uint8Array(128);
    for (let i3 = 0; i3 < 128; i3++) mapping2[i3] = 128 + i3;
    let res = /* @__PURE__ */ new Map();
    let s2 = decoder2.decode(mapping2);
    for (let i3 = 0; i3 < 128; i3++) res.set(s2.charCodeAt(i3), 128 + i3);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
}
var $e449ad78d50845fe$export$6fef87b7618bdf0b = [
  // unicode
  [
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be"
  ],
  // macintosh
  // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/
  // 0	Roman                 17	Malayalam
  // 1	Japanese	            18	Sinhalese
  // 2	Traditional Chinese	  19	Burmese
  // 3	Korean	              20	Khmer
  // 4	Arabic	              21	Thai
  // 5	Hebrew	              22	Laotian
  // 6	Greek	                23	Georgian
  // 7	Russian	              24	Armenian
  // 8	RSymbol	              25	Simplified Chinese
  // 9	Devanagari	          26	Tibetan
  // 10	Gurmukhi	            27	Mongolian
  // 11	Gujarati	            28	Geez
  // 12	Oriya	                29	Slavic
  // 13	Bengali	              30	Vietnamese
  // 14	Tamil	                31	Sindhi
  // 15	Telugu	              32	(Uninterpreted)
  // 16	Kannada
  [
    "x-mac-roman",
    "shift-jis",
    "big5",
    "euc-kr",
    "iso-8859-6",
    "iso-8859-8",
    "x-mac-greek",
    "x-mac-cyrillic",
    "x-mac-symbol",
    "x-mac-devanagari",
    "x-mac-gurmukhi",
    "x-mac-gujarati",
    "Oriya",
    "Bengali",
    "Tamil",
    "Telugu",
    "Kannada",
    "Malayalam",
    "Sinhalese",
    "Burmese",
    "Khmer",
    "iso-8859-11",
    "Laotian",
    "Georgian",
    "Armenian",
    "gbk",
    "Tibetan",
    "Mongolian",
    "Geez",
    "x-mac-ce",
    "Vietnamese",
    "Sindhi"
  ],
  // ISO (deprecated)
  [
    "ascii",
    null,
    "iso-8859-1"
  ],
  // windows
  // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx
  [
    "symbol",
    "utf-16be",
    "shift-jis",
    "gb18030",
    "big5",
    "euc-kr",
    "johab",
    null,
    null,
    null,
    "utf-16be"
  ]
];
var $e449ad78d50845fe$export$479e671907f486d1 = {
  15: "x-mac-icelandic",
  17: "x-mac-turkish",
  18: "x-mac-croatian",
  24: "x-mac-ce",
  25: "x-mac-ce",
  26: "x-mac-ce",
  27: "x-mac-ce",
  28: "x-mac-ce",
  30: "x-mac-icelandic",
  37: "x-mac-romanian",
  38: "x-mac-ce",
  39: "x-mac-ce",
  40: "x-mac-ce",
  143: "x-mac-inuit",
  146: "x-mac-gaelic"
};
var $e449ad78d50845fe$export$2092376fd002e13 = [
  // unicode
  [],
  {
    0: "en",
    30: "fo",
    60: "ks",
    90: "rw",
    1: "fr",
    31: "fa",
    61: "ku",
    91: "rn",
    2: "de",
    32: "ru",
    62: "sd",
    92: "ny",
    3: "it",
    33: "zh",
    63: "bo",
    93: "mg",
    4: "nl",
    34: "nl-BE",
    64: "ne",
    94: "eo",
    5: "sv",
    35: "ga",
    65: "sa",
    128: "cy",
    6: "es",
    36: "sq",
    66: "mr",
    129: "eu",
    7: "da",
    37: "ro",
    67: "bn",
    130: "ca",
    8: "pt",
    38: "cz",
    68: "as",
    131: "la",
    9: "no",
    39: "sk",
    69: "gu",
    132: "qu",
    10: "he",
    40: "si",
    70: "pa",
    133: "gn",
    11: "ja",
    41: "yi",
    71: "or",
    134: "ay",
    12: "ar",
    42: "sr",
    72: "ml",
    135: "tt",
    13: "fi",
    43: "mk",
    73: "kn",
    136: "ug",
    14: "el",
    44: "bg",
    74: "ta",
    137: "dz",
    15: "is",
    45: "uk",
    75: "te",
    138: "jv",
    16: "mt",
    46: "be",
    76: "si",
    139: "su",
    17: "tr",
    47: "uz",
    77: "my",
    140: "gl",
    18: "hr",
    48: "kk",
    78: "km",
    141: "af",
    19: "zh-Hant",
    49: "az-Cyrl",
    79: "lo",
    142: "br",
    20: "ur",
    50: "az-Arab",
    80: "vi",
    143: "iu",
    21: "hi",
    51: "hy",
    81: "id",
    144: "gd",
    22: "th",
    52: "ka",
    82: "tl",
    145: "gv",
    23: "ko",
    53: "mo",
    83: "ms",
    146: "ga",
    24: "lt",
    54: "ky",
    84: "ms-Arab",
    147: "to",
    25: "pl",
    55: "tg",
    85: "am",
    148: "el-polyton",
    26: "hu",
    56: "tk",
    86: "ti",
    149: "kl",
    27: "es",
    57: "mn-CN",
    87: "om",
    150: "az",
    28: "lv",
    58: "mn",
    88: "so",
    151: "nn",
    29: "se",
    59: "ps",
    89: "sw"
  },
  // ISO (deprecated)
  [],
  {
    1078: "af",
    16393: "en-IN",
    1159: "rw",
    1074: "tn",
    1052: "sq",
    6153: "en-IE",
    1089: "sw",
    1115: "si",
    1156: "gsw",
    8201: "en-JM",
    1111: "kok",
    1051: "sk",
    1118: "am",
    17417: "en-MY",
    1042: "ko",
    1060: "sl",
    5121: "ar-DZ",
    5129: "en-NZ",
    1088: "ky",
    11274: "es-AR",
    15361: "ar-BH",
    13321: "en-PH",
    1108: "lo",
    16394: "es-BO",
    3073: "ar",
    18441: "en-SG",
    1062: "lv",
    13322: "es-CL",
    2049: "ar-IQ",
    7177: "en-ZA",
    1063: "lt",
    9226: "es-CO",
    11265: "ar-JO",
    11273: "en-TT",
    2094: "dsb",
    5130: "es-CR",
    13313: "ar-KW",
    2057: "en-GB",
    1134: "lb",
    7178: "es-DO",
    12289: "ar-LB",
    1033: "en",
    1071: "mk",
    12298: "es-EC",
    4097: "ar-LY",
    12297: "en-ZW",
    2110: "ms-BN",
    17418: "es-SV",
    6145: "ary",
    1061: "et",
    1086: "ms",
    4106: "es-GT",
    8193: "ar-OM",
    1080: "fo",
    1100: "ml",
    18442: "es-HN",
    16385: "ar-QA",
    1124: "fil",
    1082: "mt",
    2058: "es-MX",
    1025: "ar-SA",
    1035: "fi",
    1153: "mi",
    19466: "es-NI",
    10241: "ar-SY",
    2060: "fr-BE",
    1146: "arn",
    6154: "es-PA",
    7169: "aeb",
    3084: "fr-CA",
    1102: "mr",
    15370: "es-PY",
    14337: "ar-AE",
    1036: "fr",
    1148: "moh",
    10250: "es-PE",
    9217: "ar-YE",
    5132: "fr-LU",
    1104: "mn",
    20490: "es-PR",
    1067: "hy",
    6156: "fr-MC",
    2128: "mn-CN",
    3082: "es",
    1101: "as",
    4108: "fr-CH",
    1121: "ne",
    1034: "es",
    2092: "az-Cyrl",
    1122: "fy",
    1044: "nb",
    21514: "es-US",
    1068: "az",
    1110: "gl",
    2068: "nn",
    14346: "es-UY",
    1133: "ba",
    1079: "ka",
    1154: "oc",
    8202: "es-VE",
    1069: "eu",
    3079: "de-AT",
    1096: "or",
    2077: "sv-FI",
    1059: "be",
    1031: "de",
    1123: "ps",
    1053: "sv",
    2117: "bn",
    5127: "de-LI",
    1045: "pl",
    1114: "syr",
    1093: "bn-IN",
    4103: "de-LU",
    1046: "pt",
    1064: "tg",
    8218: "bs-Cyrl",
    2055: "de-CH",
    2070: "pt-PT",
    2143: "tzm",
    5146: "bs",
    1032: "el",
    1094: "pa",
    1097: "ta",
    1150: "br",
    1135: "kl",
    1131: "qu-BO",
    1092: "tt",
    1026: "bg",
    1095: "gu",
    2155: "qu-EC",
    1098: "te",
    1027: "ca",
    1128: "ha",
    3179: "qu",
    1054: "th",
    3076: "zh-HK",
    1037: "he",
    1048: "ro",
    1105: "bo",
    5124: "zh-MO",
    1081: "hi",
    1047: "rm",
    1055: "tr",
    2052: "zh",
    1038: "hu",
    1049: "ru",
    1090: "tk",
    4100: "zh-SG",
    1039: "is",
    9275: "smn",
    1152: "ug",
    1028: "zh-TW",
    1136: "ig",
    4155: "smj-NO",
    1058: "uk",
    1155: "co",
    1057: "id",
    5179: "smj",
    1070: "hsb",
    1050: "hr",
    1117: "iu",
    3131: "se-FI",
    1056: "ur",
    4122: "hr-BA",
    2141: "iu-Latn",
    1083: "se",
    2115: "uz-Cyrl",
    1029: "cs",
    2108: "ga",
    2107: "se-SE",
    1091: "uz",
    1030: "da",
    1076: "xh",
    8251: "sms",
    1066: "vi",
    1164: "prs",
    1077: "zu",
    6203: "sma-NO",
    1106: "cy",
    1125: "dv",
    1040: "it",
    7227: "sms",
    1160: "wo",
    2067: "nl-BE",
    2064: "it-CH",
    1103: "sa",
    1157: "sah",
    1043: "nl",
    1041: "ja",
    7194: "sr-Cyrl-BA",
    1144: "ii",
    3081: "en-AU",
    1099: "kn",
    3098: "sr",
    1130: "yo",
    10249: "en-BZ",
    1087: "kk",
    6170: "sr-Latn-BA",
    4105: "en-CA",
    1107: "km",
    2074: "sr-Latn",
    9225: "en-029",
    1158: "quc",
    1132: "nso"
  }
];
var $2bcf221753ec8e32$var$NameRecord = new Struct({
  platformID: uint16,
  encodingID: uint16,
  languageID: uint16,
  nameID: uint16,
  length: uint16,
  string: new Pointer(uint16, new StringT("length", (t3) => (0, $e449ad78d50845fe$export$badc544e0651b6b1)(t3.platformID, t3.encodingID, t3.languageID)), {
    type: "parent",
    relativeTo: (ctx) => ctx.parent.stringOffset,
    allowNull: false
  })
});
var $2bcf221753ec8e32$var$LangTagRecord = new Struct({
  length: uint16,
  tag: new Pointer(uint16, new StringT("length", "utf16be"), {
    type: "parent",
    relativeTo: (ctx) => ctx.stringOffset
  })
});
var $2bcf221753ec8e32$var$NameTable = new VersionedStruct(uint16, {
  0: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count")
  },
  1: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count"),
    langTagCount: uint16,
    langTags: new ArrayT($2bcf221753ec8e32$var$LangTagRecord, "langTagCount")
  }
});
var $2bcf221753ec8e32$export$2e2bcd8739ae039 = $2bcf221753ec8e32$var$NameTable;
var $2bcf221753ec8e32$var$NAMES = [
  "copyright",
  "fontFamily",
  "fontSubfamily",
  "uniqueSubfamily",
  "fullName",
  "version",
  "postscriptName",
  "trademark",
  "manufacturer",
  "designer",
  "description",
  "vendorURL",
  "designerURL",
  "license",
  "licenseURL",
  null,
  "preferredFamily",
  "preferredSubfamily",
  "compatibleFull",
  "sampleText",
  "postscriptCIDFontName",
  "wwsFamilyName",
  "wwsSubfamilyName"
];
$2bcf221753ec8e32$var$NameTable.process = function(stream2) {
  var records = {};
  for (let record of this.records) {
    let language = (0, $e449ad78d50845fe$export$2092376fd002e13)[record.platformID][record.languageID];
    if (language == null && this.langTags != null && record.languageID >= 32768) language = this.langTags[record.languageID - 32768].tag;
    if (language == null) language = record.platformID + "-" + record.languageID;
    let key = record.nameID >= 256 ? "fontFeatures" : $2bcf221753ec8e32$var$NAMES[record.nameID] || record.nameID;
    if (records[key] == null) records[key] = {};
    let obj = records[key];
    if (record.nameID >= 256) obj = obj[record.nameID] || (obj[record.nameID] = {});
    if (typeof record.string === "string" || typeof obj[language] !== "string") obj[language] = record.string;
  }
  this.records = records;
};
$2bcf221753ec8e32$var$NameTable.preEncode = function() {
  if (Array.isArray(this.records)) return;
  this.version = 0;
  let records = [];
  for (let key in this.records) {
    let val = this.records[key];
    if (key === "fontFeatures") continue;
    records.push({
      platformID: 3,
      encodingID: 1,
      languageID: 1033,
      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
      length: val.en.length * 2,
      string: val.en
    });
    if (key === "postscriptName") records.push({
      platformID: 1,
      encodingID: 0,
      languageID: 0,
      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
      length: val.en.length,
      string: val.en
    });
  }
  this.records = records;
  this.count = records.length;
  this.stringOffset = $2bcf221753ec8e32$var$NameTable.size(this, null, false);
};
var $84b272aa31b70606$var$OS2 = new VersionedStruct(uint16, {
  header: {
    xAvgCharWidth: int16,
    usWeightClass: uint16,
    usWidthClass: uint16,
    fsType: new Bitfield(uint16, [
      null,
      "noEmbedding",
      "viewOnly",
      "editable",
      null,
      null,
      null,
      null,
      "noSubsetting",
      "bitmapOnly"
    ]),
    ySubscriptXSize: int16,
    ySubscriptYSize: int16,
    ySubscriptXOffset: int16,
    ySubscriptYOffset: int16,
    ySuperscriptXSize: int16,
    ySuperscriptYSize: int16,
    ySuperscriptXOffset: int16,
    ySuperscriptYOffset: int16,
    yStrikeoutSize: int16,
    yStrikeoutPosition: int16,
    sFamilyClass: int16,
    panose: new ArrayT(uint8, 10),
    ulCharRange: new ArrayT(uint32, 4),
    vendorID: new StringT(4),
    fsSelection: new Bitfield(uint16, [
      "italic",
      "underscore",
      "negative",
      "outlined",
      "strikeout",
      "bold",
      "regular",
      "useTypoMetrics",
      "wws",
      "oblique"
    ]),
    usFirstCharIndex: uint16,
    usLastCharIndex: uint16
    // The maximum Unicode index in this font
  },
  // The Apple version of this table ends here, but the Microsoft one continues on...
  0: {},
  1: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2)
  },
  2: {
    // these should be common with version 1 somehow
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16
  },
  5: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16,
    usLowerOpticalPointSize: uint16,
    usUpperOpticalPointSize: uint16
  }
});
var $84b272aa31b70606$var$versions = $84b272aa31b70606$var$OS2.versions;
$84b272aa31b70606$var$versions[3] = $84b272aa31b70606$var$versions[4] = $84b272aa31b70606$var$versions[2];
var $84b272aa31b70606$export$2e2bcd8739ae039 = $84b272aa31b70606$var$OS2;
var $32d9e2eb9565d93c$export$2e2bcd8739ae039 = new VersionedStruct(fixed32, {
  header: {
    italicAngle: fixed32,
    underlinePosition: int16,
    underlineThickness: int16,
    isFixedPitch: uint32,
    minMemType42: uint32,
    maxMemType42: uint32,
    minMemType1: uint32,
    maxMemType1: uint32
    // Maximum memory usage when a TrueType font is downloaded as a Type 1 font
  },
  1: {},
  2: {
    numberOfGlyphs: uint16,
    glyphNameIndex: new ArrayT(uint16, "numberOfGlyphs"),
    names: new ArrayT(new StringT(uint8))
  },
  2.5: {
    numberOfGlyphs: uint16,
    offsets: new ArrayT(uint8, "numberOfGlyphs")
  },
  3: {},
  4: {
    map: new ArrayT(uint32, (t3) => t3.parent.maxp.numGlyphs)
  }
});
var $5202bd9d9ad8eaac$export$2e2bcd8739ae039 = new Struct({
  controlValues: new ArrayT(int16)
});
var $5c0f37ca5ffb1850$export$2e2bcd8739ae039 = new Struct({
  instructions: new ArrayT(uint8)
});
var $2b2b260902b1c57e$var$loca = new VersionedStruct("head.indexToLocFormat", {
  0: {
    offsets: new ArrayT(uint16)
  },
  1: {
    offsets: new ArrayT(uint32)
  }
});
$2b2b260902b1c57e$var$loca.process = function() {
  if (this.version === 0 && !this._processed) {
    for (let i3 = 0; i3 < this.offsets.length; i3++) this.offsets[i3] <<= 1;
    this._processed = true;
  }
};
$2b2b260902b1c57e$var$loca.preEncode = function() {
  if (this.version === 0 && this._processed !== false) {
    for (let i3 = 0; i3 < this.offsets.length; i3++) this.offsets[i3] >>>= 1;
    this._processed = false;
  }
};
var $2b2b260902b1c57e$export$2e2bcd8739ae039 = $2b2b260902b1c57e$var$loca;
var $7afb878c7bea4f66$export$2e2bcd8739ae039 = new Struct({
  controlValueProgram: new ArrayT(uint8)
});
var $6c92b6371bce8bd9$export$2e2bcd8739ae039 = new ArrayT(new BufferT());
var $43e9821ef3717eec$export$2e2bcd8739ae039 = class {
  getCFFVersion(ctx) {
    while (ctx && !ctx.hdrSize) ctx = ctx.parent;
    return ctx ? ctx.version : -1;
  }
  decode(stream2, parent) {
    let version4 = this.getCFFVersion(parent);
    let count = version4 >= 2 ? stream2.readUInt32BE() : stream2.readUInt16BE();
    if (count === 0) return [];
    let offSize = stream2.readUInt8();
    let offsetType;
    if (offSize === 1) offsetType = uint8;
    else if (offSize === 2) offsetType = uint16;
    else if (offSize === 3) offsetType = uint24;
    else if (offSize === 4) offsetType = uint32;
    else throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream2.pos}`);
    let ret = [];
    let startPos = stream2.pos + (count + 1) * offSize - 1;
    let start2 = offsetType.decode(stream2);
    for (let i3 = 0; i3 < count; i3++) {
      let end2 = offsetType.decode(stream2);
      if (this.type != null) {
        let pos = stream2.pos;
        stream2.pos = startPos + start2;
        parent.length = end2 - start2;
        ret.push(this.type.decode(stream2, parent));
        stream2.pos = pos;
      } else ret.push({
        offset: startPos + start2,
        length: end2 - start2
      });
      start2 = end2;
    }
    stream2.pos = startPos + start2;
    return ret;
  }
  size(arr, parent) {
    let size = 2;
    if (arr.length === 0) return size;
    let type = this.type || new BufferT();
    let offset2 = 1;
    for (let i3 = 0; i3 < arr.length; i3++) {
      let item = arr[i3];
      offset2 += type.size(item, parent);
    }
    let offsetType;
    if (offset2 <= 255) offsetType = uint8;
    else if (offset2 <= 65535) offsetType = uint16;
    else if (offset2 <= 16777215) offsetType = uint24;
    else if (offset2 <= 4294967295) offsetType = uint32;
    else throw new Error("Bad offset in CFFIndex");
    size += 1 + offsetType.size() * (arr.length + 1);
    size += offset2 - 1;
    return size;
  }
  encode(stream2, arr, parent) {
    stream2.writeUInt16BE(arr.length);
    if (arr.length === 0) return;
    let type = this.type || new BufferT();
    let sizes = [];
    let offset2 = 1;
    for (let item of arr) {
      let s2 = type.size(item, parent);
      sizes.push(s2);
      offset2 += s2;
    }
    let offsetType;
    if (offset2 <= 255) offsetType = uint8;
    else if (offset2 <= 65535) offsetType = uint16;
    else if (offset2 <= 16777215) offsetType = uint24;
    else if (offset2 <= 4294967295) offsetType = uint32;
    else throw new Error("Bad offset in CFFIndex");
    stream2.writeUInt8(offsetType.size());
    offset2 = 1;
    offsetType.encode(stream2, offset2);
    for (let size of sizes) {
      offset2 += size;
      offsetType.encode(stream2, offset2);
    }
    for (let item of arr) type.encode(stream2, item, parent);
    return;
  }
  constructor(type) {
    this.type = type;
  }
};
var $c2d28e92708f99da$var$FLOAT_EOF = 15;
var $c2d28e92708f99da$var$FLOAT_LOOKUP = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  ".",
  "E",
  "E-",
  null,
  "-"
];
var $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP = {
  ".": 10,
  "E": 11,
  "E-": 12,
  "-": 14
};
var $c2d28e92708f99da$export$2e2bcd8739ae039 = class {
  static decode(stream2, value2) {
    if (32 <= value2 && value2 <= 246) return value2 - 139;
    if (247 <= value2 && value2 <= 250) return (value2 - 247) * 256 + stream2.readUInt8() + 108;
    if (251 <= value2 && value2 <= 254) return -(value2 - 251) * 256 - stream2.readUInt8() - 108;
    if (value2 === 28) return stream2.readInt16BE();
    if (value2 === 29) return stream2.readInt32BE();
    if (value2 === 30) {
      let str = "";
      while (true) {
        let b2 = stream2.readUInt8();
        let n1 = b2 >> 4;
        if (n1 === $c2d28e92708f99da$var$FLOAT_EOF) break;
        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n1];
        let n22 = b2 & 15;
        if (n22 === $c2d28e92708f99da$var$FLOAT_EOF) break;
        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n22];
      }
      return parseFloat(str);
    }
    return null;
  }
  static size(value2) {
    if (value2.forceLarge) value2 = 32768;
    if ((value2 | 0) !== value2) {
      let str = "" + value2;
      return 1 + Math.ceil((str.length + 1) / 2);
    } else if (-107 <= value2 && value2 <= 107) return 1;
    else if (108 <= value2 && value2 <= 1131 || -1131 <= value2 && value2 <= -108) return 2;
    else if (-32768 <= value2 && value2 <= 32767) return 3;
    else return 5;
  }
  static encode(stream2, value2) {
    let val = Number(value2);
    if (value2.forceLarge) {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    } else if ((val | 0) !== val) {
      stream2.writeUInt8(30);
      let str = "" + val;
      for (let i3 = 0; i3 < str.length; i3 += 2) {
        let c1 = str[i3];
        let n1 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c1] || +c1;
        if (i3 === str.length - 1) var n22 = $c2d28e92708f99da$var$FLOAT_EOF;
        else {
          let c22 = str[i3 + 1];
          var n22 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c22] || +c22;
        }
        stream2.writeUInt8(n1 << 4 | n22 & 15);
      }
      if (n22 !== $c2d28e92708f99da$var$FLOAT_EOF) return stream2.writeUInt8($c2d28e92708f99da$var$FLOAT_EOF << 4);
    } else if (-107 <= val && val <= 107) return stream2.writeUInt8(val + 139);
    else if (108 <= val && val <= 1131) {
      val -= 108;
      stream2.writeUInt8((val >> 8) + 247);
      return stream2.writeUInt8(val & 255);
    } else if (-1131 <= val && val <= -108) {
      val = -val - 108;
      stream2.writeUInt8((val >> 8) + 251);
      return stream2.writeUInt8(val & 255);
    } else if (-32768 <= val && val <= 32767) {
      stream2.writeUInt8(28);
      return stream2.writeInt16BE(val);
    } else {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    }
  }
};
var $61aa549f16d58b9b$export$2e2bcd8739ae039 = class {
  decodeOperands(type, stream2, ret, operands) {
    if (Array.isArray(type)) return operands.map((op, i3) => this.decodeOperands(type[i3], stream2, ret, [
      op
    ]));
    else if (type.decode != null) return type.decode(stream2, ret, operands);
    else switch (type) {
      case "number":
      case "offset":
      case "sid":
        return operands[0];
      case "boolean":
        return !!operands[0];
      default:
        return operands;
    }
  }
  encodeOperands(type, stream2, ctx, operands) {
    if (Array.isArray(type)) return operands.map((op, i3) => this.encodeOperands(type[i3], stream2, ctx, op)[0]);
    else if (type.encode != null) return type.encode(stream2, operands, ctx);
    else if (typeof operands === "number") return [
      operands
    ];
    else if (typeof operands === "boolean") return [
      +operands
    ];
    else if (Array.isArray(operands)) return operands;
    else return [
      operands
    ];
  }
  decode(stream2, parent) {
    let end2 = stream2.pos + parent.length;
    let ret = {};
    let operands = [];
    Object.defineProperties(ret, {
      parent: {
        value: parent
      },
      _startOffset: {
        value: stream2.pos
      }
    });
    for (let key in this.fields) {
      let field = this.fields[key];
      ret[field[1]] = field[3];
    }
    while (stream2.pos < end2) {
      let b2 = stream2.readUInt8();
      if (b2 < 28) {
        if (b2 === 12) b2 = b2 << 8 | stream2.readUInt8();
        let field = this.fields[b2];
        if (!field) throw new Error(`Unknown operator ${b2}`);
        let val = this.decodeOperands(field[2], stream2, ret, operands);
        if (val != null) {
          if (val instanceof (0, PropertyDescriptor)) Object.defineProperty(ret, field[1], val);
          else ret[field[1]] = val;
        }
        operands = [];
      } else operands.push((0, $c2d28e92708f99da$export$2e2bcd8739ae039).decode(stream2, b2));
    }
    return ret;
  }
  size(dict, parent, includePointers = true) {
    let ctx = {
      parent,
      val: dict,
      pointerSize: 0,
      startOffset: parent.startOffset || 0
    };
    let len = 0;
    for (let k2 in this.fields) {
      let field = this.fields[k2];
      let val = dict[field[1]];
      if (val == null || (0, import_fast_deep_equal.default)(val, field[3])) continue;
      let operands = this.encodeOperands(field[2], null, ctx, val);
      for (let op of operands) len += (0, $c2d28e92708f99da$export$2e2bcd8739ae039).size(op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      len += key.length;
    }
    if (includePointers) len += ctx.pointerSize;
    return len;
  }
  encode(stream2, dict, parent) {
    let ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val: dict,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(dict, ctx, false);
    for (let field of this.ops) {
      let val = dict[field[1]];
      if (val == null || (0, import_fast_deep_equal.default)(val, field[3])) continue;
      let operands = this.encodeOperands(field[2], stream2, ctx, val);
      for (let op of operands) (0, $c2d28e92708f99da$export$2e2bcd8739ae039).encode(stream2, op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      for (let op of key) stream2.writeUInt8(op);
    }
    let i3 = 0;
    while (i3 < ctx.pointers.length) {
      let ptr = ctx.pointers[i3++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
    return;
  }
  constructor(ops = []) {
    this.ops = ops;
    this.fields = {};
    for (let field of ops) {
      let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
      this.fields[key] = field;
    }
  }
};
var $0e34a43d05bde82c$export$2e2bcd8739ae039 = class extends Pointer {
  decode(stream2, parent, operands) {
    this.offsetType = {
      decode: () => operands[0]
    };
    return super.decode(stream2, parent, operands);
  }
  encode(stream2, value2, ctx) {
    if (!stream2) {
      this.offsetType = {
        size: () => 0
      };
      this.size(value2, ctx);
      return [
        new $0e34a43d05bde82c$var$Ptr(0)
      ];
    }
    let ptr = null;
    this.offsetType = {
      encode: (stream3, val) => ptr = val
    };
    super.encode(stream2, value2, ctx);
    return [
      new $0e34a43d05bde82c$var$Ptr(ptr)
    ];
  }
  constructor(type, options = {}) {
    if (options.type == null) options.type = "global";
    super(null, type, options);
  }
};
var $0e34a43d05bde82c$var$Ptr = class {
  valueOf() {
    return this.val;
  }
  constructor(val) {
    this.val = val;
    this.forceLarge = true;
  }
};
var $6d59db2e29cc77b3$var$CFFBlendOp = class {
  static decode(stream2, parent, operands) {
    let numBlends = operands.pop();
    while (operands.length > numBlends) operands.pop();
  }
};
var $6d59db2e29cc77b3$export$2e2bcd8739ae039 = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                    type                                          default
  [
    6,
    "BlueValues",
    "delta",
    null
  ],
  [
    7,
    "OtherBlues",
    "delta",
    null
  ],
  [
    8,
    "FamilyBlues",
    "delta",
    null
  ],
  [
    9,
    "FamilyOtherBlues",
    "delta",
    null
  ],
  [
    [
      12,
      9
    ],
    "BlueScale",
    "number",
    0.039625
  ],
  [
    [
      12,
      10
    ],
    "BlueShift",
    "number",
    7
  ],
  [
    [
      12,
      11
    ],
    "BlueFuzz",
    "number",
    1
  ],
  [
    10,
    "StdHW",
    "number",
    null
  ],
  [
    11,
    "StdVW",
    "number",
    null
  ],
  [
    [
      12,
      12
    ],
    "StemSnapH",
    "delta",
    null
  ],
  [
    [
      12,
      13
    ],
    "StemSnapV",
    "delta",
    null
  ],
  [
    [
      12,
      14
    ],
    "ForceBold",
    "boolean",
    false
  ],
  [
    [
      12,
      17
    ],
    "LanguageGroup",
    "number",
    0
  ],
  [
    [
      12,
      18
    ],
    "ExpansionFactor",
    "number",
    0.06
  ],
  [
    [
      12,
      19
    ],
    "initialRandomSeed",
    "number",
    0
  ],
  [
    20,
    "defaultWidthX",
    "number",
    0
  ],
  [
    21,
    "nominalWidthX",
    "number",
    0
  ],
  [
    22,
    "vsindex",
    "number",
    0
  ],
  [
    23,
    "blend",
    $6d59db2e29cc77b3$var$CFFBlendOp,
    null
  ],
  [
    19,
    "Subrs",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(), {
      type: "local"
    }),
    null
  ]
]);
var $229224aec43783c5$export$2e2bcd8739ae039 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall",
  "001.000",
  "001.001",
  "001.002",
  "001.003",
  "Black",
  "Bold",
  "Book",
  "Light",
  "Medium",
  "Regular",
  "Roman",
  "Semibold"
];
var $bc0433d9b7e41f5f$export$dee0027060fa13bd = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "",
  "questiondown",
  "",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "",
  "ring",
  "cedilla",
  "",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "AE",
  "",
  "ordfeminine",
  "",
  "",
  "",
  "",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "",
  "",
  "",
  "",
  "",
  "ae",
  "",
  "",
  "",
  "dotlessi",
  "",
  "",
  "lslash",
  "oslash",
  "oe",
  "germandbls"
];
var $bc0433d9b7e41f5f$export$4f58f497e14a53c3 = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "",
  "",
  "isuperior",
  "",
  "",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "",
  "",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "",
  "",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "",
  "Dotaccentsmall",
  "",
  "",
  "Macronsmall",
  "",
  "",
  "figuredash",
  "hypheninferior",
  "",
  "",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "",
  "",
  "",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "",
  "",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var $ef658f5c9a1488b2$export$c33b50336c234f16 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron"
];
var $ef658f5c9a1488b2$export$3ed0f9e1fee8d489 = [
  ".notdef",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var $ef658f5c9a1488b2$export$dc28be11139d4120 = [
  ".notdef",
  "space",
  "dollaroldstyle",
  "dollarsuperior",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "hyphensuperior",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "centoldstyle",
  "figuredash",
  "hypheninferior",
  "onequarter",
  "onehalf",
  "threequarters",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior"
];
var $7cbbe4e24ef3cb75$var$LangSysTable = new Struct({
  reserved: new Reserved(uint16),
  reqFeatureIndex: uint16,
  featureCount: uint16,
  featureIndexes: new ArrayT(uint16, "featureCount")
});
var $7cbbe4e24ef3cb75$var$LangSysRecord = new Struct({
  tag: new StringT(4),
  langSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$var$Script = new Struct({
  defaultLangSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable),
  count: uint16,
  langSysRecords: new ArrayT($7cbbe4e24ef3cb75$var$LangSysRecord, "count")
});
var $7cbbe4e24ef3cb75$var$ScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $7cbbe4e24ef3cb75$var$Script, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$export$3e15fc05ce864229 = new ArrayT($7cbbe4e24ef3cb75$var$ScriptRecord, uint16);
var $7cbbe4e24ef3cb75$var$FeatureParams = new Struct({
  version: uint16,
  nameID: uint16
});
var $7cbbe4e24ef3cb75$export$6e91cf7616333d5 = new Struct({
  featureParams: new Pointer(uint16, $7cbbe4e24ef3cb75$var$FeatureParams),
  lookupCount: uint16,
  lookupListIndexes: new ArrayT(uint16, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$FeatureRecord = new Struct({
  tag: new StringT(4),
  feature: new Pointer(uint16, $7cbbe4e24ef3cb75$export$6e91cf7616333d5, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$export$aa18130def4b6cb4 = new ArrayT($7cbbe4e24ef3cb75$var$FeatureRecord, uint16);
var $7cbbe4e24ef3cb75$var$LookupFlags = new Struct({
  markAttachmentType: uint8,
  flags: new Bitfield(uint8, [
    "rightToLeft",
    "ignoreBaseGlyphs",
    "ignoreLigatures",
    "ignoreMarks",
    "useMarkFilteringSet"
  ])
});
function $7cbbe4e24ef3cb75$export$df0008c6ff2da22a(SubTable) {
  let Lookup = new Struct({
    lookupType: uint16,
    flags: $7cbbe4e24ef3cb75$var$LookupFlags,
    subTableCount: uint16,
    subTables: new ArrayT(new Pointer(uint16, SubTable), "subTableCount"),
    markFilteringSet: new Optional(uint16, (t3) => t3.flags.flags.useMarkFilteringSet)
  });
  return new LazyArray(new Pointer(uint16, Lookup), uint16);
}
var $7cbbe4e24ef3cb75$var$RangeRecord = new Struct({
  start: uint16,
  end: uint16,
  startCoverageIndex: uint16
});
var $7cbbe4e24ef3cb75$export$17608c3f81a6111 = new VersionedStruct(uint16, {
  1: {
    glyphCount: uint16,
    glyphs: new ArrayT(uint16, "glyphCount")
  },
  2: {
    rangeCount: uint16,
    rangeRecords: new ArrayT($7cbbe4e24ef3cb75$var$RangeRecord, "rangeCount")
  }
});
var $7cbbe4e24ef3cb75$var$ClassRangeRecord = new Struct({
  start: uint16,
  end: uint16,
  class: uint16
});
var $7cbbe4e24ef3cb75$export$843d551fbbafef71 = new VersionedStruct(uint16, {
  1: {
    startGlyph: uint16,
    glyphCount: uint16,
    classValueArray: new ArrayT(uint16, "glyphCount")
  },
  2: {
    classRangeCount: uint16,
    classRangeRecord: new ArrayT($7cbbe4e24ef3cb75$var$ClassRangeRecord, "classRangeCount")
  }
});
var $7cbbe4e24ef3cb75$export$8215d14a63d9fb10 = new Struct({
  a: uint16,
  b: uint16,
  deltaFormat: uint16
});
var $7cbbe4e24ef3cb75$var$LookupRecord = new Struct({
  sequenceIndex: uint16,
  lookupListIndex: uint16
});
var $7cbbe4e24ef3cb75$var$Rule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  input: new ArrayT(uint16, (t3) => t3.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$RuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$Rule), uint16);
var $7cbbe4e24ef3cb75$var$ClassRule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  classes: new ArrayT(uint16, (t3) => t3.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$ClassSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassRule), uint16);
var $7cbbe4e24ef3cb75$export$841858b892ce1f4c = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    ruleSetCount: uint16,
    ruleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$RuleSet), "ruleSetCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    classDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    classSetCnt: uint16,
    classSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassSet), "classSetCnt")
  },
  3: {
    glyphCount: uint16,
    lookupCount: uint16,
    coverages: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "glyphCount"),
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
var $7cbbe4e24ef3cb75$var$ChainRule = new Struct({
  backtrackGlyphCount: uint16,
  backtrack: new ArrayT(uint16, "backtrackGlyphCount"),
  inputGlyphCount: uint16,
  input: new ArrayT(uint16, (t3) => t3.inputGlyphCount - 1),
  lookaheadGlyphCount: uint16,
  lookahead: new ArrayT(uint16, "lookaheadGlyphCount"),
  lookupCount: uint16,
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$ChainRuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRule), uint16);
var $7cbbe4e24ef3cb75$export$5e6d09e6861162f6 = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    chainCount: uint16,
    chainRuleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    backtrackClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    inputClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    lookaheadClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    chainCount: uint16,
    chainClassSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  3: {
    backtrackGlyphCount: uint16,
    backtrackCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "backtrackGlyphCount"),
    inputGlyphCount: uint16,
    inputCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "inputGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "lookaheadGlyphCount"),
    lookupCount: uint16,
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
var $1a47b0c45c1c22fe$var$F2DOT14 = new Fixed(16, "BE", 14);
var $1a47b0c45c1c22fe$var$RegionAxisCoordinates = new Struct({
  startCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  peakCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  endCoord: $1a47b0c45c1c22fe$var$F2DOT14
});
var $1a47b0c45c1c22fe$var$VariationRegionList = new Struct({
  axisCount: uint16,
  regionCount: uint16,
  variationRegions: new ArrayT(new ArrayT($1a47b0c45c1c22fe$var$RegionAxisCoordinates, "axisCount"), "regionCount")
});
var $1a47b0c45c1c22fe$var$DeltaSet = new Struct({
  shortDeltas: new ArrayT(int16, (t3) => t3.parent.shortDeltaCount),
  regionDeltas: new ArrayT(int8, (t3) => t3.parent.regionIndexCount - t3.parent.shortDeltaCount),
  deltas: (t3) => t3.shortDeltas.concat(t3.regionDeltas)
});
var $1a47b0c45c1c22fe$var$ItemVariationData = new Struct({
  itemCount: uint16,
  shortDeltaCount: uint16,
  regionIndexCount: uint16,
  regionIndexes: new ArrayT(uint16, "regionIndexCount"),
  deltaSets: new ArrayT($1a47b0c45c1c22fe$var$DeltaSet, "itemCount")
});
var $1a47b0c45c1c22fe$export$fe1b122a2710f241 = new Struct({
  format: uint16,
  variationRegionList: new Pointer(uint32, $1a47b0c45c1c22fe$var$VariationRegionList),
  variationDataCount: uint16,
  itemVariationData: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ItemVariationData), "variationDataCount")
});
var $1a47b0c45c1c22fe$var$ConditionTable = new VersionedStruct(uint16, {
  1: {
    axisIndex: uint16,
    axisIndex: uint16,
    filterRangeMinValue: $1a47b0c45c1c22fe$var$F2DOT14,
    filterRangeMaxValue: $1a47b0c45c1c22fe$var$F2DOT14
  }
});
var $1a47b0c45c1c22fe$var$ConditionSet = new Struct({
  conditionCount: uint16,
  conditionTable: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionTable), "conditionCount")
});
var $1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord = new Struct({
  featureIndex: uint16,
  alternateFeatureTable: new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$6e91cf7616333d5), {
    type: "parent"
  })
});
var $1a47b0c45c1c22fe$var$FeatureTableSubstitution = new Struct({
  version: fixed32,
  substitutionCount: uint16,
  substitutions: new ArrayT($1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord, "substitutionCount")
});
var $1a47b0c45c1c22fe$var$FeatureVariationRecord = new Struct({
  conditionSet: new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionSet, {
    type: "parent"
  }),
  featureTableSubstitution: new Pointer(uint32, $1a47b0c45c1c22fe$var$FeatureTableSubstitution, {
    type: "parent"
  })
});
var $1a47b0c45c1c22fe$export$441b70b7971dd419 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  featureVariationRecordCount: uint32,
  featureVariationRecords: new ArrayT($1a47b0c45c1c22fe$var$FeatureVariationRecord, "featureVariationRecordCount")
});
var $b84fd3dd9d8eddb2$var$PredefinedOp = class {
  decode(stream2, parent, operands) {
    if (this.predefinedOps[operands[0]]) return this.predefinedOps[operands[0]];
    return this.type.decode(stream2, parent, operands);
  }
  size(value2, ctx) {
    return this.type.size(value2, ctx);
  }
  encode(stream2, value2, ctx) {
    let index3 = this.predefinedOps.indexOf(value2);
    if (index3 !== -1) return index3;
    return this.type.encode(stream2, value2, ctx);
  }
  constructor(predefinedOps, type) {
    this.predefinedOps = predefinedOps;
    this.type = type;
  }
};
var $b84fd3dd9d8eddb2$var$CFFEncodingVersion = class extends NumberT {
  decode(stream2) {
    return uint8.decode(stream2) & 127;
  }
  constructor() {
    super("UInt8");
  }
};
var $b84fd3dd9d8eddb2$var$Range1 = new Struct({
  first: uint16,
  nLeft: uint8
});
var $b84fd3dd9d8eddb2$var$Range2 = new Struct({
  first: uint16,
  nLeft: uint16
});
var $b84fd3dd9d8eddb2$var$CFFCustomEncoding = new VersionedStruct(new $b84fd3dd9d8eddb2$var$CFFEncodingVersion(), {
  0: {
    nCodes: uint8,
    codes: new ArrayT(uint8, "nCodes")
  },
  1: {
    nRanges: uint8,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$Range1, "nRanges")
  }
});
var $b84fd3dd9d8eddb2$var$CFFEncoding = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd),
  (0, $bc0433d9b7e41f5f$export$4f58f497e14a53c3)
], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomEncoding, {
  lazy: true
}));
var $b84fd3dd9d8eddb2$var$RangeArray = class extends ArrayT {
  decode(stream2, parent) {
    let length2 = (0, resolveLength)(this.length, stream2, parent);
    let count = 0;
    let res = [];
    while (count < length2) {
      let range2 = this.type.decode(stream2, parent);
      range2.offset = count;
      count += range2.nLeft + 1;
      res.push(range2);
    }
    return res;
  }
};
var $b84fd3dd9d8eddb2$var$CFFCustomCharset = new VersionedStruct(uint8, {
  0: {
    glyphs: new ArrayT(uint16, (t3) => t3.parent.CharStrings.length - 1)
  },
  1: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range1, (t3) => t3.parent.CharStrings.length - 1)
  },
  2: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range2, (t3) => t3.parent.CharStrings.length - 1)
  }
});
var $b84fd3dd9d8eddb2$var$CFFCharset = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  (0, $ef658f5c9a1488b2$export$c33b50336c234f16),
  (0, $ef658f5c9a1488b2$export$3ed0f9e1fee8d489),
  (0, $ef658f5c9a1488b2$export$dc28be11139d4120)
], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomCharset, {
  lazy: true
}));
var $b84fd3dd9d8eddb2$var$FDRange3 = new Struct({
  first: uint16,
  fd: uint8
});
var $b84fd3dd9d8eddb2$var$FDRange4 = new Struct({
  first: uint32,
  fd: uint16
});
var $b84fd3dd9d8eddb2$var$FDSelect = new VersionedStruct(uint8, {
  0: {
    fds: new ArrayT(uint8, (t3) => t3.parent.CharStrings.length)
  },
  3: {
    nRanges: uint16,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange3, "nRanges"),
    sentinel: uint16
  },
  4: {
    nRanges: uint32,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange4, "nRanges"),
    sentinel: uint32
  }
});
var $b84fd3dd9d8eddb2$var$ptr = new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)((0, $6d59db2e29cc77b3$export$2e2bcd8739ae039));
var $b84fd3dd9d8eddb2$var$CFFPrivateOp = class {
  decode(stream2, parent, operands) {
    parent.length = operands[0];
    return $b84fd3dd9d8eddb2$var$ptr.decode(stream2, parent, [
      operands[1]
    ]);
  }
  size(dict, ctx) {
    return [
      (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false),
      $b84fd3dd9d8eddb2$var$ptr.size(dict, ctx)[0]
    ];
  }
  encode(stream2, dict, ctx) {
    return [
      (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false),
      $b84fd3dd9d8eddb2$var$ptr.encode(stream2, dict, ctx)[0]
    ];
  }
};
var $b84fd3dd9d8eddb2$var$FontDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                   type(s)                                 default
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ]
]);
var $b84fd3dd9d8eddb2$var$CFFTopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                   type(s)                                 default
  [
    [
      12,
      30
    ],
    "ROS",
    [
      "sid",
      "sid",
      "number"
    ],
    null
  ],
  [
    0,
    "version",
    "sid",
    null
  ],
  [
    1,
    "Notice",
    "sid",
    null
  ],
  [
    [
      12,
      0
    ],
    "Copyright",
    "sid",
    null
  ],
  [
    2,
    "FullName",
    "sid",
    null
  ],
  [
    3,
    "FamilyName",
    "sid",
    null
  ],
  [
    4,
    "Weight",
    "sid",
    null
  ],
  [
    [
      12,
      1
    ],
    "isFixedPitch",
    "boolean",
    false
  ],
  [
    [
      12,
      2
    ],
    "ItalicAngle",
    "number",
    0
  ],
  [
    [
      12,
      3
    ],
    "UnderlinePosition",
    "number",
    -100
  ],
  [
    [
      12,
      4
    ],
    "UnderlineThickness",
    "number",
    50
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ],
  [
    [
      12,
      6
    ],
    "CharstringType",
    "number",
    2
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    13,
    "UniqueID",
    "number",
    null
  ],
  [
    5,
    "FontBBox",
    "array",
    [
      0,
      0,
      0,
      0
    ]
  ],
  [
    [
      12,
      8
    ],
    "StrokeWidth",
    "number",
    0
  ],
  [
    14,
    "XUID",
    "array",
    null
  ],
  [
    15,
    "charset",
    $b84fd3dd9d8eddb2$var$CFFCharset,
    (0, $ef658f5c9a1488b2$export$c33b50336c234f16)
  ],
  [
    16,
    "Encoding",
    $b84fd3dd9d8eddb2$var$CFFEncoding,
    (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd)
  ],
  [
    17,
    "CharStrings",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
    null
  ],
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      20
    ],
    "SyntheticBase",
    "number",
    null
  ],
  [
    [
      12,
      21
    ],
    "PostScript",
    "sid",
    null
  ],
  [
    [
      12,
      22
    ],
    "BaseFontName",
    "sid",
    null
  ],
  [
    [
      12,
      23
    ],
    "BaseFontBlend",
    "delta",
    null
  ],
  // CID font specific
  [
    [
      12,
      31
    ],
    "CIDFontVersion",
    "number",
    0
  ],
  [
    [
      12,
      32
    ],
    "CIDFontRevision",
    "number",
    0
  ],
  [
    [
      12,
      33
    ],
    "CIDFontType",
    "number",
    0
  ],
  [
    [
      12,
      34
    ],
    "CIDCount",
    "number",
    8720
  ],
  [
    [
      12,
      35
    ],
    "UIDBase",
    "number",
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ]
]);
var $b84fd3dd9d8eddb2$var$VariationStore = new Struct({
  length: uint16,
  itemVariationStore: (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)
});
var $b84fd3dd9d8eddb2$var$CFF2TopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    17,
    "CharStrings",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    24,
    "vstore",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$VariationStore),
    null
  ],
  [
    25,
    "maxstack",
    "number",
    193
  ]
]);
var $b84fd3dd9d8eddb2$var$CFFTop = new VersionedStruct(fixed16, {
  1: {
    hdrSize: uint8,
    offSize: uint8,
    nameIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
    topDictIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFTopDict),
    stringIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
  },
  2: {
    hdrSize: uint8,
    length: uint16,
    topDict: $b84fd3dd9d8eddb2$var$CFF2TopDict,
    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
  }
});
var $b84fd3dd9d8eddb2$export$2e2bcd8739ae039 = $b84fd3dd9d8eddb2$var$CFFTop;
var $822ac0d589e4e237$var$CFFFont = class _$822ac0d589e4e237$var$CFFFont {
  static decode(stream2) {
    return new _$822ac0d589e4e237$var$CFFFont(stream2);
  }
  decode() {
    let start2 = this.stream.pos;
    let top = (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).decode(this.stream);
    for (let key in top) {
      let val = top[key];
      this[key] = val;
    }
    if (this.version < 2) {
      if (this.topDictIndex.length !== 1) throw new Error("Only a single font is allowed in CFF");
      this.topDict = this.topDictIndex[0];
    }
    this.isCIDFont = this.topDict.ROS != null;
    return this;
  }
  string(sid) {
    if (this.version >= 2) return null;
    if (sid < (0, $229224aec43783c5$export$2e2bcd8739ae039).length) return (0, $229224aec43783c5$export$2e2bcd8739ae039)[sid];
    return this.stringIndex[sid - (0, $229224aec43783c5$export$2e2bcd8739ae039).length];
  }
  get postscriptName() {
    if (this.version < 2) return this.nameIndex[0];
    return null;
  }
  get fullName() {
    return this.string(this.topDict.FullName);
  }
  get familyName() {
    return this.string(this.topDict.FamilyName);
  }
  getCharString(glyph) {
    this.stream.pos = this.topDict.CharStrings[glyph].offset;
    return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);
  }
  getGlyphName(gid) {
    if (this.version >= 2) return null;
    if (this.isCIDFont) return null;
    let { charset } = this.topDict;
    if (Array.isArray(charset)) return charset[gid];
    if (gid === 0) return ".notdef";
    gid -= 1;
    switch (charset.version) {
      case 0:
        return this.string(charset.glyphs[gid]);
      case 1:
      case 2:
        for (let i3 = 0; i3 < charset.ranges.length; i3++) {
          let range2 = charset.ranges[i3];
          if (range2.offset <= gid && gid <= range2.offset + range2.nLeft) return this.string(range2.first + (gid - range2.offset));
        }
        break;
    }
    return null;
  }
  fdForGlyph(gid) {
    if (!this.topDict.FDSelect) return null;
    switch (this.topDict.FDSelect.version) {
      case 0:
        return this.topDict.FDSelect.fds[gid];
      case 3:
      case 4:
        let { ranges } = this.topDict.FDSelect;
        let low = 0;
        let high = ranges.length - 1;
        while (low <= high) {
          let mid = low + high >> 1;
          if (gid < ranges[mid].first) high = mid - 1;
          else if (mid < high && gid >= ranges[mid + 1].first) low = mid + 1;
          else return ranges[mid].fd;
        }
      default:
        throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);
    }
  }
  privateDictForGlyph(gid) {
    if (this.topDict.FDSelect) {
      let fd = this.fdForGlyph(gid);
      if (this.topDict.FDArray[fd]) return this.topDict.FDArray[fd].Private;
      return null;
    }
    if (this.version < 2) return this.topDict.Private;
    return this.topDict.FDArray[0].Private;
  }
  constructor(stream2) {
    this.stream = stream2;
    this.decode();
  }
};
var $822ac0d589e4e237$export$2e2bcd8739ae039 = $822ac0d589e4e237$var$CFFFont;
var $2bbf2bc1ce37cd8f$var$VerticalOrigin = new Struct({
  glyphIndex: uint16,
  vertOriginY: int16
});
var $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  defaultVertOriginY: int16,
  numVertOriginYMetrics: uint16,
  metrics: new ArrayT($2bbf2bc1ce37cd8f$var$VerticalOrigin, "numVertOriginYMetrics")
});
var $0941618dc22a946d$export$16b227cb15d716a0 = new Struct({
  height: uint8,
  width: uint8,
  horiBearingX: int8,
  horiBearingY: int8,
  horiAdvance: uint8,
  vertBearingX: int8,
  vertBearingY: int8,
  vertAdvance: uint8
});
var $0941618dc22a946d$export$62c53e75f69bfe12 = new Struct({
  height: uint8,
  width: uint8,
  bearingX: int8,
  bearingY: int8,
  advance: uint8
});
var $0941618dc22a946d$var$EBDTComponent = new Struct({
  glyph: uint16,
  xOffset: int8,
  yOffset: int8
});
var $0941618dc22a946d$var$ByteAligned = class {
};
var $0941618dc22a946d$var$BitAligned = class {
};
var $0941618dc22a946d$export$f1f5ddeb20d14f = new VersionedStruct("version", {
  1: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$ByteAligned
  },
  2: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$BitAligned
  },
  // format 3 is deprecated
  // format 4 is not supported by Microsoft
  5: {
    data: $0941618dc22a946d$var$BitAligned
  },
  6: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$ByteAligned
  },
  7: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$BitAligned
  },
  8: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  9: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  17: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  18: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  19: {
    dataLen: uint32,
    data: new BufferT("dataLen")
  }
});
var $9911c4c7201c13de$var$SBitLineMetrics = new Struct({
  ascender: int8,
  descender: int8,
  widthMax: uint8,
  caretSlopeNumerator: int8,
  caretSlopeDenominator: int8,
  caretOffset: int8,
  minOriginSB: int8,
  minAdvanceSB: int8,
  maxBeforeBL: int8,
  minAfterBL: int8,
  pad: new Reserved(int8, 2)
});
var $9911c4c7201c13de$var$CodeOffsetPair = new Struct({
  glyphCode: uint16,
  offset: uint16
});
var $9911c4c7201c13de$var$IndexSubtable = new VersionedStruct(uint16, {
  header: {
    imageFormat: uint16,
    imageDataOffset: uint32
  },
  1: {
    offsetArray: new ArrayT(uint32, (t3) => t3.parent.lastGlyphIndex - t3.parent.firstGlyphIndex + 1)
  },
  2: {
    imageSize: uint32,
    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0)
  },
  3: {
    offsetArray: new ArrayT(uint16, (t3) => t3.parent.lastGlyphIndex - t3.parent.firstGlyphIndex + 1)
  },
  4: {
    numGlyphs: uint32,
    glyphArray: new ArrayT($9911c4c7201c13de$var$CodeOffsetPair, (t3) => t3.numGlyphs + 1)
  },
  5: {
    imageSize: uint32,
    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0),
    numGlyphs: uint32,
    glyphCodeArray: new ArrayT(uint16, "numGlyphs")
  }
});
var $9911c4c7201c13de$var$IndexSubtableArray = new Struct({
  firstGlyphIndex: uint16,
  lastGlyphIndex: uint16,
  subtable: new Pointer(uint32, $9911c4c7201c13de$var$IndexSubtable)
});
var $9911c4c7201c13de$var$BitmapSizeTable = new Struct({
  indexSubTableArray: new Pointer(uint32, new ArrayT($9911c4c7201c13de$var$IndexSubtableArray, 1), {
    type: "parent"
  }),
  indexTablesSize: uint32,
  numberOfIndexSubTables: uint32,
  colorRef: uint32,
  hori: $9911c4c7201c13de$var$SBitLineMetrics,
  vert: $9911c4c7201c13de$var$SBitLineMetrics,
  startGlyphIndex: uint16,
  endGlyphIndex: uint16,
  ppemX: uint8,
  ppemY: uint8,
  bitDepth: uint8,
  flags: new Bitfield(uint8, [
    "horizontal",
    "vertical"
  ])
});
var $9911c4c7201c13de$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  numSizes: uint32,
  sizes: new ArrayT($9911c4c7201c13de$var$BitmapSizeTable, "numSizes")
});
var $abb847051efd51b1$var$ImageTable = new Struct({
  ppem: uint16,
  resolution: uint16,
  imageOffsets: new ArrayT(new Pointer(uint32, "void"), (t3) => t3.parent.parent.maxp.numGlyphs + 1)
});
var $abb847051efd51b1$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  flags: new Bitfield(uint16, [
    "renderOutlines"
  ]),
  numImgTables: uint32,
  imageTables: new ArrayT(new Pointer(uint32, $abb847051efd51b1$var$ImageTable), "numImgTables")
});
var $eb629188f3dfefdd$var$LayerRecord = new Struct({
  gid: uint16,
  paletteIndex: uint16
  // Index value to use in the appropriate palette. This value must
});
var $eb629188f3dfefdd$var$BaseGlyphRecord = new Struct({
  gid: uint16,
  // and is not rendered for color.
  firstLayerIndex: uint16,
  // There will be numLayers consecutive entries for this base glyph.
  numLayers: uint16
});
var $eb629188f3dfefdd$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numBaseGlyphRecords: uint16,
  baseGlyphRecord: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$BaseGlyphRecord, "numBaseGlyphRecords")),
  layerRecords: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$LayerRecord, "numLayerRecords"), {
    lazy: true
  }),
  numLayerRecords: uint16
});
var $08734b8e7dc64587$var$ColorRecord = new Struct({
  blue: uint8,
  green: uint8,
  red: uint8,
  alpha: uint8
});
var $08734b8e7dc64587$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  header: {
    numPaletteEntries: uint16,
    numPalettes: uint16,
    numColorRecords: uint16,
    colorRecords: new Pointer(uint32, new ArrayT($08734b8e7dc64587$var$ColorRecord, "numColorRecords")),
    colorRecordIndices: new ArrayT(uint16, "numPalettes")
  },
  0: {},
  1: {
    offsetPaletteTypeArray: new Pointer(uint32, new ArrayT(uint32, "numPalettes")),
    offsetPaletteLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPalettes")),
    offsetPaletteEntryLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPaletteEntries"))
  }
});
var $497cef411d884e34$var$BaseCoord = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
    // X or Y value, in design units
  },
  2: {
    coordinate: int16,
    referenceGlyph: uint16,
    baseCoordPoint: uint16
    // Index of contour point on the referenceGlyph
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
    // Device table for X or Y value
  }
});
var $497cef411d884e34$var$BaseValues = new Struct({
  defaultIndex: uint16,
  baseCoordCount: uint16,
  baseCoords: new ArrayT(new Pointer(uint16, $497cef411d884e34$var$BaseCoord), "baseCoordCount")
});
var $497cef411d884e34$var$FeatMinMaxRecord = new Struct({
  tag: new StringT(4),
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  }),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  })
  // May be NULL
});
var $497cef411d884e34$var$MinMax = new Struct({
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  featMinMaxCount: uint16,
  featMinMaxRecords: new ArrayT($497cef411d884e34$var$FeatMinMaxRecord, "featMinMaxCount")
  // In alphabetical order
});
var $497cef411d884e34$var$BaseLangSysRecord = new Struct({
  tag: new StringT(4),
  minMax: new Pointer(uint16, $497cef411d884e34$var$MinMax, {
    type: "parent"
  })
});
var $497cef411d884e34$var$BaseScript = new Struct({
  baseValues: new Pointer(uint16, $497cef411d884e34$var$BaseValues),
  defaultMinMax: new Pointer(uint16, $497cef411d884e34$var$MinMax),
  baseLangSysCount: uint16,
  baseLangSysRecords: new ArrayT($497cef411d884e34$var$BaseLangSysRecord, "baseLangSysCount")
  // in alphabetical order by BaseLangSysTag
});
var $497cef411d884e34$var$BaseScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $497cef411d884e34$var$BaseScript, {
    type: "parent"
  })
});
var $497cef411d884e34$var$BaseScriptList = new ArrayT($497cef411d884e34$var$BaseScriptRecord, uint16);
var $497cef411d884e34$var$BaseTagList = new ArrayT(new StringT(4), uint16);
var $497cef411d884e34$var$Axis = new Struct({
  baseTagList: new Pointer(uint16, $497cef411d884e34$var$BaseTagList),
  baseScriptList: new Pointer(uint16, $497cef411d884e34$var$BaseScriptList)
});
var $497cef411d884e34$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    horizAxis: new Pointer(uint16, $497cef411d884e34$var$Axis),
    vertAxis: new Pointer(uint16, $497cef411d884e34$var$Axis)
    // May be NULL
  },
  65536: {},
  65537: {
    itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
  }
});
var $cf5f33c63ef209e6$var$AttachPoint = new ArrayT(uint16, uint16);
var $cf5f33c63ef209e6$var$AttachList = new Struct({
  coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
  glyphCount: uint16,
  attachPoints: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$AttachPoint), "glyphCount")
});
var $cf5f33c63ef209e6$var$CaretValue = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
  },
  2: {
    caretValuePoint: uint16
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
  }
});
var $cf5f33c63ef209e6$var$LigGlyph = new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$CaretValue), uint16);
var $cf5f33c63ef209e6$var$LigCaretList = new Struct({
  coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
  ligGlyphCount: uint16,
  ligGlyphs: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$LigGlyph), "ligGlyphCount")
});
var $cf5f33c63ef209e6$var$MarkGlyphSetsDef = new Struct({
  markSetTableFormat: uint16,
  markSetCount: uint16,
  coverage: new ArrayT(new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "markSetCount")
});
var $cf5f33c63ef209e6$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    glyphClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
    attachList: new Pointer(uint16, $cf5f33c63ef209e6$var$AttachList),
    ligCaretList: new Pointer(uint16, $cf5f33c63ef209e6$var$LigCaretList),
    markAttachClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71))
  },
  65536: {},
  65538: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef)
  },
  65539: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef),
    itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
  }
});
var $47e0e8ef515d9903$var$ValueFormat = new Bitfield(uint16, [
  "xPlacement",
  "yPlacement",
  "xAdvance",
  "yAdvance",
  "xPlaDevice",
  "yPlaDevice",
  "xAdvDevice",
  "yAdvDevice"
]);
var $47e0e8ef515d9903$var$types = {
  xPlacement: int16,
  yPlacement: int16,
  xAdvance: int16,
  yAdvance: int16,
  xPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  yPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  xAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  yAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  })
};
var $47e0e8ef515d9903$var$ValueRecord = class {
  buildStruct(parent) {
    let struct = parent;
    while (!struct[this.key] && struct.parent) struct = struct.parent;
    if (!struct[this.key]) return;
    let fields = {};
    fields.rel = () => struct._startOffset;
    let format3 = struct[this.key];
    for (let key in format3) if (format3[key]) fields[key] = $47e0e8ef515d9903$var$types[key];
    return new Struct(fields);
  }
  size(val, ctx) {
    return this.buildStruct(ctx).size(val, ctx);
  }
  decode(stream2, parent) {
    let res = this.buildStruct(parent).decode(stream2, parent);
    delete res.rel;
    return res;
  }
  constructor(key = "valueFormat") {
    this.key = key;
  }
};
var $47e0e8ef515d9903$var$PairValueRecord = new Struct({
  secondGlyph: uint16,
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
var $47e0e8ef515d9903$var$PairSet = new ArrayT($47e0e8ef515d9903$var$PairValueRecord, uint16);
var $47e0e8ef515d9903$var$Class2Record = new Struct({
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
var $47e0e8ef515d9903$var$Anchor = new VersionedStruct(uint16, {
  1: {
    xCoordinate: int16,
    yCoordinate: int16
  },
  2: {
    xCoordinate: int16,
    yCoordinate: int16,
    anchorPoint: uint16
  },
  3: {
    xCoordinate: int16,
    yCoordinate: int16,
    xDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10)),
    yDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
  }
});
var $47e0e8ef515d9903$var$EntryExitRecord = new Struct({
  entryAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  }),
  exitAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
var $47e0e8ef515d9903$var$MarkRecord = new Struct({
  class: uint16,
  markAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
var $47e0e8ef515d9903$var$MarkArray = new ArrayT($47e0e8ef515d9903$var$MarkRecord, uint16);
var $47e0e8ef515d9903$var$BaseRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t3) => t3.parent.classCount);
var $47e0e8ef515d9903$var$BaseArray = new ArrayT($47e0e8ef515d9903$var$BaseRecord, uint16);
var $47e0e8ef515d9903$var$ComponentRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t3) => t3.parent.parent.classCount);
var $47e0e8ef515d9903$var$LigatureAttach = new ArrayT($47e0e8ef515d9903$var$ComponentRecord, uint16);
var $47e0e8ef515d9903$var$LigatureArray = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$LigatureAttach), uint16);
var $47e0e8ef515d9903$export$73a8cfb19cd43a0f = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      value: new $47e0e8ef515d9903$var$ValueRecord()
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      valueCount: uint16,
      values: new LazyArray(new $47e0e8ef515d9903$var$ValueRecord(), "valueCount")
    }
  }),
  2: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      pairSetCount: uint16,
      pairSets: new LazyArray(new Pointer(uint16, $47e0e8ef515d9903$var$PairSet), "pairSetCount")
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      classDef1: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
      classDef2: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
      class1Count: uint16,
      class2Count: uint16,
      classRecords: new LazyArray(new LazyArray($47e0e8ef515d9903$var$Class2Record, "class2Count"), "class1Count")
    }
  }),
  3: {
    format: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    entryExitCount: uint16,
    entryExitRecords: new ArrayT($47e0e8ef515d9903$var$EntryExitRecord, "entryExitCount")
  },
  4: {
    format: uint16,
    markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    baseCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    baseArray: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  5: {
    format: uint16,
    markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    ligatureCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    ligatureArray: new Pointer(uint16, $47e0e8ef515d9903$var$LigatureArray)
  },
  6: {
    format: uint16,
    mark1Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    mark2Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    mark1Array: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    mark2Array: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  7: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
  8: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
  9: {
    posFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  }
});
$47e0e8ef515d9903$export$73a8cfb19cd43a0f.versions[9].extension.type = $47e0e8ef515d9903$export$73a8cfb19cd43a0f;
var $47e0e8ef515d9903$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
    featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
    lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($47e0e8ef515d9903$export$73a8cfb19cd43a0f))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
  }
});
var $d3f442064af66e06$var$Sequence = new ArrayT(uint16, uint16);
var $d3f442064af66e06$var$AlternateSet = $d3f442064af66e06$var$Sequence;
var $d3f442064af66e06$var$Ligature = new Struct({
  glyph: uint16,
  compCount: uint16,
  components: new ArrayT(uint16, (t3) => t3.compCount - 1)
});
var $d3f442064af66e06$var$LigatureSet = new ArrayT(new Pointer(uint16, $d3f442064af66e06$var$Ligature), uint16);
var $d3f442064af66e06$var$GSUBLookup = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      deltaGlyphID: int16
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      glyphCount: uint16,
      substitute: new LazyArray(uint16, "glyphCount")
    }
  }),
  2: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    sequences: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$Sequence), "count")
  },
  3: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    alternateSet: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$AlternateSet), "count")
  },
  4: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    ligatureSets: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$LigatureSet), "count")
  },
  5: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
  6: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
  7: {
    substFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  },
  8: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    backtrackCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "backtrackGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "lookaheadGlyphCount"),
    glyphCount: uint16,
    substitutes: new ArrayT(uint16, "glyphCount")
  }
});
$d3f442064af66e06$var$GSUBLookup.versions[7].extension.type = $d3f442064af66e06$var$GSUBLookup;
var $d3f442064af66e06$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
    featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
    lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($d3f442064af66e06$var$GSUBLookup))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
  }
});
var $71cfb3c4767fbd0c$var$JstfGSUBModList = new ArrayT(uint16, uint16);
var $71cfb3c4767fbd0c$var$JstfPriority = new Struct({
  shrinkageEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f))),
  extensionEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f)))
});
var $71cfb3c4767fbd0c$var$JstfLangSys = new ArrayT(new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfPriority), uint16);
var $71cfb3c4767fbd0c$var$JstfLangSysRecord = new Struct({
  tag: new StringT(4),
  jstfLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys)
});
var $71cfb3c4767fbd0c$var$JstfScript = new Struct({
  extenderGlyphs: new Pointer(uint16, new ArrayT(uint16, uint16)),
  defaultLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys),
  langSysCount: uint16,
  langSysRecords: new ArrayT($71cfb3c4767fbd0c$var$JstfLangSysRecord, "langSysCount")
});
var $71cfb3c4767fbd0c$var$JstfScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfScript, {
    type: "parent"
  })
});
var $71cfb3c4767fbd0c$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  scriptCount: uint16,
  scriptList: new ArrayT($71cfb3c4767fbd0c$var$JstfScriptRecord, "scriptCount")
});
var $d059a6bd2d3b5b63$var$VariableSizeNumber = class {
  decode(stream2, parent) {
    switch (this.size(0, parent)) {
      case 1:
        return stream2.readUInt8();
      case 2:
        return stream2.readUInt16BE();
      case 3:
        return stream2.readUInt24BE();
      case 4:
        return stream2.readUInt32BE();
    }
  }
  size(val, parent) {
    return (0, resolveLength)(this._size, null, parent);
  }
  constructor(size) {
    this._size = size;
  }
};
var $d059a6bd2d3b5b63$var$MapDataEntry = new Struct({
  entry: new $d059a6bd2d3b5b63$var$VariableSizeNumber((t3) => ((t3.parent.entryFormat & 48) >> 4) + 1),
  outerIndex: (t3) => t3.entry >> (t3.parent.entryFormat & 15) + 1,
  innerIndex: (t3) => t3.entry & (1 << (t3.parent.entryFormat & 15) + 1) - 1
});
var $d059a6bd2d3b5b63$var$DeltaSetIndexMap = new Struct({
  entryFormat: uint16,
  mapCount: uint16,
  mapData: new ArrayT($d059a6bd2d3b5b63$var$MapDataEntry, "mapCount")
});
var $d059a6bd2d3b5b63$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)),
  advanceWidthMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  LSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  RSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap)
});
var $dceeca3e1977ce30$var$Signature = new Struct({
  format: uint32,
  length: uint32,
  offset: uint32
});
var $dceeca3e1977ce30$var$SignatureBlock = new Struct({
  reserved: new Reserved(uint16, 2),
  cbSignature: uint32,
  signature: new BufferT("cbSignature")
});
var $dceeca3e1977ce30$export$2e2bcd8739ae039 = new Struct({
  ulVersion: uint32,
  usNumSigs: uint16,
  usFlag: uint16,
  signatures: new ArrayT($dceeca3e1977ce30$var$Signature, "usNumSigs"),
  signatureBlocks: new ArrayT($dceeca3e1977ce30$var$SignatureBlock, "usNumSigs")
});
var $8acd740a9435aad0$var$GaspRange = new Struct({
  rangeMaxPPEM: uint16,
  rangeGaspBehavior: new Bitfield(uint16, [
    "grayscale",
    "gridfit",
    "symmetricSmoothing",
    "symmetricGridfit"
    // only in version 1, for ClearType
  ])
});
var $8acd740a9435aad0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRanges: uint16,
  gaspRanges: new ArrayT($8acd740a9435aad0$var$GaspRange, "numRanges")
  // Sorted by ppem
});
var $b5f380243c34d6a0$var$DeviceRecord = new Struct({
  pixelSize: uint8,
  maximumWidth: uint8,
  widths: new ArrayT(uint8, (t3) => t3.parent.parent.maxp.numGlyphs)
});
var $b5f380243c34d6a0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecords: int16,
  sizeDeviceRecord: int32,
  records: new ArrayT($b5f380243c34d6a0$var$DeviceRecord, "numRecords")
});
var $ca2df1256966e313$var$KernPair = new Struct({
  left: uint16,
  right: uint16,
  value: int16
});
var $ca2df1256966e313$var$ClassTable = new Struct({
  firstGlyph: uint16,
  nGlyphs: uint16,
  offsets: new ArrayT(uint16, "nGlyphs"),
  max: (t3) => t3.offsets.length && Math.max.apply(Math, t3.offsets)
});
var $ca2df1256966e313$var$Kern2Array = new Struct({
  off: (t3) => t3._startOffset - t3.parent.parent._startOffset,
  len: (t3) => ((t3.parent.leftTable.max - t3.off) / t3.parent.rowWidth + 1) * (t3.parent.rowWidth / 2),
  values: new LazyArray(int16, "len")
});
var $ca2df1256966e313$var$KernSubtable = new VersionedStruct("format", {
  0: {
    nPairs: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    pairs: new ArrayT($ca2df1256966e313$var$KernPair, "nPairs")
  },
  2: {
    rowWidth: uint16,
    leftTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    rightTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    array: new Pointer(uint16, $ca2df1256966e313$var$Kern2Array, {
      type: "parent"
    })
  },
  3: {
    glyphCount: uint16,
    kernValueCount: uint8,
    leftClassCount: uint8,
    rightClassCount: uint8,
    flags: uint8,
    kernValue: new ArrayT(int16, "kernValueCount"),
    leftClass: new ArrayT(uint8, "glyphCount"),
    rightClass: new ArrayT(uint8, "glyphCount"),
    kernIndex: new ArrayT(uint8, (t3) => t3.leftClassCount * t3.rightClassCount)
  }
});
var $ca2df1256966e313$var$KernTable = new VersionedStruct("version", {
  0: {
    subVersion: uint16,
    length: uint16,
    format: uint8,
    coverage: new Bitfield(uint8, [
      "horizontal",
      "minimum",
      "crossStream",
      "override"
      // If set to 1 the value in this table replaces the accumulated value
    ]),
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t3) => t3.length - t3._currentOffset)
  },
  1: {
    length: uint32,
    coverage: new Bitfield(uint8, [
      null,
      null,
      null,
      null,
      null,
      "variation",
      "crossStream",
      "vertical"
      // Set if table has vertical kerning values
    ]),
    format: uint8,
    tupleIndex: uint16,
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t3) => t3.length - t3._currentOffset)
  }
});
var $ca2df1256966e313$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  0: {
    nTables: uint16,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  },
  1: {
    reserved: new Reserved(uint16),
    nTables: uint32,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  }
});
var $7a9f92b0c46ebe33$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numGlyphs: uint16,
  yPels: new ArrayT(uint8, "numGlyphs")
});
var $2b2ccc419d152631$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  fontNumber: uint32,
  pitch: uint16,
  xHeight: uint16,
  style: uint16,
  typeFamily: uint16,
  capHeight: uint16,
  symbolSet: uint16,
  typeface: new StringT(16),
  characterComplement: new StringT(8),
  fileName: new StringT(6),
  strokeWeight: new StringT(1),
  widthType: new StringT(1),
  serifStyle: uint8,
  reserved: new Reserved(uint8)
});
var $ca5b40b9bcda9c9b$var$Ratio = new Struct({
  bCharSet: uint8,
  xRatio: uint8,
  yStartRatio: uint8,
  yEndRatio: uint8
  // Ending y-Ratio value
});
var $ca5b40b9bcda9c9b$var$vTable = new Struct({
  yPelHeight: uint16,
  yMax: int16,
  yMin: int16
  // Minimum value (in pels) for this yPelHeight
});
var $ca5b40b9bcda9c9b$var$VdmxGroup = new Struct({
  recs: uint16,
  startsz: uint8,
  endsz: uint8,
  entries: new ArrayT($ca5b40b9bcda9c9b$var$vTable, "recs")
  // The VDMX records
});
var $ca5b40b9bcda9c9b$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecs: uint16,
  numRatios: uint16,
  ratioRanges: new ArrayT($ca5b40b9bcda9c9b$var$Ratio, "numRatios"),
  offsets: new ArrayT(uint16, "numRatios"),
  groups: new ArrayT($ca5b40b9bcda9c9b$var$VdmxGroup, "numRecs")
  // The actual VDMX groupings
});
var $69530a3c40755af0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceHeightMax: int16,
  minTopSideBearing: int16,
  minBottomSideBearing: int16,
  yMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance heights in the Vertical Metrics table
});
var $344073dd270f0e62$var$VmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
  // The top sidebearing of the glyph
});
var $344073dd270f0e62$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($344073dd270f0e62$var$VmtxEntry, (t3) => t3.parent.vhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t3) => t3.parent.maxp.numGlyphs - t3.parent.vhea.numberOfMetrics)
});
var $3793b781918cfced$var$shortFrac = new Fixed(16, "BE", 14);
var $3793b781918cfced$var$Correspondence = new Struct({
  fromCoord: $3793b781918cfced$var$shortFrac,
  toCoord: $3793b781918cfced$var$shortFrac
});
var $3793b781918cfced$var$Segment = new Struct({
  pairCount: uint16,
  correspondence: new ArrayT($3793b781918cfced$var$Correspondence, "pairCount")
});
var $3793b781918cfced$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  axisCount: uint32,
  segment: new ArrayT($3793b781918cfced$var$Segment, "axisCount")
});
var $6cb7dd5f47d82580$var$UnboundedArrayAccessor = class {
  getItem(index3) {
    if (this._items[index3] == null) {
      let pos = this.stream.pos;
      this.stream.pos = this.base + this.type.size(null, this.parent) * index3;
      this._items[index3] = this.type.decode(this.stream, this.parent);
      this.stream.pos = pos;
    }
    return this._items[index3];
  }
  inspect() {
    return `[UnboundedArray ${this.type.constructor.name}]`;
  }
  constructor(type, stream2, parent) {
    this.type = type;
    this.stream = stream2;
    this.parent = parent;
    this.base = this.stream.pos;
    this._items = [];
  }
};
var $6cb7dd5f47d82580$export$c5af1eebc882e39a = class extends ArrayT {
  decode(stream2, parent) {
    return new $6cb7dd5f47d82580$var$UnboundedArrayAccessor(this.type, stream2, parent);
  }
  constructor(type) {
    super(type, 0);
  }
};
var $6cb7dd5f47d82580$export$8351f8c2ae2f103c = function(ValueType = uint16) {
  class Shadow {
    decode(stream2, ctx) {
      ctx = ctx.parent.parent;
      return this.type.decode(stream2, ctx);
    }
    size(val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.size(val, ctx);
    }
    encode(stream2, val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.encode(stream2, val, ctx);
    }
    constructor(type) {
      this.type = type;
    }
  }
  ValueType = new Shadow(ValueType);
  let BinarySearchHeader = new Struct({
    unitSize: uint16,
    nUnits: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16
  });
  let LookupSegmentSingle = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    value: ValueType
  });
  let LookupSegmentArray = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    values: new Pointer(uint16, new ArrayT(ValueType, (t3) => t3.lastGlyph - t3.firstGlyph + 1), {
      type: "parent"
    })
  });
  let LookupSingle = new Struct({
    glyph: uint16,
    value: ValueType
  });
  return new VersionedStruct(uint16, {
    0: {
      values: new $6cb7dd5f47d82580$export$c5af1eebc882e39a(ValueType)
      // length == number of glyphs maybe?
    },
    2: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentSingle, (t3) => t3.binarySearchHeader.nUnits)
    },
    4: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentArray, (t3) => t3.binarySearchHeader.nUnits)
    },
    6: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSingle, (t3) => t3.binarySearchHeader.nUnits)
    },
    8: {
      firstGlyph: uint16,
      count: uint16,
      values: new ArrayT(ValueType, "count")
    }
  });
};
function $6cb7dd5f47d82580$export$79f7d93d790934ba(entryData = {}, lookupType = uint16) {
  let entry = Object.assign({
    newState: uint16,
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint16, (t3) => t3.nClasses));
  let StateHeader = new Struct({
    nClasses: uint32,
    classTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$8351f8c2ae2f103c(lookupType)),
    stateArray: new Pointer(uint32, StateArray),
    entryTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader;
}
function $6cb7dd5f47d82580$export$105027425199cc51(entryData = {}, lookupType = uint16) {
  let ClassLookupTable = new Struct({
    version() {
      return 8;
    },
    firstGlyph: uint16,
    values: new ArrayT(uint8, uint16)
  });
  let entry = Object.assign({
    newStateOffset: uint16,
    // convert offset to stateArray index
    newState: (t3) => (t3.newStateOffset - (t3.parent.stateArray.base - t3.parent._startOffset)) / t3.parent.nClasses,
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint8, (t3) => t3.nClasses));
  let StateHeader1 = new Struct({
    nClasses: uint16,
    classTable: new Pointer(uint16, ClassLookupTable),
    stateArray: new Pointer(uint16, StateArray),
    entryTable: new Pointer(uint16, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader1;
}
var $6a3746e8c708f5a3$var$BslnSubtable = new VersionedStruct("format", {
  0: {
    deltas: new ArrayT(int16, 32)
  },
  1: {
    deltas: new ArrayT(int16, 32),
    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
  },
  2: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32)
  },
  3: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32),
    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
  }
});
var $6a3746e8c708f5a3$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  defaultBaseline: uint16,
  subtable: $6a3746e8c708f5a3$var$BslnSubtable
});
var $d0c76fac617b308a$var$Setting = new Struct({
  setting: uint16,
  nameIndex: int16,
  name: (t3) => t3.parent.parent.parent.name.records.fontFeatures[t3.nameIndex]
});
var $d0c76fac617b308a$var$FeatureName = new Struct({
  feature: uint16,
  nSettings: uint16,
  settingTable: new Pointer(uint32, new ArrayT($d0c76fac617b308a$var$Setting, "nSettings"), {
    type: "parent"
  }),
  featureFlags: new Bitfield(uint8, [
    null,
    null,
    null,
    null,
    null,
    null,
    "hasDefault",
    "exclusive"
  ]),
  defaultSetting: uint8,
  nameIndex: int16,
  name: (t3) => t3.parent.parent.name.records.fontFeatures[t3.nameIndex]
});
var $d0c76fac617b308a$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  featureNameCount: uint16,
  reserved1: new Reserved(uint16),
  reserved2: new Reserved(uint32),
  featureNames: new ArrayT($d0c76fac617b308a$var$FeatureName, "featureNameCount")
});
var $e83fd065f00fcd01$var$Axis = new Struct({
  axisTag: new StringT(4),
  minValue: fixed32,
  defaultValue: fixed32,
  maxValue: fixed32,
  flags: uint16,
  nameID: uint16,
  name: (t3) => t3.parent.parent.name.records.fontFeatures[t3.nameID]
});
var $e83fd065f00fcd01$var$Instance = new Struct({
  nameID: uint16,
  name: (t3) => t3.parent.parent.name.records.fontFeatures[t3.nameID],
  flags: uint16,
  coord: new ArrayT(fixed32, (t3) => t3.parent.axisCount),
  postscriptNameID: new Optional(uint16, (t3) => t3.parent.instanceSize - t3._currentOffset > 0)
});
var $e83fd065f00fcd01$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  offsetToData: uint16,
  countSizePairs: uint16,
  axisCount: uint16,
  axisSize: uint16,
  instanceCount: uint16,
  instanceSize: uint16,
  axis: new ArrayT($e83fd065f00fcd01$var$Axis, "axisCount"),
  instance: new ArrayT($e83fd065f00fcd01$var$Instance, "instanceCount")
});
var $dbe33c8d3a7f131c$var$shortFrac = new Fixed(16, "BE", 14);
var $dbe33c8d3a7f131c$var$Offset = class {
  static decode(stream2, parent) {
    return parent.flags ? stream2.readUInt32BE() : stream2.readUInt16BE() * 2;
  }
};
var $dbe33c8d3a7f131c$var$gvar = new Struct({
  version: uint16,
  reserved: new Reserved(uint16),
  axisCount: uint16,
  globalCoordCount: uint16,
  globalCoords: new Pointer(uint32, new ArrayT(new ArrayT($dbe33c8d3a7f131c$var$shortFrac, "axisCount"), "globalCoordCount")),
  glyphCount: uint16,
  flags: uint16,
  offsetToData: uint32,
  offsets: new ArrayT(new Pointer($dbe33c8d3a7f131c$var$Offset, "void", {
    relativeTo: (ctx) => ctx.offsetToData,
    allowNull: false
  }), (t3) => t3.glyphCount + 1)
});
var $dbe33c8d3a7f131c$export$2e2bcd8739ae039 = $dbe33c8d3a7f131c$var$gvar;
var $05b01887df96c4ee$var$ClassTable = new Struct({
  length: uint16,
  coverage: uint16,
  subFeatureFlags: uint32,
  stateTable: new (0, $6cb7dd5f47d82580$export$105027425199cc51)()
});
var $05b01887df96c4ee$var$WidthDeltaRecord = new Struct({
  justClass: uint32,
  beforeGrowLimit: fixed32,
  beforeShrinkLimit: fixed32,
  afterGrowLimit: fixed32,
  afterShrinkLimit: fixed32,
  growFlags: uint16,
  shrinkFlags: uint16
});
var $05b01887df96c4ee$var$WidthDeltaCluster = new ArrayT($05b01887df96c4ee$var$WidthDeltaRecord, uint32);
var $05b01887df96c4ee$var$ActionData = new VersionedStruct("actionType", {
  0: {
    lowerLimit: fixed32,
    upperLimit: fixed32,
    order: uint16,
    glyphs: new ArrayT(uint16, uint16)
  },
  1: {
    addGlyph: uint16
  },
  2: {
    substThreshold: fixed32,
    addGlyph: uint16,
    substGlyph: uint16
  },
  3: {},
  4: {
    variationAxis: uint32,
    minimumLimit: fixed32,
    noStretchValue: fixed32,
    maximumLimit: fixed32
  },
  5: {
    flags: uint16,
    glyph: uint16
  }
});
var $05b01887df96c4ee$var$Action = new Struct({
  actionClass: uint16,
  actionType: uint16,
  actionLength: uint32,
  actionData: $05b01887df96c4ee$var$ActionData,
  padding: new Reserved(uint8, (t3) => t3.actionLength - t3._currentOffset)
});
var $05b01887df96c4ee$var$PostcompensationAction = new ArrayT($05b01887df96c4ee$var$Action, uint32);
var $05b01887df96c4ee$var$PostCompensationTable = new Struct({
  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$PostcompensationAction))
});
var $05b01887df96c4ee$var$JustificationTable = new Struct({
  classTable: new Pointer(uint16, $05b01887df96c4ee$var$ClassTable, {
    type: "parent"
  }),
  wdcOffset: uint16,
  postCompensationTable: new Pointer(uint16, $05b01887df96c4ee$var$PostCompensationTable, {
    type: "parent"
  }),
  widthDeltaClusters: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$WidthDeltaCluster, {
    type: "parent",
    relativeTo: (ctx) => ctx.wdcOffset
  }))
});
var $05b01887df96c4ee$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  format: uint16,
  horizontal: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable),
  vertical: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable)
});
var $03ee6ebd54db1053$var$LigatureData = {
  action: uint16
};
var $03ee6ebd54db1053$var$ContextualData = {
  markIndex: uint16,
  currentIndex: uint16
};
var $03ee6ebd54db1053$var$InsertionData = {
  currentInsertIndex: uint16,
  markedInsertIndex: uint16
};
var $03ee6ebd54db1053$var$SubstitutionTable = new Struct({
  items: new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()))
});
var $03ee6ebd54db1053$var$SubtableData = new VersionedStruct("type", {
  0: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)()
  },
  1: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$ContextualData),
    substitutionTable: new Pointer(uint32, $03ee6ebd54db1053$var$SubstitutionTable)
  },
  2: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$LigatureData),
    ligatureActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint32)),
    components: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16)),
    ligatureList: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
  },
  4: {
    lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()
  },
  5: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$InsertionData),
    insertionActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
  }
});
var $03ee6ebd54db1053$var$Subtable = new Struct({
  length: uint32,
  coverage: uint24,
  type: uint8,
  subFeatureFlags: uint32,
  table: $03ee6ebd54db1053$var$SubtableData,
  padding: new Reserved(uint8, (t3) => t3.length - t3._currentOffset)
});
var $03ee6ebd54db1053$var$FeatureEntry = new Struct({
  featureType: uint16,
  featureSetting: uint16,
  enableFlags: uint32,
  disableFlags: uint32
});
var $03ee6ebd54db1053$var$MorxChain = new Struct({
  defaultFlags: uint32,
  chainLength: uint32,
  nFeatureEntries: uint32,
  nSubtables: uint32,
  features: new ArrayT($03ee6ebd54db1053$var$FeatureEntry, "nFeatureEntries"),
  subtables: new ArrayT($03ee6ebd54db1053$var$Subtable, "nSubtables")
});
var $03ee6ebd54db1053$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  unused: new Reserved(uint16),
  nChains: uint32,
  chains: new ArrayT($03ee6ebd54db1053$var$MorxChain, "nChains")
});
var $b7492a80b0d1a056$var$OpticalBounds = new Struct({
  left: int16,
  top: int16,
  right: int16,
  bottom: int16
});
var $b7492a80b0d1a056$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)($b7492a80b0d1a056$var$OpticalBounds)
});
var $c3395722bea751e2$var$tables = {};
var $c3395722bea751e2$export$2e2bcd8739ae039 = $c3395722bea751e2$var$tables;
$c3395722bea751e2$var$tables.cmap = (0, $26a62205ad06574e$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.head = (0, $f2612a29f92ac062$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hhea = (0, $2c179dd593583073$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hmtx = (0, $bdc9060542264b85$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.maxp = (0, $dbf51cb3d3fe409d$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.name = (0, $2bcf221753ec8e32$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["OS/2"] = (0, $84b272aa31b70606$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.post = (0, $32d9e2eb9565d93c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.fpgm = (0, $5c0f37ca5ffb1850$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.loca = (0, $2b2b260902b1c57e$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.prep = (0, $7afb878c7bea4f66$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["cvt "] = (0, $5202bd9d9ad8eaac$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.glyf = (0, $6c92b6371bce8bd9$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["CFF "] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["CFF2"] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.VORG = (0, $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.EBLC = (0, $9911c4c7201c13de$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.CBLC = $c3395722bea751e2$var$tables.EBLC;
$c3395722bea751e2$var$tables.sbix = (0, $abb847051efd51b1$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.COLR = (0, $eb629188f3dfefdd$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.CPAL = (0, $08734b8e7dc64587$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.BASE = (0, $497cef411d884e34$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GDEF = (0, $cf5f33c63ef209e6$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GPOS = (0, $47e0e8ef515d9903$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GSUB = (0, $d3f442064af66e06$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.JSTF = (0, $71cfb3c4767fbd0c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.HVAR = (0, $d059a6bd2d3b5b63$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.DSIG = (0, $dceeca3e1977ce30$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.gasp = (0, $8acd740a9435aad0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hdmx = (0, $b5f380243c34d6a0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.kern = (0, $ca2df1256966e313$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.LTSH = (0, $7a9f92b0c46ebe33$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.PCLT = (0, $2b2ccc419d152631$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.VDMX = (0, $ca5b40b9bcda9c9b$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.vhea = (0, $69530a3c40755af0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.vmtx = (0, $344073dd270f0e62$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.avar = (0, $3793b781918cfced$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.bsln = (0, $6a3746e8c708f5a3$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.feat = (0, $d0c76fac617b308a$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.fvar = (0, $e83fd065f00fcd01$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.gvar = (0, $dbe33c8d3a7f131c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.just = (0, $05b01887df96c4ee$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.morx = (0, $03ee6ebd54db1053$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.opbd = (0, $b7492a80b0d1a056$export$2e2bcd8739ae039);
var $816c07a04b6dba87$var$TableEntry = new Struct({
  tag: new StringT(4),
  checkSum: uint32,
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  length: uint32
});
var $816c07a04b6dba87$var$Directory = new Struct({
  tag: new StringT(4),
  numTables: uint16,
  searchRange: uint16,
  entrySelector: uint16,
  rangeShift: uint16,
  tables: new ArrayT($816c07a04b6dba87$var$TableEntry, "numTables")
});
$816c07a04b6dba87$var$Directory.process = function() {
  let tables = {};
  for (let table of this.tables) tables[table.tag] = table;
  this.tables = tables;
};
$816c07a04b6dba87$var$Directory.preEncode = function() {
  if (!Array.isArray(this.tables)) {
    let tables = [];
    for (let tag in this.tables) {
      let table = this.tables[tag];
      if (table) tables.push({
        tag,
        checkSum: 0,
        offset: new VoidPointer((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag], table),
        length: (0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag].size(table)
      });
    }
    this.tables = tables;
  }
  this.tag = "true";
  this.numTables = this.tables.length;
  let maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
  let maxPowerOf2 = Math.pow(2, maxExponentFor2);
  this.searchRange = maxPowerOf2 * 16;
  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
  this.rangeShift = this.numTables * 16 - this.searchRange;
};
var $816c07a04b6dba87$export$2e2bcd8739ae039 = $816c07a04b6dba87$var$Directory;
function $12727730ddfc8bfe$export$2e0ae67339d5f1ac(arr, cmp) {
  let min2 = 0;
  let max2 = arr.length - 1;
  while (min2 <= max2) {
    let mid = min2 + max2 >> 1;
    let res = cmp(arr[mid]);
    if (res < 0) max2 = mid - 1;
    else if (res > 0) min2 = mid + 1;
    else return mid;
  }
  return -1;
}
function $12727730ddfc8bfe$export$d02631cccf789723(index3, end2) {
  let range2 = [];
  while (index3 < end2) range2.push(index3++);
  return range2;
}
var $12727730ddfc8bfe$export$3d28c1996ced1f14 = new TextDecoder("ascii");
var $12727730ddfc8bfe$var$CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var $12727730ddfc8bfe$var$LOOKUP = new Uint8Array(256);
for (let i3 = 0; i3 < $12727730ddfc8bfe$var$CHARS.length; i3++) $12727730ddfc8bfe$var$LOOKUP[$12727730ddfc8bfe$var$CHARS.charCodeAt(i3)] = i3;
function $12727730ddfc8bfe$export$94fdf11bafc8de6b(base64) {
  let bufferLength = base64.length * 0.75;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") bufferLength--;
  }
  let bytes = new Uint8Array(bufferLength);
  let p2 = 0;
  for (let i3 = 0, len = base64.length; i3 < len; i3 += 4) {
    let encoded1 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i3)];
    let encoded2 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i3 + 1)];
    let encoded3 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i3 + 2)];
    let encoded4 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i3 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes;
}
var $f08dd41ef10b694c$export$2e2bcd8739ae039 = class {
  findSubtable(cmapTable, pairs2) {
    for (let [platformID, encodingID] of pairs2) for (let cmap of cmapTable.tables) {
      if (cmap.platformID === platformID && cmap.encodingID === encodingID) return cmap.table;
    }
    return null;
  }
  lookup(codepoint, variationSelector) {
    if (this.encoding) codepoint = this.encoding.get(codepoint) || codepoint;
    else if (variationSelector) {
      let gid = this.getVariationSelector(codepoint, variationSelector);
      if (gid) return gid;
    }
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return cmap.codeMap.get(codepoint) || 0;
      case 4: {
        let min2 = 0;
        let max2 = cmap.segCount - 1;
        while (min2 <= max2) {
          let mid = min2 + max2 >> 1;
          if (codepoint < cmap.startCode.get(mid)) max2 = mid - 1;
          else if (codepoint > cmap.endCode.get(mid)) min2 = mid + 1;
          else {
            let rangeOffset = cmap.idRangeOffset.get(mid);
            let gid;
            if (rangeOffset === 0) gid = codepoint + cmap.idDelta.get(mid);
            else {
              let index3 = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
              gid = cmap.glyphIndexArray.get(index3) || 0;
              if (gid !== 0) gid += cmap.idDelta.get(mid);
            }
            return gid & 65535;
          }
        }
        return 0;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;
      case 12:
      case 13: {
        let min2 = 0;
        let max2 = cmap.nGroups - 1;
        while (min2 <= max2) {
          let mid = min2 + max2 >> 1;
          let group = cmap.groups.get(mid);
          if (codepoint < group.startCharCode) max2 = mid - 1;
          else if (codepoint > group.endCharCode) min2 = mid + 1;
          else {
            if (cmap.version === 12) return group.glyphID + (codepoint - group.startCharCode);
            else return group.glyphID;
          }
        }
        return 0;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  getVariationSelector(codepoint, variationSelector) {
    if (!this.uvs) return 0;
    let selectors = this.uvs.varSelectors.toArray();
    let i3 = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(selectors, (x) => variationSelector - x.varSelector);
    let sel = selectors[i3];
    if (i3 !== -1 && sel.defaultUVS) i3 = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.defaultUVS, (x) => codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? 1 : 0);
    if (i3 !== -1 && sel.nonDefaultUVS) {
      i3 = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.nonDefaultUVS, (x) => codepoint - x.unicodeValue);
      if (i3 !== -1) return sel.nonDefaultUVS[i3].glyphID;
    }
    return 0;
  }
  getCharacterSet() {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(0, cmap.codeMap.length);
      case 4: {
        let res = [];
        let endCodes = cmap.endCode.toArray();
        for (let i3 = 0; i3 < endCodes.length; i3++) {
          let tail = endCodes[i3] + 1;
          let start2 = cmap.startCode.get(i3);
          res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(start2, tail));
        }
        return res;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);
      case 12:
      case 13: {
        let res = [];
        for (let group of cmap.groups.toArray()) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
        return res;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  codePointsForGlyph(gid) {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0: {
        let res = [];
        for (let i3 = 0; i3 < 256; i3++) if (cmap.codeMap.get(i3) === gid) res.push(i3);
        return res;
      }
      case 4: {
        let res = [];
        for (let i3 = 0; i3 < cmap.segCount; i3++) {
          let end2 = cmap.endCode.get(i3);
          let start2 = cmap.startCode.get(i3);
          let rangeOffset = cmap.idRangeOffset.get(i3);
          let delta = cmap.idDelta.get(i3);
          for (var c3 = start2; c3 <= end2; c3++) {
            let g2 = 0;
            if (rangeOffset === 0) g2 = c3 + delta;
            else {
              let index3 = rangeOffset / 2 + (c3 - start2) - (cmap.segCount - i3);
              g2 = cmap.glyphIndexArray.get(index3) || 0;
              if (g2 !== 0) g2 += delta;
            }
            if (g2 === gid) res.push(c3);
          }
        }
        return res;
      }
      case 12: {
        let res = [];
        for (let group of cmap.groups.toArray()) if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) res.push(group.startCharCode + (gid - group.glyphID));
        return res;
      }
      case 13: {
        let res = [];
        for (let group of cmap.groups.toArray()) if (gid === group.glyphID) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
        return res;
      }
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  constructor(cmapTable) {
    this.encoding = null;
    this.cmap = this.findSubtable(cmapTable, [
      // 32-bit subtables
      [
        3,
        10
      ],
      [
        0,
        6
      ],
      [
        0,
        4
      ],
      // 16-bit subtables
      [
        3,
        1
      ],
      [
        0,
        3
      ],
      [
        0,
        2
      ],
      [
        0,
        1
      ],
      [
        0,
        0
      ]
    ]);
    if (!this.cmap) for (let cmap of cmapTable.tables) {
      let encoding = (0, $e449ad78d50845fe$export$badc544e0651b6b1)(cmap.platformID, cmap.encodingID, cmap.table.language - 1);
      let mapping = (0, $e449ad78d50845fe$export$1dceb3c14ed68bee)(encoding);
      if (mapping) {
        this.cmap = cmap.table;
        this.encoding = mapping;
      }
    }
    if (!this.cmap) throw new Error("Could not find a supported cmap table");
    this.uvs = this.findSubtable(cmapTable, [
      [
        0,
        5
      ]
    ]);
    if (this.uvs && this.uvs.version !== 14) this.uvs = null;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "getCharacterSet", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "codePointsForGlyph", null);
var $0bba3a9db57637f3$export$2e2bcd8739ae039 = class {
  process(glyphs, positions) {
    for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {
      let left = glyphs[glyphIndex].id;
      let right = glyphs[glyphIndex + 1].id;
      positions[glyphIndex].xAdvance += this.getKerning(left, right);
    }
  }
  getKerning(left, right) {
    let res = 0;
    for (let table of this.kern.tables) {
      if (table.coverage.crossStream) continue;
      switch (table.version) {
        case 0:
          if (!table.coverage.horizontal) continue;
          break;
        case 1:
          if (table.coverage.vertical || table.coverage.variation) continue;
          break;
        default:
          throw new Error(`Unsupported kerning table version ${table.version}`);
      }
      let val = 0;
      let s2 = table.subtable;
      switch (table.format) {
        case 0:
          let pairIdx = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(s2.pairs, function(pair) {
            return left - pair.left || right - pair.right;
          });
          if (pairIdx >= 0) val = s2.pairs[pairIdx].value;
          break;
        case 2:
          let leftOffset = 0, rightOffset = 0;
          if (left >= s2.leftTable.firstGlyph && left < s2.leftTable.firstGlyph + s2.leftTable.nGlyphs) leftOffset = s2.leftTable.offsets[left - s2.leftTable.firstGlyph];
          else leftOffset = s2.array.off;
          if (right >= s2.rightTable.firstGlyph && right < s2.rightTable.firstGlyph + s2.rightTable.nGlyphs) rightOffset = s2.rightTable.offsets[right - s2.rightTable.firstGlyph];
          let index3 = (leftOffset + rightOffset - s2.array.off) / 2;
          val = s2.array.values.get(index3);
          break;
        case 3:
          if (left >= s2.glyphCount || right >= s2.glyphCount) return 0;
          val = s2.kernValue[s2.kernIndex[s2.leftClass[left] * s2.rightClassCount + s2.rightClass[right]]];
          break;
        default:
          throw new Error(`Unsupported kerning sub-table format ${table.format}`);
      }
      if (table.coverage.override) res = val;
      else res += val;
    }
    return res;
  }
  constructor(font) {
    this.kern = font.kern;
  }
};
var $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039 = class {
  positionGlyphs(glyphs, positions) {
    let clusterStart = 0;
    let clusterEnd = 0;
    for (let index3 = 0; index3 < glyphs.length; index3++) {
      let glyph = glyphs[index3];
      if (glyph.isMark) clusterEnd = index3;
      else {
        if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
        clusterStart = clusterEnd = index3;
      }
    }
    if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
    return positions;
  }
  positionCluster(glyphs, positions, clusterStart, clusterEnd) {
    let base = glyphs[clusterStart];
    let baseBox = base.cbox.copy();
    if (base.codePoints.length > 1)
      baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
    let xOffset = -positions[clusterStart].xAdvance;
    let yOffset = 0;
    let yGap = this.font.unitsPerEm / 16;
    for (let index3 = clusterStart + 1; index3 <= clusterEnd; index3++) {
      let mark = glyphs[index3];
      let markBox = mark.cbox;
      let position = positions[index3];
      let combiningClass = this.getCombiningClass(mark.codePoints[0]);
      if (combiningClass !== "Not_Reordered") {
        position.xOffset = position.yOffset = 0;
        switch (combiningClass) {
          case "Double_Above":
          case "Double_Below":
            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
            break;
          case "Attached_Below_Left":
          case "Below_Left":
          case "Above_Left":
            position.xOffset += baseBox.minX - markBox.minX;
            break;
          case "Attached_Above_Right":
          case "Below_Right":
          case "Above_Right":
            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
            break;
          default:
            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
        }
        switch (combiningClass) {
          case "Double_Below":
          case "Below_Left":
          case "Below":
          case "Below_Right":
          case "Attached_Below_Left":
          case "Attached_Below":
            if (combiningClass === "Attached_Below_Left" || combiningClass === "Attached_Below") baseBox.minY += yGap;
            position.yOffset = -baseBox.minY - markBox.maxY;
            baseBox.minY += markBox.height;
            break;
          case "Double_Above":
          case "Above_Left":
          case "Above":
          case "Above_Right":
          case "Attached_Above":
          case "Attached_Above_Right":
            if (combiningClass === "Attached_Above" || combiningClass === "Attached_Above_Right") baseBox.maxY += yGap;
            position.yOffset = baseBox.maxY - markBox.minY;
            baseBox.maxY += markBox.height;
            break;
        }
        position.xAdvance = position.yAdvance = 0;
        position.xOffset += xOffset;
        position.yOffset += yOffset;
      } else {
        xOffset -= position.xAdvance;
        yOffset -= position.yAdvance;
      }
    }
    return;
  }
  getCombiningClass(codePoint) {
    let combiningClass = (0, $747425b437e121da$export$c03b919c6651ed55)(codePoint);
    if ((codePoint & -256) === 3584) {
      if (combiningClass === "Not_Reordered") switch (codePoint) {
        case 3633:
        case 3636:
        case 3637:
        case 3638:
        case 3639:
        case 3655:
        case 3660:
        case 3645:
        case 3662:
          return "Above_Right";
        case 3761:
        case 3764:
        case 3765:
        case 3766:
        case 3767:
        case 3771:
        case 3788:
        case 3789:
          return "Above";
        case 3772:
          return "Below";
      }
      else if (codePoint === 3642) return "Below_Right";
    }
    switch (combiningClass) {
      // Hebrew
      case "CCC10":
      case "CCC11":
      case "CCC12":
      case "CCC13":
      case "CCC14":
      case "CCC15":
      case "CCC16":
      case "CCC17":
      case "CCC18":
      case "CCC20":
      case "CCC22":
        return "Below";
      case "CCC23":
        return "Attached_Above";
      case "CCC24":
        return "Above_Right";
      case "CCC25":
      case "CCC19":
        return "Above_Left";
      case "CCC26":
        return "Above";
      case "CCC21":
        break;
      // Arabic and Syriac
      case "CCC27":
      case "CCC28":
      case "CCC30":
      case "CCC31":
      case "CCC33":
      case "CCC34":
      case "CCC35":
      case "CCC36":
        return "Above";
      case "CCC29":
      case "CCC32":
        return "Below";
      // Thai
      case "CCC103":
        return "Below_Right";
      case "CCC107":
        return "Above_Right";
      // Lao
      case "CCC118":
        return "Below";
      case "CCC122":
        return "Above";
      // Tibetan
      case "CCC129":
      case "CCC132":
        return "Below";
      case "CCC130":
        return "Above";
    }
    return combiningClass;
  }
  constructor(font) {
    this.font = font;
  }
};
var $f34600ab9d7f70d8$export$2e2bcd8739ae039 = class _$f34600ab9d7f70d8$export$2e2bcd8739ae039 {
  /**
  * The width of the bounding box
  * @type {number}
  */
  get width() {
    return this.maxX - this.minX;
  }
  /**
  * The height of the bounding box
  * @type {number}
  */
  get height() {
    return this.maxY - this.minY;
  }
  addPoint(x, y2) {
    if (Math.abs(x) !== Infinity) {
      if (x < this.minX) this.minX = x;
      if (x > this.maxX) this.maxX = x;
    }
    if (Math.abs(y2) !== Infinity) {
      if (y2 < this.minY) this.minY = y2;
      if (y2 > this.maxY) this.maxY = y2;
    }
  }
  copy() {
    return new _$f34600ab9d7f70d8$export$2e2bcd8739ae039(this.minX, this.minY, this.maxX, this.maxY);
  }
  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
};
var $130d1a642ebcd2b7$var$UNICODE_SCRIPTS = {
  Caucasian_Albanian: "aghb",
  Arabic: "arab",
  Imperial_Aramaic: "armi",
  Armenian: "armn",
  Avestan: "avst",
  Balinese: "bali",
  Bamum: "bamu",
  Bassa_Vah: "bass",
  Batak: "batk",
  Bengali: [
    "bng2",
    "beng"
  ],
  Bopomofo: "bopo",
  Brahmi: "brah",
  Braille: "brai",
  Buginese: "bugi",
  Buhid: "buhd",
  Chakma: "cakm",
  Canadian_Aboriginal: "cans",
  Carian: "cari",
  Cham: "cham",
  Cherokee: "cher",
  Coptic: "copt",
  Cypriot: "cprt",
  Cyrillic: "cyrl",
  Devanagari: [
    "dev2",
    "deva"
  ],
  Deseret: "dsrt",
  Duployan: "dupl",
  Egyptian_Hieroglyphs: "egyp",
  Elbasan: "elba",
  Ethiopic: "ethi",
  Georgian: "geor",
  Glagolitic: "glag",
  Gothic: "goth",
  Grantha: "gran",
  Greek: "grek",
  Gujarati: [
    "gjr2",
    "gujr"
  ],
  Gurmukhi: [
    "gur2",
    "guru"
  ],
  Hangul: "hang",
  Han: "hani",
  Hanunoo: "hano",
  Hebrew: "hebr",
  Hiragana: "hira",
  Pahawh_Hmong: "hmng",
  Katakana_Or_Hiragana: "hrkt",
  Old_Italic: "ital",
  Javanese: "java",
  Kayah_Li: "kali",
  Katakana: "kana",
  Kharoshthi: "khar",
  Khmer: "khmr",
  Khojki: "khoj",
  Kannada: [
    "knd2",
    "knda"
  ],
  Kaithi: "kthi",
  Tai_Tham: "lana",
  Lao: "lao ",
  Latin: "latn",
  Lepcha: "lepc",
  Limbu: "limb",
  Linear_A: "lina",
  Linear_B: "linb",
  Lisu: "lisu",
  Lycian: "lyci",
  Lydian: "lydi",
  Mahajani: "mahj",
  Mandaic: "mand",
  Manichaean: "mani",
  Mende_Kikakui: "mend",
  Meroitic_Cursive: "merc",
  Meroitic_Hieroglyphs: "mero",
  Malayalam: [
    "mlm2",
    "mlym"
  ],
  Modi: "modi",
  Mongolian: "mong",
  Mro: "mroo",
  Meetei_Mayek: "mtei",
  Myanmar: [
    "mym2",
    "mymr"
  ],
  Old_North_Arabian: "narb",
  Nabataean: "nbat",
  Nko: "nko ",
  Ogham: "ogam",
  Ol_Chiki: "olck",
  Old_Turkic: "orkh",
  Oriya: [
    "ory2",
    "orya"
  ],
  Osmanya: "osma",
  Palmyrene: "palm",
  Pau_Cin_Hau: "pauc",
  Old_Permic: "perm",
  Phags_Pa: "phag",
  Inscriptional_Pahlavi: "phli",
  Psalter_Pahlavi: "phlp",
  Phoenician: "phnx",
  Miao: "plrd",
  Inscriptional_Parthian: "prti",
  Rejang: "rjng",
  Runic: "runr",
  Samaritan: "samr",
  Old_South_Arabian: "sarb",
  Saurashtra: "saur",
  Shavian: "shaw",
  Sharada: "shrd",
  Siddham: "sidd",
  Khudawadi: "sind",
  Sinhala: "sinh",
  Sora_Sompeng: "sora",
  Sundanese: "sund",
  Syloti_Nagri: "sylo",
  Syriac: "syrc",
  Tagbanwa: "tagb",
  Takri: "takr",
  Tai_Le: "tale",
  New_Tai_Lue: "talu",
  Tamil: [
    "tml2",
    "taml"
  ],
  Tai_Viet: "tavt",
  Telugu: [
    "tel2",
    "telu"
  ],
  Tifinagh: "tfng",
  Tagalog: "tglg",
  Thaana: "thaa",
  Thai: "thai",
  Tibetan: "tibt",
  Tirhuta: "tirh",
  Ugaritic: "ugar",
  Vai: "vai ",
  Warang_Citi: "wara",
  Old_Persian: "xpeo",
  Cuneiform: "xsux",
  Yi: "yi  ",
  Inherited: "zinh",
  Common: "zyyy",
  Unknown: "zzzz"
};
var $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS = {};
for (let script in $130d1a642ebcd2b7$var$UNICODE_SCRIPTS) {
  let tag = $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  if (Array.isArray(tag)) for (let t3 of tag) $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[t3] = script;
  else $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag] = script;
}
function $130d1a642ebcd2b7$export$ce50e82f12a827a4(tag) {
  return $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag];
}
function $130d1a642ebcd2b7$export$e5cb25e204fb8450(string) {
  let len = string.length;
  let idx = 0;
  while (idx < len) {
    let code = string.charCodeAt(idx++);
    if (55296 <= code && code <= 56319 && idx < len) {
      let next = string.charCodeAt(idx);
      if (56320 <= next && next <= 57343) {
        idx++;
        code = ((code & 1023) << 10) + (next & 1023) + 65536;
      }
    }
    let script = (0, $747425b437e121da$export$941569448d136665)(code);
    if (script !== "Common" && script !== "Inherited" && script !== "Unknown") return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
function $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints) {
  for (let i3 = 0; i3 < codePoints.length; i3++) {
    let codePoint = codePoints[i3];
    let script = (0, $747425b437e121da$export$941569448d136665)(codePoint);
    if (script !== "Common" && script !== "Inherited" && script !== "Unknown") return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
var $130d1a642ebcd2b7$var$RTL = {
  arab: true,
  hebr: true,
  syrc: true,
  thaa: true,
  cprt: true,
  khar: true,
  phnx: true,
  "nko ": true,
  lydi: true,
  avst: true,
  armi: true,
  phli: true,
  prti: true,
  sarb: true,
  orkh: true,
  samr: true,
  mand: true,
  merc: true,
  mero: true,
  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)
  mani: true,
  mend: true,
  nbat: true,
  narb: true,
  palm: true,
  phlp: true
  // Psalter Pahlavi
};
function $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script) {
  if ($130d1a642ebcd2b7$var$RTL[script]) return "rtl";
  return "ltr";
}
var $be07b3e97a42687a$export$2e2bcd8739ae039 = class {
  /**
  * The total advance width of the run.
  * @type {number}
  */
  get advanceWidth() {
    let width = 0;
    for (let position of this.positions) width += position.xAdvance;
    return width;
  }
  /**
  * The total advance height of the run.
  * @type {number}
  */
  get advanceHeight() {
    let height2 = 0;
    for (let position of this.positions) height2 += position.yAdvance;
    return height2;
  }
  /**
  * The bounding box containing all glyphs in the run.
  * @type {BBox}
  */
  get bbox() {
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    let x = 0;
    let y2 = 0;
    for (let index3 = 0; index3 < this.glyphs.length; index3++) {
      let glyph = this.glyphs[index3];
      let p2 = this.positions[index3];
      let b2 = glyph.bbox;
      bbox.addPoint(b2.minX + x + p2.xOffset, b2.minY + y2 + p2.yOffset);
      bbox.addPoint(b2.maxX + x + p2.xOffset, b2.maxY + y2 + p2.yOffset);
      x += p2.xAdvance;
      y2 += p2.yAdvance;
    }
    return bbox;
  }
  constructor(glyphs, features, script, language, direction) {
    this.glyphs = glyphs;
    this.positions = null;
    this.script = script;
    this.language = language || null;
    this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    this.features = {};
    if (Array.isArray(features)) for (let tag of features) this.features[tag] = true;
    else if (typeof features === "object") this.features = features;
  }
};
var $1ac75d9a55b67f01$export$2e2bcd8739ae039 = class {
  constructor(xAdvance = 0, yAdvance = 0, xOffset = 0, yOffset = 0) {
    this.xAdvance = xAdvance;
    this.yAdvance = yAdvance;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
  }
};
var $3b6302b64eccc32c$var$features = {
  allTypographicFeatures: {
    code: 0,
    exclusive: false,
    allTypeFeatures: 0
  },
  ligatures: {
    code: 1,
    exclusive: false,
    requiredLigatures: 0,
    commonLigatures: 2,
    rareLigatures: 4,
    // logos: 6
    rebusPictures: 8,
    diphthongLigatures: 10,
    squaredLigatures: 12,
    abbrevSquaredLigatures: 14,
    symbolLigatures: 16,
    contextualLigatures: 18,
    historicalLigatures: 20
  },
  cursiveConnection: {
    code: 2,
    exclusive: true,
    unconnected: 0,
    partiallyConnected: 1,
    cursive: 2
  },
  letterCase: {
    code: 3,
    exclusive: true
  },
  // upperAndLowerCase: 0          # deprecated
  // allCaps: 1                    # deprecated
  // allLowerCase: 2               # deprecated
  // smallCaps: 3                  # deprecated
  // initialCaps: 4                # deprecated
  // initialCapsAndSmallCaps: 5    # deprecated
  verticalSubstitution: {
    code: 4,
    exclusive: false,
    substituteVerticalForms: 0
  },
  linguisticRearrangement: {
    code: 5,
    exclusive: false,
    linguisticRearrangement: 0
  },
  numberSpacing: {
    code: 6,
    exclusive: true,
    monospacedNumbers: 0,
    proportionalNumbers: 1,
    thirdWidthNumbers: 2,
    quarterWidthNumbers: 3
  },
  smartSwash: {
    code: 8,
    exclusive: false,
    wordInitialSwashes: 0,
    wordFinalSwashes: 2,
    // lineInitialSwashes: 4
    // lineFinalSwashes: 6
    nonFinalSwashes: 8
  },
  diacritics: {
    code: 9,
    exclusive: true,
    showDiacritics: 0,
    hideDiacritics: 1,
    decomposeDiacritics: 2
  },
  verticalPosition: {
    code: 10,
    exclusive: true,
    normalPosition: 0,
    superiors: 1,
    inferiors: 2,
    ordinals: 3,
    scientificInferiors: 4
  },
  fractions: {
    code: 11,
    exclusive: true,
    noFractions: 0,
    verticalFractions: 1,
    diagonalFractions: 2
  },
  overlappingCharacters: {
    code: 13,
    exclusive: false,
    preventOverlap: 0
  },
  typographicExtras: {
    code: 14,
    exclusive: false,
    // hyphensToEmDash: 0
    // hyphenToEnDash: 2
    slashedZero: 4
  },
  // formInterrobang: 6
  // smartQuotes: 8
  // periodsToEllipsis: 10
  mathematicalExtras: {
    code: 15,
    exclusive: false,
    // hyphenToMinus: 0
    // asteristoMultiply: 2
    // slashToDivide: 4
    // inequalityLigatures: 6
    // exponents: 8
    mathematicalGreek: 10
  },
  ornamentSets: {
    code: 16,
    exclusive: true,
    noOrnaments: 0,
    dingbats: 1,
    piCharacters: 2,
    fleurons: 3,
    decorativeBorders: 4,
    internationalSymbols: 5,
    mathSymbols: 6
  },
  characterAlternatives: {
    code: 17,
    exclusive: true,
    noAlternates: 0
  },
  // user defined options
  designComplexity: {
    code: 18,
    exclusive: true,
    designLevel1: 0,
    designLevel2: 1,
    designLevel3: 2,
    designLevel4: 3,
    designLevel5: 4
  },
  styleOptions: {
    code: 19,
    exclusive: true,
    noStyleOptions: 0,
    displayText: 1,
    engravedText: 2,
    illuminatedCaps: 3,
    titlingCaps: 4,
    tallCaps: 5
  },
  characterShape: {
    code: 20,
    exclusive: true,
    traditionalCharacters: 0,
    simplifiedCharacters: 1,
    JIS1978Characters: 2,
    JIS1983Characters: 3,
    JIS1990Characters: 4,
    traditionalAltOne: 5,
    traditionalAltTwo: 6,
    traditionalAltThree: 7,
    traditionalAltFour: 8,
    traditionalAltFive: 9,
    expertCharacters: 10,
    JIS2004Characters: 11,
    hojoCharacters: 12,
    NLCCharacters: 13,
    traditionalNamesCharacters: 14
  },
  numberCase: {
    code: 21,
    exclusive: true,
    lowerCaseNumbers: 0,
    upperCaseNumbers: 1
  },
  textSpacing: {
    code: 22,
    exclusive: true,
    proportionalText: 0,
    monospacedText: 1,
    halfWidthText: 2,
    thirdWidthText: 3,
    quarterWidthText: 4,
    altProportionalText: 5,
    altHalfWidthText: 6
  },
  transliteration: {
    code: 23,
    exclusive: true,
    noTransliteration: 0
  },
  // hanjaToHangul: 1
  // hiraganaToKatakana: 2
  // katakanaToHiragana: 3
  // kanaToRomanization: 4
  // romanizationToHiragana: 5
  // romanizationToKatakana: 6
  // hanjaToHangulAltOne: 7
  // hanjaToHangulAltTwo: 8
  // hanjaToHangulAltThree: 9
  annotation: {
    code: 24,
    exclusive: true,
    noAnnotation: 0,
    boxAnnotation: 1,
    roundedBoxAnnotation: 2,
    circleAnnotation: 3,
    invertedCircleAnnotation: 4,
    parenthesisAnnotation: 5,
    periodAnnotation: 6,
    romanNumeralAnnotation: 7,
    diamondAnnotation: 8,
    invertedBoxAnnotation: 9,
    invertedRoundedBoxAnnotation: 10
  },
  kanaSpacing: {
    code: 25,
    exclusive: true,
    fullWidthKana: 0,
    proportionalKana: 1
  },
  ideographicSpacing: {
    code: 26,
    exclusive: true,
    fullWidthIdeographs: 0,
    proportionalIdeographs: 1,
    halfWidthIdeographs: 2
  },
  unicodeDecomposition: {
    code: 27,
    exclusive: false,
    canonicalComposition: 0,
    compatibilityComposition: 2,
    transcodingComposition: 4
  },
  rubyKana: {
    code: 28,
    exclusive: false,
    // noRubyKana: 0     # deprecated - use rubyKanaOff instead
    // rubyKana: 1     # deprecated - use rubyKanaOn instead
    rubyKana: 2
  },
  CJKSymbolAlternatives: {
    code: 29,
    exclusive: true,
    noCJKSymbolAlternatives: 0,
    CJKSymbolAltOne: 1,
    CJKSymbolAltTwo: 2,
    CJKSymbolAltThree: 3,
    CJKSymbolAltFour: 4,
    CJKSymbolAltFive: 5
  },
  ideographicAlternatives: {
    code: 30,
    exclusive: true,
    noIdeographicAlternatives: 0,
    ideographicAltOne: 1,
    ideographicAltTwo: 2,
    ideographicAltThree: 3,
    ideographicAltFour: 4,
    ideographicAltFive: 5
  },
  CJKVerticalRomanPlacement: {
    code: 31,
    exclusive: true,
    CJKVerticalRomanCentered: 0,
    CJKVerticalRomanHBaseline: 1
  },
  italicCJKRoman: {
    code: 32,
    exclusive: false,
    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead
    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead
    CJKItalicRoman: 2
  },
  caseSensitiveLayout: {
    code: 33,
    exclusive: false,
    caseSensitiveLayout: 0,
    caseSensitiveSpacing: 2
  },
  alternateKana: {
    code: 34,
    exclusive: false,
    alternateHorizKana: 0,
    alternateVertKana: 2
  },
  stylisticAlternatives: {
    code: 35,
    exclusive: false,
    noStylisticAlternates: 0,
    stylisticAltOne: 2,
    stylisticAltTwo: 4,
    stylisticAltThree: 6,
    stylisticAltFour: 8,
    stylisticAltFive: 10,
    stylisticAltSix: 12,
    stylisticAltSeven: 14,
    stylisticAltEight: 16,
    stylisticAltNine: 18,
    stylisticAltTen: 20,
    stylisticAltEleven: 22,
    stylisticAltTwelve: 24,
    stylisticAltThirteen: 26,
    stylisticAltFourteen: 28,
    stylisticAltFifteen: 30,
    stylisticAltSixteen: 32,
    stylisticAltSeventeen: 34,
    stylisticAltEighteen: 36,
    stylisticAltNineteen: 38,
    stylisticAltTwenty: 40
  },
  contextualAlternates: {
    code: 36,
    exclusive: false,
    contextualAlternates: 0,
    swashAlternates: 2,
    contextualSwashAlternates: 4
  },
  lowerCase: {
    code: 37,
    exclusive: true,
    defaultLowerCase: 0,
    lowerCaseSmallCaps: 1,
    lowerCasePetiteCaps: 2
  },
  upperCase: {
    code: 38,
    exclusive: true,
    defaultUpperCase: 0,
    upperCaseSmallCaps: 1,
    upperCasePetiteCaps: 2
  },
  languageTag: {
    code: 39,
    exclusive: true
  },
  CJKRomanSpacing: {
    code: 103,
    exclusive: true,
    halfWidthCJKRoman: 0,
    proportionalCJKRoman: 1,
    defaultCJKRoman: 2,
    fullWidthCJKRoman: 3
  }
};
var $3b6302b64eccc32c$var$feature = (name, selector) => [
  $3b6302b64eccc32c$var$features[name].code,
  $3b6302b64eccc32c$var$features[name][selector]
];
var $3b6302b64eccc32c$var$OTMapping = {
  rlig: $3b6302b64eccc32c$var$feature("ligatures", "requiredLigatures"),
  clig: $3b6302b64eccc32c$var$feature("ligatures", "contextualLigatures"),
  dlig: $3b6302b64eccc32c$var$feature("ligatures", "rareLigatures"),
  hlig: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  liga: $3b6302b64eccc32c$var$feature("ligatures", "commonLigatures"),
  hist: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  smcp: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCaseSmallCaps"),
  pcap: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCasePetiteCaps"),
  frac: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  dnom: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  numr: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  afrc: $3b6302b64eccc32c$var$feature("fractions", "verticalFractions"),
  // aalt
  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?
  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?
  // unic, vatu, vhal, vjmo, vpal, vrt2
  // dist -> trak table?
  // kern, vkrn -> kern table
  // lfbd + opbd + rtbd -> opbd table?
  // mark, mkmk -> acnt table?
  // locl -> languageTag + ltag table
  case: $3b6302b64eccc32c$var$feature("caseSensitiveLayout", "caseSensitiveLayout"),
  ccmp: $3b6302b64eccc32c$var$feature("unicodeDecomposition", "canonicalComposition"),
  cpct: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  valt: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  swsh: $3b6302b64eccc32c$var$feature("contextualAlternates", "swashAlternates"),
  cswh: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualSwashAlternates"),
  curs: $3b6302b64eccc32c$var$feature("cursiveConnection", "cursive"),
  c2pc: $3b6302b64eccc32c$var$feature("upperCase", "upperCasePetiteCaps"),
  c2sc: $3b6302b64eccc32c$var$feature("upperCase", "upperCaseSmallCaps"),
  init: $3b6302b64eccc32c$var$feature("smartSwash", "wordInitialSwashes"),
  fin2: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  medi: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  med2: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  fin3: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  fina: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  pkna: $3b6302b64eccc32c$var$feature("kanaSpacing", "proportionalKana"),
  half: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  halt: $3b6302b64eccc32c$var$feature("textSpacing", "altHalfWidthText"),
  hkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateHorizKana"),
  vkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateVertKana"),
  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated
  ital: $3b6302b64eccc32c$var$feature("italicCJKRoman", "CJKItalicRoman"),
  lnum: $3b6302b64eccc32c$var$feature("numberCase", "upperCaseNumbers"),
  onum: $3b6302b64eccc32c$var$feature("numberCase", "lowerCaseNumbers"),
  mgrk: $3b6302b64eccc32c$var$feature("mathematicalExtras", "mathematicalGreek"),
  // nalt: not enough info. what type of annotation?
  // ornm: ditto, which ornament style?
  calt: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualAlternates"),
  vrt2: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  vert: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  tnum: $3b6302b64eccc32c$var$feature("numberSpacing", "monospacedNumbers"),
  pnum: $3b6302b64eccc32c$var$feature("numberSpacing", "proportionalNumbers"),
  sups: $3b6302b64eccc32c$var$feature("verticalPosition", "superiors"),
  subs: $3b6302b64eccc32c$var$feature("verticalPosition", "inferiors"),
  ordn: $3b6302b64eccc32c$var$feature("verticalPosition", "ordinals"),
  pwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  hwid: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  qwid: $3b6302b64eccc32c$var$feature("textSpacing", "quarterWidthText"),
  twid: $3b6302b64eccc32c$var$feature("textSpacing", "thirdWidthText"),
  fwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  palt: $3b6302b64eccc32c$var$feature("textSpacing", "altProportionalText"),
  trad: $3b6302b64eccc32c$var$feature("characterShape", "traditionalCharacters"),
  smpl: $3b6302b64eccc32c$var$feature("characterShape", "simplifiedCharacters"),
  jp78: $3b6302b64eccc32c$var$feature("characterShape", "JIS1978Characters"),
  jp83: $3b6302b64eccc32c$var$feature("characterShape", "JIS1983Characters"),
  jp90: $3b6302b64eccc32c$var$feature("characterShape", "JIS1990Characters"),
  jp04: $3b6302b64eccc32c$var$feature("characterShape", "JIS2004Characters"),
  expt: $3b6302b64eccc32c$var$feature("characterShape", "expertCharacters"),
  hojo: $3b6302b64eccc32c$var$feature("characterShape", "hojoCharacters"),
  nlck: $3b6302b64eccc32c$var$feature("characterShape", "NLCCharacters"),
  tnam: $3b6302b64eccc32c$var$feature("characterShape", "traditionalNamesCharacters"),
  ruby: $3b6302b64eccc32c$var$feature("rubyKana", "rubyKana"),
  titl: $3b6302b64eccc32c$var$feature("styleOptions", "titlingCaps"),
  zero: $3b6302b64eccc32c$var$feature("typographicExtras", "slashedZero"),
  ss01: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltOne"),
  ss02: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwo"),
  ss03: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThree"),
  ss04: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFour"),
  ss05: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFive"),
  ss06: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSix"),
  ss07: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeven"),
  ss08: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEight"),
  ss09: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNine"),
  ss10: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTen"),
  ss11: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEleven"),
  ss12: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwelve"),
  ss13: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThirteen"),
  ss14: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFourteen"),
  ss15: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFifteen"),
  ss16: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSixteen"),
  ss17: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeventeen"),
  ss18: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEighteen"),
  ss19: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNineteen"),
  ss20: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwenty")
};
for (let i3 = 1; i3 <= 99; i3++) $3b6302b64eccc32c$var$OTMapping[`cv${`00${i3}`.slice(-2)}`] = [
  $3b6302b64eccc32c$var$features.characterAlternatives.code,
  i3
];
var $3b6302b64eccc32c$var$AATMapping = {};
for (let ot in $3b6302b64eccc32c$var$OTMapping) {
  let aat = $3b6302b64eccc32c$var$OTMapping[ot];
  if ($3b6302b64eccc32c$var$AATMapping[aat[0]] == null) $3b6302b64eccc32c$var$AATMapping[aat[0]] = {};
  $3b6302b64eccc32c$var$AATMapping[aat[0]][aat[1]] = ot;
}
function $3b6302b64eccc32c$export$b813f7d2a1677c16(features) {
  let res = {};
  for (let k2 in features) {
    let r3;
    if (r3 = $3b6302b64eccc32c$var$OTMapping[k2]) {
      if (res[r3[0]] == null) res[r3[0]] = {};
      res[r3[0]][r3[1]] = features[k2];
    }
  }
  return res;
}
function $3b6302b64eccc32c$var$mapFeatureStrings(f2) {
  let [type, setting] = f2;
  if (isNaN(type)) var typeCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type].code;
  else var typeCode = type;
  if (isNaN(setting)) var settingCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type][setting];
  else var settingCode = setting;
  return [
    typeCode,
    settingCode
  ];
}
function $3b6302b64eccc32c$export$bd6df347a4f391c4(features) {
  let res = {};
  if (Array.isArray(features)) for (let k2 = 0; k2 < features.length; k2++) {
    let r3;
    let f2 = $3b6302b64eccc32c$var$mapFeatureStrings(features[k2]);
    if (r3 = $3b6302b64eccc32c$var$AATMapping[f2[0]] && $3b6302b64eccc32c$var$AATMapping[f2[0]][f2[1]]) res[r3] = true;
  }
  else if (typeof features === "object") for (let type in features) {
    let feature = features[type];
    for (let setting in feature) {
      let r3;
      let f2 = $3b6302b64eccc32c$var$mapFeatureStrings([
        type,
        setting
      ]);
      if (feature[setting] && (r3 = $3b6302b64eccc32c$var$AATMapping[f2[0]] && $3b6302b64eccc32c$var$AATMapping[f2[0]][f2[1]])) res[r3] = true;
    }
  }
  return Object.keys(res);
}
var $ff5ce077dae0f144$export$2e2bcd8739ae039 = class {
  lookup(glyph) {
    switch (this.table.version) {
      case 0:
        return this.table.values.getItem(glyph);
      case 2:
      case 4: {
        let min2 = 0;
        let max2 = this.table.binarySearchHeader.nUnits - 1;
        while (min2 <= max2) {
          var mid = min2 + max2 >> 1;
          var seg = this.table.segments[mid];
          if (seg.firstGlyph === 65535) return null;
          if (glyph < seg.firstGlyph) max2 = mid - 1;
          else if (glyph > seg.lastGlyph) min2 = mid + 1;
          else {
            if (this.table.version === 2) return seg.value;
            else return seg.values[glyph - seg.firstGlyph];
          }
        }
        return null;
      }
      case 6: {
        let min2 = 0;
        let max2 = this.table.binarySearchHeader.nUnits - 1;
        while (min2 <= max2) {
          var mid = min2 + max2 >> 1;
          var seg = this.table.segments[mid];
          if (seg.glyph === 65535) return null;
          if (glyph < seg.glyph) max2 = mid - 1;
          else if (glyph > seg.glyph) min2 = mid + 1;
          else return seg.value;
        }
        return null;
      }
      case 8:
        return this.table.values[glyph - this.table.firstGlyph];
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
  }
  glyphsForValue(classValue) {
    let res = [];
    switch (this.table.version) {
      case 2:
      case 4:
        for (let segment of this.table.segments) if (this.table.version === 2 && segment.value === classValue) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(segment.firstGlyph, segment.lastGlyph + 1));
        else {
          for (let index3 = 0; index3 < segment.values.length; index3++) if (segment.values[index3] === classValue) res.push(segment.firstGlyph + index3);
        }
        break;
      case 6:
        for (let segment of this.table.segments) if (segment.value === classValue) res.push(segment.glyph);
        break;
      case 8:
        for (let i3 = 0; i3 < this.table.values.length; i3++) if (this.table.values[i3] === classValue) res.push(this.table.firstGlyph + i3);
        break;
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
    return res;
  }
  constructor(table) {
    this.table = table;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $ff5ce077dae0f144$export$2e2bcd8739ae039.prototype, "glyphsForValue", null);
var $50c7aac9316f2948$var$START_OF_TEXT_STATE = 0;
var $50c7aac9316f2948$var$END_OF_TEXT_CLASS = 0;
var $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS = 1;
var $50c7aac9316f2948$var$DELETED_GLYPH_CLASS = 2;
var $50c7aac9316f2948$var$DONT_ADVANCE = 16384;
var $50c7aac9316f2948$export$2e2bcd8739ae039 = class {
  process(glyphs, reverse2, processEntry) {
    let currentState = $50c7aac9316f2948$var$START_OF_TEXT_STATE;
    let index3 = reverse2 ? glyphs.length - 1 : 0;
    let dir = reverse2 ? -1 : 1;
    while (dir === 1 && index3 <= glyphs.length || dir === -1 && index3 >= -1) {
      let glyph = null;
      let classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
      let shouldAdvance = true;
      if (index3 === glyphs.length || index3 === -1) classCode = $50c7aac9316f2948$var$END_OF_TEXT_CLASS;
      else {
        glyph = glyphs[index3];
        if (glyph.id === 65535) classCode = $50c7aac9316f2948$var$DELETED_GLYPH_CLASS;
        else {
          classCode = this.lookupTable.lookup(glyph.id);
          if (classCode == null) classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
        }
      }
      let row = this.stateTable.stateArray.getItem(currentState);
      let entryIndex = row[classCode];
      let entry = this.stateTable.entryTable.getItem(entryIndex);
      if (classCode !== $50c7aac9316f2948$var$END_OF_TEXT_CLASS && classCode !== $50c7aac9316f2948$var$DELETED_GLYPH_CLASS) {
        processEntry(glyph, entry, index3);
        shouldAdvance = !(entry.flags & $50c7aac9316f2948$var$DONT_ADVANCE);
      }
      currentState = entry.newState;
      if (shouldAdvance) index3 += dir;
    }
    return glyphs;
  }
  /**
  * Performs a depth-first traversal of the glyph strings
  * represented by the state machine.
  */
  traverse(opts2, state2 = 0, visited = /* @__PURE__ */ new Set()) {
    if (visited.has(state2)) return;
    visited.add(state2);
    let { nClasses, stateArray, entryTable } = this.stateTable;
    let row = stateArray.getItem(state2);
    for (let classCode = 4; classCode < nClasses; classCode++) {
      let entryIndex = row[classCode];
      let entry = entryTable.getItem(entryIndex);
      for (let glyph of this.lookupTable.glyphsForValue(classCode)) {
        if (opts2.enter) opts2.enter(glyph, entry);
        if (entry.newState !== 0) this.traverse(opts2, entry.newState, visited);
        if (opts2.exit) opts2.exit(glyph, entry);
      }
    }
  }
  constructor(stateTable) {
    this.stateTable = stateTable;
    this.lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(stateTable.classTable);
  }
};
var $55f71433a605c87d$var$MARK_FIRST = 32768;
var $55f71433a605c87d$var$MARK_LAST = 8192;
var $55f71433a605c87d$var$VERB = 15;
var $55f71433a605c87d$var$SET_MARK = 32768;
var $55f71433a605c87d$var$SET_COMPONENT = 32768;
var $55f71433a605c87d$var$PERFORM_ACTION = 8192;
var $55f71433a605c87d$var$LAST_MASK = 2147483648;
var $55f71433a605c87d$var$STORE_MASK = 1073741824;
var $55f71433a605c87d$var$OFFSET_MASK = 1073741823;
var $55f71433a605c87d$var$REVERSE_DIRECTION = 4194304;
var $55f71433a605c87d$var$CURRENT_INSERT_BEFORE = 2048;
var $55f71433a605c87d$var$MARKED_INSERT_BEFORE = 1024;
var $55f71433a605c87d$var$CURRENT_INSERT_COUNT = 992;
var $55f71433a605c87d$var$MARKED_INSERT_COUNT = 31;
var $55f71433a605c87d$export$2e2bcd8739ae039 = class {
  // Processes an array of glyphs and applies the specified features
  // Features should be in the form of {featureType:{featureSetting:boolean}}
  process(glyphs, features = {}) {
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let feature of chain.features) {
        let f2;
        if (f2 = features[feature.featureType]) {
          if (f2[feature.featureSetting]) {
            flags &= feature.disableFlags;
            flags |= feature.enableFlags;
          } else if (f2[feature.featureSetting] === false) {
            flags |= ~feature.disableFlags;
            flags &= ~feature.enableFlags;
          }
        }
      }
      for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.processSubtable(subtable, glyphs);
    }
    let index3 = glyphs.length - 1;
    while (index3 >= 0) {
      if (glyphs[index3].id === 65535) glyphs.splice(index3, 1);
      index3--;
    }
    return glyphs;
  }
  processSubtable(subtable, glyphs) {
    this.subtable = subtable;
    this.glyphs = glyphs;
    if (this.subtable.type === 4) {
      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
      return;
    }
    this.ligatureStack = [];
    this.markedGlyph = null;
    this.firstGlyph = null;
    this.lastGlyph = null;
    this.markedIndex = null;
    let stateMachine = this.getStateMachine(subtable);
    let process2 = this.getProcessor();
    let reverse2 = !!(this.subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    return stateMachine.process(this.glyphs, reverse2, process2);
  }
  getStateMachine(subtable) {
    return new (0, $50c7aac9316f2948$export$2e2bcd8739ae039)(subtable.table.stateTable);
  }
  getProcessor() {
    switch (this.subtable.type) {
      case 0:
        return this.processIndicRearragement;
      case 1:
        return this.processContextualSubstitution;
      case 2:
        return this.processLigature;
      case 4:
        return this.processNoncontextualSubstitutions;
      case 5:
        return this.processGlyphInsertion;
      default:
        throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);
    }
  }
  processIndicRearragement(glyph, entry, index3) {
    if (entry.flags & $55f71433a605c87d$var$MARK_FIRST) this.firstGlyph = index3;
    if (entry.flags & $55f71433a605c87d$var$MARK_LAST) this.lastGlyph = index3;
    $55f71433a605c87d$var$reorderGlyphs(this.glyphs, entry.flags & $55f71433a605c87d$var$VERB, this.firstGlyph, this.lastGlyph);
  }
  processContextualSubstitution(glyph, entry, index3) {
    let subsitutions = this.subtable.table.substitutionTable.items;
    if (entry.markIndex !== 65535) {
      let lookup4 = subsitutions.getItem(entry.markIndex);
      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup4);
      glyph = this.glyphs[this.markedGlyph];
      var gid = lookupTable.lookup(glyph.id);
      if (gid) this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.currentIndex !== 65535) {
      let lookup4 = subsitutions.getItem(entry.currentIndex);
      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup4);
      glyph = this.glyphs[index3];
      var gid = lookupTable.lookup(glyph.id);
      if (gid) this.glyphs[index3] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.flags & $55f71433a605c87d$var$SET_MARK) this.markedGlyph = index3;
  }
  processLigature(glyph, entry, index3) {
    if (entry.flags & $55f71433a605c87d$var$SET_COMPONENT) this.ligatureStack.push(index3);
    if (entry.flags & $55f71433a605c87d$var$PERFORM_ACTION) {
      let actions = this.subtable.table.ligatureActions;
      let components = this.subtable.table.components;
      let ligatureList = this.subtable.table.ligatureList;
      let actionIndex = entry.action;
      let last2 = false;
      let ligatureIndex = 0;
      let codePoints = [];
      let ligatureGlyphs = [];
      while (!last2) {
        let componentGlyph = this.ligatureStack.pop();
        codePoints.unshift(...this.glyphs[componentGlyph].codePoints);
        let action = actions.getItem(actionIndex++);
        last2 = !!(action & $55f71433a605c87d$var$LAST_MASK);
        let store = !!(action & $55f71433a605c87d$var$STORE_MASK);
        let offset2 = (action & $55f71433a605c87d$var$OFFSET_MASK) << 2 >> 2;
        offset2 += this.glyphs[componentGlyph].id;
        let component = components.getItem(offset2);
        ligatureIndex += component;
        if (last2 || store) {
          let ligatureEntry = ligatureList.getItem(ligatureIndex);
          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
          ligatureGlyphs.push(componentGlyph);
          ligatureIndex = 0;
          codePoints = [];
        } else this.glyphs[componentGlyph] = this.font.getGlyph(65535);
      }
      this.ligatureStack.push(...ligatureGlyphs);
    }
  }
  processNoncontextualSubstitutions(subtable, glyphs, index3) {
    let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(subtable.table.lookupTable);
    for (index3 = 0; index3 < glyphs.length; index3++) {
      let glyph = glyphs[index3];
      if (glyph.id !== 65535) {
        let gid = lookupTable.lookup(glyph.id);
        if (gid) glyphs[index3] = this.font.getGlyph(gid, glyph.codePoints);
      }
    }
  }
  _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {
    let insertions = [];
    while (count--) {
      let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
      insertions.push(this.font.getGlyph(gid));
    }
    if (!isBefore) glyphIndex++;
    this.glyphs.splice(glyphIndex, 0, ...insertions);
  }
  processGlyphInsertion(glyph, entry, index3) {
    if (entry.flags & $55f71433a605c87d$var$SET_MARK) this.markedIndex = index3;
    if (entry.markedInsertIndex !== 65535) {
      let count = (entry.flags & $55f71433a605c87d$var$MARKED_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$MARKED_INSERT_BEFORE);
      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);
    }
    if (entry.currentInsertIndex !== 65535) {
      let count = (entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_BEFORE);
      this._insertGlyphs(index3, entry.currentInsertIndex, count, isBefore);
    }
  }
  getSupportedFeatures() {
    let features = [];
    for (let chain of this.morx.chains) for (let feature of chain.features) features.push([
      feature.featureType,
      feature.featureSetting
    ]);
    return features;
  }
  generateInputs(gid) {
    if (!this.inputCache) this.generateInputCache();
    return this.inputCache[gid] || [];
  }
  generateInputCache() {
    this.inputCache = {};
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.generateInputsForSubtable(subtable);
    }
  }
  generateInputsForSubtable(subtable) {
    if (subtable.type !== 2) return;
    let reverse2 = !!(subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    if (reverse2) throw new Error("Reverse subtable, not supported.");
    this.subtable = subtable;
    this.ligatureStack = [];
    let stateMachine = this.getStateMachine(subtable);
    let process2 = this.getProcessor();
    let input = [];
    let stack = [];
    this.glyphs = [];
    stateMachine.traverse({
      enter: (glyph, entry) => {
        let glyphs = this.glyphs;
        stack.push({
          glyphs: glyphs.slice(),
          ligatureStack: this.ligatureStack.slice()
        });
        let g2 = this.font.getGlyph(glyph);
        input.push(g2);
        glyphs.push(input[input.length - 1]);
        process2(glyphs[glyphs.length - 1], entry, glyphs.length - 1);
        let count = 0;
        let found = 0;
        for (let i3 = 0; i3 < glyphs.length && count <= 1; i3++) if (glyphs[i3].id !== 65535) {
          count++;
          found = glyphs[i3].id;
        }
        if (count === 1) {
          let result = input.map((g3) => g3.id);
          let cache2 = this.inputCache[found];
          if (cache2) cache2.push(result);
          else this.inputCache[found] = [
            result
          ];
        }
      },
      exit: () => {
        ({ glyphs: this.glyphs, ligatureStack: this.ligatureStack } = stack.pop());
        input.pop();
      }
    });
  }
  constructor(font) {
    this.processIndicRearragement = this.processIndicRearragement.bind(this);
    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);
    this.processLigature = this.processLigature.bind(this);
    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);
    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);
    this.font = font;
    this.morx = font.morx;
    this.inputCache = null;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $55f71433a605c87d$export$2e2bcd8739ae039.prototype, "getStateMachine", null);
function $55f71433a605c87d$var$swap(glyphs, rangeA, rangeB, reverseA = false, reverseB = false) {
  let end2 = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
  if (reverseB) end2.reverse();
  let start2 = glyphs.splice(rangeA[0], rangeA[1], ...end2);
  if (reverseA) start2.reverse();
  glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start2);
  return glyphs;
}
function $55f71433a605c87d$var$reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {
  let length2 = lastGlyph - firstGlyph + 1;
  switch (verb) {
    case 0:
      return glyphs;
    case 1:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        0
      ]);
    case 2:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        1
      ]);
    case 3:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        1
      ]);
    case 4:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ]);
    case 5:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ], true, false);
    case 6:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ]);
    case 7:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ], false, true);
    case 8:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ]);
    case 9:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ], false, true);
    case 10:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ]);
    case 11:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ], true, false);
    case 12:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ]);
    case 13:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, false);
    case 14:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], false, true);
    case 15:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, true);
    default:
      throw new Error(`Unknown verb: ${verb}`);
  }
}
var $ba6dd74203be8728$export$2e2bcd8739ae039 = class {
  substitute(glyphRun) {
    if (glyphRun.direction === "rtl") glyphRun.glyphs.reverse();
    this.morxProcessor.process(glyphRun.glyphs, $3b6302b64eccc32c$export$b813f7d2a1677c16(glyphRun.features));
  }
  getAvailableFeatures(script, language) {
    return $3b6302b64eccc32c$export$bd6df347a4f391c4(this.morxProcessor.getSupportedFeatures());
  }
  stringsForGlyph(gid) {
    let glyphStrings = this.morxProcessor.generateInputs(gid);
    let result = /* @__PURE__ */ new Set();
    for (let glyphs of glyphStrings) this._addStrings(glyphs, 0, result, "");
    return result;
  }
  _addStrings(glyphs, index3, strings, string) {
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index3]);
    for (let codePoint of codePoints) {
      let s2 = string + String.fromCodePoint(codePoint);
      if (index3 < glyphs.length - 1) this._addStrings(glyphs, index3 + 1, strings, s2);
      else strings.add(s2);
    }
  }
  constructor(font) {
    this.font = font;
    this.morxProcessor = new (0, $55f71433a605c87d$export$2e2bcd8739ae039)(font);
    this.fallbackPosition = false;
  }
};
var $94d7a73bd2edfc9a$export$2e2bcd8739ae039 = class {
  /**
  * Adds the given features to the last stage.
  * Ignores features that have already been applied.
  */
  _addFeatures(features, global2) {
    let stageIndex = this.stages.length - 1;
    let stage = this.stages[stageIndex];
    for (let feature of features) if (this.allFeatures[feature] == null) {
      stage.push(feature);
      this.allFeatures[feature] = stageIndex;
      if (global2) this.globalFeatures[feature] = true;
    }
  }
  /**
  * Add features to the last stage
  */
  add(arg, global2 = true) {
    if (this.stages.length === 0) this.stages.push([]);
    if (typeof arg === "string") arg = [
      arg
    ];
    if (Array.isArray(arg)) this._addFeatures(arg, global2);
    else if (typeof arg === "object") {
      this._addFeatures(arg.global || [], true);
      this._addFeatures(arg.local || [], false);
    } else throw new Error("Unsupported argument to ShapingPlan#add");
  }
  /**
  * Add a new stage
  */
  addStage(arg, global2) {
    if (typeof arg === "function") this.stages.push(arg, []);
    else {
      this.stages.push([]);
      this.add(arg, global2);
    }
  }
  setFeatureOverrides(features) {
    if (Array.isArray(features)) this.add(features);
    else if (typeof features === "object") for (let tag in features) {
      if (features[tag]) this.add(tag);
      else if (this.allFeatures[tag] != null) {
        let stage = this.stages[this.allFeatures[tag]];
        stage.splice(stage.indexOf(tag), 1);
        delete this.allFeatures[tag];
        delete this.globalFeatures[tag];
      }
    }
  }
  /**
  * Assigns the global features to the given glyphs
  */
  assignGlobalFeatures(glyphs) {
    for (let glyph of glyphs) for (let feature in this.globalFeatures) glyph.features[feature] = true;
  }
  /**
  * Executes the planned stages using the given OTProcessor
  */
  process(processor, glyphs, positions) {
    for (let stage of this.stages) {
      if (typeof stage === "function") {
        if (!positions) stage(this.font, glyphs, this);
      } else if (stage.length > 0) processor.applyFeatures(stage, glyphs, positions);
    }
  }
  constructor(font, script, direction) {
    this.font = font;
    this.script = script;
    this.direction = direction;
    this.stages = [];
    this.globalFeatures = {};
    this.allFeatures = {};
  }
};
var $649970d87335b30f$var$VARIATION_FEATURES = [
  "rvrn"
];
var $649970d87335b30f$var$COMMON_FEATURES = [
  "ccmp",
  "locl",
  "rlig",
  "mark",
  "mkmk"
];
var $649970d87335b30f$var$FRACTIONAL_FEATURES = [
  "frac",
  "numr",
  "dnom"
];
var $649970d87335b30f$var$HORIZONTAL_FEATURES = [
  "calt",
  "clig",
  "liga",
  "rclt",
  "curs",
  "kern"
];
var $649970d87335b30f$var$DIRECTIONAL_FEATURES = {
  ltr: [
    "ltra",
    "ltrm"
  ],
  rtl: [
    "rtla",
    "rtlm"
  ]
};
var $649970d87335b30f$export$2e2bcd8739ae039 = class {
  static plan(plan, glyphs, features) {
    this.planPreprocessing(plan);
    this.planFeatures(plan);
    this.planPostprocessing(plan, features);
    plan.assignGlobalFeatures(glyphs);
    this.assignFeatures(plan, glyphs);
  }
  static planPreprocessing(plan) {
    plan.add({
      global: [
        ...$649970d87335b30f$var$VARIATION_FEATURES,
        ...$649970d87335b30f$var$DIRECTIONAL_FEATURES[plan.direction]
      ],
      local: $649970d87335b30f$var$FRACTIONAL_FEATURES
    });
  }
  static planFeatures(plan) {
  }
  static planPostprocessing(plan, userFeatures) {
    plan.add([
      ...$649970d87335b30f$var$COMMON_FEATURES,
      ...$649970d87335b30f$var$HORIZONTAL_FEATURES
    ]);
    plan.setFeatureOverrides(userFeatures);
  }
  static assignFeatures(plan, glyphs) {
    for (let i3 = 0; i3 < glyphs.length; i3++) {
      let glyph = glyphs[i3];
      if (glyph.codePoints[0] === 8260) {
        let start2 = i3;
        let end2 = i3 + 1;
        while (start2 > 0 && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[start2 - 1].codePoints[0])) {
          glyphs[start2 - 1].features.numr = true;
          glyphs[start2 - 1].features.frac = true;
          start2--;
        }
        while (end2 < glyphs.length && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[end2].codePoints[0])) {
          glyphs[end2].features.dnom = true;
          glyphs[end2].features.frac = true;
          end2++;
        }
        glyph.features.frac = true;
        i3 = end2 - 1;
      }
    }
  }
};
(0, _define_property)($649970d87335b30f$export$2e2bcd8739ae039, "zeroMarkWidths", "AFTER_GPOS");
var $764eb544bbe1ccf0$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("APABAAAAAAAAOAAAAf0BAv7tmi1MxDAUx7vtvjhAgcDgkEgEAnmXEBIMCYaEcygEiqBQ4FAkCE4ikUgMiiBJSAgSiUQSDMn9L9eSl6bddddug9t7yS/trevre+3r27pcNxZiG+yCfdCVv/9LeQxOwRm4AJegD27ALbgD9+ABPJF+z+BN/h7yDj5k/VOWX6SdmU5+wLWknggxDxaS8u0qiiX4uiz9XamQ3wzDMAzDMAzDMAzDVI/h959V/v7BMAzDMAzDMLlyNTNiMSdewVxbiA44B4/guz1qW58VYlMI0WsJ0W+N6kXw0spvPtdwhtkwnGM6uLaV4Xyzg3v3PM9DPfQ/sOg4xPWjipy31P8LTqbU304c/cLCUmWJLNB2Uz2U1KTeRKNmKHVMfbJC+/0loTZRH/W5cvEvBJPMbREkWt3FD1NcqXZBSpuE2Ad0PBehPtNrPtIEdYP+hiRt/V1jIiE69X4NT/uVZI3PUHE9bm5M7ePGdZWy951v7Nn6j8v1WWKP3mt6ttnsigx6VN7Vc0VomSSGqW2mGNP1muZPl7LfjNUaKNFtDGVf2fvE9O7VlBS5j333c5p/eeoOqcs1R/hIqDWLJ7TTlksirVT1SI7l8k4Yp+g3jafGcrU1RM6l9th80XOpnlN97bDNY4i4s61B0Si/ipa0uHMl6zqEjlFfCZm/TM8KmzQDjmuTAQ=="));
var $764eb544bbe1ccf0$var$FEATURES = [
  "isol",
  "fina",
  "fin2",
  "fin3",
  "medi",
  "med2",
  "init"
];
var $764eb544bbe1ccf0$var$ShapingClasses = {
  Non_Joining: 0,
  Left_Joining: 1,
  Right_Joining: 2,
  Dual_Joining: 3,
  Join_Causing: 3,
  ALAPH: 4,
  "DALATH RISH": 5,
  Transparent: 6
};
var $764eb544bbe1ccf0$var$ISOL = "isol";
var $764eb544bbe1ccf0$var$FINA = "fina";
var $764eb544bbe1ccf0$var$FIN2 = "fin2";
var $764eb544bbe1ccf0$var$FIN3 = "fin3";
var $764eb544bbe1ccf0$var$MEDI = "medi";
var $764eb544bbe1ccf0$var$MED2 = "med2";
var $764eb544bbe1ccf0$var$INIT = "init";
var $764eb544bbe1ccf0$var$NONE = null;
var $764eb544bbe1ccf0$var$STATE_TABLE = [
  //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH
  // State 0: prev was U,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 1: prev was R or ISOL/ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 2: prev was D/L in ISOL form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 3: prev was D in FINA form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 4: prev was FINA ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 6: prev was DALATH/RISH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN3,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ]
];
var $764eb544bbe1ccf0$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.add([
      "ccmp",
      "locl"
    ]);
    for (let i3 = 0; i3 < $764eb544bbe1ccf0$var$FEATURES.length; i3++) {
      let feature = $764eb544bbe1ccf0$var$FEATURES[i3];
      plan.addStage(feature, false);
    }
    plan.addStage("mset");
  }
  static assignFeatures(plan, glyphs) {
    super.assignFeatures(plan, glyphs);
    let prev = -1;
    let state2 = 0;
    let actions = [];
    for (let i3 = 0; i3 < glyphs.length; i3++) {
      let curAction, prevAction;
      var glyph = glyphs[i3];
      let type = $764eb544bbe1ccf0$var$getShapingClass(glyph.codePoints[0]);
      if (type === $764eb544bbe1ccf0$var$ShapingClasses.Transparent) {
        actions[i3] = $764eb544bbe1ccf0$var$NONE;
        continue;
      }
      [prevAction, curAction, state2] = $764eb544bbe1ccf0$var$STATE_TABLE[state2][type];
      if (prevAction !== $764eb544bbe1ccf0$var$NONE && prev !== -1) actions[prev] = prevAction;
      actions[i3] = curAction;
      prev = i3;
    }
    for (let index3 = 0; index3 < glyphs.length; index3++) {
      let feature;
      var glyph = glyphs[index3];
      if (feature = actions[index3]) glyph.features[feature] = true;
    }
  }
};
function $764eb544bbe1ccf0$var$getShapingClass(codePoint) {
  let res = $764eb544bbe1ccf0$var$trie.get(codePoint);
  if (res) return res - 1;
  let category = (0, $747425b437e121da$export$410364bbb673ddbc)(codePoint);
  if (category === "Mn" || category === "Me" || category === "Cf") return $764eb544bbe1ccf0$var$ShapingClasses.Transparent;
  return $764eb544bbe1ccf0$var$ShapingClasses.Non_Joining;
}
var $85d408632270248b$export$2e2bcd8739ae039 = class {
  reset(options = {}, index3 = 0) {
    this.options = options;
    this.flags = options.flags || {};
    this.markAttachmentType = options.markAttachmentType || 0;
    this.index = index3;
  }
  get cur() {
    return this.glyphs[this.index] || null;
  }
  shouldIgnore(glyph) {
    return this.flags.ignoreMarks && glyph.isMark || this.flags.ignoreBaseGlyphs && glyph.isBase || this.flags.ignoreLigatures && glyph.isLigature || this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType;
  }
  move(dir) {
    this.index += dir;
    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) this.index += dir;
    if (0 > this.index || this.index >= this.glyphs.length) return null;
    return this.glyphs[this.index];
  }
  next() {
    return this.move(1);
  }
  prev() {
    return this.move(-1);
  }
  peek(count = 1) {
    let idx = this.index;
    let res = this.increment(count);
    this.index = idx;
    return res;
  }
  peekIndex(count = 1) {
    let idx = this.index;
    this.increment(count);
    let res = this.index;
    this.index = idx;
    return res;
  }
  increment(count = 1) {
    let dir = count < 0 ? -1 : 1;
    count = Math.abs(count);
    while (count--) this.move(dir);
    return this.glyphs[this.index];
  }
  constructor(glyphs, options) {
    this.glyphs = glyphs;
    this.reset(options);
  }
};
var $a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS = [
  "DFLT",
  "dflt",
  "latn"
];
var $a83b9c36aaa94fd3$export$2e2bcd8739ae039 = class {
  findScript(script) {
    if (this.table.scriptList == null) return null;
    if (!Array.isArray(script)) script = [
      script
    ];
    for (let s2 of script) for (let entry of this.table.scriptList) {
      if (entry.tag === s2) return entry;
    }
    return null;
  }
  selectScript(script, language, direction) {
    let changed = false;
    let entry;
    if (!this.script || script !== this.scriptTag) {
      entry = this.findScript(script);
      if (!entry) entry = this.findScript($a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS);
      if (!entry) return this.scriptTag;
      this.scriptTag = entry.tag;
      this.script = entry.script;
      this.language = null;
      this.languageTag = null;
      changed = true;
    }
    if (!direction || direction !== this.direction) this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    if (language && language.length < 4) language += " ".repeat(4 - language.length);
    if (!language || language !== this.languageTag) {
      this.language = null;
      for (let lang of this.script.langSysRecords) if (lang.tag === language) {
        this.language = lang.langSys;
        this.languageTag = lang.tag;
        break;
      }
      if (!this.language) {
        this.language = this.script.defaultLangSys;
        this.languageTag = null;
      }
      changed = true;
    }
    if (changed) {
      this.features = {};
      if (this.language) for (let featureIndex of this.language.featureIndexes) {
        let record = this.table.featureList[featureIndex];
        let substituteFeature = this.substituteFeatureForVariations(featureIndex);
        this.features[record.tag] = substituteFeature || record.feature;
      }
    }
    return this.scriptTag;
  }
  lookupsForFeatures(userFeatures = [], exclude) {
    let lookups = [];
    for (let tag of userFeatures) {
      let feature = this.features[tag];
      if (!feature) continue;
      for (let lookupIndex of feature.lookupListIndexes) {
        if (exclude && exclude.indexOf(lookupIndex) !== -1) continue;
        lookups.push({
          feature: tag,
          index: lookupIndex,
          lookup: this.table.lookupList.get(lookupIndex)
        });
      }
    }
    lookups.sort((a3, b2) => a3.index - b2.index);
    return lookups;
  }
  substituteFeatureForVariations(featureIndex) {
    if (this.variationsIndex === -1) return null;
    let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];
    let substitutions = record.featureTableSubstitution.substitutions;
    for (let substitution of substitutions) {
      if (substitution.featureIndex === featureIndex) return substitution.alternateFeatureTable;
    }
    return null;
  }
  findVariationsIndex(coords) {
    let variations = this.table.featureVariations;
    if (!variations) return -1;
    let records = variations.featureVariationRecords;
    for (let i3 = 0; i3 < records.length; i3++) {
      let conditions = records[i3].conditionSet.conditionTable;
      if (this.variationConditionsMatch(conditions, coords)) return i3;
    }
    return -1;
  }
  variationConditionsMatch(conditions, coords) {
    return conditions.every((condition) => {
      let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;
      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;
    });
  }
  applyFeatures(userFeatures, glyphs, advances) {
    let lookups = this.lookupsForFeatures(userFeatures);
    this.applyLookups(lookups, glyphs, advances);
  }
  applyLookups(lookups, glyphs, positions) {
    this.glyphs = glyphs;
    this.positions = positions;
    this.glyphIterator = new (0, $85d408632270248b$export$2e2bcd8739ae039)(glyphs);
    for (let { feature, lookup: lookup4 } of lookups) {
      this.currentFeature = feature;
      this.glyphIterator.reset(lookup4.flags);
      while (this.glyphIterator.index < glyphs.length) {
        if (!(feature in this.glyphIterator.cur.features)) {
          this.glyphIterator.next();
          continue;
        }
        for (let table of lookup4.subTables) {
          let res = this.applyLookup(lookup4.lookupType, table);
          if (res) break;
        }
        this.glyphIterator.next();
      }
    }
  }
  applyLookup(lookup4, table) {
    throw new Error("applyLookup must be implemented by subclasses");
  }
  applyLookupList(lookupRecords) {
    let options = this.glyphIterator.options;
    let glyphIndex = this.glyphIterator.index;
    for (let lookupRecord of lookupRecords) {
      this.glyphIterator.reset(options, glyphIndex);
      this.glyphIterator.increment(lookupRecord.sequenceIndex);
      let lookup4 = this.table.lookupList.get(lookupRecord.lookupListIndex);
      this.glyphIterator.reset(lookup4.flags, this.glyphIterator.index);
      for (let table of lookup4.subTables) {
        if (this.applyLookup(lookup4.lookupType, table)) break;
      }
    }
    this.glyphIterator.reset(options, glyphIndex);
    return true;
  }
  coverageIndex(coverage, glyph) {
    if (glyph == null) glyph = this.glyphIterator.cur.id;
    switch (coverage.version) {
      case 1:
        return coverage.glyphs.indexOf(glyph);
      case 2:
        for (let range2 of coverage.rangeRecords) {
          if (range2.start <= glyph && glyph <= range2.end) return range2.startCoverageIndex + glyph - range2.start;
        }
        break;
    }
    return -1;
  }
  match(sequenceIndex, sequence, fn, matched) {
    let pos = this.glyphIterator.index;
    let glyph = this.glyphIterator.increment(sequenceIndex);
    let idx = 0;
    while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {
      if (matched) matched.push(this.glyphIterator.index);
      idx++;
      glyph = this.glyphIterator.next();
    }
    this.glyphIterator.index = pos;
    if (idx < sequence.length) return false;
    return matched || true;
  }
  sequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);
  }
  sequenceMatchIndices(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => {
      if (!(this.currentFeature in glyph.features)) return false;
      return component === glyph.id;
    }, []);
  }
  coverageSequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (coverage, glyph) => this.coverageIndex(coverage, glyph.id) >= 0);
  }
  getClassID(glyph, classDef) {
    switch (classDef.version) {
      case 1:
        let i3 = glyph - classDef.startGlyph;
        if (i3 >= 0 && i3 < classDef.classValueArray.length) return classDef.classValueArray[i3];
        break;
      case 2:
        for (let range2 of classDef.classRangeRecord) {
          if (range2.start <= glyph && glyph <= range2.end) return range2.class;
        }
        break;
    }
    return 0;
  }
  classSequenceMatches(sequenceIndex, sequence, classDef) {
    return this.match(sequenceIndex, sequence, (classID, glyph) => classID === this.getClassID(glyph.id, classDef));
  }
  applyContext(table) {
    let index3, set5;
    switch (table.version) {
      case 1:
        index3 = this.coverageIndex(table.coverage);
        if (index3 === -1) return false;
        set5 = table.ruleSets[index3];
        for (let rule of set5) {
          if (this.sequenceMatches(1, rule.input)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table.coverage) === -1) return false;
        index3 = this.getClassID(this.glyphIterator.cur.id, table.classDef);
        if (index3 === -1) return false;
        set5 = table.classSet[index3];
        for (let rule of set5) {
          if (this.classSequenceMatches(1, rule.classes, table.classDef)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(0, table.coverages)) return this.applyLookupList(table.lookupRecords);
        break;
    }
    return false;
  }
  applyChainingContext(table) {
    let index3;
    switch (table.version) {
      case 1:
        index3 = this.coverageIndex(table.coverage);
        if (index3 === -1) return false;
        let set5 = table.chainRuleSets[index3];
        for (let rule of set5) {
          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table.coverage) === -1) return false;
        index3 = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
        let rules = table.chainClassSet[index3];
        if (!rules) return false;
        for (let rule of rules) {
          if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, rule.input, table.inputClassDef) && this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table.lookaheadClassDef)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) return this.applyLookupList(table.lookupRecords);
        break;
    }
    return false;
  }
  constructor(font, table) {
    this.font = font;
    this.table = table;
    this.script = null;
    this.scriptTag = null;
    this.language = null;
    this.languageTag = null;
    this.features = {};
    this.lookups = {};
    this.variationsIndex = font._variationProcessor ? this.findVariationsIndex(font._variationProcessor.normalizedCoords) : -1;
    this.selectScript();
    this.glyphs = [];
    this.positions = [];
    this.ligatureID = 1;
    this.currentFeature = null;
  }
};
var $10e7b257e1a9a756$export$2e2bcd8739ae039 = class _$10e7b257e1a9a756$export$2e2bcd8739ae039 {
  get id() {
    return this._id;
  }
  set id(id) {
    this._id = id;
    this.substituted = true;
    let GDEF = this._font.GDEF;
    if (GDEF && GDEF.glyphClassDef) {
      let classID = (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.glyphClassDef);
      this.isBase = classID === 1;
      this.isLigature = classID === 2;
      this.isMark = classID === 3;
      this.markAttachmentType = GDEF.markAttachClassDef ? (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.markAttachClassDef) : 0;
    } else {
      this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
      this.isBase = !this.isMark;
      this.isLigature = this.codePoints.length > 1;
      this.markAttachmentType = 0;
    }
  }
  copy() {
    return new _$10e7b257e1a9a756$export$2e2bcd8739ae039(this._font, this.id, this.codePoints, this.features);
  }
  constructor(font, id, codePoints = [], features) {
    this._font = font;
    this.codePoints = codePoints;
    this.id = id;
    this.features = {};
    if (Array.isArray(features)) for (let i3 = 0; i3 < features.length; i3++) {
      let feature = features[i3];
      this.features[feature] = true;
    }
    else if (typeof features === "object") Object.assign(this.features, features);
    this.ligatureID = null;
    this.ligatureComponent = null;
    this.isLigated = false;
    this.cursiveAttachment = null;
    this.markAttachment = null;
    this.shaperInfo = null;
    this.substituted = false;
    this.isMultiplied = false;
  }
};
var $e1c6bbc8cb416f8c$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.add([
      "ljmo",
      "vjmo",
      "tjmo"
    ], false);
  }
  static assignFeatures(plan, glyphs) {
    let state2 = 0;
    let i3 = 0;
    while (i3 < glyphs.length) {
      let action;
      let glyph = glyphs[i3];
      let code = glyph.codePoints[0];
      let type = $e1c6bbc8cb416f8c$var$getType(code);
      [action, state2] = $e1c6bbc8cb416f8c$var$STATE_TABLE[state2][type];
      switch (action) {
        case $e1c6bbc8cb416f8c$var$DECOMPOSE:
          if (!plan.font.hasGlyphForCodePoint(code)) i3 = $e1c6bbc8cb416f8c$var$decompose(glyphs, i3, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$COMPOSE:
          i3 = $e1c6bbc8cb416f8c$var$compose(glyphs, i3, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$TONE_MARK:
          $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i3, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$INVALID:
          i3 = $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i3, plan.font);
          break;
      }
      i3++;
    }
  }
};
(0, _define_property)($e1c6bbc8cb416f8c$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
var $e1c6bbc8cb416f8c$var$HANGUL_BASE = 44032;
var $e1c6bbc8cb416f8c$var$HANGUL_END = 55204;
var $e1c6bbc8cb416f8c$var$HANGUL_COUNT = $e1c6bbc8cb416f8c$var$HANGUL_END - $e1c6bbc8cb416f8c$var$HANGUL_BASE + 1;
var $e1c6bbc8cb416f8c$var$L_BASE = 4352;
var $e1c6bbc8cb416f8c$var$V_BASE = 4449;
var $e1c6bbc8cb416f8c$var$T_BASE = 4519;
var $e1c6bbc8cb416f8c$var$L_COUNT = 19;
var $e1c6bbc8cb416f8c$var$V_COUNT = 21;
var $e1c6bbc8cb416f8c$var$T_COUNT = 28;
var $e1c6bbc8cb416f8c$var$L_END = $e1c6bbc8cb416f8c$var$L_BASE + $e1c6bbc8cb416f8c$var$L_COUNT - 1;
var $e1c6bbc8cb416f8c$var$V_END = $e1c6bbc8cb416f8c$var$V_BASE + $e1c6bbc8cb416f8c$var$V_COUNT - 1;
var $e1c6bbc8cb416f8c$var$T_END = $e1c6bbc8cb416f8c$var$T_BASE + $e1c6bbc8cb416f8c$var$T_COUNT - 1;
var $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE = 9676;
var $e1c6bbc8cb416f8c$var$isL = (code) => 4352 <= code && code <= 4447 || 43360 <= code && code <= 43388;
var $e1c6bbc8cb416f8c$var$isV = (code) => 4448 <= code && code <= 4519 || 55216 <= code && code <= 55238;
var $e1c6bbc8cb416f8c$var$isT = (code) => 4520 <= code && code <= 4607 || 55243 <= code && code <= 55291;
var $e1c6bbc8cb416f8c$var$isTone = (code) => 12334 <= code && code <= 12335;
var $e1c6bbc8cb416f8c$var$isLVT = (code) => $e1c6bbc8cb416f8c$var$HANGUL_BASE <= code && code <= $e1c6bbc8cb416f8c$var$HANGUL_END;
var $e1c6bbc8cb416f8c$var$isLV = (code) => code - $e1c6bbc8cb416f8c$var$HANGUL_BASE < $e1c6bbc8cb416f8c$var$HANGUL_COUNT && (code - $e1c6bbc8cb416f8c$var$HANGUL_BASE) % $e1c6bbc8cb416f8c$var$T_COUNT === 0;
var $e1c6bbc8cb416f8c$var$isCombiningL = (code) => $e1c6bbc8cb416f8c$var$L_BASE <= code && code <= $e1c6bbc8cb416f8c$var$L_END;
var $e1c6bbc8cb416f8c$var$isCombiningV = (code) => $e1c6bbc8cb416f8c$var$V_BASE <= code && code <= $e1c6bbc8cb416f8c$var$V_END;
var $e1c6bbc8cb416f8c$var$isCombiningT = (code) => $e1c6bbc8cb416f8c$var$T_BASE + 1 && 1 <= code && code <= $e1c6bbc8cb416f8c$var$T_END;
var $e1c6bbc8cb416f8c$var$X = 0;
var $e1c6bbc8cb416f8c$var$L = 1;
var $e1c6bbc8cb416f8c$var$V = 2;
var $e1c6bbc8cb416f8c$var$T = 3;
var $e1c6bbc8cb416f8c$var$LV = 4;
var $e1c6bbc8cb416f8c$var$LVT = 5;
var $e1c6bbc8cb416f8c$var$M = 6;
function $e1c6bbc8cb416f8c$var$getType(code) {
  if ($e1c6bbc8cb416f8c$var$isL(code)) return $e1c6bbc8cb416f8c$var$L;
  if ($e1c6bbc8cb416f8c$var$isV(code)) return $e1c6bbc8cb416f8c$var$V;
  if ($e1c6bbc8cb416f8c$var$isT(code)) return $e1c6bbc8cb416f8c$var$T;
  if ($e1c6bbc8cb416f8c$var$isLV(code)) return $e1c6bbc8cb416f8c$var$LV;
  if ($e1c6bbc8cb416f8c$var$isLVT(code)) return $e1c6bbc8cb416f8c$var$LVT;
  if ($e1c6bbc8cb416f8c$var$isTone(code)) return $e1c6bbc8cb416f8c$var$M;
  return $e1c6bbc8cb416f8c$var$X;
}
var $e1c6bbc8cb416f8c$var$NO_ACTION = 0;
var $e1c6bbc8cb416f8c$var$DECOMPOSE = 1;
var $e1c6bbc8cb416f8c$var$COMPOSE = 2;
var $e1c6bbc8cb416f8c$var$TONE_MARK = 4;
var $e1c6bbc8cb416f8c$var$INVALID = 5;
var $e1c6bbc8cb416f8c$var$STATE_TABLE = [
  //       X                 L                 V                T                  LV                LVT               M
  // State 0: start state
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 1: <L>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 2: <L,V> or <LV>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ],
  // State 3: <L,V,T> or <LVT>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ]
];
function $e1c6bbc8cb416f8c$var$getGlyph(font, code, features) {
  return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, font.glyphForCodePoint(code).id, [
    code
  ], features);
}
function $e1c6bbc8cb416f8c$var$decompose(glyphs, i3, font) {
  let glyph = glyphs[i3];
  let code = glyph.codePoints[0];
  let s2 = code - $e1c6bbc8cb416f8c$var$HANGUL_BASE;
  let t3 = $e1c6bbc8cb416f8c$var$T_BASE + s2 % $e1c6bbc8cb416f8c$var$T_COUNT;
  s2 = s2 / $e1c6bbc8cb416f8c$var$T_COUNT | 0;
  let l2 = $e1c6bbc8cb416f8c$var$L_BASE + s2 / $e1c6bbc8cb416f8c$var$V_COUNT | 0;
  let v2 = $e1c6bbc8cb416f8c$var$V_BASE + s2 % $e1c6bbc8cb416f8c$var$V_COUNT;
  if (!font.hasGlyphForCodePoint(l2) || !font.hasGlyphForCodePoint(v2) || t3 !== $e1c6bbc8cb416f8c$var$T_BASE && !font.hasGlyphForCodePoint(t3)) return i3;
  let ljmo = $e1c6bbc8cb416f8c$var$getGlyph(font, l2, glyph.features);
  ljmo.features.ljmo = true;
  let vjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, v2, glyph.features);
  vjmo.features.vjmo = true;
  let insert2 = [
    ljmo,
    vjmo
  ];
  if (t3 > $e1c6bbc8cb416f8c$var$T_BASE) {
    let tjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, t3, glyph.features);
    tjmo.features.tjmo = true;
    insert2.push(tjmo);
  }
  glyphs.splice(i3, 1, ...insert2);
  return i3 + insert2.length - 1;
}
function $e1c6bbc8cb416f8c$var$compose(glyphs, i3, font) {
  let glyph = glyphs[i3];
  let code = glyphs[i3].codePoints[0];
  let type = $e1c6bbc8cb416f8c$var$getType(code);
  let prev = glyphs[i3 - 1].codePoints[0];
  let prevType = $e1c6bbc8cb416f8c$var$getType(prev);
  let lv, ljmo, vjmo, tjmo;
  if (prevType === $e1c6bbc8cb416f8c$var$LV && type === $e1c6bbc8cb416f8c$var$T) {
    lv = prev;
    tjmo = glyph;
  } else {
    if (type === $e1c6bbc8cb416f8c$var$V) {
      ljmo = glyphs[i3 - 1];
      vjmo = glyph;
    } else {
      ljmo = glyphs[i3 - 2];
      vjmo = glyphs[i3 - 1];
      tjmo = glyph;
    }
    let l2 = ljmo.codePoints[0];
    let v2 = vjmo.codePoints[0];
    if ($e1c6bbc8cb416f8c$var$isCombiningL(l2) && $e1c6bbc8cb416f8c$var$isCombiningV(v2)) lv = $e1c6bbc8cb416f8c$var$HANGUL_BASE + ((l2 - $e1c6bbc8cb416f8c$var$L_BASE) * $e1c6bbc8cb416f8c$var$V_COUNT + (v2 - $e1c6bbc8cb416f8c$var$V_BASE)) * $e1c6bbc8cb416f8c$var$T_COUNT;
  }
  let t3 = tjmo && tjmo.codePoints[0] || $e1c6bbc8cb416f8c$var$T_BASE;
  if (lv != null && (t3 === $e1c6bbc8cb416f8c$var$T_BASE || $e1c6bbc8cb416f8c$var$isCombiningT(t3))) {
    let s2 = lv + (t3 - $e1c6bbc8cb416f8c$var$T_BASE);
    if (font.hasGlyphForCodePoint(s2)) {
      let del = prevType === $e1c6bbc8cb416f8c$var$V ? 3 : 2;
      glyphs.splice(i3 - del + 1, del, $e1c6bbc8cb416f8c$var$getGlyph(font, s2, glyph.features));
      return i3 - del + 1;
    }
  }
  if (ljmo) ljmo.features.ljmo = true;
  if (vjmo) vjmo.features.vjmo = true;
  if (tjmo) tjmo.features.tjmo = true;
  if (prevType === $e1c6bbc8cb416f8c$var$LV) {
    $e1c6bbc8cb416f8c$var$decompose(glyphs, i3 - 1, font);
    return i3 + 1;
  }
  return i3;
}
function $e1c6bbc8cb416f8c$var$getLength(code) {
  switch ($e1c6bbc8cb416f8c$var$getType(code)) {
    case $e1c6bbc8cb416f8c$var$LV:
    case $e1c6bbc8cb416f8c$var$LVT:
      return 1;
    case $e1c6bbc8cb416f8c$var$V:
      return 2;
    case $e1c6bbc8cb416f8c$var$T:
      return 3;
  }
}
function $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i3, font) {
  let glyph = glyphs[i3];
  let code = glyphs[i3].codePoints[0];
  if (font.glyphForCodePoint(code).advanceWidth === 0) return;
  let prev = glyphs[i3 - 1].codePoints[0];
  let len = $e1c6bbc8cb416f8c$var$getLength(prev);
  glyphs.splice(i3, 1);
  return glyphs.splice(i3 - len, 0, glyph);
}
function $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i3, font) {
  let glyph = glyphs[i3];
  let code = glyphs[i3].codePoints[0];
  if (font.hasGlyphForCodePoint($e1c6bbc8cb416f8c$var$DOTTED_CIRCLE)) {
    let dottedCircle = $e1c6bbc8cb416f8c$var$getGlyph(font, $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE, glyph.features);
    let idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i3 : i3 + 1;
    glyphs.splice(idx, 0, dottedCircle);
    i3++;
  }
  return i3;
}
var $4b0735ca6c692ea5$exports = {};
$4b0735ca6c692ea5$exports = JSON.parse('{"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,14,15,16,17],[0,0,0,18,19,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,28,29,30,31,32,33,0,34,0,0,35,36,0,0,37,0],[0,0,0,38,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,39,0,0,0,40,41,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,12,43,0,0,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,0,43,0,0,0,0],[0,0,0,45,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,50,0,0,51,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0],[0,0,0,53,54,55,56,57,58,0,59,0,0,60,61,0,0,62,0],[0,0,0,4,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,63,64,0,0,40,41,0,9,0,10,0,0,0,42,0,63,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,0,2,16,0],[0,0,0,18,65,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,0,0],[0,0,0,69,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,73,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,75,0,0,0,76,77,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,25,79,0,0,0,0],[0,0,0,18,19,20,74,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,81,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,86,0,0,87,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,0],[0,0,0,18,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,89,90,0,0,76,77,0,23,0,24,0,0,0,78,0,89,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,0,0],[0,0,0,94,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,96,0,0,0,97,98,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,35,100,0,0,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,102,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,107,0,0,108,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,109,0,0,0,0,0,0,0,0],[0,0,0,28,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,110,111,0,0,97,98,0,33,0,34,0,0,0,99,0,110,0,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,0,0],[0,0,0,0,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,0,0,115,116,117,118,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,39,0,122,0,123,123,8,9,0,10,0,0,0,42,0,39,0,0],[0,124,64,0,0,0,0,0,0,0,0,0,0,0,0,0,124,0,0],[0,39,0,0,0,121,125,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,126,126,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,47,47,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,128,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,129,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,50,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,134,0,0,0,0,0,0,0,0],[0,0,0,135,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,136,0,0,0,137,138,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,60,140,0,0,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,0,140,0,0,0,0],[0,0,0,142,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,147,0,0,148,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,149,0,0,0,0,0,0,0,0],[0,0,0,53,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,150,151,0,0,137,138,0,58,0,59,0,0,0,139,0,150,0,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,0,0],[0,0,0,155,116,156,157,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,75,3,4,5,159,160,8,161,0,162,0,11,12,163,0,75,16,0],[0,0,0,0,0,40,164,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,0,165,0,0,0,0],[0,124,64,0,0,40,164,0,9,0,10,0,0,0,42,0,124,0,0],[0,0,0,0,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,167,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,168,0,0,0,0,0,0,0,0],[0,0,0,0,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,0,79,0,0,0,0],[0,0,0,169,170,171,172,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,75,0,176,0,177,177,22,23,0,24,0,0,0,78,0,75,0,0],[0,178,90,0,0,0,0,0,0,0,0,0,0,0,0,0,178,0,0],[0,75,0,0,0,175,179,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,180,180,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,83,83,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,182,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,183,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,86,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,188,0,0,0,0,0,0,0,0],[0,0,0,189,170,190,191,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,76,193,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,0,194,0,0,0,0],[0,178,90,0,0,76,193,0,23,0,24,0,0,0,78,0,178,0,0],[0,0,0,0,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,195,196,197,198,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,96,0,202,0,203,203,32,33,0,34,0,0,0,99,0,96,0,0],[0,204,111,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0],[0,96,0,0,0,201,205,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,206,206,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,104,104,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,208,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,209,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,107,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,0,0,0],[0,0,0,215,196,216,217,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,97,219,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,0,220,0,0,0,0],[0,204,111,0,0,97,219,0,33,0,34,0,0,0,99,0,204,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,223,0,0,0,40,224,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,119,225,0,0,0,0],[0,0,0,115,116,117,222,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,115,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,226,64,0,0,40,224,0,9,0,10,0,0,0,42,0,226,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,39,0,0,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,44,44,8,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,227,0,228,229,0,9,0,10,0,0,230,0,0,0,0,0],[0,39,0,122,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,231,231,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,131,131,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,234,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,235,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,0,0,240,241,242,243,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,136,0,247,0,248,248,57,58,0,59,0,0,0,139,0,136,0,0],[0,249,151,0,0,0,0,0,0,0,0,0,0,0,0,0,249,0,0],[0,136,0,0,0,246,250,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,251,251,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,144,144,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,253,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,254,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,147,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,259,0,0,0,0,0,0,0,0],[0,0,0,260,241,261,262,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,137,264,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,0,265,0,0,0,0],[0,249,151,0,0,137,264,0,58,0,59,0,0,0,139,0,249,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,158,225,0,0,0,0],[0,0,0,155,116,156,222,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,155,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,43,266,266,8,161,0,24,0,0,12,267,0,0,0,0],[0,75,0,176,43,268,268,269,161,0,24,0,0,0,267,0,75,0,0],[0,0,0,0,0,270,0,0,271,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,272,0,0,0,0,0,0,0,0],[0,273,274,0,0,40,41,0,9,0,10,0,0,0,42,0,273,0,0],[0,0,0,40,0,123,123,8,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,121,275,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,276,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,279,0,0,0,76,280,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,173,281,0,0,0,0],[0,0,0,169,170,171,278,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,169,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,282,90,0,0,76,280,0,23,0,24,0,0,0,78,0,282,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,75,0,0,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,80,80,22,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,283,0,284,285,0,23,0,24,0,0,286,0,0,0,0,0],[0,75,0,176,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,287,287,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,288,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,185,185,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,290,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,291,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,192,281,0,0,0,0],[0,0,0,189,170,190,278,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,189,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,76,0,177,177,22,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,175,296,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,299,0,0,0,97,300,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,199,301,0,0,0,0],[0,0,0,195,196,197,298,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,195,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,302,111,0,0,97,300,0,33,0,34,0,0,0,99,0,302,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,96,0,0,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,101,101,32,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,303,0,304,305,0,33,0,34,0,0,306,0,0,0,0,0],[0,96,0,202,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,307,307,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,308,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,211,211,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,310,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,311,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,218,301,0,0,0,0],[0,0,0,215,196,216,298,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,215,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,97,0,203,203,32,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,201,316,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,0,225,0,0,0,0],[0,0,0,317,318,319,320,8,9,0,10,0,0,321,322,0,0,16,0],[0,223,0,323,0,123,123,8,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,0,0,121,324,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,325,318,326,327,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,64,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,230,0,0,0,0,0],[0,0,0,227,0,228,121,0,9,0,10,0,0,230,0,0,0,0,0],[0,0,0,227,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,0],[0,0,0,0,0,329,329,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,330,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,237,237,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,332,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,333,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,337,0,0,0,137,338,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,244,339,0,0,0,0],[0,0,0,240,241,242,336,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,240,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,340,151,0,0,137,338,0,58,0,59,0,0,0,139,0,340,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,136,0,0,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,141,141,57,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,341,0,342,343,0,58,0,59,0,0,344,0,0,0,0,0],[0,136,0,247,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,345,345,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,346,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,256,256,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,348,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,349,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,263,339,0,0,0,0],[0,0,0,260,241,261,336,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,260,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,137,0,248,248,57,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,246,354,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,126,126,8,23,0,0,0,0,0,0,0,0,0,0],[0,355,90,0,0,121,125,0,9,0,10,0,0,0,42,0,355,0,0],[0,0,0,0,0,356,356,269,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,357,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,270,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,363,0,0,0,0,0,0,0,0],[0,0,0,364,116,365,366,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,40,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,0,281,0,0,0,0],[0,0,0,369,370,371,372,22,23,0,24,0,0,373,374,0,0,27,0],[0,279,0,375,0,177,177,22,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,0,0,175,376,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,377,370,378,379,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,90,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,286,0,0,0,0,0],[0,0,0,283,0,284,175,0,23,0,24,0,0,286,0,0,0,0,0],[0,0,0,283,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,82,0,0],[0,0,0,0,0,381,381,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,382,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,293,293,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,384,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,385,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,76,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,0,301,0,0,0,0],[0,0,0,387,388,389,390,32,33,0,34,0,0,391,392,0,0,37,0],[0,299,0,393,0,203,203,32,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,0,0,201,394,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,395,388,396,397,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,111,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,306,0,0,0,0,0],[0,0,0,303,0,304,201,0,33,0,34,0,0,306,0,0,0,0,0],[0,0,0,303,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,0,0],[0,0,0,0,0,399,399,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,400,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,313,313,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,402,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,403,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,97,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,407,0,0,0,40,408,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,321,409,0,0,0,0],[0,0,0,317,318,319,406,8,9,0,10,0,0,321,322,0,0,16,0],[0,0,0,317,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,410,64,0,0,40,408,0,9,0,10,0,0,0,42,0,410,0,0],[0,223,0,0,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,323,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,328,409,0,0,0,0],[0,0,0,325,318,326,406,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,325,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,0,0,0,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0],[0,0,0,0,0,411,411,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,412,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,413,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,0,339,0,0,0,0],[0,0,0,414,415,416,417,57,58,0,59,0,0,418,419,0,0,62,0],[0,337,0,420,0,248,248,57,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,0,0,246,421,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,422,415,423,424,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,151,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,344,0,0,0,0,0],[0,0,0,341,0,342,246,0,58,0,59,0,0,344,0,0,0,0,0],[0,0,0,341,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,143,0,0],[0,0,0,0,0,426,426,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,427,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,351,351,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,429,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,430,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,137,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,432,116,433,434,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,0,0,180,180,269,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,359,359,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,437,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,438,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,443,274,0,0,0,0,0,0,0,0,0,0,0,0,0,443,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,367,225,0,0,0,0],[0,0,0,364,116,365,445,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,364,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,448,0,0,0,76,449,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,373,450,0,0,0,0],[0,0,0,369,370,371,447,22,23,0,24,0,0,373,374,0,0,27,0],[0,0,0,369,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,451,90,0,0,76,449,0,23,0,24,0,0,0,78,0,451,0,0],[0,279,0,0,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,375,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,380,450,0,0,0,0],[0,0,0,377,370,378,447,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,377,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,0,0,0,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,184,0,0],[0,0,0,0,0,452,452,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,453,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,454,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,457,0,0,0,97,458,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,391,459,0,0,0,0],[0,0,0,387,388,389,456,32,33,0,34,0,0,391,392,0,0,37,0],[0,0,0,387,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,460,111,0,0,97,458,0,33,0,34,0,0,0,99,0,460,0,0],[0,299,0,0,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,393,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,398,459,0,0,0,0],[0,0,0,395,388,396,456,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,395,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,0,0,0,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,210,0,0],[0,0,0,0,0,461,461,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,462,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,463,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,0,409,0,0,0,0],[0,0,0,464,465,466,467,8,9,0,10,0,0,468,469,0,0,16,0],[0,407,0,470,0,123,123,8,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,0,0,121,471,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,472,465,473,474,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,0,0,0,0,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,236,0,0],[0,0,0,0,0,0,476,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,479,0,0,0,137,480,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,418,481,0,0,0,0],[0,0,0,414,415,416,478,57,58,0,59,0,0,418,419,0,0,62,0],[0,0,0,414,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,482,151,0,0,137,480,0,58,0,59,0,0,0,139,0,482,0,0],[0,337,0,0,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,420,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,425,481,0,0,0,0],[0,0,0,422,415,423,478,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,422,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,0,0,0,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0],[0,0,0,0,0,483,483,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,484,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,485,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,435,225,0,0,0,0],[0,0,0,432,116,433,445,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,432,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,486,486,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,487,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,440,440,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,489,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,490,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,495,0,496,497,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,0,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,0,225,0,0,0,0],[0,0,0,0,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,0,450,0,0,0,0],[0,0,0,499,500,501,502,22,23,0,24,0,0,503,504,0,0,27,0],[0,448,0,505,0,177,177,22,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,0,0,175,506,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,507,500,508,509,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,0,0,0,0,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,292,0,0],[0,0,0,0,0,0,511,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,0,459,0,0,0,0],[0,0,0,512,513,514,515,32,33,0,34,0,0,516,517,0,0,37,0],[0,457,0,518,0,203,203,32,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,0,0,201,519,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,520,513,521,522,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,0,0,0,0,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,312,0,0],[0,0,0,0,0,0,524,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,527,0,0,0,40,528,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,468,529,0,0,0,0],[0,0,0,464,465,466,526,8,9,0,10,0,0,468,469,0,0,16,0],[0,0,0,464,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,530,64,0,0,40,528,0,9,0,10,0,0,0,42,0,530,0,0],[0,407,0,0,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,470,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,475,529,0,0,0,0],[0,0,0,472,465,473,526,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,472,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0],[0,0,0,0,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,0,481,0,0,0,0],[0,0,0,531,532,533,534,57,58,0,59,0,0,535,536,0,0,62,0],[0,479,0,537,0,248,248,57,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,0,0,246,538,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,539,532,540,541,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,0,0,0,0,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,350,0,0],[0,0,0,0,0,0,543,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,358,0,0],[0,0,0,0,0,544,544,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,545,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,492,492,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,547,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,548,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,274,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,498,0,0,0,0,0],[0,0,0,495,0,496,368,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,495,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,553,0,0,0,76,554,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,503,555,0,0,0,0],[0,0,0,499,500,501,552,22,23,0,24,0,0,503,504,0,0,27,0],[0,0,0,499,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,556,90,0,0,76,554,0,23,0,24,0,0,0,78,0,556,0,0],[0,448,0,0,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,505,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,510,555,0,0,0,0],[0,0,0,507,500,508,552,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,507,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,559,0,0,0,97,560,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,516,561,0,0,0,0],[0,0,0,512,513,514,558,32,33,0,34,0,0,516,517,0,0,37,0],[0,0,0,512,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,562,111,0,0,97,560,0,33,0,34,0,0,0,99,0,562,0,0],[0,457,0,0,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,518,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,523,561,0,0,0,0],[0,0,0,520,513,521,558,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,520,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,0,0],[0,0,0,0,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,0,529,0,0,0,0],[0,0,0,563,66,564,565,8,9,0,10,0,0,566,68,0,0,16,0],[0,527,0,567,0,123,123,8,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,0,0,121,568,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,569,66,570,571,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,575,0,0,0,137,576,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,535,577,0,0,0,0],[0,0,0,531,532,533,574,57,58,0,59,0,0,535,536,0,0,62,0],[0,0,0,531,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,578,151,0,0,137,576,0,58,0,59,0,0,0,139,0,578,0,0],[0,479,0,0,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,537,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,542,577,0,0,0,0],[0,0,0,539,532,540,574,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,539,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,137,0,0],[0,0,0,0,0,0,0,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,439,0,0],[0,0,0,0,0,579,579,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,580,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,581,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,0,555,0,0,0,0],[0,0,0,582,91,583,584,22,23,0,24,0,0,585,93,0,0,27,0],[0,553,0,586,0,177,177,22,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,0,0,175,587,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,588,91,589,590,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,0,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,0,561,0,0,0,0],[0,0,0,592,112,593,594,32,33,0,34,0,0,595,114,0,0,37,0],[0,559,0,596,0,203,203,32,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,0,0,201,597,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,598,112,599,600,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,566,165,0,0,0,0],[0,0,0,563,66,564,67,8,9,0,10,0,0,566,68,0,0,16,0],[0,0,0,563,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,527,0,0,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,567,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,572,165,0,0,0,0],[0,0,0,569,66,570,67,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,569,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,0,577,0,0,0,0],[0,0,0,603,152,604,605,57,58,0,59,0,0,606,154,0,0,62,0],[0,575,0,607,0,248,248,57,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,0,0,246,608,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,609,152,610,611,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,0,0,0,0,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,491,0,0],[0,0,0,0,0,0,613,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,585,194,0,0,0,0],[0,0,0,582,91,583,92,22,23,0,24,0,0,585,93,0,0,27,0],[0,0,0,582,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,553,0,0,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,586,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,591,194,0,0,0,0],[0,0,0,588,91,589,92,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,588,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,595,220,0,0,0,0],[0,0,0,592,112,593,113,32,33,0,34,0,0,595,114,0,0,37,0],[0,0,0,592,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,559,0,0,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,596,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,601,220,0,0,0,0],[0,0,0,598,112,599,113,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,598,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,606,265,0,0,0,0],[0,0,0,603,152,604,153,57,58,0,59,0,0,606,154,0,0,62,0],[0,0,0,603,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,575,0,0,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,607,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,612,265,0,0,0,0],[0,0,0,609,152,610,153,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,609,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,549,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0]],"accepting":[false,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,false,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,false,false,true,false,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,false,false,true,true,false,false,true,true,true,false,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,false,false,false,false,false,false,false,true,true,false,false,true,true,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,false,true,true,false,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,false,true,true,true,true,true,false,true,true,false,true,true,true],"tags":[[],["broken_cluster"],["consonant_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],[],["broken_cluster"],["symbol_cluster"],[],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["symbol_cluster"],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],[],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],[],[],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],["consonant_syllable"],["vowel_syllable"],["standalone_cluster"]]}');
var $aa333a9607471296$exports = {};
$aa333a9607471296$exports = JSON.parse('{"categories":["O","IND","S","GB","B","FM","CGJ","VMAbv","VMPst","VAbv","VPst","CMBlw","VPre","VBlw","H","VMBlw","CMAbv","MBlw","CS","R","SUB","MPst","MPre","FAbv","FPst","FBlw","null","SMAbv","SMBlw","VMPre","ZWNJ","ZWJ","WJ","M","VS","N","HN","MAbv"],"decompositions":{"2507":[2503,2494],"2508":[2503,2519],"2888":[2887,2902],"2891":[2887,2878],"2892":[2887,2903],"3018":[3014,3006],"3019":[3015,3006],"3020":[3014,3031],"3144":[3142,3158],"3264":[3263,3285],"3271":[3270,3285],"3272":[3270,3286],"3274":[3270,3266],"3275":[3270,3266,3285],"3402":[3398,3390],"3403":[3399,3390],"3404":[3398,3415],"3546":[3545,3530],"3548":[3545,3535],"3549":[3545,3535,3530],"3550":[3545,3551],"3635":[3661,3634],"3763":[3789,3762],"3955":[3953,3954],"3957":[3953,3956],"3958":[4018,3968],"3959":[4018,3953,3968],"3960":[4019,3968],"3961":[4019,3953,3968],"3969":[3953,3968],"6971":[6970,6965],"6973":[6972,6965],"6976":[6974,6965],"6977":[6975,6965],"6979":[6978,6965],"69934":[69937,69927],"69935":[69938,69927],"70475":[70471,70462],"70476":[70471,70487],"70843":[70841,70842],"70844":[70841,70832],"70846":[70841,70845],"71098":[71096,71087],"71099":[71097,71087]},"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,3,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,17,18,11,19,20,21,22,0,0,0,23,0,0,2,0,0,24,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,27,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,39,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,49,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,53,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0]],"accepting":[false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true],"tags":[[],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["symbol_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["virama_terminated_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["number_joiner_terminated_cluster"],["standard_cluster"],["standard_cluster"],["numeral_cluster"]]}');
var $90a9d3398ee54fe5$export$a513ea61a7bee91c = {
  X: 1,
  C: 2,
  V: 4,
  N: 8,
  H: 16,
  ZWNJ: 32,
  ZWJ: 64,
  M: 128,
  SM: 256,
  VD: 512,
  A: 1024,
  Placeholder: 2048,
  Dotted_Circle: 4096,
  RS: 8192,
  Coeng: 16384,
  Repha: 32768,
  Ra: 65536,
  CM: 131072,
  Symbol: 262144
  // Avagraha, etc that take marks (SM,A,VD).
};
var $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0 = {
  Start: 1,
  Ra_To_Become_Reph: 2,
  Pre_M: 4,
  Pre_C: 8,
  Base_C: 16,
  After_Main: 32,
  Above_C: 64,
  Before_Sub: 128,
  Below_C: 256,
  After_Sub: 512,
  Before_Post: 1024,
  Post_C: 2048,
  After_Post: 4096,
  Final_C: 8192,
  SMVD: 16384,
  End: 32768
};
var $90a9d3398ee54fe5$export$8519deaa7de2b07 = $90a9d3398ee54fe5$export$a513ea61a7bee91c.C | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Ra | $90a9d3398ee54fe5$export$a513ea61a7bee91c.CM | $90a9d3398ee54fe5$export$a513ea61a7bee91c.V | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Placeholder | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Dotted_Circle;
var $90a9d3398ee54fe5$export$bbcd928767338e0d = $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWJ | $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWNJ;
var $90a9d3398ee54fe5$export$ca9599b2a300afc = $90a9d3398ee54fe5$export$a513ea61a7bee91c.H | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Coeng;
var $90a9d3398ee54fe5$export$e99d119da76a0fc5 = {
  Default: {
    hasOldSpec: false,
    virama: 0,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Devanagari: {
    hasOldSpec: true,
    virama: 2381,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Bengali: {
    hasOldSpec: true,
    virama: 2509,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gurmukhi: {
    hasOldSpec: true,
    virama: 2637,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gujarati: {
    hasOldSpec: true,
    virama: 2765,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Oriya: {
    hasOldSpec: true,
    virama: 2893,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Tamil: {
    hasOldSpec: true,
    virama: 3021,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Telugu: {
    hasOldSpec: true,
    virama: 3149,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Explicit",
    blwfMode: "Post_Only"
  },
  Kannada: {
    hasOldSpec: true,
    virama: 3277,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Post_Only"
  },
  Malayalam: {
    hasOldSpec: true,
    virama: 3405,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Log_Repha",
    blwfMode: "Pre_And_Post"
  },
  // Handled by UniversalShaper
  // Sinhala: {
  //   hasOldSpec: false,
  //   virama: 0x0DCA,
  //   basePos: 'Last_Sinhala',
  //   rephPos: POSITIONS.After_Main,
  //   rephMode: 'Explicit',
  //   blwfMode: 'Pre_And_Post'
  // },
  Khmer: {
    hasOldSpec: false,
    virama: 6098,
    basePos: "First",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph,
    rephMode: "Vis_Repha",
    blwfMode: "Pre_And_Post"
  }
};
var $90a9d3398ee54fe5$export$f647c9cfdd77d95a = {
  // Khmer
  6078: [
    6081,
    6078
  ],
  6079: [
    6081,
    6079
  ],
  6080: [
    6081,
    6080
  ],
  6084: [
    6081,
    6084
  ],
  6085: [
    6081,
    6085
  ]
};
var { decompositions: $7826f90f6f0cecc9$var$decompositions } = (0, $parcel$interopDefault2($aa333a9607471296$exports));
var $7826f90f6f0cecc9$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("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"));
var $7826f90f6f0cecc9$var$stateMachine = new (0, import_dfa.default)((0, $parcel$interopDefault2($4b0735ca6c692ea5$exports)));
var $7826f90f6f0cecc9$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.addStage($7826f90f6f0cecc9$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp"
    ]);
    plan.addStage($7826f90f6f0cecc9$var$initialReordering);
    plan.addStage("nukt");
    plan.addStage("akhn");
    plan.addStage("rphf", false);
    plan.addStage("rkrf");
    plan.addStage("pref", false);
    plan.addStage("blwf", false);
    plan.addStage("abvf", false);
    plan.addStage("half", false);
    plan.addStage("pstf", false);
    plan.addStage("vatu");
    plan.addStage("cjct");
    plan.addStage("cfar", false);
    plan.addStage($7826f90f6f0cecc9$var$finalReordering);
    plan.addStage({
      local: [
        "init"
      ],
      global: [
        "pres",
        "abvs",
        "blws",
        "psts",
        "haln",
        "dist",
        "abvm",
        "blwm",
        "calt",
        "clig"
      ]
    });
    plan.unicodeScript = $130d1a642ebcd2b7$export$ce50e82f12a827a4(plan.script);
    plan.indicConfig = (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5)[plan.unicodeScript] || (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5).Default;
    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== "2";
  }
  static assignFeatures(plan, glyphs) {
    for (let i3 = glyphs.length - 1; i3 >= 0; i3--) {
      let codepoint = glyphs[i3].codePoints[0];
      let d2 = (0, $90a9d3398ee54fe5$export$f647c9cfdd77d95a)[codepoint] || $7826f90f6f0cecc9$var$decompositions[codepoint];
      if (d2) {
        let decomposed = d2.map((c3) => {
          let g2 = plan.font.glyphForCodePoint(c3);
          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g2.id, [
            c3
          ], glyphs[i3].features);
        });
        glyphs.splice(i3, 1, ...decomposed);
      }
    }
  }
};
(0, _define_property)($7826f90f6f0cecc9$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
function $7826f90f6f0cecc9$var$indicCategory(glyph) {
  return $7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) >> 8;
}
function $7826f90f6f0cecc9$var$indicPosition(glyph) {
  return 1 << ($7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) & 255);
}
var $7826f90f6f0cecc9$var$IndicInfo = class {
  constructor(category, position, syllableType, syllable) {
    this.category = category;
    this.position = position;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
};
function $7826f90f6f0cecc9$var$setupSyllables(font, glyphs) {
  let syllable = 0;
  let last2 = 0;
  for (let [start2, end2, tags2] of $7826f90f6f0cecc9$var$stateMachine.match(glyphs.map($7826f90f6f0cecc9$var$indicCategory))) {
    if (start2 > last2) {
      ++syllable;
      for (let i3 = last2; i3 < start2; i3++) glyphs[i3].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
    }
    ++syllable;
    for (let i3 = start2; i3 <= end2; i3++) glyphs[i3].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(glyphs[i3]), $7826f90f6f0cecc9$var$indicPosition(glyphs[i3]), tags2[0], syllable);
    last2 = end2 + 1;
  }
  if (last2 < glyphs.length) {
    ++syllable;
    for (let i3 = last2; i3 < glyphs.length; i3++) glyphs[i3].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
  }
}
function $7826f90f6f0cecc9$var$isConsonant(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$8519deaa7de2b07);
}
function $7826f90f6f0cecc9$var$isJoiner(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$bbcd928767338e0d);
}
function $7826f90f6f0cecc9$var$isHalantOrCoeng(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$ca9599b2a300afc);
}
function $7826f90f6f0cecc9$var$wouldSubstitute(glyphs, feature) {
  for (let glyph of glyphs) glyph.features = {
    [feature]: true
  };
  let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;
  GSUB.applyFeatures([
    feature
  ], glyphs);
  return glyphs.length === 1;
}
function $7826f90f6f0cecc9$var$consonantPosition(font, consonant, virama) {
  let glyphs = [
    virama,
    consonant,
    virama
  ];
  if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "blwf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "blwf")) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pstf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pstf")) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pref") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pref")) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
  return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
}
function $7826f90f6f0cecc9$var$initialReordering(font, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features = font._layoutEngine.engine.GSUBProcessor.features;
  let dottedCircle = font.glyphForCodePoint(9676).id;
  let virama = font.glyphForCodePoint(indicConfig.virama).id;
  if (virama) {
    let info = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, virama, [
      indicConfig.virama
    ]);
    for (let i3 = 0; i3 < glyphs.length; i3++) if (glyphs[i3].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) glyphs[i3].shaperInfo.position = $7826f90f6f0cecc9$var$consonantPosition(font, glyphs[i3].copy(), info);
  }
  for (let start2 = 0, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start2 < glyphs.length; start2 = end2, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start2)) {
    let { category, syllableType } = glyphs[start2].shaperInfo;
    if (syllableType === "symbol_cluster" || syllableType === "non_indic_cluster") continue;
    if (syllableType === "broken_cluster" && dottedCircle) {
      let g2 = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, dottedCircle, [
        9676
      ]);
      g2.shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(g2), $7826f90f6f0cecc9$var$indicPosition(g2), glyphs[start2].shaperInfo.syllableType, glyphs[start2].shaperInfo.syllable);
      let i3 = start2;
      while (i3 < end2 && glyphs[i3].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha) i3++;
      glyphs.splice(i3++, 0, g2);
      end2++;
    }
    let base = end2;
    let limit = start2;
    let hasReph = false;
    if (indicConfig.rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && features.rphf && start2 + 3 <= end2 && (indicConfig.rephMode === "Implicit" && !$7826f90f6f0cecc9$var$isJoiner(glyphs[start2 + 2]) || indicConfig.rephMode === "Explicit" && glyphs[start2 + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
      let g2 = [
        glyphs[start2].copy(),
        glyphs[start2 + 1].copy(),
        glyphs[start2 + 2].copy()
      ];
      if ($7826f90f6f0cecc9$var$wouldSubstitute(g2.slice(0, 2), "rphf") || indicConfig.rephMode === "Explicit" && $7826f90f6f0cecc9$var$wouldSubstitute(g2, "rphf")) {
        limit += 2;
        while (limit < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit])) limit++;
        base = start2;
        hasReph = true;
      }
    } else if (indicConfig.rephMode === "Log_Repha" && glyphs[start2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha) {
      limit++;
      while (limit < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit])) limit++;
      base = start2;
      hasReph = true;
    }
    switch (indicConfig.basePos) {
      case "Last": {
        let i3 = end2;
        let seenBelow = false;
        do {
          let info = glyphs[--i3].shaperInfo;
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i3])) {
            if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C && (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C || seenBelow)) {
              base = i3;
              break;
            }
            if (info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C) seenBelow = true;
            base = i3;
          } else if (start2 < i3 && info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ && glyphs[i3 - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) break;
        } while (i3 > limit);
        break;
      }
      case "First":
        base = start2;
        for (let i3 = base + 1; i3 < end2; i3++) if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i3])) glyphs[i3].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
    }
    if (hasReph && base === start2 && limit - base <= 2) hasReph = false;
    for (let i3 = start2; i3 < base; i3++) {
      let info = glyphs[i3].shaperInfo;
      info.position = Math.min((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_C, info.position);
    }
    if (base < end2) glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
    for (let i3 = base + 1; i3 < end2; i3++) if (glyphs[i3].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
      for (let j = i3 + 1; j < end2; j++) if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j])) {
        glyphs[j].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Final_C;
        break;
      }
      break;
    }
    if (hasReph) glyphs[start2].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph;
    if (plan.isOldSpec) {
      let disallowDoubleHalants = plan.unicodeScript !== "Malayalam";
      for (let i3 = base + 1; i3 < end2; i3++) if (glyphs[i3].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) {
        let j;
        for (j = end2 - 1; j > i3; j--) {
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j]) || disallowDoubleHalants && glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) break;
        }
        if (glyphs[j].shaperInfo.category !== (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && j > i3) {
          let t3 = glyphs[i3];
          glyphs.splice(i3, 0, ...glyphs.splice(i3 + 1, j - i3));
          glyphs[j] = t3;
        }
        break;
      }
    }
    let lastPos = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Start;
    for (let i3 = start2; i3 < end2; i3++) {
      let info = glyphs[i3].shaperInfo;
      if (info.category & ((0, $90a9d3398ee54fe5$export$bbcd928767338e0d) | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).RS | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).CM | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc) & info.category)) {
        info.position = lastPos;
        if (info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          for (let j = i3; j > start2; j--) if (glyphs[j - 1].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
            info.position = glyphs[j - 1].shaperInfo.position;
            break;
          }
        }
      } else if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) lastPos = info.position;
    }
    let last2 = base;
    for (let i3 = base + 1; i3 < end2; i3++) {
      if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i3])) {
        for (let j = last2 + 1; j < i3; j++) if (glyphs[j].shaperInfo.position < (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) glyphs[j].shaperInfo.position = glyphs[i3].shaperInfo.position;
        last2 = i3;
      } else if (glyphs[i3].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) last2 = i3;
    }
    let arr = glyphs.slice(start2, end2);
    arr.sort((a3, b2) => a3.shaperInfo.position - b2.shaperInfo.position);
    glyphs.splice(start2, arr.length, ...arr);
    for (let i3 = start2; i3 < end2; i3++) if (glyphs[i3].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
      base = i3;
      break;
    }
    for (let i3 = start2; i3 < end2 && glyphs[i3].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph; i3++) glyphs[i3].features.rphf = true;
    let blwf = !plan.isOldSpec && indicConfig.blwfMode === "Pre_And_Post";
    for (let i3 = start2; i3 < base; i3++) {
      glyphs[i3].features.half = true;
      if (blwf) glyphs[i3].features.blwf = true;
    }
    for (let i3 = base + 1; i3 < end2; i3++) {
      glyphs[i3].features.abvf = true;
      glyphs[i3].features.pstf = true;
      glyphs[i3].features.blwf = true;
    }
    if (plan.isOldSpec && plan.unicodeScript === "Devanagari") {
      for (let i3 = start2; i3 + 1 < base; i3++) if (glyphs[i3].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Ra && glyphs[i3 + 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && (i3 + 1 === base || glyphs[i3 + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
        glyphs[i3].features.blwf = true;
        glyphs[i3 + 1].features.blwf = true;
      }
    }
    let prefLen = 2;
    if (features.pref && base + prefLen < end2)
      for (let i3 = base + 1; i3 + prefLen - 1 < end2; i3++) {
        let g2 = [
          glyphs[i3].copy(),
          glyphs[i3 + 1].copy()
        ];
        if ($7826f90f6f0cecc9$var$wouldSubstitute(g2, "pref")) {
          for (let j = 0; j < prefLen; j++) glyphs[i3++].features.pref = true;
          if (features.cfar) for (; i3 < end2; i3++) glyphs[i3].features.cfar = true;
          break;
        }
      }
    for (let i3 = start2 + 1; i3 < end2; i3++) if ($7826f90f6f0cecc9$var$isJoiner(glyphs[i3])) {
      let nonJoiner = glyphs[i3].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWNJ;
      let j = i3;
      do {
        j--;
        if (nonJoiner) delete glyphs[j].features.half;
      } while (j > start2 && !$7826f90f6f0cecc9$var$isConsonant(glyphs[j]));
    }
  }
}
function $7826f90f6f0cecc9$var$finalReordering(font, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features = font._layoutEngine.engine.GSUBProcessor.features;
  for (let start2 = 0, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start2 < glyphs.length; start2 = end2, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start2)) {
    let tryPref = !!features.pref;
    let base = start2;
    for (; base < end2; base++) if (glyphs[base].shaperInfo.position >= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
      if (tryPref && base + 1 < end2) {
        for (let i3 = base + 1; i3 < end2; i3++) if (glyphs[i3].features.pref) {
          if (!(glyphs[i3].substituted && glyphs[i3].isLigated && !glyphs[i3].isMultiplied)) {
            base = i3;
            while (base < end2 && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[base])) base++;
            glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).BASE_C;
            tryPref = false;
          }
          break;
        }
      }
      if (plan.unicodeScript === "Malayalam") for (let i3 = base + 1; i3 < end2; i3++) {
        while (i3 < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[i3])) i3++;
        if (i3 === end2 || !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[i3])) break;
        i3++;
        while (i3 < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[i3])) i3++;
        if (i3 < end2 && $7826f90f6f0cecc9$var$isConsonant(glyphs[i3]) && glyphs[i3].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C) {
          base = i3;
          glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
        }
      }
      if (start2 < base && glyphs[base].shaperInfo.position > (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) base--;
      break;
    }
    if (base === end2 && start2 < base && glyphs[base - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ) base--;
    if (base < end2) while (start2 < base && glyphs[base].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc))) base--;
    if (start2 + 1 < end2 && start2 < base) {
      let newPos = base === end2 ? base - 2 : base - 1;
      if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
        while (newPos > start2 && !(glyphs[newPos].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc)))) newPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          if (newPos + 1 < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos + 1])) newPos++;
        } else newPos = start2;
      }
      if (start2 < newPos && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
        for (let i3 = newPos; i3 > start2; i3--) if (glyphs[i3 - 1].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          let oldPos = i3 - 1;
          if (oldPos < base && base <= newPos) base--;
          let tmp = glyphs[oldPos];
          glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));
          glyphs[newPos] = tmp;
          newPos--;
        }
      }
    }
    if (start2 + 1 < end2 && glyphs[start2].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && glyphs[start2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha !== (glyphs[start2].isLigated && !glyphs[start2].isMultiplied)) {
      let newRephPos;
      let rephPos = indicConfig.rephPos;
      let found = false;
      if (rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post) {
        newRephPos = start2 + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;
          found = true;
        }
        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main) {
          newRephPos = base;
          while (newRephPos + 1 < end2 && glyphs[newRephPos + 1].shaperInfo.position <= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main) newRephPos++;
          found = newRephPos < end2;
        }
        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Sub) {
          newRephPos = base;
          while (newRephPos + 1 < end2 && !(glyphs[newRephPos + 1].shaperInfo.position & ((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD))) newRephPos++;
          found = newRephPos < end2;
        }
      }
      if (!found) {
        newRephPos = start2 + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;
          found = true;
        }
      }
      if (!found) {
        newRephPos = end2 - 1;
        while (newRephPos > start2 && glyphs[newRephPos].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) newRephPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          for (let i3 = base + 1; i3 < newRephPos; i3++) if (glyphs[i3].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) newRephPos--;
        }
      }
      let reph = glyphs[start2];
      glyphs.splice(start2, 0, ...glyphs.splice(start2 + 1, newRephPos - start2));
      glyphs[newRephPos] = reph;
      if (start2 < base && base <= newRephPos) base--;
    }
    if (tryPref && base + 1 < end2) {
      for (let i3 = base + 1; i3 < end2; i3++) if (glyphs[i3].features.pref) {
        if (glyphs[i3].isLigated && !glyphs[i3].isMultiplied) {
          let newPos = base;
          if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
            while (newPos > start2 && !(glyphs[newPos - 1].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc)))) newPos--;
            if (newPos > start2 && glyphs[newPos - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
              let oldPos2 = i3;
              for (let j = base + 1; j < oldPos2; j++) if (glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
                newPos--;
                break;
              }
            }
          }
          if (newPos > start2 && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos - 1])) {
            if (newPos < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos])) newPos++;
          }
          let oldPos = i3;
          let tmp = glyphs[oldPos];
          glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));
          glyphs[newPos] = tmp;
          if (newPos <= base && base < oldPos) base++;
        }
        break;
      }
    }
    if (glyphs[start2].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M && (!start2 || !/Cf|Mn/.test((0, $747425b437e121da$export$410364bbb673ddbc)(glyphs[start2 - 1].codePoints[0])))) glyphs[start2].features.init = true;
  }
}
function $7826f90f6f0cecc9$var$nextSyllable(glyphs, start2) {
  if (start2 >= glyphs.length) return start2;
  let syllable = glyphs[start2].shaperInfo.syllable;
  while (++start2 < glyphs.length && glyphs[start2].shaperInfo.syllable === syllable) ;
  return start2;
}
var { categories: $7ab494fe977143c6$var$categories, decompositions: $7ab494fe977143c6$var$decompositions } = (0, $parcel$interopDefault2($aa333a9607471296$exports));
var $7ab494fe977143c6$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("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"));
var $7ab494fe977143c6$var$stateMachine = new (0, import_dfa.default)((0, $parcel$interopDefault2($aa333a9607471296$exports)));
var $7ab494fe977143c6$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.addStage($7ab494fe977143c6$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp",
      "nukt",
      "akhn"
    ]);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "rphf"
    ], false);
    plan.addStage($7ab494fe977143c6$var$recordRphf);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "pref"
    ]);
    plan.addStage($7ab494fe977143c6$var$recordPref);
    plan.addStage([
      "rkrf",
      "abvf",
      "blwf",
      "half",
      "pstf",
      "vatu",
      "cjct"
    ]);
    plan.addStage($7ab494fe977143c6$var$reorder);
    plan.addStage([
      "abvs",
      "blws",
      "pres",
      "psts",
      "dist",
      "abvm",
      "blwm"
    ]);
  }
  static assignFeatures(plan, glyphs) {
    for (let i3 = glyphs.length - 1; i3 >= 0; i3--) {
      let codepoint = glyphs[i3].codePoints[0];
      if ($7ab494fe977143c6$var$decompositions[codepoint]) {
        let decomposed = $7ab494fe977143c6$var$decompositions[codepoint].map((c3) => {
          let g2 = plan.font.glyphForCodePoint(c3);
          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g2.id, [
            c3
          ], glyphs[i3].features);
        });
        glyphs.splice(i3, 1, ...decomposed);
      }
    }
  }
};
(0, _define_property)($7ab494fe977143c6$export$2e2bcd8739ae039, "zeroMarkWidths", "BEFORE_GPOS");
function $7ab494fe977143c6$var$useCategory(glyph) {
  return $7ab494fe977143c6$var$trie.get(glyph.codePoints[0]);
}
var $7ab494fe977143c6$var$USEInfo = class {
  constructor(category, syllableType, syllable) {
    this.category = category;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
};
function $7ab494fe977143c6$var$setupSyllables(font, glyphs) {
  let syllable = 0;
  for (let [start2, end2, tags2] of $7ab494fe977143c6$var$stateMachine.match(glyphs.map($7ab494fe977143c6$var$useCategory))) {
    ++syllable;
    for (let i3 = start2; i3 <= end2; i3++) glyphs[i3].shaperInfo = new $7ab494fe977143c6$var$USEInfo($7ab494fe977143c6$var$categories[$7ab494fe977143c6$var$useCategory(glyphs[i3])], tags2[0], syllable);
    let limit = glyphs[start2].shaperInfo.category === "R" ? 1 : Math.min(3, end2 - start2);
    for (let i3 = start2; i3 < start2 + limit; i3++) glyphs[i3].features.rphf = true;
  }
}
function $7ab494fe977143c6$var$clearSubstitutionFlags(font, glyphs) {
  for (let glyph of glyphs) glyph.substituted = false;
}
function $7ab494fe977143c6$var$recordRphf(font, glyphs) {
  for (let glyph of glyphs) if (glyph.substituted && glyph.features.rphf)
    glyph.shaperInfo.category = "R";
}
function $7ab494fe977143c6$var$recordPref(font, glyphs) {
  for (let glyph of glyphs) if (glyph.substituted)
    glyph.shaperInfo.category = "VPre";
}
function $7ab494fe977143c6$var$reorder(font, glyphs) {
  let dottedCircle = font.glyphForCodePoint(9676).id;
  for (let start2 = 0, end2 = $7ab494fe977143c6$var$nextSyllable(glyphs, 0); start2 < glyphs.length; start2 = end2, end2 = $7ab494fe977143c6$var$nextSyllable(glyphs, start2)) {
    let i3, j;
    let info = glyphs[start2].shaperInfo;
    let type = info.syllableType;
    if (type !== "virama_terminated_cluster" && type !== "standard_cluster" && type !== "broken_cluster") continue;
    if (type === "broken_cluster" && dottedCircle) {
      let g2 = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, dottedCircle, [
        9676
      ]);
      g2.shaperInfo = info;
      for (i3 = start2; i3 < end2 && glyphs[i3].shaperInfo.category === "R"; i3++) ;
      glyphs.splice(++i3, 0, g2);
      end2++;
    }
    if (info.category === "R" && end2 - start2 > 1)
      for (i3 = start2 + 1; i3 < end2; i3++) {
        info = glyphs[i3].shaperInfo;
        if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i3])) {
          if ($7ab494fe977143c6$var$isHalant(glyphs[i3])) i3--;
          glyphs.splice(start2, 0, ...glyphs.splice(start2 + 1, i3 - start2), glyphs[i3]);
          break;
        }
      }
    for (i3 = start2, j = end2; i3 < end2; i3++) {
      info = glyphs[i3].shaperInfo;
      if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i3]))
        j = $7ab494fe977143c6$var$isHalant(glyphs[i3]) ? i3 + 1 : i3;
      else if ((info.category === "VPre" || info.category === "VMPre") && j < i3) glyphs.splice(j, 1, glyphs[i3], ...glyphs.splice(j, i3 - j));
    }
  }
}
function $7ab494fe977143c6$var$nextSyllable(glyphs, start2) {
  if (start2 >= glyphs.length) return start2;
  let syllable = glyphs[start2].shaperInfo.syllable;
  while (++start2 < glyphs.length && glyphs[start2].shaperInfo.syllable === syllable) ;
  return start2;
}
function $7ab494fe977143c6$var$isHalant(glyph) {
  return glyph.shaperInfo.category === "H" && !glyph.isLigated;
}
function $7ab494fe977143c6$var$isBase(info) {
  return info.category === "B" || info.category === "GB";
}
var $102b6fe50f1d50b4$var$SHAPERS = {
  arab: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mong: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  syrc: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  "nko ": (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  phag: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mand: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mani: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  phlp: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  hang: (0, $e1c6bbc8cb416f8c$export$2e2bcd8739ae039),
  bng2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  beng: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  dev2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  deva: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gjr2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gujr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  guru: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gur2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  knda: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  knd2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  mlm2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  mlym: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  ory2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  orya: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  taml: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  tml2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  telu: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  tel2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  khmr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  bali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  batk: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  brah: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  bugi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  buhd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  cakm: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  cham: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  dupl: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  egyp: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  gran: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  hano: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  java: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  kthi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  kali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  khar: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  khoj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sind: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  lepc: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  limb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  mahj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // mand: UniversalShaper, // Mandaic
  // mani: UniversalShaper, // Manichaean
  mtei: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  modi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // mong: UniversalShaper, // Mongolian
  // 'nko ': UniversalShaper, // NKo
  hmng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // phag: UniversalShaper, // Phags-pa
  // phlp: UniversalShaper, // Psalter Pahlavi
  rjng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  saur: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  shrd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sidd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sinh: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  sund: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sylo: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tglg: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tagb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tale: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  lana: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tavt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  takr: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tibt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tfng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tirh: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  latn: (0, $649970d87335b30f$export$2e2bcd8739ae039),
  DFLT: (0, $649970d87335b30f$export$2e2bcd8739ae039)
};
function $102b6fe50f1d50b4$export$7877a478dd30fd3d(script) {
  if (!Array.isArray(script)) script = [
    script
  ];
  for (let s2 of script) {
    let shaper = $102b6fe50f1d50b4$var$SHAPERS[s2];
    if (shaper) return shaper;
  }
  return 0, $649970d87335b30f$export$2e2bcd8739ae039;
}
var $0a876c45f1f7c41c$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
  applyLookup(lookupType, table) {
    switch (lookupType) {
      case 1: {
        let index3 = this.coverageIndex(table.coverage);
        if (index3 === -1) return false;
        let glyph = this.glyphIterator.cur;
        switch (table.version) {
          case 1:
            glyph.id = glyph.id + table.deltaGlyphID & 65535;
            break;
          case 2:
            glyph.id = table.substitute.get(index3);
            break;
        }
        return true;
      }
      case 2: {
        let index3 = this.coverageIndex(table.coverage);
        if (index3 !== -1) {
          let sequence = table.sequences.get(index3);
          if (sequence.length === 0) {
            this.glyphs.splice(this.glyphIterator.index, 1);
            return true;
          }
          this.glyphIterator.cur.id = sequence[0];
          this.glyphIterator.cur.ligatureComponent = 0;
          let features = this.glyphIterator.cur.features;
          let curGlyph = this.glyphIterator.cur;
          let replacement = sequence.slice(1).map((gid, i3) => {
            let glyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, gid, void 0, features);
            glyph.shaperInfo = curGlyph.shaperInfo;
            glyph.isLigated = curGlyph.isLigated;
            glyph.ligatureComponent = i3 + 1;
            glyph.substituted = true;
            glyph.isMultiplied = true;
            return glyph;
          });
          this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);
          return true;
        }
        return false;
      }
      case 3: {
        let index3 = this.coverageIndex(table.coverage);
        if (index3 !== -1) {
          let USER_INDEX = 0;
          this.glyphIterator.cur.id = table.alternateSet.get(index3)[USER_INDEX];
          return true;
        }
        return false;
      }
      case 4: {
        let index3 = this.coverageIndex(table.coverage);
        if (index3 === -1) return false;
        for (let ligature of table.ligatureSets.get(index3)) {
          let matched = this.sequenceMatchIndices(1, ligature.components);
          if (!matched) continue;
          let curGlyph = this.glyphIterator.cur;
          let characters2 = curGlyph.codePoints.slice();
          for (let index4 of matched) characters2.push(...this.glyphs[index4].codePoints);
          let ligatureGlyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, ligature.glyph, characters2, curGlyph.features);
          ligatureGlyph.shaperInfo = curGlyph.shaperInfo;
          ligatureGlyph.isLigated = true;
          ligatureGlyph.substituted = true;
          let isMarkLigature = curGlyph.isMark;
          for (let i3 = 0; i3 < matched.length && isMarkLigature; i3++) isMarkLigature = this.glyphs[matched[i3]].isMark;
          ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;
          let lastLigID = curGlyph.ligatureID;
          let lastNumComps = curGlyph.codePoints.length;
          let curComps = lastNumComps;
          let idx = this.glyphIterator.index + 1;
          for (let matchIndex of matched) {
            if (isMarkLigature) idx = matchIndex;
            else while (idx < matchIndex) {
              var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
              this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
              this.glyphs[idx].ligatureComponent = ligatureComponent;
              idx++;
            }
            lastLigID = this.glyphs[idx].ligatureID;
            lastNumComps = this.glyphs[idx].codePoints.length;
            curComps += lastNumComps;
            idx++;
          }
          if (lastLigID && !isMarkLigature) for (let i3 = idx; i3 < this.glyphs.length; i3++) {
            if (this.glyphs[i3].ligatureID === lastLigID) {
              var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i3].ligatureComponent || 1, lastNumComps);
              this.glyphs[i3].ligatureComponent = ligatureComponent;
            } else break;
          }
          for (let i3 = matched.length - 1; i3 >= 0; i3--) this.glyphs.splice(matched[i3], 1);
          this.glyphs[this.glyphIterator.index] = ligatureGlyph;
          return true;
        }
        return false;
      }
      case 5:
        return this.applyContext(table);
      case 6:
        return this.applyChainingContext(table);
      case 7:
        return this.applyLookup(table.lookupType, table.extension);
      default:
        throw new Error(`GSUB lookupType ${lookupType} is not supported`);
    }
  }
};
var $c96c93587d49c14d$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
  applyPositionValue(sequenceIndex, value2) {
    let position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
    if (value2.xAdvance != null) position.xAdvance += value2.xAdvance;
    if (value2.yAdvance != null) position.yAdvance += value2.yAdvance;
    if (value2.xPlacement != null) position.xOffset += value2.xPlacement;
    if (value2.yPlacement != null) position.yOffset += value2.yPlacement;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (value2.xPlaDevice) position.xOffset += variationProcessor.getDelta(variationStore, value2.xPlaDevice.a, value2.xPlaDevice.b);
      if (value2.yPlaDevice) position.yOffset += variationProcessor.getDelta(variationStore, value2.yPlaDevice.a, value2.yPlaDevice.b);
      if (value2.xAdvDevice) position.xAdvance += variationProcessor.getDelta(variationStore, value2.xAdvDevice.a, value2.xAdvDevice.b);
      if (value2.yAdvDevice) position.yAdvance += variationProcessor.getDelta(variationStore, value2.yAdvDevice.a, value2.yAdvDevice.b);
    }
  }
  applyLookup(lookupType, table) {
    switch (lookupType) {
      case 1: {
        let index3 = this.coverageIndex(table.coverage);
        if (index3 === -1) return false;
        switch (table.version) {
          case 1:
            this.applyPositionValue(0, table.value);
            break;
          case 2:
            this.applyPositionValue(0, table.values.get(index3));
            break;
        }
        return true;
      }
      case 2: {
        let nextGlyph = this.glyphIterator.peek();
        if (!nextGlyph) return false;
        let index3 = this.coverageIndex(table.coverage);
        if (index3 === -1) return false;
        switch (table.version) {
          case 1:
            let set5 = table.pairSets.get(index3);
            for (let pair2 of set5) if (pair2.secondGlyph === nextGlyph.id) {
              this.applyPositionValue(0, pair2.value1);
              this.applyPositionValue(1, pair2.value2);
              return true;
            }
            return false;
          case 2:
            let class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);
            let class2 = this.getClassID(nextGlyph.id, table.classDef2);
            if (class1 === -1 || class2 === -1) return false;
            var pair = table.classRecords.get(class1).get(class2);
            this.applyPositionValue(0, pair.value1);
            this.applyPositionValue(1, pair.value2);
            return true;
        }
      }
      case 3: {
        let nextIndex = this.glyphIterator.peekIndex();
        let nextGlyph = this.glyphs[nextIndex];
        if (!nextGlyph) return false;
        let curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];
        if (!curRecord || !curRecord.exitAnchor) return false;
        let nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];
        if (!nextRecord || !nextRecord.entryAnchor) return false;
        let entry = this.getAnchor(nextRecord.entryAnchor);
        let exit = this.getAnchor(curRecord.exitAnchor);
        let cur = this.positions[this.glyphIterator.index];
        let next = this.positions[nextIndex];
        let d2;
        switch (this.direction) {
          case "ltr":
            cur.xAdvance = exit.x + cur.xOffset;
            d2 = entry.x + next.xOffset;
            next.xAdvance -= d2;
            next.xOffset -= d2;
            break;
          case "rtl":
            d2 = exit.x + cur.xOffset;
            cur.xAdvance -= d2;
            cur.xOffset -= d2;
            next.xAdvance = entry.x + next.xOffset;
            break;
        }
        if (this.glyphIterator.flags.rightToLeft) {
          this.glyphIterator.cur.cursiveAttachment = nextIndex;
          cur.yOffset = entry.y - exit.y;
        } else {
          nextGlyph.cursiveAttachment = this.glyphIterator.index;
          cur.yOffset = exit.y - entry.y;
        }
        return true;
      }
      case 4: {
        let markIndex = this.coverageIndex(table.markCoverage);
        if (markIndex === -1) return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0)) ;
        if (baseGlyphIndex < 0) return false;
        let baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);
        if (baseIndex === -1) return false;
        let markRecord = table.markArray[markIndex];
        let baseAnchor = table.baseArray[baseIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 5: {
        let markIndex = this.coverageIndex(table.markCoverage);
        if (markIndex === -1) return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark) ;
        if (baseGlyphIndex < 0) return false;
        let ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);
        if (ligIndex === -1) return false;
        let ligAttach = table.ligatureArray[ligIndex];
        let markGlyph = this.glyphIterator.cur;
        let ligGlyph = this.glyphs[baseGlyphIndex];
        let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
        let markRecord = table.markArray[markIndex];
        let baseAnchor = ligAttach[compIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 6: {
        let mark1Index = this.coverageIndex(table.mark1Coverage);
        if (mark1Index === -1) return false;
        let prevIndex = this.glyphIterator.peekIndex(-1);
        let prev = this.glyphs[prevIndex];
        if (!prev || !prev.isMark) return false;
        let cur = this.glyphIterator.cur;
        let good = false;
        if (cur.ligatureID === prev.ligatureID) {
          if (!cur.ligatureID) good = true;
          else if (cur.ligatureComponent === prev.ligatureComponent) good = true;
        } else if (cur.ligatureID && !cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent) good = true;
        if (!good) return false;
        let mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);
        if (mark2Index === -1) return false;
        let markRecord = table.mark1Array[mark1Index];
        let baseAnchor = table.mark2Array[mark2Index][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, prevIndex);
        return true;
      }
      case 7:
        return this.applyContext(table);
      case 8:
        return this.applyChainingContext(table);
      case 9:
        return this.applyLookup(table.lookupType, table.extension);
      default:
        throw new Error(`Unsupported GPOS table: ${lookupType}`);
    }
  }
  applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {
    let baseCoords = this.getAnchor(baseAnchor);
    let markCoords = this.getAnchor(markRecord.markAnchor);
    let basePos = this.positions[baseGlyphIndex];
    let markPos = this.positions[this.glyphIterator.index];
    markPos.xOffset = baseCoords.x - markCoords.x;
    markPos.yOffset = baseCoords.y - markCoords.y;
    this.glyphIterator.cur.markAttachment = baseGlyphIndex;
  }
  getAnchor(anchor) {
    let x = anchor.xCoordinate;
    let y2 = anchor.yCoordinate;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (anchor.xDeviceTable) x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);
      if (anchor.yDeviceTable) y2 += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);
    }
    return {
      x,
      y: y2
    };
  }
  applyFeatures(userFeatures, glyphs, advances) {
    super.applyFeatures(userFeatures, glyphs, advances);
    for (var i3 = 0; i3 < this.glyphs.length; i3++) this.fixCursiveAttachment(i3);
    this.fixMarkAttachment();
  }
  fixCursiveAttachment(i3) {
    let glyph = this.glyphs[i3];
    if (glyph.cursiveAttachment != null) {
      let j = glyph.cursiveAttachment;
      glyph.cursiveAttachment = null;
      this.fixCursiveAttachment(j);
      this.positions[i3].yOffset += this.positions[j].yOffset;
    }
  }
  fixMarkAttachment() {
    for (let i3 = 0; i3 < this.glyphs.length; i3++) {
      let glyph = this.glyphs[i3];
      if (glyph.markAttachment != null) {
        let j = glyph.markAttachment;
        this.positions[i3].xOffset += this.positions[j].xOffset;
        this.positions[i3].yOffset += this.positions[j].yOffset;
        if (this.direction === "ltr") for (let k2 = j; k2 < i3; k2++) {
          this.positions[i3].xOffset -= this.positions[k2].xAdvance;
          this.positions[i3].yOffset -= this.positions[k2].yAdvance;
        }
        else for (let k2 = j + 1; k2 < i3 + 1; k2++) {
          this.positions[i3].xOffset += this.positions[k2].xAdvance;
          this.positions[i3].yOffset += this.positions[k2].yAdvance;
        }
      }
    }
  }
};
var $a62492810de27e3d$export$2e2bcd8739ae039 = class {
  setup(glyphRun) {
    this.glyphInfos = glyphRun.glyphs.map((glyph) => new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, glyph.id, [
      ...glyph.codePoints
    ]));
    let script = null;
    if (this.GPOSProcessor) script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    if (this.GSUBProcessor) script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    this.shaper = $102b6fe50f1d50b4$export$7877a478dd30fd3d(script);
    this.plan = new (0, $94d7a73bd2edfc9a$export$2e2bcd8739ae039)(this.font, script, glyphRun.direction);
    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);
    for (let key in this.plan.allFeatures) glyphRun.features[key] = true;
  }
  substitute(glyphRun) {
    if (this.GSUBProcessor) {
      this.plan.process(this.GSUBProcessor, this.glyphInfos);
      glyphRun.glyphs = this.glyphInfos.map((glyphInfo) => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));
    }
  }
  position(glyphRun) {
    if (this.shaper.zeroMarkWidths === "BEFORE_GPOS") this.zeroMarkAdvances(glyphRun.positions);
    if (this.GPOSProcessor) this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);
    if (this.shaper.zeroMarkWidths === "AFTER_GPOS") this.zeroMarkAdvances(glyphRun.positions);
    if (glyphRun.direction === "rtl") {
      glyphRun.glyphs.reverse();
      glyphRun.positions.reverse();
    }
    return this.GPOSProcessor && this.GPOSProcessor.features;
  }
  zeroMarkAdvances(positions) {
    for (let i3 = 0; i3 < this.glyphInfos.length; i3++) if (this.glyphInfos[i3].isMark) {
      positions[i3].xAdvance = 0;
      positions[i3].yAdvance = 0;
    }
  }
  cleanup() {
    this.glyphInfos = null;
    this.plan = null;
    this.shaper = null;
  }
  getAvailableFeatures(script, language) {
    let features = [];
    if (this.GSUBProcessor) {
      this.GSUBProcessor.selectScript(script, language);
      features.push(...Object.keys(this.GSUBProcessor.features));
    }
    if (this.GPOSProcessor) {
      this.GPOSProcessor.selectScript(script, language);
      features.push(...Object.keys(this.GPOSProcessor.features));
    }
    return features;
  }
  constructor(font) {
    this.font = font;
    this.glyphInfos = null;
    this.plan = null;
    this.GSUBProcessor = null;
    this.GPOSProcessor = null;
    this.fallbackPosition = true;
    if (font.GSUB) this.GSUBProcessor = new (0, $0a876c45f1f7c41c$export$2e2bcd8739ae039)(font, font.GSUB);
    if (font.GPOS) this.GPOSProcessor = new (0, $c96c93587d49c14d$export$2e2bcd8739ae039)(font, font.GPOS);
  }
};
var $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039 = class {
  layout(string, features, script, language, direction) {
    if (typeof features === "string") {
      direction = language;
      language = script;
      script = features;
      features = [];
    }
    if (typeof string === "string") {
      if (script == null) script = $130d1a642ebcd2b7$export$e5cb25e204fb8450(string);
      var glyphs = this.font.glyphsForString(string);
    } else {
      if (script == null) {
        let codePoints = [];
        for (let glyph of string) codePoints.push(...glyph.codePoints);
        script = $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints);
      }
      var glyphs = string;
    }
    let glyphRun = new (0, $be07b3e97a42687a$export$2e2bcd8739ae039)(glyphs, features, script, language, direction);
    if (glyphs.length === 0) {
      glyphRun.positions = [];
      return glyphRun;
    }
    if (this.engine && this.engine.setup) this.engine.setup(glyphRun);
    this.substitute(glyphRun);
    this.position(glyphRun);
    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);
    if (this.engine && this.engine.cleanup) this.engine.cleanup();
    return glyphRun;
  }
  substitute(glyphRun) {
    if (this.engine && this.engine.substitute) this.engine.substitute(glyphRun);
  }
  position(glyphRun) {
    glyphRun.positions = glyphRun.glyphs.map((glyph) => new (0, $1ac75d9a55b67f01$export$2e2bcd8739ae039)(glyph.advanceWidth));
    let positioned = null;
    if (this.engine && this.engine.position) positioned = this.engine.position(glyphRun);
    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
      if (!this.unicodeLayoutEngine) this.unicodeLayoutEngine = new (0, $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039)(this.font);
      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
    }
    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {
      if (!this.kernProcessor) this.kernProcessor = new (0, $0bba3a9db57637f3$export$2e2bcd8739ae039)(this.font);
      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);
      glyphRun.features.kern = true;
    }
  }
  hideDefaultIgnorables(glyphs, positions) {
    let space = this.font.glyphForCodePoint(32);
    for (let i3 = 0; i3 < glyphs.length; i3++) if (this.isDefaultIgnorable(glyphs[i3].codePoints[0])) {
      glyphs[i3] = space;
      positions[i3].xAdvance = 0;
      positions[i3].yAdvance = 0;
    }
  }
  isDefaultIgnorable(ch) {
    let plane = ch >> 16;
    if (plane === 0)
      switch (ch >> 8) {
        case 0:
          return ch === 173;
        case 3:
          return ch === 847;
        case 6:
          return ch === 1564;
        case 23:
          return 6068 <= ch && ch <= 6069;
        case 24:
          return 6155 <= ch && ch <= 6158;
        case 32:
          return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;
        case 254:
          return 65024 <= ch && ch <= 65039 || ch === 65279;
        case 255:
          return 65520 <= ch && ch <= 65528;
        default:
          return false;
      }
    else
      switch (plane) {
        case 1:
          return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;
        case 14:
          return 917504 <= ch && ch <= 921599;
        default:
          return false;
      }
  }
  getAvailableFeatures(script, language) {
    let features = [];
    if (this.engine) features.push(...this.engine.getAvailableFeatures(script, language));
    if (this.font.kern && features.indexOf("kern") === -1) features.push("kern");
    return features;
  }
  stringsForGlyph(gid) {
    let result = /* @__PURE__ */ new Set();
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);
    for (let codePoint of codePoints) result.add(String.fromCodePoint(codePoint));
    if (this.engine && this.engine.stringsForGlyph) for (let string of this.engine.stringsForGlyph(gid)) result.add(string);
    return Array.from(result);
  }
  constructor(font) {
    this.font = font;
    this.unicodeLayoutEngine = null;
    this.kernProcessor = null;
    if (this.font.morx) this.engine = new (0, $ba6dd74203be8728$export$2e2bcd8739ae039)(this.font);
    else if (this.font.GSUB || this.font.GPOS) this.engine = new (0, $a62492810de27e3d$export$2e2bcd8739ae039)(this.font);
  }
};
var $f43aec954cdfdf21$var$SVG_COMMANDS = {
  moveTo: "M",
  lineTo: "L",
  quadraticCurveTo: "Q",
  bezierCurveTo: "C",
  closePath: "Z"
};
var $f43aec954cdfdf21$export$2e2bcd8739ae039 = class _$f43aec954cdfdf21$export$2e2bcd8739ae039 {
  /**
  * Compiles the path to a JavaScript function that can be applied with
  * a graphics context in order to render the path.
  * @return {string}
  */
  toFunction() {
    return (ctx) => {
      this.commands.forEach((c3) => {
        return ctx[c3.command].apply(ctx, c3.args);
      });
    };
  }
  /**
  * Converts the path to an SVG path data string
  * @return {string}
  */
  toSVG() {
    let cmds = this.commands.map((c3) => {
      let args = c3.args.map((arg) => Math.round(arg * 100) / 100);
      return `${$f43aec954cdfdf21$var$SVG_COMMANDS[c3.command]}${args.join(" ")}`;
    });
    return cmds.join("");
  }
  /**
  * Gets the "control box" of a path.
  * This is like the bounding box, but it includes all points including
  * control points of bezier segments and is much faster to compute than
  * the real bounding box.
  * @type {BBox}
  */
  get cbox() {
    if (!this._cbox) {
      let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
      for (let command of this.commands) for (let i3 = 0; i3 < command.args.length; i3 += 2) cbox.addPoint(command.args[i3], command.args[i3 + 1]);
      this._cbox = Object.freeze(cbox);
    }
    return this._cbox;
  }
  /**
  * Gets the exact bounding box of the path by evaluating curve segments.
  * Slower to compute than the control box, but more accurate.
  * @type {BBox}
  */
  get bbox() {
    if (this._bbox) return this._bbox;
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    let cx2 = 0, cy2 = 0;
    let f2 = (t3) => Math.pow(1 - t3, 3) * p0[i3] + 3 * Math.pow(1 - t3, 2) * t3 * p1[i3] + 3 * (1 - t3) * Math.pow(t3, 2) * p2[i3] + Math.pow(t3, 3) * p3[i3];
    for (let c3 of this.commands) switch (c3.command) {
      case "moveTo":
      case "lineTo":
        let [x, y2] = c3.args;
        bbox.addPoint(x, y2);
        cx2 = x;
        cy2 = y2;
        break;
      case "quadraticCurveTo":
      case "bezierCurveTo":
        if (c3.command === "quadraticCurveTo") {
          var [qp1x, qp1y, p3x, p3y] = c3.args;
          var cp1x = cx2 + 2 / 3 * (qp1x - cx2);
          var cp1y = cy2 + 2 / 3 * (qp1y - cy2);
          var cp2x = p3x + 2 / 3 * (qp1x - p3x);
          var cp2y = p3y + 2 / 3 * (qp1y - p3y);
        } else var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c3.args;
        bbox.addPoint(p3x, p3y);
        var p0 = [
          cx2,
          cy2
        ];
        var p1 = [
          cp1x,
          cp1y
        ];
        var p2 = [
          cp2x,
          cp2y
        ];
        var p3 = [
          p3x,
          p3y
        ];
        for (var i3 = 0; i3 <= 1; i3++) {
          let b2 = 6 * p0[i3] - 12 * p1[i3] + 6 * p2[i3];
          let a3 = -3 * p0[i3] + 9 * p1[i3] - 9 * p2[i3] + 3 * p3[i3];
          c3 = 3 * p1[i3] - 3 * p0[i3];
          if (a3 === 0) {
            if (b2 === 0) continue;
            let t3 = -c3 / b2;
            if (0 < t3 && t3 < 1) {
              if (i3 === 0) bbox.addPoint(f2(t3), bbox.maxY);
              else if (i3 === 1) bbox.addPoint(bbox.maxX, f2(t3));
            }
            continue;
          }
          let b2ac = Math.pow(b2, 2) - 4 * c3 * a3;
          if (b2ac < 0) continue;
          let t1 = (-b2 + Math.sqrt(b2ac)) / (2 * a3);
          if (0 < t1 && t1 < 1) {
            if (i3 === 0) bbox.addPoint(f2(t1), bbox.maxY);
            else if (i3 === 1) bbox.addPoint(bbox.maxX, f2(t1));
          }
          let t22 = (-b2 - Math.sqrt(b2ac)) / (2 * a3);
          if (0 < t22 && t22 < 1) {
            if (i3 === 0) bbox.addPoint(f2(t22), bbox.maxY);
            else if (i3 === 1) bbox.addPoint(bbox.maxX, f2(t22));
          }
        }
        cx2 = p3x;
        cy2 = p3y;
        break;
    }
    return this._bbox = Object.freeze(bbox);
  }
  /**
  * Applies a mapping function to each point in the path.
  * @param {function} fn
  * @return {Path}
  */
  mapPoints(fn) {
    let path = new _$f43aec954cdfdf21$export$2e2bcd8739ae039();
    for (let c3 of this.commands) {
      let args = [];
      for (let i3 = 0; i3 < c3.args.length; i3 += 2) {
        let [x, y2] = fn(c3.args[i3], c3.args[i3 + 1]);
        args.push(x, y2);
      }
      path[c3.command](...args);
    }
    return path;
  }
  /**
  * Transforms the path by the given matrix.
  */
  transform(m0, m1, m2, m3, m4, m5) {
    return this.mapPoints((x, y2) => {
      const tx = m0 * x + m2 * y2 + m4;
      const ty = m1 * x + m3 * y2 + m5;
      return [
        tx,
        ty
      ];
    });
  }
  /**
  * Translates the path by the given offset.
  */
  translate(x, y2) {
    return this.transform(1, 0, 0, 1, x, y2);
  }
  /**
  * Rotates the path by the given angle (in radians).
  */
  rotate(angle) {
    let cos = Math.cos(angle);
    let sin = Math.sin(angle);
    return this.transform(cos, sin, -sin, cos, 0, 0);
  }
  /**
  * Scales the path.
  */
  scale(scaleX, scaleY = scaleX) {
    return this.transform(scaleX, 0, 0, scaleY, 0, 0);
  }
  constructor() {
    this.commands = [];
    this._bbox = null;
    this._cbox = null;
  }
};
for (let command of [
  "moveTo",
  "lineTo",
  "quadraticCurveTo",
  "bezierCurveTo",
  "closePath"
]) $f43aec954cdfdf21$export$2e2bcd8739ae039.prototype[command] = function(...args) {
  this._bbox = this._cbox = null;
  this.commands.push({
    command,
    args
  });
  return this;
};
var $7713b9b7b438dff8$export$2e2bcd8739ae039 = [
  ".notdef",
  ".null",
  "nonmarkingreturn",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quotesingle",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "grave",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "Adieresis",
  "Aring",
  "Ccedilla",
  "Eacute",
  "Ntilde",
  "Odieresis",
  "Udieresis",
  "aacute",
  "agrave",
  "acircumflex",
  "adieresis",
  "atilde",
  "aring",
  "ccedilla",
  "eacute",
  "egrave",
  "ecircumflex",
  "edieresis",
  "iacute",
  "igrave",
  "icircumflex",
  "idieresis",
  "ntilde",
  "oacute",
  "ograve",
  "ocircumflex",
  "odieresis",
  "otilde",
  "uacute",
  "ugrave",
  "ucircumflex",
  "udieresis",
  "dagger",
  "degree",
  "cent",
  "sterling",
  "section",
  "bullet",
  "paragraph",
  "germandbls",
  "registered",
  "copyright",
  "trademark",
  "acute",
  "dieresis",
  "notequal",
  "AE",
  "Oslash",
  "infinity",
  "plusminus",
  "lessequal",
  "greaterequal",
  "yen",
  "mu",
  "partialdiff",
  "summation",
  "product",
  "pi",
  "integral",
  "ordfeminine",
  "ordmasculine",
  "Omega",
  "ae",
  "oslash",
  "questiondown",
  "exclamdown",
  "logicalnot",
  "radical",
  "florin",
  "approxequal",
  "Delta",
  "guillemotleft",
  "guillemotright",
  "ellipsis",
  "nonbreakingspace",
  "Agrave",
  "Atilde",
  "Otilde",
  "OE",
  "oe",
  "endash",
  "emdash",
  "quotedblleft",
  "quotedblright",
  "quoteleft",
  "quoteright",
  "divide",
  "lozenge",
  "ydieresis",
  "Ydieresis",
  "fraction",
  "currency",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "daggerdbl",
  "periodcentered",
  "quotesinglbase",
  "quotedblbase",
  "perthousand",
  "Acircumflex",
  "Ecircumflex",
  "Aacute",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Oacute",
  "Ocircumflex",
  "apple",
  "Ograve",
  "Uacute",
  "Ucircumflex",
  "Ugrave",
  "dotlessi",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "Lslash",
  "lslash",
  "Scaron",
  "scaron",
  "Zcaron",
  "zcaron",
  "brokenbar",
  "Eth",
  "eth",
  "Yacute",
  "yacute",
  "Thorn",
  "thorn",
  "minus",
  "multiply",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "onehalf",
  "onequarter",
  "threequarters",
  "franc",
  "Gbreve",
  "gbreve",
  "Idotaccent",
  "Scedilla",
  "scedilla",
  "Cacute",
  "cacute",
  "Ccaron",
  "ccaron",
  "dcroat"
];
var $f92906be28e61769$export$2e2bcd8739ae039 = class {
  _getPath() {
    return new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
  }
  _getCBox() {
    return this.path.cbox;
  }
  _getBBox() {
    return this.path.bbox;
  }
  _getTableMetrics(table) {
    if (this.id < table.metrics.length) return table.metrics.get(this.id);
    let metric = table.metrics.get(table.metrics.length - 1);
    let res = {
      advance: metric ? metric.advance : 0,
      bearing: table.bearings.get(this.id - table.metrics.length) || 0
    };
    return res;
  }
  _getMetrics(cbox) {
    if (this._metrics) return this._metrics;
    let { advance: advanceWidth2, bearing: leftBearing } = this._getTableMetrics(this._font.hmtx);
    if (this._font.vmtx) var { advance: advanceHeight, bearing: topBearing } = this._getTableMetrics(this._font.vmtx);
    else {
      let os2;
      if (typeof cbox === "undefined" || cbox === null) ({ cbox } = this);
      if ((os2 = this._font["OS/2"]) && os2.version > 0) {
        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
        var topBearing = os2.typoAscender - cbox.maxY;
      } else {
        let { hhea } = this._font;
        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);
        var topBearing = hhea.ascent - cbox.maxY;
      }
    }
    if (this._font._variationProcessor && this._font.HVAR) advanceWidth2 += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
    return this._metrics = {
      advanceWidth: advanceWidth2,
      advanceHeight,
      leftBearing,
      topBearing
    };
  }
  /**
  * The glyphs control box.
  * This is often the same as the bounding box, but is faster to compute.
  * Because of the way bezier curves are defined, some of the control points
  * can be outside of the bounding box. Where `bbox` takes this into account,
  * `cbox` does not. Thus, cbox is less accurate, but faster to compute.
  * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)
  * for a more detailed description.
  *
  * @type {BBox}
  */
  get cbox() {
    return this._getCBox();
  }
  /**
  * The glyphs bounding box, i.e. the rectangle that encloses the
  * glyph outline as tightly as possible.
  * @type {BBox}
  */
  get bbox() {
    return this._getBBox();
  }
  /**
  * A vector Path object representing the glyph outline.
  * @type {Path}
  */
  get path() {
    return this._getPath();
  }
  /**
  * Returns a path scaled to the given font size.
  * @param {number} size
  * @return {Path}
  */
  getScaledPath(size) {
    let scale2 = 1 / this._font.unitsPerEm * size;
    return this.path.scale(scale2);
  }
  /**
  * The glyph's advance width.
  * @type {number}
  */
  get advanceWidth() {
    return this._getMetrics().advanceWidth;
  }
  /**
  * The glyph's advance height.
  * @type {number}
  */
  get advanceHeight() {
    return this._getMetrics().advanceHeight;
  }
  get ligatureCaretPositions() {
  }
  _getName() {
    let { post } = this._font;
    if (!post) return null;
    switch (post.version) {
      case 1:
        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id];
      case 2:
        let id = post.glyphNameIndex[this.id];
        if (id < (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length) return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[id];
        return post.names[id - (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length];
      case 2.5:
        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id + post.offsets[this.id]];
      case 4:
        return String.fromCharCode(post.map[this.id]);
    }
  }
  /**
  * The glyph's name
  * @type {string}
  */
  get name() {
    return this._getName();
  }
  /**
  * Renders the glyph to the given graphics context, at the specified font size.
  * @param {CanvasRenderingContext2d} ctx
  * @param {number} size
  */
  render(ctx, size) {
    ctx.save();
    let scale2 = 1 / this._font.head.unitsPerEm * size;
    ctx.scale(scale2, scale2);
    let fn = this.path.toFunction();
    fn(ctx);
    ctx.fill();
    ctx.restore();
  }
  constructor(id, codePoints, font) {
    this.id = id;
    this.codePoints = codePoints;
    this._font = font;
    this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
    this.isLigature = this.codePoints.length > 1;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "cbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "bbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "path", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceWidth", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceHeight", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "name", null);
var $69aac16029968692$var$GlyfHeader = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16
});
var $69aac16029968692$var$ON_CURVE = 1;
var $69aac16029968692$var$X_SHORT_VECTOR = 2;
var $69aac16029968692$var$Y_SHORT_VECTOR = 4;
var $69aac16029968692$var$REPEAT = 8;
var $69aac16029968692$var$SAME_X = 16;
var $69aac16029968692$var$SAME_Y = 32;
var $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS = 1;
var $69aac16029968692$var$WE_HAVE_A_SCALE = 8;
var $69aac16029968692$var$MORE_COMPONENTS = 32;
var $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE = 64;
var $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO = 128;
var $69aac16029968692$var$WE_HAVE_INSTRUCTIONS = 256;
var $69aac16029968692$export$baf26146a414f24a = class _$69aac16029968692$export$baf26146a414f24a {
  copy() {
    return new _$69aac16029968692$export$baf26146a414f24a(this.onCurve, this.endContour, this.x, this.y);
  }
  constructor(onCurve, endContour, x = 0, y2 = 0) {
    this.onCurve = onCurve;
    this.endContour = endContour;
    this.x = x;
    this.y = y2;
  }
};
var $69aac16029968692$var$Component = class {
  constructor(glyphID, dx, dy) {
    this.glyphID = glyphID;
    this.dx = dx;
    this.dy = dy;
    this.pos = 0;
    this.scaleX = this.scaleY = 1;
    this.scale01 = this.scale10 = 0;
  }
};
var $69aac16029968692$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  // Parses just the glyph header and returns the bounding box
  _getCBox(internal) {
    if (this._font._variationProcessor && !internal) return this.path.cbox;
    let stream2 = this._font._getTableStream("glyf");
    stream2.pos += this._font.loca.offsets[this.id];
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
    let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
    return Object.freeze(cbox);
  }
  // Parses a single glyph coordinate
  _parseGlyphCoord(stream2, prev, short, same) {
    if (short) {
      var val = stream2.readUInt8();
      if (!same) val = -val;
      val += prev;
    } else if (same) var val = prev;
    else var val = prev + stream2.readInt16BE();
    return val;
  }
  // Decodes the glyph data into points for simple glyphs,
  // or components for composite glyphs
  _decode() {
    let glyfPos = this._font.loca.offsets[this.id];
    let nextPos = this._font.loca.offsets[this.id + 1];
    if (glyfPos === nextPos) return null;
    let stream2 = this._font._getTableStream("glyf");
    stream2.pos += glyfPos;
    let startPos = stream2.pos;
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
    if (glyph.numberOfContours > 0) this._decodeSimple(glyph, stream2);
    else if (glyph.numberOfContours < 0) this._decodeComposite(glyph, stream2, startPos);
    return glyph;
  }
  _decodeSimple(glyph, stream2) {
    glyph.points = [];
    let endPtsOfContours = new ArrayT(uint16, glyph.numberOfContours).decode(stream2);
    glyph.instructions = new ArrayT(uint8, uint16).decode(stream2);
    let flags = [];
    let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
    while (flags.length < numCoords) {
      var flag = stream2.readUInt8();
      flags.push(flag);
      if (flag & $69aac16029968692$var$REPEAT) {
        let count = stream2.readUInt8();
        for (let j = 0; j < count; j++) flags.push(flag);
      }
    }
    for (var i3 = 0; i3 < flags.length; i3++) {
      var flag = flags[i3];
      let point = new $69aac16029968692$export$baf26146a414f24a(!!(flag & $69aac16029968692$var$ON_CURVE), endPtsOfContours.indexOf(i3) >= 0, 0, 0);
      glyph.points.push(point);
    }
    let px2 = 0;
    for (var i3 = 0; i3 < flags.length; i3++) {
      var flag = flags[i3];
      glyph.points[i3].x = px2 = this._parseGlyphCoord(stream2, px2, flag & $69aac16029968692$var$X_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_X);
    }
    let py2 = 0;
    for (var i3 = 0; i3 < flags.length; i3++) {
      var flag = flags[i3];
      glyph.points[i3].y = py2 = this._parseGlyphCoord(stream2, py2, flag & $69aac16029968692$var$Y_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_Y);
    }
    if (this._font._variationProcessor) {
      let points = glyph.points.slice();
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.slice(-4);
    }
    return;
  }
  _decodeComposite(glyph, stream2, offset2 = 0) {
    glyph.components = [];
    let haveInstructions = false;
    let flags = $69aac16029968692$var$MORE_COMPONENTS;
    while (flags & $69aac16029968692$var$MORE_COMPONENTS) {
      flags = stream2.readUInt16BE();
      let gPos = stream2.pos - offset2;
      let glyphID = stream2.readUInt16BE();
      if (!haveInstructions) haveInstructions = (flags & $69aac16029968692$var$WE_HAVE_INSTRUCTIONS) !== 0;
      if (flags & $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS) {
        var dx = stream2.readInt16BE();
        var dy = stream2.readInt16BE();
      } else {
        var dx = stream2.readInt8();
        var dy = stream2.readInt8();
      }
      var component = new $69aac16029968692$var$Component(glyphID, dx, dy);
      component.pos = gPos;
      if (flags & $69aac16029968692$var$WE_HAVE_A_SCALE)
        component.scaleX = component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      else if (flags & $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      } else if (flags & $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale01 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale10 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      }
      glyph.components.push(component);
    }
    if (this._font._variationProcessor) {
      let points = [];
      for (let j = 0; j < glyph.components.length; j++) {
        var component = glyph.components[j];
        points.push(new $69aac16029968692$export$baf26146a414f24a(true, true, component.dx, component.dy));
      }
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.splice(-4, 4);
      for (let i3 = 0; i3 < points.length; i3++) {
        let point = points[i3];
        glyph.components[i3].dx = point.x;
        glyph.components[i3].dy = point.y;
      }
    }
    return haveInstructions;
  }
  _getPhantomPoints(glyph) {
    let cbox = this._getCBox(true);
    if (this._metrics == null) this._metrics = (0, $f92906be28e61769$export$2e2bcd8739ae039).prototype._getMetrics.call(this, cbox);
    let { advanceWidth: advanceWidth2, advanceHeight, leftBearing, topBearing } = this._metrics;
    return [
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing + advanceWidth2, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing + advanceHeight)
    ];
  }
  // Decodes font data, resolves composite glyphs, and returns an array of contours
  _getContours() {
    let glyph = this._decode();
    if (!glyph) return [];
    let points = [];
    if (glyph.numberOfContours < 0)
      for (let component of glyph.components) {
        let contours2 = this._font.getGlyph(component.glyphID)._getContours();
        for (let i3 = 0; i3 < contours2.length; i3++) {
          let contour = contours2[i3];
          for (let j = 0; j < contour.length; j++) {
            let point2 = contour[j];
            let x = point2.x * component.scaleX + point2.y * component.scale01 + component.dx;
            let y2 = point2.y * component.scaleY + point2.x * component.scale10 + component.dy;
            points.push(new $69aac16029968692$export$baf26146a414f24a(point2.onCurve, point2.endContour, x, y2));
          }
        }
      }
    else points = glyph.points || [];
    if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {
      this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
      this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
      this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
      this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;
    }
    let contours = [];
    let cur = [];
    for (let k2 = 0; k2 < points.length; k2++) {
      var point = points[k2];
      cur.push(point);
      if (point.endContour) {
        contours.push(cur);
        cur = [];
      }
    }
    return contours;
  }
  _getMetrics() {
    if (this._metrics) return this._metrics;
    let cbox = this._getCBox(true);
    super._getMetrics(cbox);
    if (this._font._variationProcessor && !this._font.HVAR)
      this.path;
    return this._metrics;
  }
  // Converts contours to a Path object that can be rendered
  _getPath() {
    let contours = this._getContours();
    let path = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
    for (let i3 = 0; i3 < contours.length; i3++) {
      let contour = contours[i3];
      let firstPt = contour[0];
      let lastPt = contour[contour.length - 1];
      let start2 = 0;
      if (firstPt.onCurve) {
        var curvePt = null;
        start2 = 1;
      } else {
        if (lastPt.onCurve)
          firstPt = lastPt;
        else
          firstPt = new $69aac16029968692$export$baf26146a414f24a(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
        var curvePt = firstPt;
      }
      path.moveTo(firstPt.x, firstPt.y);
      for (let j = start2; j < contour.length; j++) {
        let pt = contour[j];
        let prevPt = j === 0 ? firstPt : contour[j - 1];
        if (prevPt.onCurve && pt.onCurve) path.lineTo(pt.x, pt.y);
        else if (prevPt.onCurve && !pt.onCurve) var curvePt = pt;
        else if (!prevPt.onCurve && !pt.onCurve) {
          let midX = (prevPt.x + pt.x) / 2;
          let midY = (prevPt.y + pt.y) / 2;
          path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
          var curvePt = pt;
        } else if (!prevPt.onCurve && pt.onCurve) {
          path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
          var curvePt = null;
        } else throw new Error("Unknown TTF path state");
      }
      if (curvePt) path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
      path.closePath();
    }
    return path;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "TTF");
  }
};
var $62cc5109c6101893$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  _getName() {
    if (this._font.CFF2) return super._getName();
    return this._font["CFF "].getGlyphName(this.id);
  }
  bias(s2) {
    if (s2.length < 1240) return 107;
    else if (s2.length < 33900) return 1131;
    else return 32768;
  }
  _getPath() {
    let cff = this._font.CFF2 || this._font["CFF "];
    let { stream: stream2 } = cff;
    let str = cff.topDict.CharStrings[this.id];
    let end2 = str.offset + str.length;
    stream2.pos = str.offset;
    let path = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
    let stack = [];
    let trans = [];
    let width = null;
    let nStems = 0;
    let x = 0, y2 = 0;
    let usedGsubrs;
    let usedSubrs;
    let open = false;
    this._usedGsubrs = usedGsubrs = {};
    this._usedSubrs = usedSubrs = {};
    let gsubrs = cff.globalSubrIndex || [];
    let gsubrsBias = this.bias(gsubrs);
    let privateDict = cff.privateDictForGlyph(this.id) || {};
    let subrs = privateDict.Subrs || [];
    let subrsBias = this.bias(subrs);
    let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;
    let vsindex = privateDict.vsindex;
    let variationProcessor = this._font._variationProcessor;
    function checkWidth() {
      if (width == null) width = stack.shift() + privateDict.nominalWidthX;
    }
    function parseStems() {
      if (stack.length % 2 !== 0) checkWidth();
      nStems += stack.length >> 1;
      return stack.length = 0;
    }
    function moveTo(x2, y3) {
      if (open) path.closePath();
      path.moveTo(x2, y3);
      open = true;
    }
    let parse3 = function() {
      while (stream2.pos < end2) {
        let op = stream2.readUInt8();
        if (op < 32) {
          let index3, subr, phase;
          let c1x, c1y, c2x, c2y, c3x, c3y;
          let c4x, c4y, c5x, c5y, c6x, c6y;
          let pts;
          switch (op) {
            case 1:
            case 3:
            case 18:
            case 23:
              parseStems();
              break;
            case 4:
              if (stack.length > 1) checkWidth();
              y2 += stack.shift();
              moveTo(x, y2);
              break;
            case 5:
              while (stack.length >= 2) {
                x += stack.shift();
                y2 += stack.shift();
                path.lineTo(x, y2);
              }
              break;
            case 6:
            case 7:
              phase = op === 6;
              while (stack.length >= 1) {
                if (phase) x += stack.shift();
                else y2 += stack.shift();
                path.lineTo(x, y2);
                phase = !phase;
              }
              break;
            case 8:
              while (stack.length > 0) {
                c1x = x + stack.shift();
                c1y = y2 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y2 = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y2);
              }
              break;
            case 10:
              index3 = stack.pop() + subrsBias;
              subr = subrs[index3];
              if (subr) {
                usedSubrs[index3] = true;
                let p2 = stream2.pos;
                let e3 = end2;
                stream2.pos = subr.offset;
                end2 = subr.offset + subr.length;
                parse3();
                stream2.pos = p2;
                end2 = e3;
              }
              break;
            case 11:
              if (cff.version >= 2) break;
              return;
            case 14:
              if (cff.version >= 2) break;
              if (stack.length > 0) checkWidth();
              if (open) {
                path.closePath();
                open = false;
              }
              break;
            case 15:
              if (cff.version < 2) throw new Error("vsindex operator not supported in CFF v1");
              vsindex = stack.pop();
              break;
            case 16: {
              if (cff.version < 2) throw new Error("blend operator not supported in CFF v1");
              if (!variationProcessor) throw new Error("blend operator in non-variation font");
              let blendVector = variationProcessor.getBlendVector(vstore, vsindex);
              let numBlends = stack.pop();
              let numOperands = numBlends * blendVector.length;
              let delta = stack.length - numOperands;
              let base = delta - numBlends;
              for (let i3 = 0; i3 < numBlends; i3++) {
                let sum = stack[base + i3];
                for (let j = 0; j < blendVector.length; j++) sum += blendVector[j] * stack[delta++];
                stack[base + i3] = sum;
              }
              while (numOperands--) stack.pop();
              break;
            }
            case 19:
            case 20:
              parseStems();
              stream2.pos += nStems + 7 >> 3;
              break;
            case 21:
              if (stack.length > 2) checkWidth();
              x += stack.shift();
              y2 += stack.shift();
              moveTo(x, y2);
              break;
            case 22:
              if (stack.length > 1) checkWidth();
              x += stack.shift();
              moveTo(x, y2);
              break;
            case 24:
              while (stack.length >= 8) {
                c1x = x + stack.shift();
                c1y = y2 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y2 = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y2);
              }
              x += stack.shift();
              y2 += stack.shift();
              path.lineTo(x, y2);
              break;
            case 25:
              while (stack.length >= 8) {
                x += stack.shift();
                y2 += stack.shift();
                path.lineTo(x, y2);
              }
              c1x = x + stack.shift();
              c1y = y2 + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              x = c2x + stack.shift();
              y2 = c2y + stack.shift();
              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y2);
              break;
            case 26:
              if (stack.length % 2) x += stack.shift();
              while (stack.length >= 4) {
                c1x = x;
                c1y = y2 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x;
                y2 = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y2);
              }
              break;
            case 27:
              if (stack.length % 2) y2 += stack.shift();
              while (stack.length >= 4) {
                c1x = x + stack.shift();
                c1y = y2;
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y2 = c2y;
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y2);
              }
              break;
            case 28:
              stack.push(stream2.readInt16BE());
              break;
            case 29:
              index3 = stack.pop() + gsubrsBias;
              subr = gsubrs[index3];
              if (subr) {
                usedGsubrs[index3] = true;
                let p2 = stream2.pos;
                let e3 = end2;
                stream2.pos = subr.offset;
                end2 = subr.offset + subr.length;
                parse3();
                stream2.pos = p2;
                end2 = e3;
              }
              break;
            case 30:
            case 31:
              phase = op === 31;
              while (stack.length >= 4) {
                if (phase) {
                  c1x = x + stack.shift();
                  c1y = y2;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  y2 = c2y + stack.shift();
                  x = c2x + (stack.length === 1 ? stack.shift() : 0);
                } else {
                  c1x = x;
                  c1y = y2 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x + stack.shift();
                  y2 = c2y + (stack.length === 1 ? stack.shift() : 0);
                }
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y2);
                phase = !phase;
              }
              break;
            case 12:
              op = stream2.readUInt8();
              switch (op) {
                case 3:
                  let a3 = stack.pop();
                  let b2 = stack.pop();
                  stack.push(a3 && b2 ? 1 : 0);
                  break;
                case 4:
                  a3 = stack.pop();
                  b2 = stack.pop();
                  stack.push(a3 || b2 ? 1 : 0);
                  break;
                case 5:
                  a3 = stack.pop();
                  stack.push(a3 ? 0 : 1);
                  break;
                case 9:
                  a3 = stack.pop();
                  stack.push(Math.abs(a3));
                  break;
                case 10:
                  a3 = stack.pop();
                  b2 = stack.pop();
                  stack.push(a3 + b2);
                  break;
                case 11:
                  a3 = stack.pop();
                  b2 = stack.pop();
                  stack.push(a3 - b2);
                  break;
                case 12:
                  a3 = stack.pop();
                  b2 = stack.pop();
                  stack.push(a3 / b2);
                  break;
                case 14:
                  a3 = stack.pop();
                  stack.push(-a3);
                  break;
                case 15:
                  a3 = stack.pop();
                  b2 = stack.pop();
                  stack.push(a3 === b2 ? 1 : 0);
                  break;
                case 18:
                  stack.pop();
                  break;
                case 20:
                  let val = stack.pop();
                  let idx = stack.pop();
                  trans[idx] = val;
                  break;
                case 21:
                  idx = stack.pop();
                  stack.push(trans[idx] || 0);
                  break;
                case 22:
                  let s1 = stack.pop();
                  let s2 = stack.pop();
                  let v1 = stack.pop();
                  let v2 = stack.pop();
                  stack.push(v1 <= v2 ? s1 : s2);
                  break;
                case 23:
                  stack.push(Math.random());
                  break;
                case 24:
                  a3 = stack.pop();
                  b2 = stack.pop();
                  stack.push(a3 * b2);
                  break;
                case 26:
                  a3 = stack.pop();
                  stack.push(Math.sqrt(a3));
                  break;
                case 27:
                  a3 = stack.pop();
                  stack.push(a3, a3);
                  break;
                case 28:
                  a3 = stack.pop();
                  b2 = stack.pop();
                  stack.push(b2, a3);
                  break;
                case 29:
                  idx = stack.pop();
                  if (idx < 0) idx = 0;
                  else if (idx > stack.length - 1) idx = stack.length - 1;
                  stack.push(stack[idx]);
                  break;
                case 30:
                  let n4 = stack.pop();
                  let j = stack.pop();
                  if (j >= 0) while (j > 0) {
                    var t3 = stack[n4 - 1];
                    for (let i3 = n4 - 2; i3 >= 0; i3--) stack[i3 + 1] = stack[i3];
                    stack[0] = t3;
                    j--;
                  }
                  else while (j < 0) {
                    var t3 = stack[0];
                    for (let i3 = 0; i3 <= n4; i3++) stack[i3] = stack[i3 + 1];
                    stack[n4 - 1] = t3;
                    j++;
                  }
                  break;
                case 34:
                  c1x = x + stack.shift();
                  c1y = y2;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  c3x = c2x + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = c3y;
                  c5x = c4x + stack.shift();
                  c5y = c4y;
                  c6x = c5x + stack.shift();
                  c6y = c5y;
                  x = c6x;
                  y2 = c6y;
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 35:
                  pts = [];
                  for (let i3 = 0; i3 <= 5; i3++) {
                    x += stack.shift();
                    y2 += stack.shift();
                    pts.push(x, y2);
                  }
                  path.bezierCurveTo(...pts.slice(0, 6));
                  path.bezierCurveTo(...pts.slice(6));
                  stack.shift();
                  break;
                case 36:
                  c1x = x + stack.shift();
                  c1y = y2 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  c3x = c2x + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = c3y;
                  c5x = c4x + stack.shift();
                  c5y = c4y + stack.shift();
                  c6x = c5x + stack.shift();
                  c6y = c5y;
                  x = c6x;
                  y2 = c6y;
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 37:
                  let startx = x;
                  let starty = y2;
                  pts = [];
                  for (let i3 = 0; i3 <= 4; i3++) {
                    x += stack.shift();
                    y2 += stack.shift();
                    pts.push(x, y2);
                  }
                  if (Math.abs(x - startx) > Math.abs(y2 - starty)) {
                    x += stack.shift();
                    y2 = starty;
                  } else {
                    x = startx;
                    y2 += stack.shift();
                  }
                  pts.push(x, y2);
                  path.bezierCurveTo(...pts.slice(0, 6));
                  path.bezierCurveTo(...pts.slice(6));
                  break;
                default:
                  throw new Error(`Unknown op: 12 ${op}`);
              }
              break;
            default:
              throw new Error(`Unknown op: ${op}`);
          }
        } else if (op < 247) stack.push(op - 139);
        else if (op < 251) {
          var b1 = stream2.readUInt8();
          stack.push((op - 247) * 256 + b1 + 108);
        } else if (op < 255) {
          var b1 = stream2.readUInt8();
          stack.push(-(op - 251) * 256 - b1 - 108);
        } else stack.push(stream2.readInt32BE() / 65536);
      }
    };
    parse3();
    if (open) path.closePath();
    return path;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "CFF");
  }
};
var $25d8f049c222084c$var$SBIXImage = new Struct({
  originX: uint16,
  originY: uint16,
  type: new StringT(4),
  data: new BufferT((t3) => t3.parent.buflen - t3._currentOffset)
});
var $25d8f049c222084c$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
  /**
  * Returns an object representing a glyph image at the given point size.
  * The object has a data property with a Buffer containing the actual image data,
  * along with the image type, and origin.
  *
  * @param {number} size
  * @return {object}
  */
  getImageForSize(size) {
    for (let i3 = 0; i3 < this._font.sbix.imageTables.length; i3++) {
      var table = this._font.sbix.imageTables[i3];
      if (table.ppem >= size) break;
    }
    let offsets = table.imageOffsets;
    let start2 = offsets[this.id];
    let end2 = offsets[this.id + 1];
    if (start2 === end2) return null;
    this._font.stream.pos = start2;
    return $25d8f049c222084c$var$SBIXImage.decode(this._font.stream, {
      buflen: end2 - start2
    });
  }
  render(ctx, size) {
    let img = this.getImageForSize(size);
    if (img != null) {
      let scale2 = size / this._font.unitsPerEm;
      ctx.image(img.data, {
        height: size,
        x: img.originX,
        y: (this.bbox.minY - img.originY) * scale2
      });
    }
    if (this._font.sbix.flags.renderOutlines) super.render(ctx, size);
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "SBIX");
  }
};
var $0d411f0165859681$var$COLRLayer = class {
  constructor(glyph, color) {
    this.glyph = glyph;
    this.color = color;
  }
};
var $0d411f0165859681$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  _getBBox() {
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    for (let i3 = 0; i3 < this.layers.length; i3++) {
      let layer = this.layers[i3];
      let b2 = layer.glyph.bbox;
      bbox.addPoint(b2.minX, b2.minY);
      bbox.addPoint(b2.maxX, b2.maxY);
    }
    return bbox;
  }
  /**
  * Returns an array of objects containing the glyph and color for
  * each layer in the composite color glyph.
  * @type {object[]}
  */
  get layers() {
    let cpal = this._font.CPAL;
    let colr = this._font.COLR;
    let low = 0;
    let high = colr.baseGlyphRecord.length - 1;
    while (low <= high) {
      let mid = low + high >> 1;
      var rec = colr.baseGlyphRecord[mid];
      if (this.id < rec.gid) high = mid - 1;
      else if (this.id > rec.gid) low = mid + 1;
      else {
        var baseLayer = rec;
        break;
      }
    }
    if (baseLayer == null) {
      var g2 = this._font._getBaseGlyph(this.id);
      var color = {
        red: 0,
        green: 0,
        blue: 0,
        alpha: 255
      };
      return [
        new $0d411f0165859681$var$COLRLayer(g2, color)
      ];
    }
    let layers = [];
    for (let i3 = baseLayer.firstLayerIndex; i3 < baseLayer.firstLayerIndex + baseLayer.numLayers; i3++) {
      var rec = colr.layerRecords[i3];
      var color = cpal.colorRecords[rec.paletteIndex];
      var g2 = this._font._getBaseGlyph(rec.gid);
      layers.push(new $0d411f0165859681$var$COLRLayer(g2, color));
    }
    return layers;
  }
  render(ctx, size) {
    for (let { glyph, color } of this.layers) {
      ctx.fillColor([
        color.red,
        color.green,
        color.blue
      ], color.alpha / 255 * 100);
      glyph.render(ctx, size);
    }
    return;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "COLR");
  }
};
var $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS = 32768;
var $0bb840cac04e911b$var$TUPLE_COUNT_MASK = 4095;
var $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD = 32768;
var $0bb840cac04e911b$var$INTERMEDIATE_TUPLE = 16384;
var $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS = 8192;
var $0bb840cac04e911b$var$TUPLE_INDEX_MASK = 4095;
var $0bb840cac04e911b$var$POINTS_ARE_WORDS = 128;
var $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK = 127;
var $0bb840cac04e911b$var$DELTAS_ARE_ZERO = 128;
var $0bb840cac04e911b$var$DELTAS_ARE_WORDS = 64;
var $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK = 63;
var $0bb840cac04e911b$export$2e2bcd8739ae039 = class {
  normalizeCoords(coords) {
    let normalized = [];
    for (var i3 = 0; i3 < this.font.fvar.axis.length; i3++) {
      let axis = this.font.fvar.axis[i3];
      if (coords[i3] < axis.defaultValue) normalized.push((coords[i3] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));
      else normalized.push((coords[i3] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));
    }
    if (this.font.avar) for (var i3 = 0; i3 < this.font.avar.segment.length; i3++) {
      let segment = this.font.avar.segment[i3];
      for (let j = 0; j < segment.correspondence.length; j++) {
        let pair = segment.correspondence[j];
        if (j >= 1 && normalized[i3] < pair.fromCoord) {
          let prev = segment.correspondence[j - 1];
          normalized[i3] = ((normalized[i3] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) / (pair.fromCoord - prev.fromCoord + Number.EPSILON) + prev.toCoord;
          break;
        }
      }
    }
    return normalized;
  }
  transformPoints(gid, glyphPoints) {
    if (!this.font.fvar || !this.font.gvar) return;
    let { gvar } = this.font;
    if (gid >= gvar.glyphCount) return;
    let offset2 = gvar.offsets[gid];
    if (offset2 === gvar.offsets[gid + 1]) return;
    let { stream: stream2 } = this.font;
    stream2.pos = offset2;
    if (stream2.pos >= stream2.length) return;
    let tupleCount = stream2.readUInt16BE();
    let offsetToData = offset2 + stream2.readUInt16BE();
    if (tupleCount & $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS) {
      var here = stream2.pos;
      stream2.pos = offsetToData;
      var sharedPoints = this.decodePoints();
      offsetToData = stream2.pos;
      stream2.pos = here;
    }
    let origPoints = glyphPoints.map((pt) => pt.copy());
    tupleCount &= $0bb840cac04e911b$var$TUPLE_COUNT_MASK;
    for (let i3 = 0; i3 < tupleCount; i3++) {
      let tupleDataSize = stream2.readUInt16BE();
      let tupleIndex = stream2.readUInt16BE();
      if (tupleIndex & $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD) {
        var tupleCoords = [];
        for (let a3 = 0; a3 < gvar.axisCount; a3++) tupleCoords.push(stream2.readInt16BE() / 16384);
      } else {
        if ((tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK) >= gvar.globalCoordCount) throw new Error("Invalid gvar table");
        var tupleCoords = gvar.globalCoords[tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK];
      }
      if (tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) {
        var startCoords = [];
        for (let a3 = 0; a3 < gvar.axisCount; a3++) startCoords.push(stream2.readInt16BE() / 16384);
        var endCoords = [];
        for (let a3 = 0; a3 < gvar.axisCount; a3++) endCoords.push(stream2.readInt16BE() / 16384);
      }
      let factor2 = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
      if (factor2 === 0) {
        offsetToData += tupleDataSize;
        continue;
      }
      var here = stream2.pos;
      stream2.pos = offsetToData;
      if (tupleIndex & $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS) var points = this.decodePoints();
      else var points = sharedPoints;
      let nPoints = points.length === 0 ? glyphPoints.length : points.length;
      let xDeltas = this.decodeDeltas(nPoints);
      let yDeltas = this.decodeDeltas(nPoints);
      if (points.length === 0) for (let i4 = 0; i4 < glyphPoints.length; i4++) {
        var point = glyphPoints[i4];
        point.x += Math.round(xDeltas[i4] * factor2);
        point.y += Math.round(yDeltas[i4] * factor2);
      }
      else {
        let outPoints = origPoints.map((pt) => pt.copy());
        let hasDelta = glyphPoints.map(() => false);
        for (let i4 = 0; i4 < points.length; i4++) {
          let idx = points[i4];
          if (idx < glyphPoints.length) {
            let point2 = outPoints[idx];
            hasDelta[idx] = true;
            point2.x += xDeltas[i4] * factor2;
            point2.y += yDeltas[i4] * factor2;
          }
        }
        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);
        for (let i4 = 0; i4 < glyphPoints.length; i4++) {
          let deltaX = outPoints[i4].x - origPoints[i4].x;
          let deltaY = outPoints[i4].y - origPoints[i4].y;
          glyphPoints[i4].x = Math.round(glyphPoints[i4].x + deltaX);
          glyphPoints[i4].y = Math.round(glyphPoints[i4].y + deltaY);
        }
      }
      offsetToData += tupleDataSize;
      stream2.pos = here;
    }
  }
  decodePoints() {
    let stream2 = this.font.stream;
    let count = stream2.readUInt8();
    if (count & $0bb840cac04e911b$var$POINTS_ARE_WORDS) count = (count & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) << 8 | stream2.readUInt8();
    let points = new Uint16Array(count);
    let i3 = 0;
    let point = 0;
    while (i3 < count) {
      let run = stream2.readUInt8();
      let runCount = (run & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) + 1;
      let fn = run & $0bb840cac04e911b$var$POINTS_ARE_WORDS ? stream2.readUInt16 : stream2.readUInt8;
      for (let j = 0; j < runCount && i3 < count; j++) {
        point += fn.call(stream2);
        points[i3++] = point;
      }
    }
    return points;
  }
  decodeDeltas(count) {
    let stream2 = this.font.stream;
    let i3 = 0;
    let deltas = new Int16Array(count);
    while (i3 < count) {
      let run = stream2.readUInt8();
      let runCount = (run & $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK) + 1;
      if (run & $0bb840cac04e911b$var$DELTAS_ARE_ZERO) i3 += runCount;
      else {
        let fn = run & $0bb840cac04e911b$var$DELTAS_ARE_WORDS ? stream2.readInt16BE : stream2.readInt8;
        for (let j = 0; j < runCount && i3 < count; j++) deltas[i3++] = fn.call(stream2);
      }
    }
    return deltas;
  }
  tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {
    let normalized = this.normalizedCoords;
    let { gvar } = this.font;
    let factor2 = 1;
    for (let i3 = 0; i3 < gvar.axisCount; i3++) {
      if (tupleCoords[i3] === 0) continue;
      if (normalized[i3] === 0) return 0;
      if ((tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) === 0) {
        if (normalized[i3] < Math.min(0, tupleCoords[i3]) || normalized[i3] > Math.max(0, tupleCoords[i3])) return 0;
        factor2 = (factor2 * normalized[i3] + Number.EPSILON) / (tupleCoords[i3] + Number.EPSILON);
      } else {
        if (normalized[i3] < startCoords[i3] || normalized[i3] > endCoords[i3]) return 0;
        else if (normalized[i3] < tupleCoords[i3]) factor2 = factor2 * (normalized[i3] - startCoords[i3] + Number.EPSILON) / (tupleCoords[i3] - startCoords[i3] + Number.EPSILON);
        else factor2 = factor2 * (endCoords[i3] - normalized[i3] + Number.EPSILON) / (endCoords[i3] - tupleCoords[i3] + Number.EPSILON);
      }
    }
    return factor2;
  }
  // Interpolates points without delta values.
  // Needed for the  and Q glyphs in Skia.
  // Algorithm from Freetype.
  interpolateMissingDeltas(points, inPoints, hasDelta) {
    if (points.length === 0) return;
    let point = 0;
    while (point < points.length) {
      let firstPoint = point;
      let endPoint = point;
      let pt = points[endPoint];
      while (!pt.endContour) pt = points[++endPoint];
      while (point <= endPoint && !hasDelta[point]) point++;
      if (point > endPoint) continue;
      let firstDelta = point;
      let curDelta = point;
      point++;
      while (point <= endPoint) {
        if (hasDelta[point]) {
          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
          curDelta = point;
        }
        point++;
      }
      if (curDelta === firstDelta) this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
      else {
        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
        if (firstDelta > 0) this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
      }
      point = endPoint + 1;
    }
  }
  deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {
    if (p1 > p2) return;
    let iterable = [
      "x",
      "y"
    ];
    for (let i3 = 0; i3 < iterable.length; i3++) {
      let k2 = iterable[i3];
      if (inPoints[ref1][k2] > inPoints[ref2][k2]) {
        var p3 = ref1;
        ref1 = ref2;
        ref2 = p3;
      }
      let in1 = inPoints[ref1][k2];
      let in2 = inPoints[ref2][k2];
      let out1 = outPoints[ref1][k2];
      let out2 = outPoints[ref2][k2];
      if (in1 !== in2 || out1 === out2) {
        let scale2 = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
        for (let p4 = p1; p4 <= p2; p4++) {
          let out = inPoints[p4][k2];
          if (out <= in1) out += out1 - in1;
          else if (out >= in2) out += out2 - in2;
          else out = out1 + (out - in1) * scale2;
          outPoints[p4][k2] = out;
        }
      }
    }
  }
  deltaShift(p1, p2, ref, inPoints, outPoints) {
    let deltaX = outPoints[ref].x - inPoints[ref].x;
    let deltaY = outPoints[ref].y - inPoints[ref].y;
    if (deltaX === 0 && deltaY === 0) return;
    for (let p3 = p1; p3 <= p2; p3++) if (p3 !== ref) {
      outPoints[p3].x += deltaX;
      outPoints[p3].y += deltaY;
    }
  }
  getAdvanceAdjustment(gid, table) {
    let outerIndex, innerIndex;
    if (table.advanceWidthMapping) {
      let idx = gid;
      if (idx >= table.advanceWidthMapping.mapCount) idx = table.advanceWidthMapping.mapCount - 1;
      let entryFormat = table.advanceWidthMapping.entryFormat;
      ({ outerIndex, innerIndex } = table.advanceWidthMapping.mapData[idx]);
    } else {
      outerIndex = 0;
      innerIndex = gid;
    }
    return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);
  }
  // See pseudo code from `Font Variations Overview'
  // in the OpenType specification.
  getDelta(itemStore, outerIndex, innerIndex) {
    if (outerIndex >= itemStore.itemVariationData.length) return 0;
    let varData = itemStore.itemVariationData[outerIndex];
    if (innerIndex >= varData.deltaSets.length) return 0;
    let deltaSet = varData.deltaSets[innerIndex];
    let blendVector = this.getBlendVector(itemStore, outerIndex);
    let netAdjustment = 0;
    for (let master = 0; master < varData.regionIndexCount; master++) netAdjustment += deltaSet.deltas[master] * blendVector[master];
    return netAdjustment;
  }
  getBlendVector(itemStore, outerIndex) {
    let varData = itemStore.itemVariationData[outerIndex];
    if (this.blendVectors.has(varData)) return this.blendVectors.get(varData);
    let normalizedCoords = this.normalizedCoords;
    let blendVector = [];
    for (let master = 0; master < varData.regionIndexCount; master++) {
      let scalar = 1;
      let regionIndex = varData.regionIndexes[master];
      let axes = itemStore.variationRegionList.variationRegions[regionIndex];
      for (let j = 0; j < axes.length; j++) {
        let axis = axes[j];
        let axisScalar;
        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) axisScalar = 1;
        else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) axisScalar = 1;
        else if (axis.peakCoord === 0) axisScalar = 1;
        else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) axisScalar = 0;
        else {
          if (normalizedCoords[j] === axis.peakCoord) axisScalar = 1;
          else if (normalizedCoords[j] < axis.peakCoord) axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) / (axis.peakCoord - axis.startCoord + Number.EPSILON);
          else axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) / (axis.endCoord - axis.peakCoord + Number.EPSILON);
        }
        scalar *= axisScalar;
      }
      blendVector[master] = scalar;
    }
    this.blendVectors.set(varData, blendVector);
    return blendVector;
  }
  constructor(font, coords) {
    this.font = font;
    this.normalizedCoords = this.normalizeCoords(coords);
    this.blendVectors = /* @__PURE__ */ new Map();
  }
};
var $5cc7476da92df375$var$resolved = Promise.resolve();
var $5cc7476da92df375$export$2e2bcd8739ae039 = class {
  includeGlyph(glyph) {
    if (typeof glyph === "object") glyph = glyph.id;
    if (this.mapping[glyph] == null) {
      this.glyphs.push(glyph);
      this.mapping[glyph] = this.glyphs.length - 1;
    }
    return this.mapping[glyph];
  }
  constructor(font) {
    this.font = font;
    this.glyphs = [];
    this.mapping = {};
    this.includeGlyph(0);
  }
};
var $807e58506be70005$var$ON_CURVE = 1;
var $807e58506be70005$var$X_SHORT_VECTOR = 2;
var $807e58506be70005$var$Y_SHORT_VECTOR = 4;
var $807e58506be70005$var$REPEAT = 8;
var $807e58506be70005$var$SAME_X = 16;
var $807e58506be70005$var$SAME_Y = 32;
var $807e58506be70005$var$Point = class {
  static size(val) {
    return val >= 0 && val <= 255 ? 1 : 2;
  }
  static encode(stream2, value2) {
    if (value2 >= 0 && value2 <= 255) stream2.writeUInt8(value2);
    else stream2.writeInt16BE(value2);
  }
};
var $807e58506be70005$var$Glyf = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  endPtsOfContours: new ArrayT(uint16, "numberOfContours"),
  instructions: new ArrayT(uint8, uint16),
  flags: new ArrayT(uint8, 0),
  xPoints: new ArrayT($807e58506be70005$var$Point, 0),
  yPoints: new ArrayT($807e58506be70005$var$Point, 0)
});
var $807e58506be70005$export$2e2bcd8739ae039 = class {
  encodeSimple(path, instructions = []) {
    let endPtsOfContours = [];
    let xPoints = [];
    let yPoints = [];
    let flags = [];
    let same = 0;
    let lastX = 0, lastY = 0, lastFlag = 0;
    let pointCount = 0;
    for (let i3 = 0; i3 < path.commands.length; i3++) {
      let c3 = path.commands[i3];
      for (let j = 0; j < c3.args.length; j += 2) {
        let x = c3.args[j];
        let y2 = c3.args[j + 1];
        let flag = 0;
        if (c3.command === "quadraticCurveTo" && j === 2) {
          let next = path.commands[i3 + 1];
          if (next && next.command === "quadraticCurveTo") {
            let midX = (lastX + next.args[0]) / 2;
            let midY = (lastY + next.args[1]) / 2;
            if (x === midX && y2 === midY) continue;
          }
        }
        if (!(c3.command === "quadraticCurveTo" && j === 0)) flag |= $807e58506be70005$var$ON_CURVE;
        flag = this._encodePoint(x, lastX, xPoints, flag, $807e58506be70005$var$X_SHORT_VECTOR, $807e58506be70005$var$SAME_X);
        flag = this._encodePoint(y2, lastY, yPoints, flag, $807e58506be70005$var$Y_SHORT_VECTOR, $807e58506be70005$var$SAME_Y);
        if (flag === lastFlag && same < 255) {
          flags[flags.length - 1] |= $807e58506be70005$var$REPEAT;
          same++;
        } else {
          if (same > 0) {
            flags.push(same);
            same = 0;
          }
          flags.push(flag);
          lastFlag = flag;
        }
        lastX = x;
        lastY = y2;
        pointCount++;
      }
      if (c3.command === "closePath") endPtsOfContours.push(pointCount - 1);
    }
    if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== "closePath") endPtsOfContours.push(pointCount - 1);
    let bbox = path.bbox;
    let glyf = {
      numberOfContours: endPtsOfContours.length,
      xMin: bbox.minX,
      yMin: bbox.minY,
      xMax: bbox.maxX,
      yMax: bbox.maxY,
      endPtsOfContours,
      instructions,
      flags,
      xPoints,
      yPoints
    };
    let size = $807e58506be70005$var$Glyf.size(glyf);
    let tail = 4 - size % 4;
    let stream2 = new EncodeStream(size + tail);
    $807e58506be70005$var$Glyf.encode(stream2, glyf);
    if (tail !== 0) stream2.fill(0, tail);
    return stream2.buffer;
  }
  _encodePoint(value2, last2, points, flag, shortFlag, sameFlag) {
    let diff = value2 - last2;
    if (value2 === last2) flag |= sameFlag;
    else {
      if (-255 <= diff && diff <= 255) {
        flag |= shortFlag;
        if (diff < 0) diff = -diff;
        else flag |= sameFlag;
      }
      points.push(diff);
    }
    return flag;
  }
};
var $4abbb6a5dbdc441a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
  _addGlyph(gid) {
    let glyph = this.font.getGlyph(gid);
    let glyf = glyph._decode();
    let curOffset = this.font.loca.offsets[gid];
    let nextOffset = this.font.loca.offsets[gid + 1];
    let stream2 = this.font._getTableStream("glyf");
    stream2.pos += curOffset;
    let buffer = stream2.readBuffer(nextOffset - curOffset);
    if (glyf && glyf.numberOfContours < 0) {
      buffer = new Uint8Array(buffer);
      let view = new DataView(buffer.buffer);
      for (let component of glyf.components) {
        gid = this.includeGlyph(component.glyphID);
        view.setUint16(component.pos, gid);
      }
    } else if (glyf && this.font._variationProcessor)
      buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);
    this.glyf.push(buffer);
    this.loca.offsets.push(this.offset);
    this.hmtx.metrics.push({
      advance: glyph.advanceWidth,
      bearing: glyph._getMetrics().leftBearing
    });
    this.offset += buffer.length;
    return this.glyf.length - 1;
  }
  encode() {
    this.glyf = [];
    this.offset = 0;
    this.loca = {
      offsets: [],
      version: this.font.loca.version
    };
    this.hmtx = {
      metrics: [],
      bearings: []
    };
    let i3 = 0;
    while (i3 < this.glyphs.length) this._addGlyph(this.glyphs[i3++]);
    let maxp = (0, import_clone.default)(this.font.maxp);
    maxp.numGlyphs = this.glyf.length;
    this.loca.offsets.push(this.offset);
    let head = (0, import_clone.default)(this.font.head);
    head.indexToLocFormat = this.loca.version;
    let hhea = (0, import_clone.default)(this.font.hhea);
    hhea.numberOfMetrics = this.hmtx.metrics.length;
    return (0, $816c07a04b6dba87$export$2e2bcd8739ae039).toBuffer({
      tables: {
        head,
        hhea,
        loca: this.loca,
        maxp,
        "cvt ": this.font["cvt "],
        prep: this.font.prep,
        glyf: this.glyf,
        hmtx: this.hmtx,
        fpgm: this.font.fpgm
      }
    });
  }
  constructor(font) {
    super(font);
    this.glyphEncoder = new (0, $807e58506be70005$export$2e2bcd8739ae039)();
  }
};
var $001d739428a71d5a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
  subsetCharstrings() {
    this.charstrings = [];
    let gsubrs = {};
    for (let gid of this.glyphs) {
      this.charstrings.push(this.cff.getCharString(gid));
      let glyph = this.font.getGlyph(gid);
      let path = glyph.path;
      for (let subr in glyph._usedGsubrs) gsubrs[subr] = true;
    }
    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
  }
  subsetSubrs(subrs, used) {
    let res = [];
    for (let i3 = 0; i3 < subrs.length; i3++) {
      let subr = subrs[i3];
      if (used[i3]) {
        this.cff.stream.pos = subr.offset;
        res.push(this.cff.stream.readBuffer(subr.length));
      } else res.push(new Uint8Array([
        11
      ]));
    }
    return res;
  }
  subsetFontdict(topDict) {
    topDict.FDArray = [];
    topDict.FDSelect = {
      version: 0,
      fds: []
    };
    let used_fds = {};
    let used_subrs = [];
    let fd_select = {};
    for (let gid of this.glyphs) {
      let fd = this.cff.fdForGlyph(gid);
      if (fd == null) continue;
      if (!used_fds[fd]) {
        topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));
        used_subrs.push({});
        fd_select[fd] = topDict.FDArray.length - 1;
      }
      used_fds[fd] = true;
      topDict.FDSelect.fds.push(fd_select[fd]);
      let glyph = this.font.getGlyph(gid);
      let path = glyph.path;
      for (let subr in glyph._usedSubrs) used_subrs[fd_select[fd]][subr] = true;
    }
    for (let i3 = 0; i3 < topDict.FDArray.length; i3++) {
      let dict = topDict.FDArray[i3];
      delete dict.FontName;
      if (dict.Private && dict.Private.Subrs) {
        dict.Private = Object.assign({}, dict.Private);
        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i3]);
      }
    }
    return;
  }
  createCIDFontdict(topDict) {
    let used_subrs = {};
    for (let gid of this.glyphs) {
      let glyph = this.font.getGlyph(gid);
      let path = glyph.path;
      for (let subr in glyph._usedSubrs) used_subrs[subr] = true;
    }
    let privateDict = Object.assign({}, this.cff.topDict.Private);
    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
    topDict.FDArray = [
      {
        Private: privateDict
      }
    ];
    return topDict.FDSelect = {
      version: 3,
      nRanges: 1,
      ranges: [
        {
          first: 0,
          fd: 0
        }
      ],
      sentinel: this.charstrings.length
    };
  }
  addString(string) {
    if (!string) return null;
    if (!this.strings) this.strings = [];
    this.strings.push(string);
    return (0, $229224aec43783c5$export$2e2bcd8739ae039).length + this.strings.length - 1;
  }
  encode() {
    this.subsetCharstrings();
    let charset = {
      version: this.charstrings.length > 255 ? 2 : 1,
      ranges: [
        {
          first: 1,
          nLeft: this.charstrings.length - 2
        }
      ]
    };
    let topDict = Object.assign({}, this.cff.topDict);
    topDict.Private = null;
    topDict.charset = charset;
    topDict.Encoding = null;
    topDict.CharStrings = this.charstrings;
    for (let key of [
      "version",
      "Notice",
      "Copyright",
      "FullName",
      "FamilyName",
      "Weight",
      "PostScript",
      "BaseFontName",
      "FontName"
    ]) topDict[key] = this.addString(this.cff.string(topDict[key]));
    topDict.ROS = [
      this.addString("Adobe"),
      this.addString("Identity"),
      0
    ];
    topDict.CIDCount = this.charstrings.length;
    if (this.cff.isCIDFont) this.subsetFontdict(topDict);
    else this.createCIDFontdict(topDict);
    let top = {
      version: 1,
      hdrSize: this.cff.hdrSize,
      offSize: 4,
      header: this.cff.header,
      nameIndex: [
        this.cff.postscriptName
      ],
      topDictIndex: [
        topDict
      ],
      stringIndex: this.strings,
      globalSubrIndex: this.gsubrs
    };
    return (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).toBuffer(top);
  }
  constructor(font) {
    super(font);
    this.cff = this.font["CFF "];
    if (!this.cff) throw new Error("Not a CFF Font");
  }
};
var $4c1709dee528ea76$export$2e2bcd8739ae039 = class _$4c1709dee528ea76$export$2e2bcd8739ae039 {
  static probe(buffer) {
    let format3 = (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4));
    return format3 === "true" || format3 === "OTTO" || format3 === String.fromCharCode(0, 1, 0, 0);
  }
  setDefaultLanguage(lang = null) {
    this.defaultLanguage = lang;
  }
  _getTable(table) {
    if (!(table.tag in this._tables)) try {
      this._tables[table.tag] = this._decodeTable(table);
    } catch (e3) {
      if ($d636bc798e7178db$export$bd5c5d8b8dcafd78) {
        console.error(`Error decoding table ${table.tag}`);
        console.error(e3.stack);
      }
    }
    return this._tables[table.tag];
  }
  _getTableStream(tag) {
    let table = this.directory.tables[tag];
    if (table) {
      this.stream.pos = table.offset;
      return this.stream;
    }
    return null;
  }
  _decodeDirectory() {
    return this.directory = (0, $816c07a04b6dba87$export$2e2bcd8739ae039).decode(this.stream, {
      _startOffset: 0
    });
  }
  _decodeTable(table) {
    let pos = this.stream.pos;
    let stream2 = this._getTableStream(table.tag);
    let result = (0, $c3395722bea751e2$export$2e2bcd8739ae039)[table.tag].decode(stream2, this, table.length);
    this.stream.pos = pos;
    return result;
  }
  /**
  * Gets a string from the font's `name` table
  * `lang` is a BCP-47 language code.
  * @return {string}
  */
  getName(key, lang = this.defaultLanguage || $d636bc798e7178db$export$42940898df819940) {
    let record = this.name && this.name.records[key];
    if (record)
      return record[lang] || record[this.defaultLanguage] || record[$d636bc798e7178db$export$42940898df819940] || record["en"] || record[Object.keys(record)[0]] || null;
    return null;
  }
  /**
  * The unique PostScript name for this font, e.g. "Helvetica-Bold"
  * @type {string}
  */
  get postscriptName() {
    return this.getName("postscriptName");
  }
  /**
  * The font's full name, e.g. "Helvetica Bold"
  * @type {string}
  */
  get fullName() {
    return this.getName("fullName");
  }
  /**
  * The font's family name, e.g. "Helvetica"
  * @type {string}
  */
  get familyName() {
    return this.getName("fontFamily");
  }
  /**
  * The font's sub-family, e.g. "Bold".
  * @type {string}
  */
  get subfamilyName() {
    return this.getName("fontSubfamily");
  }
  /**
  * The font's copyright information
  * @type {string}
  */
  get copyright() {
    return this.getName("copyright");
  }
  /**
  * The font's version number
  * @type {string}
  */
  get version() {
    return this.getName("version");
  }
  /**
  * The fonts [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))
  * @type {number}
  */
  get ascent() {
    return this.hhea.ascent;
  }
  /**
  * The fonts [descender](https://en.wikipedia.org/wiki/Descender)
  * @type {number}
  */
  get descent() {
    return this.hhea.descent;
  }
  /**
  * The amount of space that should be included between lines
  * @type {number}
  */
  get lineGap() {
    return this.hhea.lineGap;
  }
  /**
  * The offset from the normal underline position that should be used
  * @type {number}
  */
  get underlinePosition() {
    return this.post.underlinePosition;
  }
  /**
  * The weight of the underline that should be used
  * @type {number}
  */
  get underlineThickness() {
    return this.post.underlineThickness;
  }
  /**
  * If this is an italic font, the angle the cursor should be drawn at to match the font design
  * @type {number}
  */
  get italicAngle() {
    return this.post.italicAngle;
  }
  /**
  * The height of capital letters above the baseline.
  * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.
  * @type {number}
  */
  get capHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.capHeight : this.ascent;
  }
  /**
  * The height of lower case letters in the font.
  * See [here](https://en.wikipedia.org/wiki/X-height) for more details.
  * @type {number}
  */
  get xHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.xHeight : 0;
  }
  /**
  * The number of glyphs in the font.
  * @type {number}
  */
  get numGlyphs() {
    return this.maxp.numGlyphs;
  }
  /**
  * The size of the fonts internal coordinate grid
  * @type {number}
  */
  get unitsPerEm() {
    return this.head.unitsPerEm;
  }
  /**
  * The fonts bounding box, i.e. the box that encloses all glyphs in the font.
  * @type {BBox}
  */
  get bbox() {
    return Object.freeze(new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
  }
  get _cmapProcessor() {
    return new (0, $f08dd41ef10b694c$export$2e2bcd8739ae039)(this.cmap);
  }
  /**
  * An array of all of the unicode code points supported by the font.
  * @type {number[]}
  */
  get characterSet() {
    return this._cmapProcessor.getCharacterSet();
  }
  /**
  * Returns whether there is glyph in the font for the given unicode code point.
  *
  * @param {number} codePoint
  * @return {boolean}
  */
  hasGlyphForCodePoint(codePoint) {
    return !!this._cmapProcessor.lookup(codePoint);
  }
  /**
  * Maps a single unicode code point to a Glyph object.
  * Does not perform any advanced substitutions (there is no context to do so).
  *
  * @param {number} codePoint
  * @return {Glyph}
  */
  glyphForCodePoint(codePoint) {
    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [
      codePoint
    ]);
  }
  /**
  * Returns an array of Glyph objects for the given string.
  * This is only a one-to-one mapping from characters to glyphs.
  * For most uses, you should use font.layout (described below), which
  * provides a much more advanced mapping supporting AAT and OpenType shaping.
  *
  * @param {string} string
  * @return {Glyph[]}
  */
  glyphsForString(string) {
    let glyphs = [];
    let len = string.length;
    let idx = 0;
    let last2 = -1;
    let state2 = -1;
    while (idx <= len) {
      let code = 0;
      let nextState = 0;
      if (idx < len) {
        code = string.charCodeAt(idx++);
        if (55296 <= code && code <= 56319 && idx < len) {
          let next = string.charCodeAt(idx);
          if (56320 <= next && next <= 57343) {
            idx++;
            code = ((code & 1023) << 10) + (next & 1023) + 65536;
          }
        }
        nextState = 65024 <= code && code <= 65039 || 917760 <= code && code <= 917999 ? 1 : 0;
      } else idx++;
      if (state2 === 0 && nextState === 1)
        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last2, code), [
          last2,
          code
        ]));
      else if (state2 === 0 && nextState === 0)
        glyphs.push(this.glyphForCodePoint(last2));
      last2 = code;
      state2 = nextState;
    }
    return glyphs;
  }
  get _layoutEngine() {
    return new (0, $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039)(this);
  }
  /**
  * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.
  *
  * @param {string} string
  * @param {string[]} [userFeatures]
  * @param {string} [script]
  * @param {string} [language]
  * @param {string} [direction]
  * @return {GlyphRun}
  */
  layout(string, userFeatures, script, language, direction) {
    return this._layoutEngine.layout(string, userFeatures, script, language, direction);
  }
  /**
  * Returns an array of strings that map to the given glyph id.
  * @param {number} gid - glyph id
  */
  stringsForGlyph(gid) {
    return this._layoutEngine.stringsForGlyph(gid);
  }
  /**
  * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)
  * (or mapped AAT tags) supported by the font.
  * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.
  * If this is an AAT font, the OpenType feature tags are mapped to AAT features.
  *
  * @type {string[]}
  */
  get availableFeatures() {
    return this._layoutEngine.getAvailableFeatures();
  }
  getAvailableFeatures(script, language) {
    return this._layoutEngine.getAvailableFeatures(script, language);
  }
  _getBaseGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf) this._glyphs[glyph] = new (0, $69aac16029968692$export$2e2bcd8739ae039)(glyph, characters2, this);
      else if (this.directory.tables["CFF "] || this.directory.tables.CFF2) this._glyphs[glyph] = new (0, $62cc5109c6101893$export$2e2bcd8739ae039)(glyph, characters2, this);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a glyph object for the given glyph id.
  * You can pass the array of code points this glyph represents for
  * your use later, and it will be stored in the glyph object.
  *
  * @param {number} glyph
  * @param {number[]} characters
  * @return {Glyph}
  */
  getGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.sbix) this._glyphs[glyph] = new (0, $25d8f049c222084c$export$2e2bcd8739ae039)(glyph, characters2, this);
      else if (this.directory.tables.COLR && this.directory.tables.CPAL) this._glyphs[glyph] = new (0, $0d411f0165859681$export$2e2bcd8739ae039)(glyph, characters2, this);
      else this._getBaseGlyph(glyph, characters2);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a Subset for this font.
  * @return {Subset}
  */
  createSubset() {
    if (this.directory.tables["CFF "]) return new (0, $001d739428a71d5a$export$2e2bcd8739ae039)(this);
    return new (0, $4abbb6a5dbdc441a$export$2e2bcd8739ae039)(this);
  }
  /**
  * Returns an object describing the available variation axes
  * that this font supports. Keys are setting tags, and values
  * contain the axis name, range, and default value.
  *
  * @type {object}
  */
  get variationAxes() {
    let res = {};
    if (!this.fvar) return res;
    for (let axis of this.fvar.axis) res[axis.axisTag.trim()] = {
      name: axis.name.en,
      min: axis.minValue,
      default: axis.defaultValue,
      max: axis.maxValue
    };
    return res;
  }
  /**
  * Returns an object describing the named variation instances
  * that the font designer has specified. Keys are variation names
  * and values are the variation settings for this instance.
  *
  * @type {object}
  */
  get namedVariations() {
    let res = {};
    if (!this.fvar) return res;
    for (let instance of this.fvar.instance) {
      let settings = {};
      for (let i3 = 0; i3 < this.fvar.axis.length; i3++) {
        let axis = this.fvar.axis[i3];
        settings[axis.axisTag.trim()] = instance.coord[i3];
      }
      res[instance.name.en] = settings;
    }
    return res;
  }
  /**
  * Returns a new font with the given variation settings applied.
  * Settings can either be an instance name, or an object containing
  * variation tags as specified by the `variationAxes` property.
  *
  * @param {object} settings
  * @return {TTFFont}
  */
  getVariation(settings) {
    if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))) throw new Error("Variations require a font with the fvar, gvar and glyf, or CFF2 tables.");
    if (typeof settings === "string") settings = this.namedVariations[settings];
    if (typeof settings !== "object") throw new Error("Variation settings must be either a variation name or settings object.");
    let coords = this.fvar.axis.map((axis, i3) => {
      let axisTag = axis.axisTag.trim();
      if (axisTag in settings) return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
      else return axis.defaultValue;
    });
    let stream2 = new DecodeStream(this.stream.buffer);
    stream2.pos = this._directoryPos;
    let font = new _$4c1709dee528ea76$export$2e2bcd8739ae039(stream2, coords);
    font._tables = this._tables;
    return font;
  }
  get _variationProcessor() {
    if (!this.fvar) return null;
    let variationCoords = this.variationCoords;
    if (!variationCoords && !this.CFF2) return null;
    if (!variationCoords) variationCoords = this.fvar.axis.map((axis) => axis.defaultValue);
    return new (0, $0bb840cac04e911b$export$2e2bcd8739ae039)(this, variationCoords);
  }
  // Standardized format plugin API
  getFont(name) {
    return this.getVariation(name);
  }
  constructor(stream2, variationCoords = null) {
    (0, _define_property)(this, "type", "TTF");
    this.defaultLanguage = null;
    this.stream = stream2;
    this.variationCoords = variationCoords;
    this._directoryPos = this.stream.pos;
    this._tables = {};
    this._glyphs = {};
    this._decodeDirectory();
    for (let tag in this.directory.tables) {
      let table = this.directory.tables[tag];
      if ((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag] && table.length > 0) Object.defineProperty(this, tag, {
        get: this._getTable.bind(this, table)
      });
    }
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "bbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_cmapProcessor", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "characterSet", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_layoutEngine", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "variationAxes", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "namedVariations", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_variationProcessor", null);
var $c1726355ecc5b889$var$WOFFDirectoryEntry = new Struct({
  tag: new StringT(4),
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  compLength: uint32,
  length: uint32,
  origChecksum: uint32
});
var $c1726355ecc5b889$var$WOFFDirectory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c1726355ecc5b889$var$WOFFDirectoryEntry, "numTables")
});
$c1726355ecc5b889$var$WOFFDirectory.process = function() {
  let tables = {};
  for (let table of this.tables) tables[table.tag] = table;
  this.tables = tables;
};
var $c1726355ecc5b889$export$2e2bcd8739ae039 = $c1726355ecc5b889$var$WOFFDirectory;
var $760785214b9fc52c$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOFF";
  }
  _decodeDirectory() {
    this.directory = (0, $c1726355ecc5b889$export$2e2bcd8739ae039).decode(this.stream, {
      _startOffset: 0
    });
  }
  _getTableStream(tag) {
    let table = this.directory.tables[tag];
    if (table) {
      this.stream.pos = table.offset;
      if (table.compLength < table.length) {
        this.stream.pos += 2;
        let outBuffer = new Uint8Array(table.length);
        let buf = (0, import_tiny_inflate.default)(this.stream.readBuffer(table.compLength - 2), outBuffer);
        return new DecodeStream(buf);
      } else return this.stream;
    }
    return null;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF");
  }
};
var $8046190c9f1ad19e$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
  _decode() {
    return this._font._transformedGlyphs[this.id];
  }
  _getCBox() {
    return this.path.bbox;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF2");
  }
};
var $c28ec7bbb3b8de3a$var$Base128 = {
  decode(stream2) {
    let result = 0;
    let iterable = [
      0,
      1,
      2,
      3,
      4
    ];
    for (let j = 0; j < iterable.length; j++) {
      let i3 = iterable[j];
      let code = stream2.readUInt8();
      if (result & 3758096384) throw new Error("Overflow");
      result = result << 7 | code & 127;
      if ((code & 128) === 0) return result;
    }
    throw new Error("Bad base 128 number");
  }
};
var $c28ec7bbb3b8de3a$var$knownTags = [
  "cmap",
  "head",
  "hhea",
  "hmtx",
  "maxp",
  "name",
  "OS/2",
  "post",
  "cvt ",
  "fpgm",
  "glyf",
  "loca",
  "prep",
  "CFF ",
  "VORG",
  "EBDT",
  "EBLC",
  "gasp",
  "hdmx",
  "kern",
  "LTSH",
  "PCLT",
  "VDMX",
  "vhea",
  "vmtx",
  "BASE",
  "GDEF",
  "GPOS",
  "GSUB",
  "EBSC",
  "JSTF",
  "MATH",
  "CBDT",
  "CBLC",
  "COLR",
  "CPAL",
  "SVG ",
  "sbix",
  "acnt",
  "avar",
  "bdat",
  "bloc",
  "bsln",
  "cvar",
  "fdsc",
  "feat",
  "fmtx",
  "fvar",
  "gvar",
  "hsty",
  "just",
  "lcar",
  "mort",
  "morx",
  "opbd",
  "prop",
  "trak",
  "Zapf",
  "Silf",
  "Glat",
  "Gloc",
  "Feat",
  "Sill"
];
var $c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry = new Struct({
  flags: uint8,
  customTag: new Optional(new StringT(4), (t3) => (t3.flags & 63) === 63),
  tag: (t3) => t3.customTag || $c28ec7bbb3b8de3a$var$knownTags[t3.flags & 63],
  length: $c28ec7bbb3b8de3a$var$Base128,
  transformVersion: (t3) => t3.flags >>> 6 & 3,
  transformed: (t3) => t3.tag === "glyf" || t3.tag === "loca" ? t3.transformVersion === 0 : t3.transformVersion !== 0,
  transformLength: new Optional($c28ec7bbb3b8de3a$var$Base128, (t3) => t3.transformed)
});
var $c28ec7bbb3b8de3a$var$WOFF2Directory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  totalCompressedSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry, "numTables")
});
$c28ec7bbb3b8de3a$var$WOFF2Directory.process = function() {
  let tables = {};
  for (let i3 = 0; i3 < this.tables.length; i3++) {
    let table = this.tables[i3];
    tables[table.tag] = table;
  }
  return this.tables = tables;
};
var $c28ec7bbb3b8de3a$export$2e2bcd8739ae039 = $c28ec7bbb3b8de3a$var$WOFF2Directory;
var $21ee218f84ac7f32$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOF2";
  }
  _decodeDirectory() {
    this.directory = (0, $c28ec7bbb3b8de3a$export$2e2bcd8739ae039).decode(this.stream);
    this._dataPos = this.stream.pos;
  }
  _decompress() {
    if (!this._decompressed) {
      this.stream.pos = this._dataPos;
      let buffer = this.stream.readBuffer(this.directory.totalCompressedSize);
      let decompressedSize = 0;
      for (let tag in this.directory.tables) {
        let entry = this.directory.tables[tag];
        entry.offset = decompressedSize;
        decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;
      }
      let decompressed = (0, import_decompress.default)(buffer, decompressedSize);
      if (!decompressed) throw new Error("Error decoding compressed data in WOFF2");
      this.stream = new DecodeStream(decompressed);
      this._decompressed = true;
    }
  }
  _decodeTable(table) {
    this._decompress();
    return super._decodeTable(table);
  }
  // Override this method to get a glyph and return our
  // custom subclass if there is a glyf table.
  _getBaseGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {
        if (!this._transformedGlyphs) this._transformGlyfTable();
        return this._glyphs[glyph] = new (0, $8046190c9f1ad19e$export$2e2bcd8739ae039)(glyph, characters2, this);
      } else return super._getBaseGlyph(glyph, characters2);
    }
  }
  _transformGlyfTable() {
    this._decompress();
    this.stream.pos = this.directory.tables.glyf.offset;
    let table = $21ee218f84ac7f32$var$GlyfTable.decode(this.stream);
    let glyphs = [];
    for (let index3 = 0; index3 < table.numGlyphs; index3++) {
      let glyph = {};
      let nContours = table.nContours.readInt16BE();
      glyph.numberOfContours = nContours;
      if (nContours > 0) {
        let nPoints = [];
        let totalPoints = 0;
        for (let i3 = 0; i3 < nContours; i3++) {
          let r3 = $21ee218f84ac7f32$var$read255UInt16(table.nPoints);
          totalPoints += r3;
          nPoints.push(totalPoints);
        }
        glyph.points = $21ee218f84ac7f32$var$decodeTriplet(table.flags, table.glyphs, totalPoints);
        for (let i3 = 0; i3 < nContours; i3++) glyph.points[nPoints[i3] - 1].endContour = true;
        var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
      } else if (nContours < 0) {
        let haveInstructions = (0, $69aac16029968692$export$2e2bcd8739ae039).prototype._decodeComposite.call({
          _font: this
        }, glyph, table.composites);
        if (haveInstructions) var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
      }
      glyphs.push(glyph);
    }
    this._transformedGlyphs = glyphs;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF2");
  }
};
var $21ee218f84ac7f32$var$Substream = class {
  decode(stream2, parent) {
    return new DecodeStream(this._buf.decode(stream2, parent));
  }
  constructor(length2) {
    this.length = length2;
    this._buf = new BufferT(length2);
  }
};
var $21ee218f84ac7f32$var$GlyfTable = new Struct({
  version: uint32,
  numGlyphs: uint16,
  indexFormat: uint16,
  nContourStreamSize: uint32,
  nPointsStreamSize: uint32,
  flagStreamSize: uint32,
  glyphStreamSize: uint32,
  compositeStreamSize: uint32,
  bboxStreamSize: uint32,
  instructionStreamSize: uint32,
  nContours: new $21ee218f84ac7f32$var$Substream("nContourStreamSize"),
  nPoints: new $21ee218f84ac7f32$var$Substream("nPointsStreamSize"),
  flags: new $21ee218f84ac7f32$var$Substream("flagStreamSize"),
  glyphs: new $21ee218f84ac7f32$var$Substream("glyphStreamSize"),
  composites: new $21ee218f84ac7f32$var$Substream("compositeStreamSize"),
  bboxes: new $21ee218f84ac7f32$var$Substream("bboxStreamSize"),
  instructions: new $21ee218f84ac7f32$var$Substream("instructionStreamSize")
});
var $21ee218f84ac7f32$var$WORD_CODE = 253;
var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2 = 254;
var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1 = 255;
var $21ee218f84ac7f32$var$LOWEST_U_CODE = 253;
function $21ee218f84ac7f32$var$read255UInt16(stream2) {
  let code = stream2.readUInt8();
  if (code === $21ee218f84ac7f32$var$WORD_CODE) return stream2.readUInt16BE();
  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1) return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE;
  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2) return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE * 2;
  return code;
}
function $21ee218f84ac7f32$var$withSign(flag, baseval) {
  return flag & 1 ? baseval : -baseval;
}
function $21ee218f84ac7f32$var$decodeTriplet(flags, glyphs, nPoints) {
  let y2;
  let x = y2 = 0;
  let res = [];
  for (let i3 = 0; i3 < nPoints; i3++) {
    let dx = 0, dy = 0;
    let flag = flags.readUInt8();
    let onCurve = !(flag >> 7);
    flag &= 127;
    if (flag < 10) {
      dx = 0;
      dy = $21ee218f84ac7f32$var$withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());
    } else if (flag < 20) {
      dx = $21ee218f84ac7f32$var$withSign(flag, ((flag - 10 & 14) << 7) + glyphs.readUInt8());
      dy = 0;
    } else if (flag < 84) {
      var b0 = flag - 20;
      var b1 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 & 48) + (b1 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
    } else if (flag < 120) {
      var b0 = flag - 84;
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 / 12 << 8) + glyphs.readUInt8());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());
    } else if (flag < 124) {
      var b1 = glyphs.readUInt8();
      let b2 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, (b1 << 4) + (b2 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, ((b2 & 15) << 8) + glyphs.readUInt8());
    } else {
      dx = $21ee218f84ac7f32$var$withSign(flag, glyphs.readUInt16BE());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, glyphs.readUInt16BE());
    }
    x += dx;
    y2 += dy;
    res.push(new (0, $69aac16029968692$export$baf26146a414f24a)(onCurve, false, x, y2));
  }
  return res;
}
var $cd5853a56c68fec7$var$TTCHeader = new VersionedStruct(uint32, {
  65536: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts")
  },
  131072: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts"),
    dsigTag: uint32,
    dsigLength: uint32,
    dsigOffset: uint32
  }
});
var $cd5853a56c68fec7$export$2e2bcd8739ae039 = class {
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "ttcf";
  }
  getFont(name) {
    for (let offset2 of this.header.offsets) {
      let stream2 = new DecodeStream(this.stream.buffer);
      stream2.pos = offset2;
      let font = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2);
      if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v2, i3) => name[i3] === v2)) return font;
    }
    return null;
  }
  get fonts() {
    let fonts = [];
    for (let offset2 of this.header.offsets) {
      let stream2 = new DecodeStream(this.stream.buffer);
      stream2.pos = offset2;
      fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2));
    }
    return fonts;
  }
  constructor(stream2) {
    (0, _define_property)(this, "type", "TTC");
    this.stream = stream2;
    if (stream2.readString(4) !== "ttcf") throw new Error("Not a TrueType collection");
    this.header = $cd5853a56c68fec7$var$TTCHeader.decode(stream2);
  }
};
var $05f49f930186144e$var$DFontName = new StringT(uint8);
var $05f49f930186144e$var$DFontData = new Struct({
  len: uint32,
  buf: new BufferT("len")
});
var $05f49f930186144e$var$Ref = new Struct({
  id: uint16,
  nameOffset: int16,
  attr: uint8,
  dataOffset: uint24,
  handle: uint32
});
var $05f49f930186144e$var$Type = new Struct({
  name: new StringT(4),
  maxTypeIndex: uint16,
  refList: new Pointer(uint16, new ArrayT($05f49f930186144e$var$Ref, (t3) => t3.maxTypeIndex + 1), {
    type: "parent"
  })
});
var $05f49f930186144e$var$TypeList = new Struct({
  length: uint16,
  types: new ArrayT($05f49f930186144e$var$Type, (t3) => t3.length + 1)
});
var $05f49f930186144e$var$DFontMap = new Struct({
  reserved: new Reserved(uint8, 24),
  typeList: new Pointer(uint16, $05f49f930186144e$var$TypeList),
  nameListOffset: new Pointer(uint16, "void")
});
var $05f49f930186144e$var$DFontHeader = new Struct({
  dataOffset: uint32,
  map: new Pointer(uint32, $05f49f930186144e$var$DFontMap),
  dataLength: uint32,
  mapLength: uint32
});
var $05f49f930186144e$export$2e2bcd8739ae039 = class {
  static probe(buffer) {
    let stream2 = new DecodeStream(buffer);
    try {
      var header = $05f49f930186144e$var$DFontHeader.decode(stream2);
    } catch (e3) {
      return false;
    }
    for (let type of header.map.typeList.types) {
      if (type.name === "sfnt") return true;
    }
    return false;
  }
  getFont(name) {
    if (!this.sfnt) return null;
    for (let ref of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref.dataOffset + 4;
      let stream2 = new DecodeStream(this.stream.buffer.slice(pos));
      let font = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2);
      if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v2, i3) => name[i3] === v2)) return font;
    }
    return null;
  }
  get fonts() {
    let fonts = [];
    for (let ref of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref.dataOffset + 4;
      let stream2 = new DecodeStream(this.stream.buffer.slice(pos));
      fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2));
    }
    return fonts;
  }
  constructor(stream2) {
    (0, _define_property)(this, "type", "DFont");
    this.stream = stream2;
    this.header = $05f49f930186144e$var$DFontHeader.decode(this.stream);
    for (let type of this.header.map.typeList.types) {
      for (let ref of type.refList) if (ref.nameOffset >= 0) {
        this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
        ref.name = $05f49f930186144e$var$DFontName.decode(this.stream);
      } else ref.name = null;
      if (type.name === "sfnt") this.sfnt = type;
    }
  }
};
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $4c1709dee528ea76$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $760785214b9fc52c$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $21ee218f84ac7f32$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $cd5853a56c68fec7$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $05f49f930186144e$export$2e2bcd8739ae039));

// node_modules/@react-pdf/font/lib/index.browser.js
var FONT_WEIGHTS = {
  thin: 100,
  hairline: 100,
  ultralight: 200,
  extralight: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  demibold: 600,
  bold: 700,
  ultrabold: 800,
  extrabold: 800,
  heavy: 900,
  black: 900
};
var fetchFont = async (src, options) => {
  const response = await fetch(src, options);
  const data2 = await response.arrayBuffer();
  return new Uint8Array(data2);
};
var isDataUrl = (dataUrl) => {
  const header = dataUrl.split(",")[0];
  const hasDataPrefix = header.substring(0, 5) === "data:";
  const hasBase64Prefix = header.split(";")[1] === "base64";
  return hasDataPrefix && hasBase64Prefix;
};
var resolveFontWeight = (value2) => {
  return typeof value2 === "string" ? FONT_WEIGHTS[value2] : value2;
};
var sortByFontWeight = (a3, b2) => a3.fontWeight - b2.fontWeight;
var FontSource = class {
  constructor(src, fontFamily, fontStyle, fontWeight, options) {
    __publicField(this, "src");
    __publicField(this, "fontFamily");
    __publicField(this, "fontStyle");
    __publicField(this, "fontWeight");
    __publicField(this, "data");
    __publicField(this, "options");
    __publicField(this, "loadResultPromise");
    this.src = src;
    this.fontFamily = fontFamily;
    this.fontStyle = fontStyle || "normal";
    this.fontWeight = fontWeight || 400;
    this.data = null;
    this.options = options;
    this.loadResultPromise = null;
  }
  async _load() {
    const { postscriptName } = this.options;
    if (isDataUrl(this.src)) {
      const raw = this.src.split(",")[1];
      const uint8Array = new Uint8Array(atob(raw).split("").map((c3) => c3.charCodeAt(0)));
      this.data = $d636bc798e7178db$export$185802fd694ee1f5(uint8Array, postscriptName);
    } else {
      const { headers, body, method = "GET" } = this.options;
      const data2 = await fetchFont(this.src, { method, body, headers });
      this.data = $d636bc798e7178db$export$185802fd694ee1f5(data2, postscriptName);
    }
  }
  async load() {
    if (this.loadResultPromise === null) {
      this.loadResultPromise = this._load();
    }
    return this.loadResultPromise;
  }
};
var Font = class _Font {
  constructor(family) {
    __publicField(this, "family");
    __publicField(this, "sources");
    this.family = family;
    this.sources = [];
  }
  static create(family) {
    return new _Font(family);
  }
  register({ src, fontWeight, fontStyle, ...options }) {
    const numericFontWeight = resolveFontWeight(fontWeight);
    this.sources.push(new FontSource(src, this.family, fontStyle, numericFontWeight, options));
  }
  resolve(descriptor) {
    const { fontWeight = 400, fontStyle = "normal" } = descriptor;
    const styleSources = this.sources.filter((s2) => s2.fontStyle === fontStyle);
    const exactFit = styleSources.find((s2) => s2.fontWeight === fontWeight);
    if (exactFit)
      return exactFit;
    let res;
    const numericFontWeight = resolveFontWeight(fontWeight);
    if (numericFontWeight >= 400 && numericFontWeight <= 500) {
      const leftOffset = styleSources.filter((s2) => s2.fontWeight <= numericFontWeight);
      const rightOffset = styleSources.filter((s2) => s2.fontWeight > 500);
      const fit = styleSources.filter((s2) => s2.fontWeight >= numericFontWeight && s2.fontWeight < 500);
      res = fit[0] || leftOffset[leftOffset.length - 1] || rightOffset[0];
    }
    const lt = styleSources.filter((s2) => s2.fontWeight < numericFontWeight).sort(sortByFontWeight);
    const gt = styleSources.filter((s2) => s2.fontWeight > numericFontWeight).sort(sortByFontWeight);
    if (numericFontWeight < 400) {
      res = lt[lt.length - 1] || gt[0];
    }
    if (numericFontWeight > 500) {
      res = gt[0] || lt[lt.length - 1];
    }
    if (!res) {
      throw new Error(`Could not resolve font for ${this.family}, fontWeight ${fontWeight}, fontStyle ${fontStyle}`);
    }
    return res;
  }
};
var standard = [
  "Courier",
  "Courier-Bold",
  "Courier-Oblique",
  "Courier-BoldOblique",
  "Helvetica",
  "Helvetica-Bold",
  "Helvetica-Oblique",
  "Helvetica-BoldOblique",
  "Times-Roman",
  "Times-Bold",
  "Times-Italic",
  "Times-BoldItalic"
];
var FontStore = class {
  constructor() {
    __publicField(this, "fonts", {});
    __publicField(this, "emojiSource", null);
    __publicField(this, "hyphenationCallback", null);
    __publicField(this, "register", (data2) => {
      const { family } = data2;
      if (!this.fonts[family]) {
        this.fonts[family] = Font.create(family);
      }
      if ("fonts" in data2) {
        for (let i3 = 0; i3 < data2.fonts.length; i3 += 1) {
          this.fonts[family].register({ family, ...data2.fonts[i3] });
        }
      } else {
        this.fonts[family].register(data2);
      }
    });
    __publicField(this, "registerEmojiSource", (emojiSource) => {
      const url = "url" in emojiSource ? emojiSource.url : void 0;
      const format3 = "format" in emojiSource ? emojiSource.format : void 0;
      const builder = "builder" in emojiSource ? emojiSource.builder : void 0;
      const withVariationSelectors = emojiSource.withVariationSelectors || false;
      this.emojiSource = {
        url,
        format: format3 || "png",
        builder,
        withVariationSelectors
      };
    });
    __publicField(this, "registerHyphenationCallback", (callback) => {
      this.hyphenationCallback = callback;
    });
    __publicField(this, "getFont", (descriptor) => {
      const { fontFamily } = descriptor;
      const isStandard = standard.includes(fontFamily);
      if (isStandard)
        return null;
      if (!this.fonts[fontFamily]) {
        throw new Error(`Font family not registered: ${fontFamily}. Please register it calling Font.register() method.`);
      }
      return this.fonts[fontFamily].resolve(descriptor);
    });
    __publicField(this, "load", async (descriptor) => {
      const { fontFamily } = descriptor;
      const fontFamilies = typeof fontFamily === "string" ? [fontFamily] : [...fontFamily || []];
      const promises = [];
      for (let len = fontFamilies.length, i3 = 0; i3 < len; i3 += 1) {
        const family = fontFamilies[i3];
        const isStandard = standard.includes(family);
        if (isStandard)
          return;
        const f2 = this.getFont({ ...descriptor, fontFamily: family });
        promises.push(f2.load());
      }
      await Promise.all(promises);
    });
    __publicField(this, "reset", () => {
      const keys2 = Object.keys(this.fonts);
      for (let i3 = 0; i3 < keys2.length; i3 += 1) {
        const key = keys2[i3];
        this.fonts[key].data = null;
      }
    });
    __publicField(this, "clear", () => {
      this.fonts = {};
    });
    __publicField(this, "getRegisteredFonts", () => this.fonts);
    __publicField(this, "getEmojiSource", () => this.emojiSource);
    __publicField(this, "getHyphenationCallback", () => this.hyphenationCallback);
    __publicField(this, "getRegisteredFontFamilies", () => Object.keys(this.fonts));
  }
};

// node_modules/@react-pdf/fns/lib/index.js
var adjust = (index3, fn, collection) => {
  if (index3 >= 0 && index3 >= collection.length)
    return collection;
  if (index3 < 0 && Math.abs(index3) > collection.length)
    return collection;
  const i3 = index3 < 0 ? collection.length + index3 : index3;
  return Object.assign([], collection, { [i3]: fn(collection[i3]) });
};
var reverse = (list) => Array.prototype.slice.call(list, 0).reverse();
var asyncCompose = (...fns) => async (value2, ...args) => {
  let result = value2;
  const reversedFns = reverse(fns);
  for (let i3 = 0; i3 < reversedFns.length; i3 += 1) {
    const fn = reversedFns[i3];
    result = await fn(result, ...args);
  }
  return result;
};
var capitalize = (value2) => {
  if (!value2)
    return value2;
  return value2.replace(/(^|\s)\S/g, (l2) => l2.toUpperCase());
};
var castArray = (value2) => {
  return Array.isArray(value2) ? value2 : [value2];
};
var compose = (...fns) => (value2, ...args) => {
  let result = value2;
  const reversedFns = fns.slice().reverse();
  for (let i3 = 0; i3 < reversedFns.length; i3 += 1) {
    const fn = reversedFns[i3];
    result = fn(result, ...args);
  }
  return result;
};
var dropLast = (array) => array.slice(0, array.length - 1);
var evolve = (transformations, object) => {
  const result = {};
  const keys2 = Object.keys(object);
  for (let i3 = 0; i3 < keys2.length; i3 += 1) {
    const key = keys2[i3];
    const transformation = transformations[key];
    const type = typeof transformation;
    if (type === "function") {
      result[key] = transformation(object[key]);
    } else {
      result[key] = object[key];
    }
  }
  return result;
};
var isNil = (value2) => value2 === null || value2 === void 0;
var get = (target, path, defaultValue) => {
  if (isNil(target))
    return defaultValue;
  const _path = castArray(path);
  let result = target;
  for (let i3 = 0; i3 < _path.length; i3 += 1) {
    if (isNil(result))
      return void 0;
    result = result[_path[i3]];
  }
  return isNil(result) ? defaultValue : result;
};
function last(value2) {
  return value2 === "" ? "" : value2[value2.length - 1];
}
var mapValues = (object, fn) => {
  const entries = Object.entries(object);
  const acc = {};
  return entries.reduce((acc2, [key, value2], index3) => {
    acc2[key] = fn(value2, key, index3);
    return acc2;
  }, acc);
};
var isPercent = (value2) => /((-)?\d+\.?\d*)%/g.exec(`${value2}`);
var matchPercent = (value2) => {
  const match = isPercent(value2);
  if (match) {
    const f2 = parseFloat(match[1]);
    const percent = f2 / 100;
    return { percent, value: f2 };
  }
  return null;
};
var omit = (keys2, object) => {
  const _keys = castArray(keys2);
  const copy5 = Object.assign({}, object);
  _keys.forEach((key) => {
    delete copy5[key];
  });
  return copy5;
};
var pick = (keys2, obj) => {
  const result = {};
  for (let i3 = 0; i3 < keys2.length; i3 += 1) {
    const key = keys2[i3];
    if (key in obj)
      result[key] = obj[key];
  }
  return result;
};
var repeat = (element, length2 = 0) => {
  const result = new Array(length2);
  for (let i3 = 0; i3 < length2; i3 += 1) {
    result[i3] = element;
  }
  return result;
};
var upperFirst = (value2) => {
  if (!value2)
    return value2;
  return value2.charAt(0).toUpperCase() + value2.slice(1);
};
var without = (keys2, array) => {
  const result = [];
  for (let i3 = 0; i3 < array.length; i3 += 1) {
    const value2 = array[i3];
    if (!keys2.includes(value2))
      result.push(value2);
  }
  return result;
};

// node_modules/@react-pdf/render/lib/index.js
var import_abs_svg_path = __toESM(require_abs_svg_path());
var import_parse_svg_path = __toESM(require_parse_svg_path());

// node_modules/svg-arc-to-cubic-bezier/modules/index.js
var _slicedToArray = /* @__PURE__ */ function() {
  function sliceIterator(arr, i3) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i3 && _arr.length === i3) break;
      }
    } catch (err2) {
      _d = true;
      _e = err2;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i3) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i3);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var TAU = Math.PI * 2;
var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x, y2 = _ref.y;
  x *= rx;
  y2 *= ry;
  var xp = cosphi * x - sinphi * y2;
  var yp = sinphi * x + cosphi * y2;
  return {
    x: xp + centerx,
    y: yp + centery
  };
};
var approxUnitArc = function approxUnitArc2(ang1, ang2) {
  var a3 = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);
  return [{
    x: x1 - y1 * a3,
    y: y1 + x1 * a3
  }, {
    x: x2 + y2 * a3,
    y: y2 - x2 * a3
  }, {
    x: x2,
    y: y2
  }];
};
var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot = ux * vx + uy * vy;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign * Math.acos(dot);
};
var getArcCenter = function getArcCenter2(px2, py2, cx2, cy2, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);
  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;
  var centerx = cosphi * centerxp - sinphi * centeryp + (px2 + cx2) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py2 + cy2) / 2;
  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;
  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  return [centerx, centery, ang1, ang2];
};
var arcToBezier = function arcToBezier2(_ref2) {
  var px2 = _ref2.px, py2 = _ref2.py, cx2 = _ref2.cx, cy2 = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
  var curves = [];
  if (rx === 0 || ry === 0) {
    return [];
  }
  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);
  var pxp = cosphi * (px2 - cx2) / 2 + sinphi * (py2 - cy2) / 2;
  var pyp = -sinphi * (px2 - cx2) / 2 + cosphi * (py2 - cy2) / 2;
  if (pxp === 0 && pyp === 0) {
    return [];
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var _getArcCenter = getArcCenter(px2, py2, cx2, cy2, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  var segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  for (var i3 = 0; i3 < segments; i3++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }
  return curves.map(function(curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _mapToEllipse3.x, y3 = _mapToEllipse3.y;
    return { x1, y1, x2, y2, x, y: y3 };
  });
};
var modules_default = arcToBezier;

// node_modules/normalize-svg-path/index.mjs
function normalize(path) {
  var prev;
  var result = [];
  var bezierX = 0;
  var bezierY = 0;
  var startX = 0;
  var startY = 0;
  var quadX = null;
  var quadY = null;
  var x = 0;
  var y2 = 0;
  for (var i3 = 0, len = path.length; i3 < len; i3++) {
    var seg = path[i3];
    var command = seg[0];
    switch (command) {
      case "M":
        startX = seg[1];
        startY = seg[2];
        break;
      case "A":
        var curves = modules_default({
          px: x,
          py: y2,
          cx: seg[6],
          cy: seg[7],
          rx: seg[1],
          ry: seg[2],
          xAxisRotation: seg[3],
          largeArcFlag: seg[4],
          sweepFlag: seg[5]
        });
        if (!curves.length) continue;
        for (var j = 0, c3; j < curves.length; j++) {
          c3 = curves[j];
          seg = ["C", c3.x1, c3.y1, c3.x2, c3.y2, c3.x, c3.y];
          if (j < curves.length - 1) result.push(seg);
        }
        break;
      case "S":
        var cx2 = x;
        var cy2 = y2;
        if (prev == "C" || prev == "S") {
          cx2 += cx2 - bezierX;
          cy2 += cy2 - bezierY;
        }
        seg = ["C", cx2, cy2, seg[1], seg[2], seg[3], seg[4]];
        break;
      case "T":
        if (prev == "Q" || prev == "T") {
          quadX = x * 2 - quadX;
          quadY = y2 * 2 - quadY;
        } else {
          quadX = x;
          quadY = y2;
        }
        seg = quadratic(x, y2, quadX, quadY, seg[1], seg[2]);
        break;
      case "Q":
        quadX = seg[1];
        quadY = seg[2];
        seg = quadratic(x, y2, seg[1], seg[2], seg[3], seg[4]);
        break;
      case "L":
        seg = line(x, y2, seg[1], seg[2]);
        break;
      case "H":
        seg = line(x, y2, seg[1], y2);
        break;
      case "V":
        seg = line(x, y2, x, seg[1]);
        break;
      case "Z":
        seg = line(x, y2, startX, startY);
        break;
    }
    prev = command;
    x = seg[seg.length - 2];
    y2 = seg[seg.length - 1];
    if (seg.length > 4) {
      bezierX = seg[seg.length - 4];
      bezierY = seg[seg.length - 3];
    } else {
      bezierX = x;
      bezierY = y2;
    }
    result.push(seg);
  }
  return result;
}
function line(x1, y1, x2, y2) {
  return ["C", x1, y1, x2, y2, x2, y2];
}
function quadratic(x1, y1, cx2, cy2, x2, y2) {
  return [
    "C",
    x1 / 3 + 2 / 3 * cx2,
    y1 / 3 + 2 / 3 * cy2,
    x2 / 3 + 2 / 3 * cx2,
    y2 / 3 + 2 / 3 * cy2,
    x2,
    y2
  ];
}

// node_modules/@react-pdf/render/lib/index.js
var import_color_string = __toESM(require_color_string());
var renderPath = (ctx, node) => {
  var _node$props;
  const d2 = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d;
  if (d2) ctx.path(node.props.d);
};
var KAPPA$3 = 4 * ((Math.sqrt(2) - 1) / 3);
var renderRect = (ctx, node) => {
  var _node$props, _node$props2, _node$props3, _node$props4, _node$props5, _node$props6;
  const x = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.x) || 0;
  const y2 = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.y) || 0;
  const rx = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.rx) || 0;
  const ry = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.ry) || 0;
  const width = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.width) || 0;
  const height2 = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.height) || 0;
  if (!width || !height2) return;
  if (rx && ry) {
    const krx = rx * KAPPA$3;
    const kry = ry * KAPPA$3;
    ctx.moveTo(x + rx, y2);
    ctx.lineTo(x - rx + width, y2);
    ctx.bezierCurveTo(x - rx + width + krx, y2, x + width, y2 + ry - kry, x + width, y2 + ry);
    ctx.lineTo(x + width, y2 + height2 - ry);
    ctx.bezierCurveTo(x + width, y2 + height2 - ry + kry, x - rx + width + krx, y2 + height2, x - rx + width, y2 + height2);
    ctx.lineTo(x + rx, y2 + height2);
    ctx.bezierCurveTo(x + rx - krx, y2 + height2, x, y2 + height2 - ry + kry, x, y2 + height2 - ry);
    ctx.lineTo(x, y2 + ry);
    ctx.bezierCurveTo(x, y2 + ry - kry, x + rx - krx, y2, x + rx, y2);
  } else {
    ctx.moveTo(x, y2);
    ctx.lineTo(x + width, y2);
    ctx.lineTo(x + width, y2 + height2);
    ctx.lineTo(x, y2 + height2);
  }
  ctx.closePath();
};
var renderLine$1 = (ctx, node) => {
  const {
    x1,
    x2,
    y1,
    y2
  } = node.props || {};
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
};
var renderGroup = () => {
};
var KAPPA$2 = 4 * ((Math.sqrt(2) - 1) / 3);
var drawEllipse = function(ctx, rx, ry, cx2, cy2) {
  if (cx2 === void 0) {
    cx2 = 0;
  }
  if (cy2 === void 0) {
    cy2 = 0;
  }
  const x = cx2 - rx;
  const y2 = cy2 - ry;
  const ox = rx * KAPPA$2;
  const oy = ry * KAPPA$2;
  const xe = x + rx * 2;
  const ye = y2 + ry * 2;
  const xm = x + rx;
  const ym = y2 + ry;
  ctx.moveTo(x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y2, xm, y2);
  ctx.bezierCurveTo(xm + ox, y2, xe, ym - oy, xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.closePath();
};
var renderEllipse = (ctx, node) => {
  const {
    cx: cx2,
    cy: cy2,
    rx,
    ry
  } = node.props || {};
  drawEllipse(ctx, rx, ry, cx2, cy2);
};
var renderCircle = (ctx, node) => {
  var _node$props, _node$props2, _node$props3;
  const cx2 = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.cx;
  const cy2 = (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.cy;
  const r3 = (_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.r;
  drawEllipse(ctx, r3, r3, cx2, cy2);
};
var number = (n4) => {
  if (n4 > -1e21 && n4 < 1e21) {
    return Math.round(n4 * 1e6) / 1e6;
  }
  throw new Error(`unsupported number: ${n4}`);
};
var _renderGlyphs = (ctx, encoded, positions, x, y2, options) => {
  const commands = [];
  const scale2 = ctx._fontSize / 1e3;
  let i3;
  let last2 = 0;
  let hadOffset = false;
  ctx.save();
  ctx.transform(1, 0, 0, -1, 0, ctx.page.height);
  y2 = ctx.page.height - y2;
  if (ctx.page.fonts[ctx._font.id] == null) {
    ctx.page.fonts[ctx._font.id] = ctx._font.ref();
  }
  ctx.addContent("BT");
  ctx.addContent(`1 0 0 1 ${number(x)} ${number(y2)} Tm`);
  ctx.addContent(`/${ctx._font.id} ${number(ctx._fontSize)} Tf`);
  const mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;
  if (mode) {
    ctx.addContent(`${mode} Tr`);
  }
  const addSegment = (cur) => {
    if (last2 < cur) {
      const hex = encoded.slice(last2, cur).join("");
      const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
      commands.push(`<${hex}> ${number(-advance)}`);
    }
    return last2 = cur;
  };
  const flush = (s2) => {
    addSegment(s2);
    if (commands.length > 0) {
      ctx.addContent(`[${commands.join(" ")}] TJ`);
      return commands.length = 0;
    }
  };
  for (i3 = 0; i3 < positions.length; i3 += 1) {
    const pos = positions[i3];
    if (pos.xOffset || pos.yOffset) {
      flush(i3);
      ctx.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale2)} ${number(y2 + pos.yOffset * scale2)} Tm`);
      flush(i3 + 1);
      hadOffset = true;
    } else {
      if (hadOffset) {
        ctx.addContent(`1 0 0 1 ${number(x)} ${number(y2)} Tm`);
        hadOffset = false;
      }
      if (pos.xAdvance - pos.advanceWidth !== 0) {
        addSegment(i3 + 1);
      }
    }
    x += pos.xAdvance * scale2;
  }
  flush(i3);
  ctx.addContent("ET");
  return ctx.restore();
};
var renderGlyphs = function(ctx, glyphs, positions, x, y2, options) {
  if (options === void 0) {
    options = {};
  }
  const scale2 = 1e3 / ctx._fontSize;
  const unitsPerEm = ctx._font.font.unitsPerEm || 1e3;
  const advanceWidthScale = 1e3 / unitsPerEm;
  const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);
  const encodedPositions = positions.map((pos, i3) => ({
    xAdvance: pos.xAdvance * scale2,
    yAdvance: pos.yAdvance * scale2,
    xOffset: pos.xOffset,
    yOffset: pos.yOffset,
    advanceWidth: glyphs[i3].advanceWidth * advanceWidthScale
  }));
  return _renderGlyphs(ctx, encodedGlyphs, encodedPositions, x, y2, options);
};
var renderRun$1 = (ctx, run) => {
  const runAdvanceWidth = run.xAdvance;
  const {
    font,
    fontSize,
    color,
    opacity
  } = run.attributes;
  ctx.fillColor(color);
  ctx.fillOpacity(opacity);
  if (font.sbix || font.COLR && font.CPAL) {
    ctx.save();
    ctx.translate(0, -run.ascent);
    for (let i3 = 0; i3 < run.glyphs.length; i3 += 1) {
      const position = run.positions[i3];
      const glyph = run.glyphs[i3];
      ctx.save();
      ctx.translate(position.xOffset, position.yOffset);
      glyph.render(ctx, fontSize);
      ctx.restore();
      ctx.translate(position.xAdvance, position.yAdvance);
    }
    ctx.restore();
  } else {
    ctx.font(typeof font.name === "string" ? font.name : font, fontSize);
    try {
      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);
    } catch (error) {
      console.log(error);
    }
  }
  ctx.translate(runAdvanceWidth, 0);
};
var renderSpan = (ctx, line2, textAnchor, dominantBaseline) => {
  var _line$box, _line$box2, _line$runs$, _line$runs$2, _line$runs$2$attribut;
  ctx.save();
  const x = ((_line$box = line2.box) === null || _line$box === void 0 ? void 0 : _line$box.x) || 0;
  const y2 = ((_line$box2 = line2.box) === null || _line$box2 === void 0 ? void 0 : _line$box2.y) || 0;
  const font = (_line$runs$ = line2.runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes.font;
  const scale2 = ((_line$runs$2 = line2.runs[0]) === null || _line$runs$2 === void 0 ? void 0 : (_line$runs$2$attribut = _line$runs$2.attributes) === null || _line$runs$2$attribut === void 0 ? void 0 : _line$runs$2$attribut.scale) || 1;
  const width = line2.xAdvance;
  const ascent2 = font.ascent * scale2;
  const xHeight = font.xHeight * scale2;
  const descent2 = font.descent * scale2;
  const capHeight = font.capHeight * scale2;
  let xTranslate = x;
  let yTranslate = y2;
  switch (textAnchor) {
    case "middle":
      xTranslate = x - width / 2;
      break;
    case "end":
      xTranslate = x - width;
      break;
    default:
      xTranslate = x;
      break;
  }
  switch (dominantBaseline) {
    case "middle":
    case "central":
      yTranslate = y2 + capHeight / 2;
      break;
    case "hanging":
      yTranslate = y2 + capHeight;
      break;
    case "mathematical":
      yTranslate = y2 + xHeight;
      break;
    case "text-after-edge":
      yTranslate = y2 + descent2;
      break;
    case "text-before-edge":
      yTranslate = y2 + ascent2;
      break;
    default:
      yTranslate = y2;
      break;
  }
  ctx.translate(xTranslate, yTranslate);
  line2.runs.forEach((run) => renderRun$1(ctx, run));
  ctx.restore();
};
var renderSvgText = (ctx, node) => {
  node.children.forEach((span) => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));
};
var pairs = (values) => {
  const result = [];
  for (let i3 = 0; i3 < values.length; i3 += 2) {
    result.push([values[i3], values[i3 + 1]]);
  }
  return result;
};
var parsePoints = (points) => {
  let values = (points || "").trim().replace(/,/g, " ").replace(/(\d)-(\d)/g, "$1 -$2").split(/\s+/);
  if (values.length % 2 !== 0) {
    values = values.slice(0, -1);
  }
  const mappedValues = values.map(parseFloat);
  return pairs(mappedValues);
};
var drawPolyline = (ctx, points) => {
  if (points.length > 0) {
    ctx.moveTo(points[0][0], points[0][1]);
    points.slice(1).forEach((p2) => ctx.lineTo(p2[0], p2[1]));
  }
};
var renderPolyline = (ctx, node) => {
  const points = parsePoints(node.props.points || "");
  drawPolyline(ctx, points);
};
var renderPolygon = (ctx, node) => {
  renderPolyline(ctx, node);
  ctx.closePath();
};
var renderImage$1 = (ctx, node) => {
  if (!node.image.data) return;
  const {
    x,
    y: y2
  } = node.props;
  const {
    width,
    height: height2,
    opacity
  } = node.style;
  const paddingTop = node.box.paddingLeft || 0;
  const paddingLeft = node.box.paddingLeft || 0;
  if (width === 0 || height2 === 0) {
    console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);
    return;
  }
  ctx.save();
  ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y2 + paddingTop, {
    width,
    height: height2
  });
  ctx.restore();
};
var KAPPA$1 = 4 * ((Math.sqrt(2) - 1) / 3);
var clipNode = (ctx, node) => {
  if (!node.style) return;
  const {
    top,
    left,
    width,
    height: height2
  } = node.box;
  const {
    borderTopLeftRadius = 0,
    borderTopRightRadius = 0,
    borderBottomRightRadius = 0,
    borderBottomLeftRadius = 0
  } = node.style;
  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height2);
  const ctr = rtr * (1 - KAPPA$1);
  ctx.moveTo(left + rtr, top);
  ctx.lineTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);
  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height2);
  const cbr = rbr * (1 - KAPPA$1);
  ctx.lineTo(left + width, top + height2 - rbr);
  ctx.bezierCurveTo(left + width, top + height2 - cbr, left + width - cbr, top + height2, left + width - rbr, top + height2);
  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height2);
  const cbl = rbl * (1 - KAPPA$1);
  ctx.lineTo(left + rbl, top + height2);
  ctx.bezierCurveTo(left + cbl, top + height2, left, top + height2 - cbl, left, top + height2 - rbl);
  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height2);
  const ctl = rtl * (1 - KAPPA$1);
  ctx.lineTo(left, top + rtl);
  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);
  ctx.closePath();
  ctx.clip();
};
var applySingleTransformation = (ctx, transform, origin) => {
  const {
    operation,
    value: value2
  } = transform;
  switch (operation) {
    case "scale": {
      const [scaleX, scaleY] = value2;
      ctx.scale(scaleX, scaleY, {
        origin
      });
      break;
    }
    case "rotate": {
      const [angle] = value2;
      ctx.rotate(angle, {
        origin
      });
      break;
    }
    case "translate": {
      const [x, y2 = 0] = value2;
      ctx.translate(x, y2, {
        origin
      });
      break;
    }
    case "skew": {
      const [xAngle = 0, yAngle = 0] = value2;
      const radx = xAngle * Math.PI / 180;
      const rady = yAngle * Math.PI / 180;
      const tanx = Math.tan(radx);
      const tany = Math.tan(rady);
      let x = 0;
      let y2 = 0;
      if (origin != null) {
        [x, y2] = Array.from(origin);
        const x1 = x + tanx * y2;
        const y1 = y2 + tany * x;
        x -= x1;
        y2 -= y1;
      }
      ctx.transform(1, tany, tanx, 1, x, y2);
      break;
    }
    case "matrix": {
      ctx.transform(...value2);
      break;
    }
    default: {
      console.error(`Transform operation: '${operation}' doesn't supported`);
    }
  }
};
var applyTransformations = (ctx, node) => {
  var _node$style, _node$props;
  if (!node.origin) return;
  const origin = [node.origin.left, node.origin.top];
  const operations = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.transform) || ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.transform) || [];
  operations.forEach((operation) => {
    applySingleTransformation(ctx, operation, origin);
  });
};
var getPathBoundingBox = (node) => {
  var _node$props;
  const path = normalize((0, import_abs_svg_path.default)((0, import_parse_svg_path.default)(((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d) || "")));
  if (!path.length) return [0, 0, 0, 0];
  const bounds = [Infinity, Infinity, -Infinity, -Infinity];
  for (let i3 = 0, l2 = path.length; i3 < l2; i3 += 1) {
    const points = path[i3].slice(1);
    for (let j = 0; j < points.length; j += 2) {
      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];
      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];
      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];
      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];
    }
  }
  return bounds;
};
var getCircleBoundingBox = (node) => {
  var _node$props2, _node$props3, _node$props4;
  const r3 = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.r) || 0;
  const cx2 = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.cx) || 0;
  const cy2 = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.cy) || 0;
  return [cx2 - r3, cy2 - r3, cx2 + r3, cy2 + r3];
};
var getEllipseBoundingBox = (node) => {
  var _node$props5, _node$props6, _node$props7, _node$props8;
  const cx2 = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.cx) || 0;
  const cy2 = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.cy) || 0;
  const rx = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.rx) || 0;
  const ry = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.ry) || 0;
  return [cx2 - rx, cy2 - ry, cx2 + rx, cy2 + ry];
};
var getLineBoundingBox = (node) => {
  var _node$props9, _node$props10, _node$props11, _node$props12;
  const x1 = ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : _node$props9.x1) || 0;
  const y1 = ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : _node$props10.y1) || 0;
  const x2 = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.x2) || 0;
  const y2 = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.y2) || 0;
  return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];
};
var getRectBoundingBox = (node) => {
  var _node$props13, _node$props14, _node$props15, _node$props16;
  const x = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.x) || 0;
  const y2 = ((_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.y) || 0;
  const width = ((_node$props15 = node.props) === null || _node$props15 === void 0 ? void 0 : _node$props15.width) || 0;
  const height2 = ((_node$props16 = node.props) === null || _node$props16 === void 0 ? void 0 : _node$props16.height) || 0;
  return [x, y2, x + width, y2 + height2];
};
var max = (values) => Math.max(-Infinity, ...values);
var min = (values) => Math.min(Infinity, ...values);
var getPolylineBoundingBox = (node) => {
  var _node$props17;
  const points = parsePoints(((_node$props17 = node.props) === null || _node$props17 === void 0 ? void 0 : _node$props17.points) || []);
  const xValues = points.map((p2) => p2[0]);
  const yValues = points.map((p2) => p2[1]);
  return [min(xValues), min(yValues), max(xValues), max(yValues)];
};
var boundingBoxFns = {
  [Rect]: getRectBoundingBox,
  [Line]: getLineBoundingBox,
  [Path]: getPathBoundingBox,
  [Circle]: getCircleBoundingBox,
  [Ellipse]: getEllipseBoundingBox,
  [Polygon]: getPolylineBoundingBox,
  [Polyline]: getPolylineBoundingBox
};
var getBoundingBox = (node) => {
  const boundingBoxFn = boundingBoxFns[node.type];
  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];
};
var setStrokeWidth = (ctx, node) => {
  var _node$props;
  const lineWidth = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.strokeWidth) || 0;
  if (lineWidth) ctx.lineWidth(lineWidth);
};
var setStrokeColor = (ctx, node) => {
  var _node$props2;
  const strokeColor = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.stroke) || null;
  if (strokeColor) ctx.strokeColor(strokeColor);
};
var setOpacity = (ctx, node) => {
  var _node$props3;
  const opacity = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.opacity) || null;
  if (!isNil(opacity)) ctx.opacity(opacity);
};
var setFillOpacity = (ctx, node) => {
  var _node$props4;
  const fillOpacity = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.fillOpacity) || null;
  if (!isNil(fillOpacity)) ctx.fillOpacity(fillOpacity);
};
var setStrokeOpacity = (ctx, node) => {
  var _node$props5;
  const strokeOpacity = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.strokeOpacity) || null;
  if (!isNil(strokeOpacity)) ctx.strokeOpacity(strokeOpacity);
};
var setLineJoin = (ctx, node) => {
  var _node$props6;
  const lineJoin = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.strokeLinejoin) || null;
  if (lineJoin) ctx.lineJoin(lineJoin);
};
var setLineCap = (ctx, node) => {
  var _node$props7;
  const lineCap = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.strokeLinecap) || null;
  if (lineCap) ctx.lineCap(lineCap);
};
var setLineDash = (ctx, node) => {
  var _node$props8;
  const value2 = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.strokeDasharray) || null;
  if (value2) ctx.dash(value2.split(/[\s,]+/).map(Number));
};
var hasLinearGradientFill = (node) => {
  var _node$props9, _node$props9$fill;
  return ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : (_node$props9$fill = _node$props9.fill) === null || _node$props9$fill === void 0 ? void 0 : _node$props9$fill.type) === LinearGradient;
};
var hasRadialGradientFill = (node) => {
  var _node$props10, _node$props10$fill;
  return ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : (_node$props10$fill = _node$props10.fill) === null || _node$props10$fill === void 0 ? void 0 : _node$props10$fill.type) === RadialGradient;
};
var setLinearGradientFill = (ctx, node) => {
  var _node$props11;
  const bbox = getBoundingBox(node);
  const gradient = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.fill) || null;
  const x1 = gradient.props.x1 || 0;
  const y1 = gradient.props.y1 || 0;
  const x2 = gradient.props.x2 || 1;
  const y2 = gradient.props.y2 || 0;
  const m0 = bbox[2] - bbox[0];
  const m3 = bbox[3] - bbox[1];
  const m4 = bbox[0];
  const m5 = bbox[1];
  const gx1 = m0 * x1 + m4;
  const gy1 = m3 * y1 + m5;
  const gx2 = m0 * x2 + m4;
  const gy2 = m3 * y2 + m5;
  const grad = ctx.linearGradient(gx1, gy1, gx2, gy2);
  gradient.children.forEach((stop) => {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
};
var setRadialGradientFill = (ctx, node) => {
  var _node$props12;
  const bbox = getBoundingBox(node);
  const gradient = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.fill) || null;
  const cx2 = gradient.props.cx || 0.5;
  const cy2 = gradient.props.cy || 0.5;
  const fx = gradient.props.fx || cx2;
  const fy = gradient.props.fy || cy2;
  const r3 = gradient.props.r || 0.5;
  const m0 = bbox[2] - bbox[0];
  const m3 = bbox[3] - bbox[1];
  const m4 = bbox[0];
  const m5 = bbox[1];
  const gr = r3 * m0;
  const gcx = m0 * cx2 + m4;
  const gcy = m3 * cy2 + m5;
  const gfx = m0 * fx + m4;
  const gfy = m3 * fy + m5;
  const grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);
  gradient.children.forEach((stop) => {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
};
var setFillColor = (ctx, node) => {
  var _node$props13;
  const fillColor = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.fill) || null;
  if (fillColor) ctx.fillColor(fillColor);
};
var setFill = (ctx, node) => {
  if (hasLinearGradientFill(node)) return setLinearGradientFill(ctx, node);
  if (hasRadialGradientFill(node)) return setRadialGradientFill(ctx, node);
  return setFillColor(ctx, node);
};
var draw = (ctx, node) => {
  const props = node.props || {};
  if (props.fill && props.stroke) {
    ctx.fillAndStroke(props.fillRule);
  } else if (props.fill) {
    ctx.fill(props.fillRule);
  } else if (props.stroke) {
    ctx.stroke();
  } else {
    ctx.save();
    ctx.opacity(0);
    ctx.fill(null);
    ctx.restore();
  }
};
var noop = () => {
};
var renderFns$1 = {
  [Tspan]: noop,
  [TextInstance]: noop,
  [Path]: renderPath,
  [Rect]: renderRect,
  [Line]: renderLine$1,
  [G]: renderGroup,
  [Text]: renderSvgText,
  [Circle]: renderCircle,
  [Image]: renderImage$1,
  [Ellipse]: renderEllipse,
  [Polygon]: renderPolygon,
  [Polyline]: renderPolyline
};
var renderNode$1 = (ctx, node) => {
  const renderFn = renderFns$1[node.type];
  if (renderFn) {
    renderFn(ctx, node);
  } else {
    console.warn(`SVG node of type ${node.type} is not currently supported`);
  }
};
var drawNode = (ctx, node) => {
  setLineCap(ctx, node);
  setLineDash(ctx, node);
  setLineJoin(ctx, node);
  setStrokeWidth(ctx, node);
  setStrokeColor(ctx, node);
  setFill(ctx, node);
  setStrokeOpacity(ctx, node);
  setFillOpacity(ctx, node);
  setOpacity(ctx, node);
  applyTransformations(ctx, node);
  renderNode$1(ctx, node);
  draw(ctx, node);
};
var clipPath = (ctx, node) => {
  var _node$props14;
  const value2 = (_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.clipPath;
  if (value2) {
    const children = value2.children || [];
    children.forEach((child) => renderNode$1(ctx, child));
    ctx.clip();
  }
};
var drawChildren = (ctx, node) => {
  const children = node.children || [];
  children.forEach((child) => {
    ctx.save();
    clipPath(ctx, child);
    drawNode(ctx, child);
    drawChildren(ctx, child);
    ctx.restore();
  });
};
var resolveAspectRatio = (ctx, node) => {
  const {
    width,
    height: height2
  } = node.box;
  const {
    viewBox,
    preserveAspectRatio = {}
  } = node.props;
  const {
    meetOrSlice = "meet",
    align = "xMidYMid"
  } = preserveAspectRatio;
  if (viewBox == null || width == null || height2 == null) return;
  const x = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minX) || 0;
  const y2 = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minY) || 0;
  const logicalWidth = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxX) || width;
  const logicalHeight = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxY) || height2;
  const logicalRatio = logicalWidth / logicalHeight;
  const physicalRatio = width / height2;
  const scaleX = width / logicalWidth;
  const scaleY = height2 / logicalHeight;
  if (align === "none") {
    ctx.scale(scaleX, scaleY);
    ctx.translate(-x, -y2);
    return;
  }
  if (logicalRatio < physicalRatio && meetOrSlice === "meet" || logicalRatio >= physicalRatio && meetOrSlice === "slice") {
    ctx.scale(scaleY, scaleY);
    switch (align) {
      case "xMinYMin":
      case "xMinYMid":
      case "xMinYMax":
        ctx.translate(-x, -y2);
        break;
      case "xMidYMin":
      case "xMidYMid":
      case "xMidYMax":
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height2) / 2, -y2);
        break;
      default:
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height2), -y2);
    }
  } else {
    ctx.scale(scaleX, scaleX);
    switch (align) {
      case "xMinYMin":
      case "xMidYMin":
      case "xMaxYMin":
        ctx.translate(-x, -y2);
        break;
      case "xMinYMid":
      case "xMidYMid":
      case "xMaxYMid":
        ctx.translate(-x, -y2 - (logicalHeight - height2 * logicalWidth / width) / 2);
        break;
      default:
        ctx.translate(-x, -y2 - (logicalHeight - height2 * logicalWidth / width));
    }
  }
};
var moveToOrigin = (ctx, node) => {
  const {
    top,
    left
  } = node.box;
  const paddingLeft = node.box.paddingLeft || 0;
  const paddingTop = node.box.paddingTop || 0;
  ctx.translate(left + paddingLeft, top + paddingTop);
};
var renderSvg = (ctx, node) => {
  ctx.save();
  clipNode(ctx, node);
  moveToOrigin(ctx, node);
  resolveAspectRatio(ctx, node);
  drawChildren(ctx, node);
  ctx.restore();
};
var black = {
  value: [0, 0, 0],
  opacity: 1
};
var parseColor = (hex) => {
  const parsed = import_color_string.default.get(hex);
  if (!parsed) return black;
  const value2 = import_color_string.default.to.hex(parsed.value.slice(0, 3));
  const opacity = parsed.value[3];
  return {
    value: value2,
    opacity
  };
};
var DEST_REGEXP = /^#.+/;
var isSrcId$1 = (src) => src.match(DEST_REGEXP);
var renderAttachment = (ctx, attachment) => {
  const {
    xOffset = 0,
    yOffset = 0,
    width,
    height: height2,
    image
  } = attachment;
  ctx.translate(-width + xOffset, -height2 + yOffset);
  ctx.image(image, 0, 0, {
    fit: [width, height2],
    align: "center",
    valign: "bottom"
  });
};
var renderAttachments = (ctx, run) => {
  ctx.save();
  const {
    font
  } = run.attributes;
  const space = font.glyphForCodePoint(32);
  const objectReplacement = font.glyphForCodePoint(65532);
  let attachmentAdvance = 0;
  for (let i3 = 0; i3 < run.glyphs.length; i3 += 1) {
    const position = run.positions[i3];
    const glyph = run.glyphs[i3];
    attachmentAdvance += position.xAdvance || 0;
    if (glyph.id === objectReplacement.id && run.attributes.attachment) {
      ctx.translate(attachmentAdvance, position.yOffset || 0);
      renderAttachment(ctx, run.attributes.attachment);
      run.glyphs[i3] = space;
      attachmentAdvance = 0;
    }
  }
  ctx.restore();
};
var renderRun = (ctx, run, options) => {
  const {
    font,
    fontSize,
    link
  } = run.attributes;
  const color = parseColor(run.attributes.color);
  const opacity = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;
  const {
    height: height2,
    descent: descent2,
    xAdvance
  } = run;
  if (options.outlineRuns) {
    ctx.rect(0, -height2, xAdvance, height2).stroke();
  }
  ctx.fillColor(color.value);
  ctx.fillOpacity(opacity);
  if (link) {
    if (isSrcId$1(link)) {
      ctx.goTo(0, -height2 - descent2, xAdvance, height2, link.slice(1));
    } else {
      ctx.link(0, -height2 - descent2, xAdvance, height2, link);
    }
  }
  renderAttachments(ctx, run);
  if (font.sbix || font.COLR && font.CPAL) {
    ctx.save();
    ctx.translate(0, -run.ascent);
    for (let i3 = 0; i3 < run.glyphs.length; i3 += 1) {
      const position = run.positions[i3];
      const glyph = run.glyphs[i3];
      ctx.save();
      ctx.translate(position.xOffset, position.yOffset);
      glyph.render(ctx, fontSize);
      ctx.restore();
      ctx.translate(position.xAdvance, position.yAdvance);
    }
    ctx.restore();
  } else {
    ctx.font(typeof font.name === "string" ? font.name : font, fontSize);
    try {
      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);
    } catch (error) {
      console.log(error);
    }
  }
  ctx.translate(xAdvance, 0);
};
var renderBackground$1 = (ctx, rect, backgroundColor) => {
  const color = parseColor(backgroundColor);
  ctx.save();
  ctx.fillOpacity(color.opacity);
  ctx.rect(rect.x, rect.y, rect.width, rect.height);
  ctx.fill(color.value);
  ctx.restore();
};
var renderDecorationLine = (ctx, line2) => {
  ctx.save();
  ctx.lineWidth(line2.rect.height);
  ctx.strokeOpacity(line2.opacity);
  if (/dashed/.test(line2.style)) {
    ctx.dash(3 * line2.rect.height);
  } else if (/dotted/.test(line2.style)) {
    ctx.dash(line2.rect.height);
  }
  if (/wavy/.test(line2.style)) {
    const dist = Math.max(2, line2.rect.height);
    let step = 1.1 * dist;
    const stepCount = Math.floor(line2.rect.width / (2 * step));
    const remainingWidth = line2.rect.width - stepCount * 2 * step;
    const adjustment = remainingWidth / stepCount / 2;
    step += adjustment;
    const cp1y = line2.rect.y + dist;
    const cp2y = line2.rect.y - dist;
    let {
      x
    } = line2.rect;
    ctx.moveTo(line2.rect.x, line2.rect.y);
    for (let i3 = 0; i3 < stepCount; i3 += 1) {
      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, line2.rect.y);
      x += 2 * step;
    }
  } else {
    ctx.moveTo(line2.rect.x, line2.rect.y);
    ctx.lineTo(line2.rect.x + line2.rect.width, line2.rect.y);
    if (/double/.test(line2.style)) {
      ctx.moveTo(line2.rect.x, line2.rect.y + line2.rect.height * 2);
      ctx.lineTo(line2.rect.x + line2.rect.width, line2.rect.y + line2.rect.height * 2);
    }
  }
  ctx.stroke(line2.color);
  ctx.restore();
};
var renderLine = (ctx, line2, options) => {
  const lineAscent = line2.ascent;
  if (options.outlineLines) {
    ctx.rect(line2.box.x, line2.box.y, line2.box.width, line2.box.height).stroke();
  }
  ctx.save();
  ctx.translate(line2.box.x, line2.box.y + lineAscent);
  for (let i3 = 0; i3 < line2.runs.length; i3 += 1) {
    const run = line2.runs[i3];
    const isLastRun = i3 === line2.runs.length - 1;
    if (run.attributes.backgroundColor) {
      const overflowRight = isLastRun ? line2.overflowRight : 0;
      const backgroundRect = {
        x: 0,
        y: -lineAscent,
        height: line2.box.height,
        width: run.xAdvance - overflowRight
      };
      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);
    }
    renderRun(ctx, run, options);
  }
  ctx.restore();
  ctx.save();
  ctx.translate(line2.box.x, line2.box.y);
  for (let i3 = 0; i3 < line2.decorationLines.length; i3 += 1) {
    const decorationLine = line2.decorationLines[i3];
    renderDecorationLine(ctx, decorationLine);
  }
  ctx.restore();
};
var renderBlock = (ctx, block, options) => {
  block.forEach((line2) => {
    renderLine(ctx, line2, options);
  });
};
var renderText = (ctx, node) => {
  var _node$box, _node$box2;
  const {
    top,
    left
  } = node.box;
  const blocks = [node.lines];
  const paddingTop = ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.paddingTop) || 0;
  const paddingLeft = ((_node$box2 = node.box) === null || _node$box2 === void 0 ? void 0 : _node$box2.paddingLeft) || 0;
  const initialY = node.lines[0] ? node.lines[0].box.y : 0;
  const offsetX = node.alignOffset || 0;
  ctx.save();
  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);
  blocks.forEach((block) => {
    renderBlock(ctx, block, {});
  });
  ctx.restore();
};
var renderPage = (ctx, node) => {
  var _node$props;
  const {
    width,
    height: height2
  } = node.box;
  const dpi = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.dpi) || 72;
  const userUnit = dpi / 72;
  ctx.addPage({
    size: [width, height2],
    margin: 0,
    userUnit
  });
};
var renderNote = (ctx, node) => {
  var _node$children, _node$style, _node$style2;
  const {
    top,
    left
  } = node.box;
  const value2 = (node === null || node === void 0 ? void 0 : (_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children[0].value) || "";
  const color = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.backgroundColor) || null;
  const borderWidth = ((_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.borderWidth) || null;
  ctx.note(left, top, 0, 0, value2, {
    color,
    borderWidth
  });
};
var embedImage = (ctx, node) => {
  const src = node.image.data;
  let image;
  if (typeof src === "string") {
    image = ctx._imageRegistry[src];
  }
  if (!image) {
    if (src.width && src.height) {
      image = src;
    } else {
      image = ctx.openImage(src);
    }
  }
  if (!image.obj) {
    image.embed(ctx);
  }
  return image;
};
var isNumeric = (n4) => {
  return !Number.isNaN(parseFloat(n4)) && Number.isFinite(n4);
};
var applyContainObjectFit = (cw, ch, iw, ih, px2, py2) => {
  const cr = cw / ch;
  const ir = iw / ih;
  const pxp = matchPercent(px2);
  const pyp = matchPercent(py2);
  const pxv = pxp ? pxp.percent : 0.5;
  const pyv = pyp ? pyp.percent : 0.5;
  if (cr > ir) {
    const height3 = ch;
    const width2 = height3 * ir;
    const yOffset2 = isNumeric(py2) ? py2 : 0;
    const xOffset2 = isNumeric(px2) ? px2 : (cw - width2) * pxv;
    return {
      width: width2,
      height: height3,
      xOffset: xOffset2,
      yOffset: yOffset2
    };
  }
  const width = cw;
  const height2 = width / ir;
  const xOffset = isNumeric(px2) ? px2 : 0;
  const yOffset = isNumeric(py2) ? py2 : (ch - height2) * pyv;
  return {
    width,
    height: height2,
    yOffset,
    xOffset
  };
};
var applyNoneObjectFit = (cw, ch, iw, ih, px2, py2) => {
  const width = iw;
  const height2 = ih;
  const pxp = matchPercent(px2);
  const pyp = matchPercent(py2);
  const pxv = pxp ? pxp.percent : 0.5;
  const pyv = pyp ? pyp.percent : 0.5;
  const xOffset = isNumeric(px2) ? px2 : (cw - width) * pxv;
  const yOffset = isNumeric(py2) ? py2 : (ch - height2) * pyv;
  return {
    width,
    height: height2,
    xOffset,
    yOffset
  };
};
var applyCoverObjectFit = (cw, ch, iw, ih, px2, py2) => {
  const ir = iw / ih;
  const cr = cw / ch;
  const pxp = matchPercent(px2);
  const pyp = matchPercent(py2);
  const pxv = pxp ? pxp.percent : 0.5;
  const pyv = pyp ? pyp.percent : 0.5;
  if (cr > ir) {
    const width2 = cw;
    const height3 = width2 / ir;
    const xOffset2 = isNumeric(px2) ? px2 : 0;
    const yOffset2 = isNumeric(py2) ? py2 : (ch - height3) * pyv;
    return {
      width: width2,
      height: height3,
      yOffset: yOffset2,
      xOffset: xOffset2
    };
  }
  const height2 = ch;
  const width = height2 * ir;
  const xOffset = isNumeric(px2) ? px2 : (cw - width) * pxv;
  const yOffset = isNumeric(py2) ? py2 : 0;
  return {
    width,
    height: height2,
    xOffset,
    yOffset
  };
};
var applyScaleDownObjectFit = (cw, ch, iw, ih, px2, py2) => {
  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px2, py2);
  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px2, py2);
  return containDimension.width < noneDimension.width ? containDimension : noneDimension;
};
var applyFillObjectFit = (cw, ch, px2, py2) => {
  return {
    width: cw,
    height: ch,
    xOffset: matchPercent(px2) ? 0 : px2 || 0,
    yOffset: matchPercent(py2) ? 0 : py2 || 0
  };
};
var resolveObjectFit = function(type, cw, ch, iw, ih, px2, py2) {
  if (type === void 0) {
    type = "fill";
  }
  switch (type) {
    case "contain":
      return applyContainObjectFit(cw, ch, iw, ih, px2, py2);
    case "cover":
      return applyCoverObjectFit(cw, ch, iw, ih, px2, py2);
    case "none":
      return applyNoneObjectFit(cw, ch, iw, ih, px2, py2);
    case "scale-down":
      return applyScaleDownObjectFit(cw, ch, iw, ih, px2, py2);
    default:
      return applyFillObjectFit(cw, ch, px2, py2);
  }
};
var drawImage = function(ctx, node, options) {
  var _node$style, _node$style2, _node$style3, _node$style4;
  if (options === void 0) {
    options = {};
  }
  const {
    left,
    top
  } = node.box;
  const opacity = (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity;
  const objectFit = (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.objectFit;
  const objectPositionX = (_node$style3 = node.style) === null || _node$style3 === void 0 ? void 0 : _node$style3.objectPositionX;
  const objectPositionY = (_node$style4 = node.style) === null || _node$style4 === void 0 ? void 0 : _node$style4.objectPositionY;
  const paddingTop = node.box.paddingTop || 0;
  const paddingRight = node.box.paddingRight || 0;
  const paddingBottom = node.box.paddingBottom || 0;
  const paddingLeft = node.box.paddingLeft || 0;
  const imageCache = options.imageCache || /* @__PURE__ */ new Map();
  const {
    width,
    height: height2,
    xOffset,
    yOffset
  } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);
  if (node.image.data) {
    if (width !== 0 && height2 !== 0) {
      const cacheKey = node.image.key;
      const image = imageCache.get(cacheKey) || embedImage(ctx, node);
      if (cacheKey) imageCache.set(cacheKey, image);
      const imageOpacity = isNil(opacity) ? 1 : opacity;
      ctx.fillOpacity(imageOpacity).image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {
        width,
        height: height2
      });
    } else {
      console.warn(`Image with src '${JSON.stringify(node.props.src)}' skipped due to invalid dimensions`);
    }
  }
};
var renderImage = (ctx, node, options) => {
  ctx.save();
  clipNode(ctx, node);
  drawImage(ctx, node, options);
  ctx.restore();
};
var CONTENT_COLOR = "#a1c6e7";
var PADDING_COLOR = "#c4deb9";
var MARGIN_COLOR = "#f8cca1";
var debugContent = (ctx, node) => {
  const {
    left,
    top,
    width,
    height: height2,
    paddingLeft = 0,
    paddingTop = 0,
    paddingRight = 0,
    paddingBottom = 0,
    borderLeftWidth = 0,
    borderTopWidth = 0,
    borderRightWidth = 0,
    borderBottomWidth = 0
  } = node.box;
  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height2 - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();
};
var debugPadding = (ctx, node) => {
  const {
    left,
    top,
    width,
    height: height2,
    paddingLeft = 0,
    paddingTop = 0,
    paddingRight = 0,
    paddingBottom = 0,
    borderLeftWidth = 0,
    borderTopWidth = 0,
    borderRightWidth = 0,
    borderBottomWidth = 0
  } = node.box;
  ctx.fillColor(PADDING_COLOR).opacity(0.5);
  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();
  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height2 - borderTopWidth - borderBottomWidth).fill();
  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height2 - borderTopWidth - borderBottomWidth).fill();
  ctx.rect(left + paddingLeft + borderLeftWidth, top + height2 - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();
};
var getMargin = (box) => {
  const marginLeft = box.marginLeft === "auto" ? 0 : box.marginLeft;
  const marginTop = box.marginTop === "auto" ? 0 : box.marginTop;
  const marginRight = box.marginRight === "auto" ? 0 : box.marginRight;
  const marginBottom = box.marginBottom === "auto" ? 0 : box.marginBottom;
  return {
    marginLeft,
    marginTop,
    marginRight,
    marginBottom
  };
};
var debugMargin = (ctx, node) => {
  const {
    left,
    top,
    width,
    height: height2
  } = node.box;
  const {
    marginLeft = 0,
    marginTop = 0,
    marginRight = 0,
    marginBottom = 0
  } = getMargin(node.box);
  ctx.fillColor(MARGIN_COLOR).opacity(0.5);
  ctx.rect(left, top - marginTop, width, marginTop).fill();
  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height2 + marginTop + marginBottom).fill();
  ctx.rect(left + width, top - marginTop, marginRight, height2 + marginTop + marginBottom).fill();
  ctx.rect(left, top + height2, width, marginBottom).fill();
};
var debugText = (ctx, node) => {
  const {
    left,
    top,
    width,
    height: height2
  } = node.box;
  const {
    marginLeft = 0,
    marginTop = 0,
    marginRight = 0,
    marginBottom = 0
  } = getMargin(node.box);
  const roundedWidth = Math.round(width + marginLeft + marginRight);
  const roundedHeight = Math.round(height2 + marginTop + marginBottom);
  ctx.fontSize(6).opacity(1).fillColor("black").text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1), {
    width: Infinity
  });
};
var debugOrigin = (ctx, node) => {
  if (node.origin) {
    ctx.circle(node.origin.left, node.origin.top, 3).fill("red").circle(node.origin.left, node.origin.top, 5).stroke("red");
  }
};
var renderDebug = (ctx, node) => {
  var _node$props;
  if (!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.debug)) return;
  ctx.save();
  debugContent(ctx, node);
  debugPadding(ctx, node);
  debugMargin(ctx, node);
  debugText(ctx, node);
  debugOrigin(ctx, node);
  ctx.restore();
};
var availableMethods = ["dash", "clip", "save", "path", "fill", "font", "text", "rect", "scale", "moveTo", "lineTo", "stroke", "rotate", "circle", "lineCap", "opacity", "ellipse", "polygon", "restore", "lineJoin", "fontSize", "fillColor", "lineWidth", "translate", "miterLimit", "strokeColor", "fillOpacity", "roundedRect", "fillAndStroke", "strokeOpacity", "bezierCurveTo", "quadraticCurveTo", "linearGradient", "radialGradient"];
var painter = (ctx) => {
  const p2 = availableMethods.reduce((acc, prop) => ({
    ...acc,
    [prop]: function() {
      ctx[prop](...arguments);
      return p2;
    }
  }), {});
  return p2;
};
var renderCanvas = (ctx, node) => {
  const {
    top,
    left,
    width,
    height: height2
  } = node.box;
  const paddingTop = node.box.paddingTop || 0;
  const paddingLeft = node.box.paddingLeft || 0;
  const paddingRight = node.box.paddingRight || 0;
  const paddingBottom = node.box.paddingBottom || 0;
  const availableWidth = width - paddingLeft - paddingRight;
  const availableHeight = height2 - paddingTop - paddingBottom;
  if (!availableWidth || !availableHeight) {
    console.warn("Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.");
  }
  ctx.save().translate(left + paddingLeft, top + paddingTop);
  if (node.props.paint) {
    node.props.paint(painter(ctx), availableWidth, availableHeight);
  }
  ctx.restore();
};
var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
var clipBorderTop = (ctx, layout2, style, rtr, rtl) => {
  const {
    top,
    left,
    width,
    height: height2
  } = layout2;
  const {
    borderTopWidth,
    borderRightWidth,
    borderLeftWidth
  } = style;
  ctx.moveTo(left + rtl, top);
  ctx.lineTo(left + width - rtr, top);
  const c0 = rtr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);
  const topRightYCoord = top + Math.max(borderTopWidth, rtr);
  ctx.lineTo(left + width, topRightYCoord);
  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);
  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);
  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);
  const c1 = innerTopRightRadiusX * (1 - KAPPA);
  const c22 = innerTopRightRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c22, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);
  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);
  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);
  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);
  const c3 = innerTopLeftRadiusX * (1 - KAPPA);
  const c4 = innerTopLeftRadiusY * (1 - KAPPA);
  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);
  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);
  ctx.lineTo(left, topLeftYCoord);
  ctx.lineTo(left, top + rtl);
  const c5 = rtl * (1 - KAPPA);
  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);
  ctx.closePath();
  ctx.clip();
  if (borderRightWidth) {
    const trSlope = -borderTopWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left, top);
    ctx.lineTo(left, top + height2);
    ctx.closePath();
    ctx.clip();
  }
  if (borderLeftWidth) {
    const trSlope = -borderTopWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left, top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left + width, top + height2);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderTop = (ctx, layout2, style, rtr, rtl) => {
  const {
    top,
    left,
    width
  } = layout2;
  const {
    borderTopColor,
    borderTopWidth,
    borderTopStyle,
    borderRightWidth,
    borderLeftWidth
  } = style;
  const c0 = rtl * (1 - KAPPA);
  const c1 = rtr * (1 - KAPPA);
  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));
  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);
  ctx.lineTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);
  ctx.strokeColor(borderTopColor);
  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);
  if (borderTopStyle === "dashed") {
    ctx.dash(borderTopWidth * 2, {
      space: borderTopWidth * 1.2
    });
  } else if (borderTopStyle === "dotted") {
    ctx.dash(borderTopWidth, {
      space: borderTopWidth * 1.2
    });
  }
  ctx.stroke();
  ctx.undash();
};
var clipBorderRight = (ctx, layout2, style, rtr, rbr) => {
  const {
    top,
    left,
    width,
    height: height2
  } = layout2;
  const {
    borderTopWidth,
    borderRightWidth,
    borderBottomWidth
  } = style;
  ctx.moveTo(left + width, top + rtr);
  ctx.lineTo(left + width, top + height2 - rbr);
  const c0 = rbr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width, top + height2 - c0, left + width - c0, top + height2, left + width - rbr, top + height2);
  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);
  ctx.lineTo(topBottomXCoord, top + height2);
  ctx.lineTo(topBottomXCoord, top + height2 - borderBottomWidth);
  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);
  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);
  const c1 = innerBottomRightRadiusX * (1 - KAPPA);
  const c22 = innerBottomRightRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height2 - borderBottomWidth, left + width - borderRightWidth, top + height2 - borderBottomWidth - c22, left + width - borderRightWidth, top + height2 - Math.max(rbr, borderBottomWidth));
  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));
  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);
  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);
  const c3 = innerTopRightRadiusX * (1 - KAPPA);
  const c4 = innerTopRightRadiusY * (1 - KAPPA);
  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);
  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);
  ctx.lineTo(topRightXCoord, top);
  ctx.lineTo(left + width - rtr, top);
  const c5 = rtr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);
  ctx.closePath();
  ctx.clip();
  if (borderTopWidth) {
    const trSlope = -borderTopWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left, top + height2);
    ctx.closePath();
    ctx.clip();
  }
  if (borderBottomWidth) {
    const brSlope = borderBottomWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left, top);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderRight = (ctx, layout2, style, rtr, rbr) => {
  const {
    top,
    left,
    width,
    height: height2
  } = layout2;
  const {
    borderRightColor,
    borderRightStyle,
    borderRightWidth,
    borderTopWidth,
    borderBottomWidth
  } = style;
  const c0 = rbr * (1 - KAPPA);
  const c1 = rtr * (1 - KAPPA);
  ctx.moveTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);
  ctx.lineTo(left + width, top + height2 - rbr);
  ctx.bezierCurveTo(left + width, top + height2 - c0, left + width - c0, top + height2, left + width - rbr, top + height2);
  ctx.strokeColor(borderRightColor);
  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);
  if (borderRightStyle === "dashed") {
    ctx.dash(borderRightWidth * 2, {
      space: borderRightWidth * 1.2
    });
  } else if (borderRightStyle === "dotted") {
    ctx.dash(borderRightWidth, {
      space: borderRightWidth * 1.2
    });
  }
  ctx.stroke();
  ctx.undash();
};
var clipBorderBottom = (ctx, layout2, style, rbl, rbr) => {
  const {
    top,
    left,
    width,
    height: height2
  } = layout2;
  const {
    borderBottomWidth,
    borderRightWidth,
    borderLeftWidth
  } = style;
  ctx.moveTo(left + width - rbr, top + height2);
  ctx.lineTo(left + rbl, top + height2);
  const c0 = rbl * (1 - KAPPA);
  ctx.bezierCurveTo(left + c0, top + height2, left, top + height2 - c0, left, top + height2 - rbl);
  const bottomLeftYCoord = top + height2 - Math.max(borderBottomWidth, rbl);
  ctx.lineTo(left, bottomLeftYCoord);
  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);
  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);
  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);
  const c1 = innerBottomLeftRadiusX * (1 - KAPPA);
  const c22 = innerBottomLeftRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + borderLeftWidth, top + height2 - borderBottomWidth - c22, left + borderLeftWidth + c1, top + height2 - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height2 - borderBottomWidth);
  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height2 - borderBottomWidth);
  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);
  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);
  const c3 = innerBottomRightRadiusX * (1 - KAPPA);
  const c4 = innerBottomRightRadiusY * (1 - KAPPA);
  const bottomRightYCoord = top + height2 - Math.max(borderBottomWidth, rbr);
  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height2 - borderBottomWidth, left + width - borderRightWidth, top + height2 - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);
  ctx.lineTo(left + width, bottomRightYCoord);
  ctx.lineTo(left + width, top + height2 - rbr);
  const c5 = rbr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width, top + height2 - c5, left + width - c5, top + height2, left + width - rbr, top + height2);
  ctx.closePath();
  ctx.clip();
  if (borderRightWidth) {
    const brSlope = borderBottomWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left, top);
    ctx.closePath();
    ctx.clip();
  }
  if (borderLeftWidth) {
    const trSlope = -borderBottomWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height2);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left + width, top);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderBottom = (ctx, layout2, style, rbl, rbr) => {
  const {
    top,
    left,
    width,
    height: height2
  } = layout2;
  const {
    borderBottomColor,
    borderBottomStyle,
    borderBottomWidth,
    borderRightWidth,
    borderLeftWidth
  } = style;
  const c0 = rbl * (1 - KAPPA);
  const c1 = rbr * (1 - KAPPA);
  ctx.moveTo(left + width, top + height2 - rbr);
  ctx.bezierCurveTo(left + width, top + height2 - c1, left + width - c1, top + height2, left + width - rbr, top + height2);
  ctx.lineTo(left + rbl, top + height2);
  ctx.bezierCurveTo(left + c0, top + height2, left, top + height2 - c0, left, top + height2 - rbl);
  ctx.strokeColor(borderBottomColor);
  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);
  if (borderBottomStyle === "dashed") {
    ctx.dash(borderBottomWidth * 2, {
      space: borderBottomWidth * 1.2
    });
  } else if (borderBottomStyle === "dotted") {
    ctx.dash(borderBottomWidth, {
      space: borderBottomWidth * 1.2
    });
  }
  ctx.stroke();
  ctx.undash();
};
var clipBorderLeft = (ctx, layout2, style, rbl, rtl) => {
  const {
    top,
    left,
    width,
    height: height2
  } = layout2;
  const {
    borderTopWidth,
    borderLeftWidth,
    borderBottomWidth
  } = style;
  ctx.moveTo(left, top + height2 - rbl);
  ctx.lineTo(left, top + rtl);
  const c0 = rtl * (1 - KAPPA);
  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);
  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);
  ctx.lineTo(topLeftCoordX, top);
  ctx.lineTo(topLeftCoordX, top + borderTopWidth);
  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);
  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);
  const c1 = innerTopLeftRadiusX * (1 - KAPPA);
  const c22 = innerTopLeftRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c22, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));
  ctx.lineTo(left + borderLeftWidth, top + height2 - Math.max(rbl, borderBottomWidth));
  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);
  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);
  const c3 = innerBottomLeftRadiusX * (1 - KAPPA);
  const c4 = innerBottomLeftRadiusY * (1 - KAPPA);
  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);
  ctx.bezierCurveTo(left + borderLeftWidth, top + height2 - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height2 - borderBottomWidth, bottomLeftXCoord, top + height2 - borderBottomWidth);
  ctx.lineTo(bottomLeftXCoord, top + height2);
  ctx.lineTo(left + rbl, top + height2);
  const c5 = rbl * (1 - KAPPA);
  ctx.bezierCurveTo(left + c5, top + height2, left, top + height2 - c5, left, top + height2 - rbl);
  ctx.closePath();
  ctx.clip();
  if (borderBottomWidth) {
    const trSlope = -borderBottomWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height2);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left, top);
    ctx.lineTo(left + width, top);
    ctx.closePath();
    ctx.clip();
  }
  if (borderBottomWidth) {
    const trSlope = -borderTopWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left, top);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderLeft = (ctx, layout2, style, rbl, rtl) => {
  const {
    top,
    left,
    height: height2
  } = layout2;
  const {
    borderLeftColor,
    borderLeftStyle,
    borderLeftWidth,
    borderTopWidth,
    borderBottomWidth
  } = style;
  const c0 = rbl * (1 - KAPPA);
  const c1 = rtl * (1 - KAPPA);
  ctx.moveTo(left + rbl, top + height2);
  ctx.bezierCurveTo(left + c0, top + height2, left, top + height2 - c0, left, top + height2 - rbl);
  ctx.lineTo(left, top + rtl);
  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);
  ctx.strokeColor(borderLeftColor);
  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);
  if (borderLeftStyle === "dashed") {
    ctx.dash(borderLeftWidth * 2, {
      space: borderLeftWidth * 1.2
    });
  } else if (borderLeftStyle === "dotted") {
    ctx.dash(borderLeftWidth, {
      space: borderLeftWidth * 1.2
    });
  }
  ctx.stroke();
  ctx.undash();
};
var shouldRenderBorders = (node) => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);
var renderBorders = (ctx, node) => {
  if (!shouldRenderBorders(node)) return;
  const {
    width,
    height: height2,
    borderTopWidth,
    borderLeftWidth,
    borderRightWidth,
    borderBottomWidth
  } = node.box;
  const {
    opacity,
    borderTopLeftRadius = 0,
    borderTopRightRadius = 0,
    borderBottomLeftRadius = 0,
    borderBottomRightRadius = 0,
    borderTopColor = "black",
    borderTopStyle = "solid",
    borderLeftColor = "black",
    borderLeftStyle = "solid",
    borderRightColor = "black",
    borderRightStyle = "solid",
    borderBottomColor = "black",
    borderBottomStyle = "solid"
  } = node.style;
  const style = {
    borderTopColor,
    borderTopWidth,
    borderTopStyle,
    borderLeftColor,
    borderLeftWidth,
    borderLeftStyle,
    borderRightColor,
    borderRightWidth,
    borderRightStyle,
    borderBottomColor,
    borderBottomWidth,
    borderBottomStyle
  };
  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height2);
  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height2);
  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height2);
  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height2);
  ctx.save();
  ctx.strokeOpacity(opacity);
  if (borderTopWidth) {
    ctx.save();
    clipBorderTop(ctx, node.box, style, rtr, rtl);
    fillBorderTop(ctx, node.box, style, rtr, rtl);
    ctx.restore();
  }
  if (borderRightWidth) {
    ctx.save();
    clipBorderRight(ctx, node.box, style, rtr, rbr);
    fillBorderRight(ctx, node.box, style, rtr, rbr);
    ctx.restore();
  }
  if (borderBottomWidth) {
    ctx.save();
    clipBorderBottom(ctx, node.box, style, rbl, rbr);
    fillBorderBottom(ctx, node.box, style, rbl, rbr);
    ctx.restore();
  }
  if (borderLeftWidth) {
    ctx.save();
    clipBorderLeft(ctx, node.box, style, rbl, rtl);
    fillBorderLeft(ctx, node.box, style, rbl, rtl);
    ctx.restore();
  }
  ctx.restore();
};
var drawBackground = (ctx, node) => {
  var _node$style;
  const {
    top,
    left,
    width,
    height: height2
  } = node.box;
  const color = parseColor(node.style.backgroundColor);
  const nodeOpacity = isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity) ? 1 : node.style.opacity;
  const opacity = Math.min(color.opacity, nodeOpacity);
  ctx.fillOpacity(opacity).fillColor(color.value).rect(left, top, width, height2).fill();
};
var renderBackground = (ctx, node) => {
  var _node$style2;
  const hasBackground = !!node.box && !!((_node$style2 = node.style) !== null && _node$style2 !== void 0 && _node$style2.backgroundColor);
  if (hasBackground) {
    ctx.save();
    clipNode(ctx, node);
    drawBackground(ctx, node);
    ctx.restore();
  }
};
var isSrcId = (value2) => /^#.+/.test(value2);
var setLink = (ctx, node) => {
  const props = node.props || {};
  const {
    top,
    left,
    width,
    height: height2
  } = node.box;
  const src = props.src || props.href;
  if (src) {
    const isId = isSrcId(src);
    const method = isId ? "goTo" : "link";
    const value2 = isId ? src.slice(1) : src;
    ctx[method](left, top, width, height2, value2);
  }
};
var setDestination = (ctx, node) => {
  var _node$props;
  if ((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.id) {
    ctx.addNamedDestination(node.props.id, "XYZ", null, node.box.top, null);
  }
};
var clean = (options) => {
  const opt = {
    ...options
  };
  Object.entries(opt).forEach((pair) => {
    if (!pair[1]) {
      delete opt[pair[0]];
    }
  });
  return opt;
};
var parseCommonFormOptions = (node) => {
  var _node$props, _node$props2, _node$props3, _node$props4, _node$props5;
  return {
    required: ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.required) || false,
    noExport: ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.noExport) || false,
    readOnly: ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.readOnly) || false,
    value: ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.value) || void 0,
    defaultValue: ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.defaultValue) || void 0
  };
};
var parseTextFieldOptions = (node, fieldSet) => {
  var _node$props6, _node$props7, _node$props8, _node$props9, _node$props10, _node$props11, _node$props12;
  return clean({
    ...parseCommonFormOptions(node),
    parent: fieldSet || void 0,
    align: ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.align) || "left",
    multiline: ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.multiline) || void 0,
    password: ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.password) || false,
    noSpell: ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : _node$props9.noSpell) || false,
    format: ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : _node$props10.format) || void 0,
    fontSize: ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.fontSize) || void 0,
    MaxLen: ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.maxLength) || void 0
  });
};
var parseSelectAndListFieldOptions = (node) => {
  var _node$props13, _node$props14, _node$props15, _node$props16, _node$props17;
  return clean({
    ...parseCommonFormOptions(node),
    sort: ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.sort) || false,
    edit: ((_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.edit) || false,
    multiSelect: ((_node$props15 = node.props) === null || _node$props15 === void 0 ? void 0 : _node$props15.multiSelect) || false,
    noSpell: ((_node$props16 = node.props) === null || _node$props16 === void 0 ? void 0 : _node$props16.noSpell) || false,
    select: ((_node$props17 = node.props) === null || _node$props17 === void 0 ? void 0 : _node$props17.select) || [""]
  });
};
var getAppearance = (ctx, codepoint, width, height2) => {
  const appearance = ctx.ref({
    Type: "XObject",
    Subtype: "Form",
    BBox: [0, 0, width, height2],
    Resources: {
      ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
      Font: {
        ZaDi: ctx._acroform.fonts.ZaDi
      }
    }
  });
  appearance.initDeflate();
  appearance.write(`/Tx BMC
q
/ZaDi ${height2 * 0.8} Tf
BT
${width * 0.45} ${height2 / 4} Td (${codepoint}) Tj
ET
Q
EMC`);
  appearance.end();
  return appearance;
};
var parseCheckboxOptions = (ctx, node, fieldSet) => {
  var _node$props18, _node$props19, _node$props20, _node$props21, _node$props22, _node$props23, _node$props24, _node$props25;
  const {
    width,
    height: height2
  } = node.box || {};
  const onOption = ((_node$props18 = node.props) === null || _node$props18 === void 0 ? void 0 : _node$props18.onState) || "Yes";
  const offOption = ((_node$props19 = node.props) === null || _node$props19 === void 0 ? void 0 : _node$props19.offState) || "Off";
  const xMark = ((_node$props20 = node.props) === null || _node$props20 === void 0 ? void 0 : _node$props20.xMark) || false;
  if (!Object.prototype.hasOwnProperty.call(ctx._acroform.fonts, "ZaDi")) {
    const ref = ctx.ref({
      Type: "Font",
      Subtype: "Type1",
      BaseFont: "ZapfDingbats"
    });
    ctx._acroform.fonts.ZaDi = ref;
    ref.end();
  }
  const normalAppearance = {};
  normalAppearance[onOption] = getAppearance(ctx, xMark ? "8" : "4", width, height2);
  normalAppearance[offOption] = getAppearance(ctx, xMark ? " " : "8", width, height2);
  return clean({
    ...parseCommonFormOptions(node),
    backgroundColor: ((_node$props21 = node.props) === null || _node$props21 === void 0 ? void 0 : _node$props21.backgroundColor) || void 0,
    borderColor: ((_node$props22 = node.props) === null || _node$props22 === void 0 ? void 0 : _node$props22.borderColor) || void 0,
    parent: fieldSet || void 0,
    value: `/${((_node$props23 = node.props) === null || _node$props23 === void 0 ? void 0 : _node$props23.checked) === true ? onOption : offOption}`,
    defaultValue: `/${((_node$props24 = node.props) === null || _node$props24 === void 0 ? void 0 : _node$props24.checked) === true ? onOption : offOption}`,
    AS: ((_node$props25 = node.props) === null || _node$props25 === void 0 ? void 0 : _node$props25.checked) === true ? onOption : offOption,
    AP: {
      N: normalAppearance,
      D: normalAppearance
    }
  });
};
var renderTextInput = function(ctx, node, options) {
  var _node$props, _options$fieldSets;
  if (options === void 0) {
    options = {};
  }
  const {
    top,
    left,
    width,
    height: height2
  } = node.box || {};
  const name = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.name) || "";
  const fieldSetOptions = (_options$fieldSets = options.fieldSets) === null || _options$fieldSets === void 0 ? void 0 : _options$fieldSets.at(0);
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formText(name, left, top, width, height2, parseTextFieldOptions(node, fieldSetOptions));
};
var renderSelect = (ctx, node) => {
  var _node$props;
  const {
    top,
    left,
    width,
    height: height2
  } = node.box || {};
  const name = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.name) || "";
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formCombo(name, left, top, width, height2, parseSelectAndListFieldOptions(node));
};
var renderFieldSet = function(ctx, node, options) {
  var _node$props;
  if (options === void 0) {
    options = {};
  }
  const name = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.name) || "";
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  const formField = ctx.formField(name);
  const option = options;
  if (!option.fieldSets) {
    option.fieldSets = [formField];
  } else {
    option.fieldSets.push(formField);
  }
};
var cleanUpFieldSet = (_ctx, _node, options) => {
  options.fieldSets.pop();
};
var renderList = (ctx, node) => {
  var _node$props;
  const {
    top,
    left,
    width,
    height: height2
  } = node.box || {};
  const name = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.name) || "";
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formList(name, left, top, width, height2, parseSelectAndListFieldOptions(node));
};
var renderCheckbox = function(ctx, node, options) {
  var _node$props, _options$fieldSets;
  if (options === void 0) {
    options = {};
  }
  const {
    top,
    left,
    width,
    height: height2
  } = node.box || {};
  const name = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.name) || "";
  const fieldSetOptions = (_options$fieldSets = options.fieldSets) === null || _options$fieldSets === void 0 ? void 0 : _options$fieldSets.at(0);
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formCheckbox(name, left, top, width, height2, parseCheckboxOptions(ctx, node, fieldSetOptions));
};
var isRecursiveNode = (node) => node.type !== Text && node.type !== Svg;
var renderChildren = (ctx, node, options) => {
  ctx.save();
  if (node.box) {
    ctx.translate(node.box.left, node.box.top);
  }
  const children = node.children || [];
  const renderChild = (child) => renderNode(ctx, child, options);
  children.forEach(renderChild);
  ctx.restore();
};
var renderFns = {
  [Text]: renderText,
  [Note]: renderNote,
  [Image]: renderImage,
  [FieldSet]: renderFieldSet,
  [TextInput]: renderTextInput,
  [Select]: renderSelect,
  [Checkbox]: renderCheckbox,
  [List]: renderList,
  [Canvas]: renderCanvas,
  [Svg]: renderSvg,
  [Link]: setLink
};
var cleanUpFns = {
  [FieldSet]: cleanUpFieldSet
};
var renderNode = (ctx, node, options) => {
  var _node$style;
  const overflowHidden = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.overflow) === "hidden";
  const shouldRenderChildren = isRecursiveNode(node);
  if (node.type === Page) renderPage(ctx, node);
  ctx.save();
  if (overflowHidden) clipNode(ctx, node);
  applyTransformations(ctx, node);
  renderBackground(ctx, node);
  renderBorders(ctx, node);
  const renderFn = renderFns[node.type];
  if (renderFn) renderFn(ctx, node, options);
  if (shouldRenderChildren) renderChildren(ctx, node, options);
  const cleanUpFn = cleanUpFns[node.type];
  if (cleanUpFn) cleanUpFn(ctx, node, options);
  setDestination(ctx, node);
  renderDebug(ctx, node);
  ctx.restore();
};
var addNodeBookmark = (ctx, node, pageNumber, registry) => {
  var _node$props;
  const bookmark = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.bookmark;
  if (bookmark) {
    const {
      title: title3,
      parent,
      expanded,
      zoom,
      fit
    } = bookmark;
    const outline = registry[parent] || ctx.outline;
    const top = bookmark.top || node.box.top;
    const left = bookmark.left || node.box.left;
    const instance = outline.addItem(title3, {
      pageNumber,
      expanded,
      top,
      left,
      zoom,
      fit
    });
    registry[bookmark.ref] = instance;
  }
  if (!node.children) return;
  node.children.forEach((child) => addNodeBookmark(ctx, child, pageNumber, registry));
};
var addBookmarks = (ctx, root) => {
  const registry = {};
  const pages = root.children || [];
  pages.forEach((page, i3) => {
    addNodeBookmark(ctx, page, i3, registry);
  });
};
var render = (ctx, doc) => {
  const pages = doc.children || [];
  const options = {
    imageCache: /* @__PURE__ */ new Map()
  };
  pages.forEach((page) => renderNode(ctx, page, options));
  addBookmarks(ctx, doc);
  ctx.end();
  return ctx;
};

// node_modules/@react-pdf/pdfkit/lib/pdfkit.browser.js
var import_zstream = __toESM(require_zstream());
var import_deflate = __toESM(require_deflate());
var import_inflate = __toESM(require_inflate());
var import_constants = __toESM(require_constants());
var import_md5 = __toESM(require_md5());

// node_modules/linebreak/dist/module.mjs
var import_unicode_trie3 = __toESM(require_unicode_trie(), 1);
var import_base64_js2 = __toESM(require_b64(), 1);
var $557adaaeb0c7885f$exports = {};
var $1627905f8be2ef3f$export$fb4028874a74450 = 5;
var $1627905f8be2ef3f$export$1bb1140fe1358b00 = 12;
var $1627905f8be2ef3f$export$f3e416a182673355 = 13;
var $1627905f8be2ef3f$export$24aa617c849a894a = 16;
var $1627905f8be2ef3f$export$a73c4d14459b698d = 17;
var $1627905f8be2ef3f$export$9e5d732f3676a9ba = 22;
var $1627905f8be2ef3f$export$1dff41d5c0caca01 = 28;
var $1627905f8be2ef3f$export$30a74a373318dec6 = 31;
var $1627905f8be2ef3f$export$d710c5f50fc7496a = 33;
var $1627905f8be2ef3f$export$66498d28055820a9 = 34;
var $1627905f8be2ef3f$export$eb6c6d0b7c8826f2 = 35;
var $1627905f8be2ef3f$export$de92be486109a1df = 36;
var $1627905f8be2ef3f$export$606cfc2a8896c91f = 37;
var $1627905f8be2ef3f$export$e51d3c675bb0140d = 38;
var $1627905f8be2ef3f$export$da51c6332ad11d7b = 39;
var $1627905f8be2ef3f$export$bea437c40441867d = 40;
var $1627905f8be2ef3f$export$c4c7eecbfed13dc9 = 41;
var $1627905f8be2ef3f$export$98e1f8a379849661 = 42;
var $32627af916ac1b00$export$98f50d781a474745 = 0;
var $32627af916ac1b00$export$12ee1f8f5315ca7e = 1;
var $32627af916ac1b00$export$e4965ce242860454 = 2;
var $32627af916ac1b00$export$8f14048969dcd45e = 3;
var $32627af916ac1b00$export$133eb141bf58aff4 = 4;
var $32627af916ac1b00$export$5bdb8ccbf5c57afc = [
  //OP   , CL    , CP    , QU    , GL    , NS    , EX    , SY    , IS    , PR    , PO    , NU    , AL    , HL    , ID    , IN    , HY    , BA    , BB    , B2    , ZW    , CM    , WJ    , H2    , H3    , JL    , JV    , JT    , RI    , EB    , EM    , ZWJ   , CB
  [
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$8f14048969dcd45e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ]
  // CB
];
var $557adaaeb0c7885f$var$data = import_base64_js2.default.toByteArray("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");
var $557adaaeb0c7885f$var$classTrie = new import_unicode_trie3.default($557adaaeb0c7885f$var$data);
var $557adaaeb0c7885f$var$mapClass = function(c3) {
  switch (c3) {
    case $1627905f8be2ef3f$export$d710c5f50fc7496a:
      return $1627905f8be2ef3f$export$1bb1140fe1358b00;
    case $1627905f8be2ef3f$export$da51c6332ad11d7b:
    case $1627905f8be2ef3f$export$bea437c40441867d:
    case $1627905f8be2ef3f$export$98e1f8a379849661:
      return $1627905f8be2ef3f$export$1bb1140fe1358b00;
    case $1627905f8be2ef3f$export$eb6c6d0b7c8826f2:
      return $1627905f8be2ef3f$export$fb4028874a74450;
    default:
      return c3;
  }
};
var $557adaaeb0c7885f$var$mapFirst = function(c3) {
  switch (c3) {
    case $1627905f8be2ef3f$export$606cfc2a8896c91f:
    case $1627905f8be2ef3f$export$e51d3c675bb0140d:
      return $1627905f8be2ef3f$export$66498d28055820a9;
    case $1627905f8be2ef3f$export$c4c7eecbfed13dc9:
      return $1627905f8be2ef3f$export$9e5d732f3676a9ba;
    default:
      return c3;
  }
};
var $557adaaeb0c7885f$var$Break = class {
  constructor(position, required = false) {
    this.position = position;
    this.required = required;
  }
};
var $557adaaeb0c7885f$var$LineBreaker = class {
  nextCodePoint() {
    const code = this.string.charCodeAt(this.pos++);
    const next = this.string.charCodeAt(this.pos);
    if (55296 <= code && code <= 56319 && 56320 <= next && next <= 57343) {
      this.pos++;
      return (code - 55296) * 1024 + (next - 56320) + 65536;
    }
    return code;
  }
  nextCharClass() {
    return $557adaaeb0c7885f$var$mapClass($557adaaeb0c7885f$var$classTrie.get(this.nextCodePoint()));
  }
  getSimpleBreak() {
    switch (this.nextClass) {
      case $1627905f8be2ef3f$export$c4c7eecbfed13dc9:
        return false;
      case $1627905f8be2ef3f$export$66498d28055820a9:
      case $1627905f8be2ef3f$export$606cfc2a8896c91f:
      case $1627905f8be2ef3f$export$e51d3c675bb0140d:
        this.curClass = $1627905f8be2ef3f$export$66498d28055820a9;
        return false;
      case $1627905f8be2ef3f$export$de92be486109a1df:
        this.curClass = $1627905f8be2ef3f$export$de92be486109a1df;
        return false;
    }
    return null;
  }
  getPairTableBreak(lastClass) {
    let shouldBreak2 = false;
    switch ($32627af916ac1b00$export$5bdb8ccbf5c57afc[this.curClass][this.nextClass]) {
      case $32627af916ac1b00$export$98f50d781a474745:
        shouldBreak2 = true;
        break;
      case $32627af916ac1b00$export$12ee1f8f5315ca7e:
        shouldBreak2 = lastClass === $1627905f8be2ef3f$export$c4c7eecbfed13dc9;
        break;
      case $32627af916ac1b00$export$e4965ce242860454:
        shouldBreak2 = lastClass === $1627905f8be2ef3f$export$c4c7eecbfed13dc9;
        if (!shouldBreak2) {
          shouldBreak2 = false;
          return shouldBreak2;
        }
        break;
      case $32627af916ac1b00$export$8f14048969dcd45e:
        if (lastClass !== $1627905f8be2ef3f$export$c4c7eecbfed13dc9) return shouldBreak2;
        break;
      case $32627af916ac1b00$export$133eb141bf58aff4:
        break;
    }
    if (this.LB8a) shouldBreak2 = false;
    if (this.LB21a && (this.curClass === $1627905f8be2ef3f$export$24aa617c849a894a || this.curClass === $1627905f8be2ef3f$export$a73c4d14459b698d)) {
      shouldBreak2 = false;
      this.LB21a = false;
    } else this.LB21a = this.curClass === $1627905f8be2ef3f$export$f3e416a182673355;
    if (this.curClass === $1627905f8be2ef3f$export$1dff41d5c0caca01) {
      this.LB30a++;
      if (this.LB30a == 2 && this.nextClass === $1627905f8be2ef3f$export$1dff41d5c0caca01) {
        shouldBreak2 = true;
        this.LB30a = 0;
      }
    } else this.LB30a = 0;
    this.curClass = this.nextClass;
    return shouldBreak2;
  }
  nextBreak() {
    if (this.curClass == null) {
      let firstClass = this.nextCharClass();
      this.curClass = $557adaaeb0c7885f$var$mapFirst(firstClass);
      this.nextClass = firstClass;
      this.LB8a = firstClass === $1627905f8be2ef3f$export$30a74a373318dec6;
      this.LB30a = 0;
    }
    while (this.pos < this.string.length) {
      this.lastPos = this.pos;
      const lastClass = this.nextClass;
      this.nextClass = this.nextCharClass();
      if (this.curClass === $1627905f8be2ef3f$export$66498d28055820a9 || this.curClass === $1627905f8be2ef3f$export$de92be486109a1df && this.nextClass !== $1627905f8be2ef3f$export$606cfc2a8896c91f) {
        this.curClass = $557adaaeb0c7885f$var$mapFirst($557adaaeb0c7885f$var$mapClass(this.nextClass));
        return new $557adaaeb0c7885f$var$Break(this.lastPos, true);
      }
      let shouldBreak2 = this.getSimpleBreak();
      if (shouldBreak2 === null) shouldBreak2 = this.getPairTableBreak(lastClass);
      this.LB8a = this.nextClass === $1627905f8be2ef3f$export$30a74a373318dec6;
      if (shouldBreak2) return new $557adaaeb0c7885f$var$Break(this.lastPos);
    }
    if (this.lastPos < this.string.length) {
      this.lastPos = this.string.length;
      return new $557adaaeb0c7885f$var$Break(this.string.length);
    }
    return null;
  }
  constructor(string) {
    this.string = string;
    this.pos = 0;
    this.lastPos = 0;
    this.curClass = null;
    this.nextClass = null;
    this.LB8a = false;
    this.LB21a = false;
    this.LB30a = 0;
  }
};
$557adaaeb0c7885f$exports = $557adaaeb0c7885f$var$LineBreaker;

// node_modules/jay-peg/src/markers/dac.js
var DACTable = new Struct({
  identifier: new BufferT(1),
  value: new BufferT(1)
});
var DACMarker = {
  name: () => "DAC",
  length: uint16be,
  tables: new ArrayT(DACTable, (parent) => parent.length / 2)
};
var dac_default = DACMarker;

// node_modules/jay-peg/src/markers/utils.js
var readUInt8 = (array, offset2) => {
  return array[offset2];
};
var readUInt16BE = (array, offset2) => {
  return array[offset2] << 8 | array[offset2 + 1];
};
var readUInt16LE = (array, offset2) => {
  return array[offset2] | array[offset2 + 1] << 8;
};
var readUInt32BE = (array, offset2) => {
  return readInt32BE(array, offset2) >>> 0;
};
var readUInt32LE = (array, offset2) => {
  return readInt32LE(array, offset2) >>> 0;
};
var uint8ArrayToHexString = (uint8Array) => {
  return Array.from(
    uint8Array,
    (byte) => byte.toString(16).padStart(2, "0")
  ).join("");
};
var decoder = new TextDecoder("utf-8");
var uint8ArrayToString = (uint8Array) => {
  return decoder.decode(uint8Array);
};
var concatenateUint8Arrays = (arrays) => {
  const totalLength = arrays.reduce((length2, arr) => length2 + arr.length, 0);
  const concatenatedArray = new Uint8Array(totalLength);
  let offset2 = 0;
  arrays.forEach((arr) => {
    concatenatedArray.set(arr, offset2);
    offset2 += arr.length;
  });
  return concatenatedArray;
};
var readInt32BE = (array, offset2) => {
  return array[offset2] << 24 | array[offset2 + 1] << 16 | array[offset2 + 2] << 8 | array[offset2 + 3];
};
var readInt32LE = (array, offset2) => {
  return array[offset2] | array[offset2 + 1] << 8 | array[offset2 + 2] << 16 | array[offset2 + 3] << 24;
};

// node_modules/jay-peg/src/markers/dht.js
var HuffmanTableElements = class {
  decode(stream2, parent) {
    const tables = {};
    let buffer = stream2.buffer.slice(
      stream2.pos,
      stream2.pos + parent.length - 2
    );
    while (buffer.length > 0) {
      let offset2 = 1;
      const elements = [];
      const identifier = readUInt8(buffer, 0);
      const lengths = buffer.slice(offset2, offset2 + 16);
      offset2 += 16;
      for (const length2 of lengths) {
        elements.push(buffer.slice(offset2, offset2 + length2));
        offset2 += length2;
      }
      buffer = buffer.slice(offset2);
      tables[identifier] = concatenateUint8Arrays(elements);
    }
    stream2.pos += parent.length - 2;
    return tables;
  }
};
var DefineHuffmanTableMarker = {
  name: () => "DHT",
  length: uint16be,
  tables: new HuffmanTableElements()
};
var dht_default = DefineHuffmanTableMarker;

// node_modules/jay-peg/src/markers/dqt.js
var DQTMarker = {
  name: () => "DQT",
  length: uint16be,
  tables: new ArrayT(
    new Struct({
      identifier: new BufferT(1),
      data: new BufferT(64)
    }),
    (parent) => (parent.length - 2) / 65
  )
};
var dqt_default = DQTMarker;

// node_modules/jay-peg/src/markers/dri.js
var DRIMarker = {
  name: () => "DRI",
  length: uint16be,
  restartInterval: uint16be
};
var dri_default = DRIMarker;

// node_modules/jay-peg/src/markers/eoi.js
var EndOfImageMarker = {
  name: () => "EOI",
  afterEOI: new Reserved(uint8, Infinity)
};
var eoi_default = EndOfImageMarker;

// node_modules/jay-peg/src/markers/exif.js
var tags = {
  ifd: {
    "010e": "imageDescription",
    "010f": "make",
    "011a": "xResolution",
    "011b": "yResolution",
    "011c": "planarConfiguration",
    "012d": "transferFunction",
    "013b": "artist",
    "013e": "whitePoint",
    "013f": "primaryChromaticities",
    "0100": "imageWidth",
    "0101": "imageHeight",
    "0102": "bitsPerSample",
    "0103": "compression",
    "0106": "photometricInterpretation",
    "0110": "model",
    "0111": "stripOffsets",
    "0112": "orientation",
    "0115": "samplesPerPixel",
    "0116": "rowsPerStrip",
    "0117": "stripByteCounts",
    "0128": "resolutionUnit",
    "0131": "software",
    "0132": "dateTime",
    "0201": "jpegInterchangeFormat",
    "0202": "jpegInterchangeFormatLength",
    "0211": "ycbCrCoefficients",
    "0212": "ycbCrSubSampling",
    "0213": "ycbCrPositioning",
    "0214": "referenceBlackWhite",
    "829a": "exposureTime",
    "829d": "fNumber",
    "920a": "focalLength",
    "927c": "makerNote",
    8298: "copyright",
    8769: "exifIFDPointer",
    8822: "exposureProgram",
    8824: "spectralSensitivity",
    8825: "gpsInfoIFDPointer",
    8827: "photographicSensitivity",
    8828: "oecf",
    8830: "sensitivityType",
    8831: "standardOutputSensitivity",
    8832: "recommendedExposureIndex",
    8833: "isoSpeed",
    8834: "isoSpeedLatitudeyyy",
    8835: "isoSpeedLatitudezzz",
    9e3: "exifVersion",
    9003: "dateTimeOriginal",
    9004: "dateTimeDigitized",
    9101: "componentsConfiguration",
    9102: "compressedBitsPerPixel",
    9201: "shutterSpeedValue",
    9202: "apertureValue",
    9203: "brightnessValue",
    9204: "exposureBiasValue",
    9205: "maxApertureValue",
    9206: "subjectDistance",
    9207: "meteringMode",
    9208: "lightSource",
    9209: "flash",
    9214: "subjectArea",
    9286: "userComment",
    9290: "subSecTime",
    9291: "subSecTimeOriginal",
    9292: "subSecTimeDigitized",
    a000: "flashpixVersion",
    a001: "colorSpace",
    a002: "pixelXDimension",
    a003: "pixelYDimension",
    a004: "relatedSoundFile",
    a005: "interoperabilityIFDPointer",
    a20b: "flashEnergy",
    a20c: "spatialFrequencyResponse",
    a20e: "focalPlaneXResolution",
    a20f: "focalPlaneYResolution",
    a40a: "sharpness",
    a40b: "deviceSettingDescription",
    a40c: "subjectDistanceRange",
    a210: "focalPlaneResolutionUnit",
    a214: "subjectLocation",
    a215: "exposureIndex",
    a217: "sensingMethod",
    a300: "fileSource",
    a301: "sceneType",
    a302: "cfaPattern",
    a401: "customRendered",
    a402: "exposureMode",
    a403: "whiteBalance",
    a404: "digitalZoomRatio",
    a405: "focalLengthIn35mmFilm",
    a406: "sceneCaptureType",
    a407: "gainControl",
    a408: "contrast",
    a409: "saturation",
    a420: "imageUniqueID",
    a430: "cameraOwnerName",
    a431: "bodySerialNumber",
    a432: "lensSpecification",
    a433: "lensMake",
    a434: "lensModel",
    a435: "lensSerialNumber",
    a500: "gamma"
  },
  gps: {
    "0000": "gpsVersionID",
    "0001": "gpsLatitudeRef",
    "0002": "gpsLatitude",
    "0003": "gpsLongitudeRef",
    "0004": "gpsLongitude",
    "0005": "gpsAltitudeRef",
    "0006": "gpsAltitude",
    "0007": "gpsTimeStamp",
    "0008": "gpsSatellites",
    "0009": "gpsStatus",
    "000a": "gpsMeasureMode",
    "000b": "gpsDOP",
    "000c": "gpsSpeedRef",
    "000d": "gpsSpeed",
    "000e": "gpsTrackRef",
    "000f": "gpsTrack",
    "0010": "gpsImgDirectionRef",
    "0011": "gpsImgDirection",
    "0012": "gpsMapDatum",
    "0013": "gpsDestLatitudeRef",
    "0014": "gpsDestLatitude",
    "0015": "gpsDestLongitudeRef",
    "0016": "gpsDestLongitude",
    "0017": "gpsDestBearingRef",
    "0018": "gpsDestBearing",
    "0019": "gpsDestDistanceRef",
    "001a": "gpsDestDistance",
    "001b": "gpsProcessingMethod",
    "001c": "gpsAreaInformation",
    "001d": "gpsDateStamp",
    "001e": "gpsDifferential",
    "001f": "gpsHPositioningError"
  }
};
var IDFEntries = class {
  constructor(bigEndian) {
    this.bigEndian = bigEndian;
    this.bytes = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];
  }
  _getTagValue(dataValue, dataFormat, componentsNumber) {
    switch (dataFormat) {
      case 2:
        return dataValue.toString("ascii").replace(/\0+$/, "");
      case 129:
        return dataValue.toString("utf8").replace(/\0+$/, "");
      case 7:
        return "0x" + dataValue.toString("hex");
      default:
        return this._getTagValueForNumericalData(dataValue, dataFormat, componentsNumber);
    }
  }
  _getTagValueForNumericalData(dataValue, dataFormat, componentsNumber) {
    const tagValue = [];
    const componentsBytes = this.bytes[dataFormat];
    for (let i3 = 0; i3 < componentsNumber; i3 += 1) {
      tagValue.push(this._getSingleTagValueForNumericalData(dataValue, dataFormat, i3 * componentsBytes));
    }
    return tagValue.length === 1 ? tagValue[0] : tagValue;
  }
  _getSingleTagValueForNumericalData(dataValue, dataFormat, pos) {
    const uint162 = (pos2) => this.bigEndian ? readUInt16BE(dataValue, pos2) : readUInt16LE(dataValue, pos2);
    const uint322 = (pos2) => this.bigEndian ? readUInt32BE(dataValue, pos2) : readUInt32LE(dataValue, pos2);
    const int322 = (pos2) => this.bigEndian ? readInt32BE(dataValue, pos2) : readInt32LE(dataValue, pos2);
    switch (dataFormat) {
      case 1:
        return readUInt8(dataValue, pos);
      case 3:
        return uint162(pos);
      case 4:
        return uint322(pos);
      case 5:
        return uint322(pos) / uint322(pos + 4);
      case 9:
        return int322(pos);
      case 10: {
        return int322(pos) / int322(pos + 4);
      }
    }
  }
  _decodeIDFEntries(buffer, tags2, offset2, log3 = false) {
    let pos = 2 + offset2;
    const entries = {};
    const uint162 = (pos2) => this.bigEndian ? readUInt16BE(buffer, pos2) : readUInt16LE(buffer, pos2);
    const uint322 = (pos2) => this.bigEndian ? readUInt32BE(buffer, pos2) : readUInt32LE(buffer, pos2);
    const numberOfEntries = uint162(offset2);
    for (let i3 = 0; i3 < numberOfEntries; i3++) {
      const tagAddress = buffer.slice(pos, pos + 2);
      const dataFormat = uint162(pos + 2);
      const componentsNumber = uint322(pos + 4);
      const componentsBytes = this.bytes[dataFormat];
      const dataLength = componentsNumber * componentsBytes;
      let dataValue = buffer.slice(pos + 8, pos + 12);
      if (dataLength > 4) {
        const dataOffset = this.bigEndian ? readUInt32BE(dataValue, 0) : readUInt32LE(dataValue, 0);
        dataValue = buffer.slice(dataOffset, dataOffset + dataLength);
      }
      const tagValue = this._getTagValue(dataValue, dataFormat, componentsNumber);
      const tagNumber = this.bigEndian ? uint8ArrayToHexString(tagAddress) : uint8ArrayToHexString(tagAddress.reverse());
      const tagName = tags2[tagNumber];
      entries[tagName] = tagValue;
      pos += 12;
    }
    return entries;
  }
  decode(stream2, parent) {
    const buffer = stream2.buffer.slice(stream2.pos - 8);
    const offsetToFirstIFD = parent.offsetToFirstIFD;
    if (offsetToFirstIFD > buffer.length) {
      stream2.pos += parent.parent.length - 16;
      return {};
    }
    const entries = this._decodeIDFEntries(buffer, tags.ifd, offsetToFirstIFD);
    const { exifIFDPointer, gpsInfoIFDPointer } = entries;
    if (exifIFDPointer) {
      entries.subExif = this._decodeIDFEntries(
        buffer,
        tags.ifd,
        exifIFDPointer
      );
    }
    if (gpsInfoIFDPointer) {
      const gps = gpsInfoIFDPointer;
      entries.gpsInfo = this._decodeIDFEntries(buffer, tags.gps, gps, true);
    }
    stream2.pos += parent.parent.length - 16;
    return entries;
  }
};
var IFDData = (bigEndian) => {
  const uint162 = bigEndian ? uint16be : uint16le;
  const uint322 = bigEndian ? uint32be : uint32le;
  return new Struct({
    fortyTwo: uint162,
    offsetToFirstIFD: uint322,
    entries: new IDFEntries(bigEndian)
  });
};
var TIFFHeader = class {
  decode(stream2, parent) {
    const byteOrder = uint8ArrayToString(
      stream2.buffer.slice(stream2.pos, stream2.pos + 2)
    );
    const bigEndian = byteOrder === "MM";
    stream2.pos += 2;
    const data2 = IFDData(bigEndian).decode(stream2, parent);
    return data2.entries;
  }
};
var EXIFMarker = {
  name: () => "EXIF",
  length: uint16be,
  identifier: new StringT(6),
  entries: new TIFFHeader()
};
var exif_default = EXIFMarker;

// node_modules/jay-peg/src/markers/jfif.js
var JFIFMarker = {
  name: () => "JFIF",
  length: uint16be,
  identifier: new StringT(5),
  version: uint16be,
  units: uint8,
  xDensity: uint16be,
  yDensity: uint16be,
  thumbnailWidth: uint8,
  thumbnailHeight: uint8
};
var jfif_default = JFIFMarker;

// node_modules/jay-peg/src/markers/sos.js
var ImageData = class {
  decode(stream2) {
    const buffer = stream2.buffer.slice(stream2.pos);
    let length2 = 0;
    let i3 = buffer.indexOf(255);
    while (i3 !== -1) {
      length2 = i3;
      const nextByte = buffer[length2 + 1];
      const comesRestart = nextByte >= 208 && nextByte <= 215;
      if (nextByte !== 0 && !comesRestart) break;
      i3 = buffer.indexOf(255, i3 + 1);
    }
    stream2.pos += length2;
    return buffer.slice(0, length2);
  }
};
var SOSComponentSpecification = new Struct({
  scanComponentSelector: uint8,
  entropyCodingTable: new BufferT(1)
});
var SOSMarker = {
  name: () => "SOS",
  length: uint16be,
  numberOfImageComponents: uint8,
  componentSpecifications: new ArrayT(
    SOSComponentSpecification,
    (parent) => parent.numberOfImageComponents
  ),
  startOfSpectral: uint8,
  endOfSpectral: uint8,
  successiveApproximationBit: new BufferT(1),
  data: new ImageData()
};
var sos_default = SOSMarker;

// node_modules/jay-peg/src/markers/sof.js
var FrameColorComponent = new Struct({
  id: uint8,
  samplingFactors: uint8,
  quantizationTableId: uint8
});
var StartOfFrameMarker = {
  name: () => "SOF",
  length: uint16be,
  precision: uint8,
  height: uint16be,
  width: uint16be,
  numberOfComponents: uint8,
  components: new ArrayT(
    FrameColorComponent,
    (parent) => parent.numberOfComponents
  )
};
var sof_default = StartOfFrameMarker;

// node_modules/jay-peg/src/markers/soi.js
var StartOfImageMarker = {
  name: () => "SOI"
};
var soi_default = StartOfImageMarker;

// node_modules/jay-peg/src/index.js
var UnknownMarker = {
  length: uint16be,
  buf: new BufferT((parent) => parent.length - 2)
};
var unknownMarkers = Array(63).fill(0).reduce((acc, v2, i3) => ({ ...acc, [i3 + 65472]: UnknownMarker }), {});
var Marker = new VersionedStruct(uint16be, {
  ...unknownMarkers,
  65472: sof_default,
  65473: sof_default,
  65474: sof_default,
  65475: sof_default,
  65476: dht_default,
  65477: sof_default,
  65478: sof_default,
  65479: sof_default,
  65481: sof_default,
  65482: sof_default,
  65483: sof_default,
  65484: dac_default,
  65485: sof_default,
  65486: sof_default,
  65487: sof_default,
  65496: soi_default,
  65497: eoi_default,
  65498: sos_default,
  65499: dqt_default,
  65501: dri_default,
  65504: jfif_default,
  65505: exif_default
});
var JPEG = new ArrayT(Marker);
var decode = (buffer) => {
  const markers = JPEG.fromBuffer(buffer);
  return markers.map(({ version: version4, ...rest }) => ({ type: version4, ...rest }));
};
var src_default = { decode };

// node_modules/@react-pdf/png-js/lib/png-js.browser.js
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i3 = 0, len = code.length; i3 < len; ++i3) {
    lookup[i3] = code[i3];
    revLookup[code.charCodeAt(i3)] = i3;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i3, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i3 = 0, j = 0; i3 < l2; i3 += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint82, start2, end2) {
  var tmp;
  var output = [];
  for (var i3 = start2; i3 < end2; i3 += 3) {
    tmp = (uint82[i3] << 16) + (uint82[i3 + 1] << 8) + uint82[i3 + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint82) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i3 = 0, len2 = len - extraBytes; i3 < len2; i3 += maxChunkLength) {
    parts.push(encodeChunk(uint82, i3, i3 + maxChunkLength > len2 ? len2 : i3 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset2, isLE, mLen, nBytes) {
  var e3, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i3 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer[offset2 + i3];
  i3 += d2;
  e3 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e3 = e3 * 256 + buffer[offset2 + i3], i3 += d2, nBits -= 8) {
  }
  m = e3 & (1 << -nBits) - 1;
  e3 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset2 + i3], i3 += d2, nBits -= 8) {
  }
  if (e3 === 0) {
    e3 = 1 - eBias;
  } else if (e3 === eMax) {
    return m ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e3 = e3 - eBias;
  }
  return (s2 ? -1 : 1) * m * Math.pow(2, e3 - mLen);
}
function write(buffer, value2, offset2, isLE, mLen, nBytes) {
  var e3, m, c3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i3 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m = isNaN(value2) ? 1 : 0;
    e3 = eMax;
  } else {
    e3 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c3 = Math.pow(2, -e3)) < 1) {
      e3--;
      c3 *= 2;
    }
    if (e3 + eBias >= 1) {
      value2 += rt / c3;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c3 >= 2) {
      e3++;
      c3 /= 2;
    }
    if (e3 + eBias >= eMax) {
      m = 0;
      e3 = eMax;
    } else if (e3 + eBias >= 1) {
      m = (value2 * c3 - 1) * Math.pow(2, mLen);
      e3 = e3 + eBias;
    } else {
      m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e3 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset2 + i3] = m & 255, i3 += d2, m /= 256, mLen -= 8) {
  }
  e3 = e3 << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset2 + i3] = e3 & 255, i3 += d2, e3 /= 256, eLen -= 8) {
  }
  buffer[offset2 + i3 - d2] |= s2 * 128;
}
var toString = {}.toString;
var isArray$1 = Array.isArray || function(arr) {
  return toString.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES = 50;
Buffer2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
var _kMaxLength = kMaxLength();
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length2) {
  if (kMaxLength() < length2) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length2);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length2);
    }
    that.length = length2;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length2) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length2);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length2);
}
Buffer2.poolSize = 8192;
Buffer2._augment = function(arr) {
  arr.__proto__ = Buffer2.prototype;
  return arr;
};
function from(that, value2, encodingOrOffset, length2) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value2, encodingOrOffset, length2);
  }
  if (typeof value2 === "string") {
    return fromString(that, value2, encodingOrOffset);
  }
  return fromObject(that, value2);
}
Buffer2.from = function(value2, encodingOrOffset, length2) {
  return from(null, value2, encodingOrOffset, length2);
};
if (Buffer2.TYPED_ARRAY_SUPPORT) {
  Buffer2.prototype.__proto__ = Uint8Array.prototype;
  Buffer2.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) ;
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill4, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill4 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill4, encoding) : createBuffer(that, size).fill(fill4);
  }
  return createBuffer(that, size);
}
Buffer2.alloc = function(size, fill4, encoding) {
  return alloc(null, size, fill4, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i3 = 0; i3 < size; ++i3) {
      that[i3] = 0;
    }
  }
  return that;
}
Buffer2.allocUnsafe = function(size) {
  return allocUnsafe(null, size);
};
Buffer2.allocUnsafeSlow = function(size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length2 = byteLength2(string, encoding) | 0;
  that = createBuffer(that, length2);
  var actual = that.write(string, encoding);
  if (actual !== length2) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length2);
  for (var i3 = 0; i3 < length2; i3 += 1) {
    that[i3] = array[i3] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length2) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length2 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length2 === void 0) {
    array = new Uint8Array(array);
  } else if (length2 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length2);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray$1(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length2) {
  if (length2 >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length2 | 0;
}
function SlowBuffer(length2) {
  if (+length2 != length2) {
    length2 = 0;
  }
  return Buffer2.alloc(+length2);
}
Buffer2.isBuffer = isBuffer$1;
function internalIsBuffer(b2) {
  return !!(b2 != null && b2._isBuffer);
}
Buffer2.compare = function compare(a3, b2) {
  if (!internalIsBuffer(a3) || !internalIsBuffer(b2)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a3 === b2) return 0;
  var x = a3.length;
  var y2 = b2.length;
  for (var i3 = 0, len = Math.min(x, y2); i3 < len; ++i3) {
    if (a3[i3] !== b2[i3]) {
      x = a3[i3];
      y2 = b2[i3];
      break;
    }
  }
  if (x < y2) return -1;
  if (y2 < x) return 1;
  return 0;
};
Buffer2.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer2.concat = function concat(list, length2) {
  if (!isArray$1(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer2.alloc(0);
  }
  var i3;
  if (length2 === void 0) {
    length2 = 0;
    for (i3 = 0; i3 < list.length; ++i3) {
      length2 += list[i3].length;
    }
  }
  var buffer = Buffer2.allocUnsafe(length2);
  var pos = 0;
  for (i3 = 0; i3 < list.length; ++i3) {
    var buf = list[i3];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength2(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer2.byteLength = byteLength2;
function slowToString(encoding, start2, end2) {
  var loweredCase = false;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (start2 > this.length) {
    return "";
  }
  if (end2 === void 0 || end2 > this.length) {
    end2 = this.length;
  }
  if (end2 <= 0) {
    return "";
  }
  end2 >>>= 0;
  start2 >>>= 0;
  if (end2 <= start2) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start2, end2);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start2, end2);
      case "ascii":
        return asciiSlice(this, start2, end2);
      case "latin1":
      case "binary":
        return latin1Slice(this, start2, end2);
      case "base64":
        return base64Slice(this, start2, end2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start2, end2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer2.prototype._isBuffer = true;
function swap(b2, n4, m) {
  var i3 = b2[n4];
  b2[n4] = b2[m];
  b2[m] = i3;
}
Buffer2.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i3 = 0; i3 < len; i3 += 2) {
    swap(this, i3, i3 + 1);
  }
  return this;
};
Buffer2.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i3 = 0; i3 < len; i3 += 4) {
    swap(this, i3, i3 + 3);
    swap(this, i3 + 1, i3 + 2);
  }
  return this;
};
Buffer2.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i3 = 0; i3 < len; i3 += 8) {
    swap(this, i3, i3 + 7);
    swap(this, i3 + 1, i3 + 6);
    swap(this, i3 + 2, i3 + 5);
    swap(this, i3 + 3, i3 + 4);
  }
  return this;
};
Buffer2.prototype.toString = function toString2() {
  var length2 = this.length | 0;
  if (length2 === 0) return "";
  if (arguments.length === 0) return utf8Slice(this, 0, length2);
  return slowToString.apply(this, arguments);
};
Buffer2.prototype.equals = function equals(b2) {
  if (!internalIsBuffer(b2)) throw new TypeError("Argument must be a Buffer");
  if (this === b2) return true;
  return Buffer2.compare(this, b2) === 0;
};
Buffer2.prototype.inspect = function inspect() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2) str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer2.prototype.compare = function compare2(target, start2, end2, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start2 === void 0) {
    start2 = 0;
  }
  if (end2 === void 0) {
    end2 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start2 >= end2) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start2 >= end2) {
    return 1;
  }
  start2 >>>= 0;
  end2 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y2 = end2 - start2;
  var len = Math.min(x, y2);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start2, end2);
  for (var i3 = 0; i3 < len; ++i3) {
    if (thisCopy[i3] !== targetCopy[i3]) {
      x = thisCopy[i3];
      y2 = targetCopy[i3];
      break;
    }
  }
  if (x < y2) return -1;
  if (y2 < x) return 1;
  return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read4(buf, i4) {
    if (indexSize === 1) {
      return buf[i4];
    } else {
      return buf.readUInt16BE(i4 * indexSize);
    }
  }
  var i3;
  if (dir) {
    var foundIndex = -1;
    for (i3 = byteOffset; i3 < arrLength; i3++) {
      if (read4(arr, i3) === read4(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i3;
        if (i3 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i3 -= i3 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i3 = byteOffset; i3 >= 0; i3--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read4(arr, i3 + j) !== read4(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i3;
    }
  }
  return -1;
}
Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset2, length2) {
  offset2 = Number(offset2) || 0;
  var remaining = buf.length - offset2;
  if (!length2) {
    length2 = remaining;
  } else {
    length2 = Number(length2);
    if (length2 > remaining) {
      length2 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length2 > strLen / 2) {
    length2 = strLen / 2;
  }
  for (var i3 = 0; i3 < length2; ++i3) {
    var parsed = parseInt(string.substr(i3 * 2, 2), 16);
    if (isNaN(parsed)) return i3;
    buf[offset2 + i3] = parsed;
  }
  return i3;
}
function utf8Write(buf, string, offset2, length2) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset2), buf, offset2, length2);
}
function asciiWrite(buf, string, offset2, length2) {
  return blitBuffer(asciiToBytes(string), buf, offset2, length2);
}
function latin1Write(buf, string, offset2, length2) {
  return asciiWrite(buf, string, offset2, length2);
}
function base64Write(buf, string, offset2, length2) {
  return blitBuffer(base64ToBytes(string), buf, offset2, length2);
}
function ucs2Write(buf, string, offset2, length2) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length2);
}
Buffer2.prototype.write = function write2(string, offset2, length2, encoding) {
  if (offset2 === void 0) {
    encoding = "utf8";
    length2 = this.length;
    offset2 = 0;
  } else if (length2 === void 0 && typeof offset2 === "string") {
    encoding = offset2;
    length2 = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length2)) {
      length2 = length2 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length2;
      length2 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset2;
  if (length2 === void 0 || length2 > remaining) length2 = remaining;
  if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset2, length2);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset2, length2);
      case "ascii":
        return asciiWrite(this, string, offset2, length2);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset2, length2);
      case "base64":
        return base64Write(this, string, offset2, length2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset2, length2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer2.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start2, end2) {
  if (start2 === 0 && end2 === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start2, end2));
  }
}
function utf8Slice(buf, start2, end2) {
  end2 = Math.min(buf.length, end2);
  var res = [];
  var i3 = start2;
  while (i3 < end2) {
    var firstByte = buf[i3];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i3 + bytesPerSequence <= end2) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i3 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i3 + 1];
          thirdByte = buf[i3 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i3 + 1];
          thirdByte = buf[i3 + 2];
          fourthByte = buf[i3 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i3 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i3 = 0;
  while (i3 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i3 = start2; i3 < end2; ++i3) {
    ret += String.fromCharCode(buf[i3] & 127);
  }
  return ret;
}
function latin1Slice(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i3 = start2; i3 < end2; ++i3) {
    ret += String.fromCharCode(buf[i3]);
  }
  return ret;
}
function hexSlice(buf, start2, end2) {
  var len = buf.length;
  if (!start2 || start2 < 0) start2 = 0;
  if (!end2 || end2 < 0 || end2 > len) end2 = len;
  var out = "";
  for (var i3 = start2; i3 < end2; ++i3) {
    out += toHex(buf[i3]);
  }
  return out;
}
function utf16leSlice(buf, start2, end2) {
  var bytes = buf.slice(start2, end2);
  var res = "";
  for (var i3 = 0; i3 < bytes.length; i3 += 2) {
    res += String.fromCharCode(bytes[i3] + bytes[i3 + 1] * 256);
  }
  return res;
}
Buffer2.prototype.slice = function slice(start2, end2) {
  var len = this.length;
  start2 = ~~start2;
  end2 = end2 === void 0 ? len : ~~end2;
  if (start2 < 0) {
    start2 += len;
    if (start2 < 0) start2 = 0;
  } else if (start2 > len) {
    start2 = len;
  }
  if (end2 < 0) {
    end2 += len;
    if (end2 < 0) end2 = 0;
  } else if (end2 > len) {
    end2 = len;
  }
  if (end2 < start2) end2 = start2;
  var newBuf;
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start2, end2);
    newBuf.__proto__ = Buffer2.prototype;
  } else {
    var sliceLen = end2 - start2;
    newBuf = new Buffer2(sliceLen, void 0);
    for (var i3 = 0; i3 < sliceLen; ++i3) {
      newBuf[i3] = this[i3 + start2];
    }
  }
  return newBuf;
};
function checkOffset(offset2, ext, length2) {
  if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
  if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
}
Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i3 = 0;
  while (++i3 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i3] * mul;
  }
  return val;
};
Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset(offset2, byteLength5, this.length);
  }
  var val = this[offset2 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset2 + --byteLength5] * mul;
  }
  return val;
};
Buffer2.prototype.readUInt8 = function readUInt82(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 1, this.length);
  return this[offset2];
};
Buffer2.prototype.readUInt16LE = function readUInt16LE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  return this[offset2] | this[offset2 + 1] << 8;
};
Buffer2.prototype.readUInt16BE = function readUInt16BE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  return this[offset2] << 8 | this[offset2 + 1];
};
Buffer2.prototype.readUInt32LE = function readUInt32LE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
};
Buffer2.prototype.readUInt32BE = function readUInt32BE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
};
Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i3 = 0;
  while (++i3 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i3] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset(offset2, byteLength5, this.length);
  var i3 = byteLength5;
  var mul = 1;
  var val = this[offset2 + --i3];
  while (i3 > 0 && (mul *= 256)) {
    val += this[offset2 + --i3] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 1, this.length);
  if (!(this[offset2] & 128)) return this[offset2];
  return (255 - this[offset2] + 1) * -1;
};
Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  var val = this[offset2] | this[offset2 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  var val = this[offset2 + 1] | this[offset2] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer2.prototype.readInt32LE = function readInt32LE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
};
Buffer2.prototype.readInt32BE = function readInt32BE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
};
Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return read(this, offset2, true, 23, 4);
};
Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return read(this, offset2, false, 23, 4);
};
Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 8, this.length);
  return read(this, offset2, true, 52, 8);
};
Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 8, this.length);
  return read(this, offset2, false, 52, 8);
};
function checkInt(buf, value2, offset2, ext, max2, min2) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max2 || value2 < min2) throw new RangeError('"value" argument is out of bounds');
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i3 = 0;
  this[offset2] = value2 & 255;
  while (++i3 < byteLength5 && (mul *= 256)) {
    this[offset2 + i3] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
};
Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var i3 = byteLength5 - 1;
  var mul = 1;
  this[offset2 + i3] = value2 & 255;
  while (--i3 >= 0 && (mul *= 256)) {
    this[offset2 + i3] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
};
Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 1, 255, 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
function objectWriteUInt16(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i3 = 0, j = Math.min(buf.length - offset2, 2); i3 < j; ++i3) {
    buf[offset2 + i3] = (value2 & 255 << 8 * (littleEndian ? i3 : 1 - i3)) >>> (littleEndian ? i3 : 1 - i3) * 8;
  }
}
Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset2, false);
  }
  return offset2 + 2;
};
function objectWriteUInt32(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i3 = 0, j = Math.min(buf.length - offset2, 4); i3 < j; ++i3) {
    buf[offset2 + i3] = value2 >>> (littleEndian ? i3 : 3 - i3) * 8 & 255;
  }
}
Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset2, false);
  }
  return offset2 + 4;
};
Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i3 = 0;
  var mul = 1;
  var sub = 0;
  this[offset2] = value2 & 255;
  while (++i3 < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i3 - 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i3] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
};
Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i3 = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset2 + i3] = value2 & 255;
  while (--i3 >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i3 + 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i3] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
};
Buffer2.prototype.writeInt8 = function writeInt8(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 1, 127, -128);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset2, false);
  }
  return offset2 + 2;
};
Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt32(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset2, false);
  }
  return offset2 + 4;
};
function checkIEEE754(buf, value2, offset2, ext, max2, min2) {
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset2 < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset2, 4);
  }
  write(buf, value2, offset2, littleEndian, 23, 4);
  return offset2 + 4;
}
Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset2, noAssert) {
  return writeFloat(this, value2, offset2, true, noAssert);
};
Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset2, noAssert) {
  return writeFloat(this, value2, offset2, false, noAssert);
};
function writeDouble(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset2, 8);
  }
  write(buf, value2, offset2, littleEndian, 52, 8);
  return offset2 + 8;
}
Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset2, noAssert) {
  return writeDouble(this, value2, offset2, true, noAssert);
};
Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset2, noAssert) {
  return writeDouble(this, value2, offset2, false, noAssert);
};
Buffer2.prototype.copy = function copy(target, targetStart, start2, end2) {
  if (!start2) start2 = 0;
  if (!end2 && end2 !== 0) end2 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end2 > 0 && end2 < start2) end2 = start2;
  if (end2 === start2) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start2 < 0 || start2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end2 > this.length) end2 = this.length;
  if (target.length - targetStart < end2 - start2) {
    end2 = target.length - targetStart + start2;
  }
  var len = end2 - start2;
  var i3;
  if (this === target && start2 < targetStart && targetStart < end2) {
    for (i3 = len - 1; i3 >= 0; --i3) {
      target[i3 + targetStart] = this[i3 + start2];
    }
  } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
    for (i3 = 0; i3 < len; ++i3) {
      target[i3 + targetStart] = this[i3 + start2];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start2, start2 + len),
      targetStart
    );
  }
  return len;
};
Buffer2.prototype.fill = function fill(val, start2, end2, encoding) {
  if (typeof val === "string") {
    if (typeof start2 === "string") {
      encoding = start2;
      start2 = 0;
      end2 = this.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start2 < 0 || this.length < start2 || this.length < end2) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start2) {
    return this;
  }
  start2 = start2 >>> 0;
  end2 = end2 === void 0 ? this.length : end2 >>> 0;
  if (!val) val = 0;
  var i3;
  if (typeof val === "number") {
    for (i3 = start2; i3 < end2; ++i3) {
      this[i3] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
    var len = bytes.length;
    for (i3 = 0; i3 < end2 - start2; ++i3) {
      this[i3 + start2] = bytes[i3 % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n4) {
  if (n4 < 16) return "0" + n4.toString(16);
  return n4.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length2 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i3 = 0; i3 < length2; ++i3) {
    codePoint = string.charCodeAt(i3);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i3 + 1 === length2) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i3 = 0; i3 < str.length; ++i3) {
    byteArray.push(str.charCodeAt(i3) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c3, hi, lo;
  var byteArray = [];
  for (var i3 = 0; i3 < str.length; ++i3) {
    if ((units -= 2) < 0) break;
    c3 = str.charCodeAt(i3);
    hi = c3 >> 8;
    lo = c3 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset2, length2) {
  for (var i3 = 0; i3 < length2; ++i3) {
    if (i3 + offset2 >= dst.length || i3 >= src.length) break;
    dst[i3 + offset2] = src[i3];
  }
  return i3;
}
function isnan(val) {
  return val !== val;
}
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var _polyfillNode_buffer = Object.freeze({
  __proto__: null,
  Buffer: Buffer2,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  isBuffer: isBuffer$1,
  kMaxLength: _kMaxLength
});
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e3) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e4) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e3) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e4) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      args[i3 - 1] = arguments[i3];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform = "browser";
var browser = true;
var env = {};
var argv = [];
var version = "";
var versions = {};
var release = {};
var config = {};
function noop2() {
}
var on = noop2;
var addListener = noop2;
var once = noop2;
var off = noop2;
var removeListener = noop2;
var removeAllListeners = noop2;
var emit = noop2;
function binding$1(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance2 = global$1.performance || {};
var performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance2) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = /* @__PURE__ */ new Date();
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var browser$1 = {
  nextTick,
  title,
  browser,
  env,
  argv,
  version,
  versions,
  on,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  binding: binding$1,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config,
  uptime
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n4) {
  if (n4.__esModule) return n4;
  var f2 = n4.default;
  if (typeof f2 == "function") {
    var a3 = function a4() {
      if (this instanceof a4) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a3.prototype = f2.prototype;
  } else a3 = {};
  Object.defineProperty(a3, "__esModule", { value: true });
  Object.keys(n4).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n4, k2);
    Object.defineProperty(a3, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n4[k2];
      }
    });
  });
  return a3;
}
var lib = {};
var require$$0 = getAugmentedNamespace(_polyfillNode_buffer);
var domain;
function EventHandlers() {
}
EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter() {
  EventEmitter.init.call(this);
}
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.prototype.domain = void 0;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._maxListeners = void 0;
EventEmitter.defaultMaxListeners = 10;
EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    if (domain.active) ;
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n4) {
  if (typeof n4 !== "number" || n4 < 0 || isNaN(n4))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n4;
  return this;
};
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i3 = 0; i3 < len; ++i3)
      listeners3[i3].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i3 = 0; i3 < len; ++i3)
      listeners3[i3].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i3 = 0; i3 < len; ++i3)
      listeners3[i3].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i3 = 0; i3 < len; ++i3)
      listeners3[i3].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i3 = 0; i3 < len; ++i3)
      listeners3[i3].apply(self2, args);
  }
}
EventEmitter.prototype.emit = function emit2(type) {
  var er, handler, len, args, i3, events2, domain3;
  var doError = type === "error";
  events2 = this._events;
  if (events2)
    doError = doError && events2.error == null;
  else if (!doError)
    return false;
  domain3 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain3) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain3;
      er.domainThrown = false;
      domain3.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err2 = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err2.context = er;
      throw err2;
    }
    return false;
  }
  handler = events2[type];
  if (!handler)
    return false;
  var isFn = typeof handler === "function";
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i3 = 1; i3 < len; i3++)
        args[i3 - 1] = arguments[i3];
      emitMany(handler, isFn, this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events2;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = target._events;
  if (!events2) {
    events2 = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events2.newListener) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (!existing) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e3) {
  typeof console.warn === "function" ? console.warn(e3) : console.log(e3);
}
EventEmitter.prototype.addListener = function addListener2(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function _onceWrap(target, type, listener) {
  var fired = false;
  function g2() {
    target.removeListener(type, g2);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g2.listener = listener;
  return g2;
}
EventEmitter.prototype.once = function once2(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener2(type, listener) {
  var list, events2, position, i3, originalListener;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = this._events;
  if (!events2)
    return this;
  list = events2[type];
  if (!list)
    return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i3 = list.length; i3-- > 0; ) {
      if (list[i3] === listener || list[i3].listener && list[i3].listener === listener) {
        originalListener = list[i3].listener;
        position = i3;
        break;
      }
    }
    if (position < 0)
      return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events2[type];
      }
    } else {
      spliceOne(list, position);
    }
    if (events2.removeListener)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = function(type, listener) {
  return this.removeListener(type, listener);
};
EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type) {
  var listeners3, events2;
  events2 = this._events;
  if (!events2)
    return this;
  if (!events2.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events2[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    for (var i3 = 0, key; i3 < keys2.length; ++i3) {
      key = keys2[i3];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }
  listeners3 = events2[type];
  if (typeof listeners3 === "function") {
    this.removeListener(type, listeners3);
  } else if (listeners3) {
    do {
      this.removeListener(type, listeners3[listeners3.length - 1]);
    } while (listeners3[0]);
  }
  return this;
};
EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events2 = this._events;
  if (!events2)
    ret = [];
  else {
    evlistener = events2[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === "function")
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }
  return ret;
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount$1.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount$1;
function listenerCount$1(type) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function spliceOne(list, index3) {
  for (var i3 = index3, k2 = i3 + 1, n4 = list.length; k2 < n4; i3 += 1, k2 += 1)
    list[i3] = list[k2];
  list.pop();
}
function arrayClone(arr, i3) {
  var copy5 = new Array(i3);
  while (i3--)
    copy5[i3] = arr[i3];
  return copy5;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i3 = 0; i3 < ret.length; ++i3) {
    ret[i3] = arr[i3].listener || arr[i3];
  }
  return ret;
}
var inherits;
if (typeof Object.create === "function") {
  inherits = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$1 = inherits;
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
  var keys2 = Object.keys(obj);
  var descriptors = {};
  for (var i3 = 0; i3 < keys2.length; i3++) {
    descriptors[keys2[i3]] = Object.getOwnPropertyDescriptor(obj, keys2[i3]);
  }
  return descriptors;
};
var formatRegExp = /%[sdj%]/g;
function format(f2) {
  if (!isString(f2)) {
    var objects = [];
    for (var i3 = 0; i3 < arguments.length; i3++) {
      objects.push(inspect$1(arguments[i3]));
    }
    return objects.join(" ");
  }
  var i3 = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f2).replace(formatRegExp, function(x2) {
    if (x2 === "%%") return "%";
    if (i3 >= len) return x2;
    switch (x2) {
      case "%s":
        return String(args[i3++]);
      case "%d":
        return Number(args[i3++]);
      case "%j":
        try {
          return JSON.stringify(args[i3++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i3]; i3 < len; x = args[++i3]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect$1(x);
    }
  }
  return str;
}
function deprecate(fn, msg2) {
  if (isUndefined(global$1.process)) {
    return function() {
      return deprecate(fn, msg2).apply(this, arguments);
    };
  }
  if (browser$1.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1.throwDeprecation) {
        throw new Error(msg2);
      } else if (browser$1.traceDeprecation) {
        console.trace(msg2);
      } else {
        console.error(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs = {};
var debugEnviron;
function debuglog(set5) {
  if (isUndefined(debugEnviron))
    debugEnviron = browser$1.env.NODE_DEBUG || "";
  set5 = set5.toUpperCase();
  if (!debugs[set5]) {
    if (new RegExp("\\b" + set5 + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set5] = function() {
        var msg2 = format.apply(null, arguments);
        console.error("%s %d: %s", set5, pid, msg2);
      };
    } else {
      debugs[set5] = function() {
      };
    }
  }
  return debugs[set5];
}
function inspect$1(obj, opts2) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts2)) {
    ctx.showHidden = opts2;
  } else if (opts2) {
    _extend(ctx, opts2);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
inspect$1.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect$1.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor(str, styleType) {
  var style = inspect$1.styles[styleType];
  if (style) {
    return "\x1B[" + inspect$1.colors[style][0] + "m" + str + "\x1B[" + inspect$1.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value2, recurseTimes) {
  if (ctx.customInspect && value2 && isFunction(value2.inspect) && // Filter out the util module, it's inspect function is special
  value2.inspect !== inspect$1 && // Also filter out any prototype objects using the circular check.
  !(value2.constructor && value2.constructor.prototype === value2)) {
    var ret = value2.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value2);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value2);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value2);
  }
  if (isError(value2) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value2);
  }
  if (keys2.length === 0) {
    if (isFunction(value2)) {
      var name = value2.name ? ": " + value2.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    }
    if (isDate(value2)) {
      return ctx.stylize(Date.prototype.toString.call(value2), "date");
    }
    if (isError(value2)) {
      return formatError(value2);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value2)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value2)) {
    var n4 = value2.name ? ": " + value2.name : "";
    base = " [Function" + n4 + "]";
  }
  if (isRegExp(value2)) {
    base = " " + RegExp.prototype.toString.call(value2);
  }
  if (isDate(value2)) {
    base = " " + Date.prototype.toUTCString.call(value2);
  }
  if (isError(value2)) {
    base = " " + formatError(value2);
  }
  if (keys2.length === 0 && (!array || value2.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value2);
  var output;
  if (array) {
    output = formatArray(ctx, value2, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value2) {
  if (isUndefined(value2))
    return ctx.stylize("undefined", "undefined");
  if (isString(value2)) {
    var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value2))
    return ctx.stylize("" + value2, "number");
  if (isBoolean(value2))
    return ctx.stylize("" + value2, "boolean");
  if (isNull(value2))
    return ctx.stylize("null", "null");
}
function formatError(value2) {
  return "[" + Error.prototype.toString.call(value2) + "]";
}
function formatArray(ctx, value2, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i3 = 0, l2 = value2.length; i3 < l2; ++i3) {
    if (hasOwnProperty(value2, String(i3))) {
      output.push(formatProperty(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        String(i3),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line2) {
            return "  " + line2;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line2) {
            return "   " + line2;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var length2 = output.reduce(function(prev, cur) {
    if (cur.indexOf("\n") >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length2 > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d2) {
  return isObject(d2) && objectToString(d2) === "[object Date]";
}
function isError(e3) {
  return isObject(e3) && (objectToString(e3) === "[object Error]" || e3 instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
function isBuffer(maybeBuf) {
  return Buffer2.isBuffer(maybeBuf);
}
function objectToString(o2) {
  return Object.prototype.toString.call(o2);
}
function pad(n4) {
  return n4 < 10 ? "0" + n4.toString(10) : n4.toString(10);
}
var months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp() {
  var d2 = /* @__PURE__ */ new Date();
  var time = [
    pad(d2.getHours()),
    pad(d2.getMinutes()),
    pad(d2.getSeconds())
  ].join(":");
  return [d2.getDate(), months[d2.getMonth()], time].join(" ");
}
function log() {
  console.log("%s - %s", timestamp(), format.apply(null, arguments));
}
function _extend(origin, add2) {
  if (!add2 || !isObject(add2)) return origin;
  var keys2 = Object.keys(add2);
  var i3 = keys2.length;
  while (i3--) {
    origin[keys2[i3]] = add2[keys2[i3]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
function promisify(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== "function") {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }
  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function(resolve3, reject) {
      promiseResolve = resolve3;
      promiseReject = reject;
    });
    var args = [];
    for (var i3 = 0; i3 < arguments.length; i3++) {
      args.push(arguments[i3]);
    }
    args.push(function(err2, value2) {
      if (err2) {
        promiseReject(err2);
      } else {
        promiseResolve(value2);
      }
    });
    try {
      original.apply(this, args);
    } catch (err2) {
      promiseReject(err2);
    }
    return promise;
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}
promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
function callbackify(original) {
  if (typeof original !== "function") {
    throw new TypeError('The "original" argument must be of type Function');
  }
  function callbackified() {
    var args = [];
    for (var i3 = 0; i3 < arguments.length; i3++) {
      args.push(arguments[i3]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new TypeError("The last argument must be of type Function");
    }
    var self2 = this;
    var cb = function() {
      return maybeCb.apply(self2, arguments);
    };
    original.apply(this, args).then(
      function(ret) {
        browser$1.nextTick(cb.bind(null, null, ret));
      },
      function(rej) {
        browser$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
      }
    );
  }
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}
var _polyfillNode_util = {
  inherits: inherits$1,
  _extend,
  log,
  isBuffer,
  isPrimitive,
  isFunction,
  isError,
  isDate,
  isObject,
  isRegExp,
  isUndefined,
  isSymbol,
  isString,
  isNumber,
  isNullOrUndefined,
  isNull,
  isBoolean,
  isArray,
  inspect: inspect$1,
  deprecate,
  format,
  debuglog,
  promisify,
  callbackify
};
var _polyfillNode_util$1 = Object.freeze({
  __proto__: null,
  _extend,
  callbackify,
  debuglog,
  default: _polyfillNode_util,
  deprecate,
  format,
  inherits: inherits$1,
  inspect: inspect$1,
  isArray,
  isBoolean,
  isBuffer,
  isDate,
  isError,
  isFunction,
  isNull,
  isNullOrUndefined,
  isNumber,
  isObject,
  isPrimitive,
  isRegExp,
  isString,
  isSymbol,
  isUndefined,
  log,
  promisify
});
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
BufferList.prototype.push = function(v2) {
  var entry = { data: v2, next: null };
  if (this.length > 0) this.tail.next = entry;
  else this.head = entry;
  this.tail = entry;
  ++this.length;
};
BufferList.prototype.unshift = function(v2) {
  var entry = { data: v2, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};
BufferList.prototype.shift = function() {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;
  else this.head = this.head.next;
  --this.length;
  return ret;
};
BufferList.prototype.clear = function() {
  this.head = this.tail = null;
  this.length = 0;
};
BufferList.prototype.join = function(s2) {
  if (this.length === 0) return "";
  var p2 = this.head;
  var ret = "" + p2.data;
  while (p2 = p2.next) {
    ret += s2 + p2.data;
  }
  return ret;
};
BufferList.prototype.concat = function(n4) {
  if (this.length === 0) return Buffer2.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = Buffer2.allocUnsafe(n4 >>> 0);
  var p2 = this.head;
  var i3 = 0;
  while (p2) {
    p2.data.copy(ret, i3);
    i3 += p2.data.length;
    p2 = p2.next;
  }
  return ret;
};
var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
StringDecoder.prototype.write = function(buffer) {
  var charStr = "";
  while (this.charLength) {
    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      return "";
    }
    buffer = buffer.slice(available, buffer.length);
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 55296 && charCode <= 56319) {
      this.charLength += this.surrogateSize;
      charStr = "";
      continue;
    }
    this.charReceived = this.charLength = 0;
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }
  this.detectIncompleteChar(buffer);
  var end2 = buffer.length;
  if (this.charLength) {
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end2);
    end2 -= this.charReceived;
  }
  charStr += buffer.toString(this.encoding, 0, end2);
  var end2 = charStr.length - 1;
  var charCode = charStr.charCodeAt(end2);
  if (charCode >= 55296 && charCode <= 56319) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end2);
  }
  return charStr;
};
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  var i3 = buffer.length >= 3 ? 3 : buffer.length;
  for (; i3 > 0; i3--) {
    var c3 = buffer[buffer.length - i3];
    if (i3 == 1 && c3 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (i3 <= 2 && c3 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (i3 <= 3 && c3 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i3;
};
StringDecoder.prototype.end = function(buffer) {
  var res = "";
  if (buffer && buffer.length)
    res = this.write(buffer);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
Readable.ReadableState = ReadableState;
var debug = debuglog("stream");
inherits$1(Readable, EventEmitter);
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream2) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function") this._read = options.read;
  EventEmitter.call(this);
}
Readable.prototype.push = function(chunk, encoding) {
  var state2 = this._readableState;
  if (!state2.objectMode && typeof chunk === "string") {
    encoding = encoding || state2.defaultEncoding;
    if (encoding !== state2.encoding) {
      chunk = Buffer2.from(chunk, encoding);
      encoding = "";
    }
  }
  return readableAddChunk(this, state2, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk) {
  var state2 = this._readableState;
  return readableAddChunk(this, state2, chunk, "", true);
};
Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
function readableAddChunk(stream2, state2, chunk, encoding, addToFront) {
  var er = chunkInvalid(state2, chunk);
  if (er) {
    stream2.emit("error", er);
  } else if (chunk === null) {
    state2.reading = false;
    onEofChunk(stream2, state2);
  } else if (state2.objectMode || chunk && chunk.length > 0) {
    if (state2.ended && !addToFront) {
      var e3 = new Error("stream.push() after EOF");
      stream2.emit("error", e3);
    } else if (state2.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream2.emit("error", _e);
    } else {
      var skipAdd;
      if (state2.decoder && !addToFront && !encoding) {
        chunk = state2.decoder.write(chunk);
        skipAdd = !state2.objectMode && chunk.length === 0;
      }
      if (!addToFront) state2.reading = false;
      if (!skipAdd) {
        if (state2.flowing && state2.length === 0 && !state2.sync) {
          stream2.emit("data", chunk);
          stream2.read(0);
        } else {
          state2.length += state2.objectMode ? 1 : chunk.length;
          if (addToFront) state2.buffer.unshift(chunk);
          else state2.buffer.push(chunk);
          if (state2.needReadable) emitReadable(stream2);
        }
      }
      maybeReadMore(stream2, state2);
    }
  } else if (!addToFront) {
    state2.reading = false;
  }
  return needMoreData(state2);
}
function needMoreData(state2) {
  return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
}
Readable.prototype.setEncoding = function(enc) {
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};
var MAX_HWM = 8388608;
function computeNewHighWaterMark(n4) {
  if (n4 >= MAX_HWM) {
    n4 = MAX_HWM;
  } else {
    n4--;
    n4 |= n4 >>> 1;
    n4 |= n4 >>> 2;
    n4 |= n4 >>> 4;
    n4 |= n4 >>> 8;
    n4 |= n4 >>> 16;
    n4++;
  }
  return n4;
}
function howMuchToRead(n4, state2) {
  if (n4 <= 0 || state2.length === 0 && state2.ended) return 0;
  if (state2.objectMode) return 1;
  if (n4 !== n4) {
    if (state2.flowing && state2.length) return state2.buffer.head.data.length;
    else return state2.length;
  }
  if (n4 > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n4);
  if (n4 <= state2.length) return n4;
  if (!state2.ended) {
    state2.needReadable = true;
    return 0;
  }
  return state2.length;
}
Readable.prototype.read = function(n4) {
  debug("read", n4);
  n4 = parseInt(n4, 10);
  var state2 = this._readableState;
  var nOrig = n4;
  if (n4 !== 0) state2.emittedReadable = false;
  if (n4 === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
    debug("read: emitReadable", state2.length, state2.ended);
    if (state2.length === 0 && state2.ended) endReadable(this);
    else emitReadable(this);
    return null;
  }
  n4 = howMuchToRead(n4, state2);
  if (n4 === 0 && state2.ended) {
    if (state2.length === 0) endReadable(this);
    return null;
  }
  var doRead = state2.needReadable;
  debug("need readable", doRead);
  if (state2.length === 0 || state2.length - n4 < state2.highWaterMark) {
    doRead = true;
    debug("length less than watermark", doRead);
  }
  if (state2.ended || state2.reading) {
    doRead = false;
    debug("reading or ended", doRead);
  } else if (doRead) {
    debug("do read");
    state2.reading = true;
    state2.sync = true;
    if (state2.length === 0) state2.needReadable = true;
    this._read(state2.highWaterMark);
    state2.sync = false;
    if (!state2.reading) n4 = howMuchToRead(nOrig, state2);
  }
  var ret;
  if (n4 > 0) ret = fromList(n4, state2);
  else ret = null;
  if (ret === null) {
    state2.needReadable = true;
    n4 = 0;
  } else {
    state2.length -= n4;
  }
  if (state2.length === 0) {
    if (!state2.ended) state2.needReadable = true;
    if (nOrig !== n4 && state2.ended) endReadable(this);
  }
  if (ret !== null) this.emit("data", ret);
  return ret;
};
function chunkInvalid(state2, chunk) {
  var er = null;
  if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state2.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream2, state2) {
  if (state2.ended) return;
  if (state2.decoder) {
    var chunk = state2.decoder.end();
    if (chunk && chunk.length) {
      state2.buffer.push(chunk);
      state2.length += state2.objectMode ? 1 : chunk.length;
    }
  }
  state2.ended = true;
  emitReadable(stream2);
}
function emitReadable(stream2) {
  var state2 = stream2._readableState;
  state2.needReadable = false;
  if (!state2.emittedReadable) {
    debug("emitReadable", state2.flowing);
    state2.emittedReadable = true;
    if (state2.sync) nextTick(emitReadable_, stream2);
    else emitReadable_(stream2);
  }
}
function emitReadable_(stream2) {
  debug("emit readable");
  stream2.emit("readable");
  flow(stream2);
}
function maybeReadMore(stream2, state2) {
  if (!state2.readingMore) {
    state2.readingMore = true;
    nextTick(maybeReadMore_, stream2, state2);
  }
}
function maybeReadMore_(stream2, state2) {
  var len = state2.length;
  while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
    debug("maybeReadMore read 0");
    stream2.read(0);
    if (len === state2.length)
      break;
    else len = state2.length;
  }
  state2.readingMore = false;
}
Readable.prototype._read = function(n4) {
  this.emit("error", new Error("not implemented"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state2 = this._readableState;
  switch (state2.pipesCount) {
    case 0:
      state2.pipes = dest;
      break;
    case 1:
      state2.pipes = [state2.pipes, dest];
      break;
    default:
      state2.pipes.push(dest);
      break;
  }
  state2.pipesCount += 1;
  debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
  var doEnd = !pipeOpts || pipeOpts.end !== false;
  var endFn = doEnd ? onend3 : cleanup;
  if (state2.endEmitted) nextTick(endFn);
  else src.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable) {
    debug("onunpipe");
    if (readable === src) {
      cleanup();
    }
  }
  function onend3() {
    debug("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain(src);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend3);
    src.removeListener("end", cleanup);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  var increasedAwaitDrain = false;
  src.on("data", ondata);
  function ondata(chunk) {
    debug("ondata");
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
        debug("false write response, pause", src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }
  function onerror(er) {
    debug("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (listenerCount(dest, "error") === 0) dest.emit("error", er);
  }
  prependListener2(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug("unpipe");
    src.unpipe(dest);
  }
  dest.emit("pipe", src);
  if (!state2.flowing) {
    debug("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function() {
    var state2 = src._readableState;
    debug("pipeOnDrain", state2.awaitDrain);
    if (state2.awaitDrain) state2.awaitDrain--;
    if (state2.awaitDrain === 0 && src.listeners("data").length) {
      state2.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function(dest) {
  var state2 = this._readableState;
  if (state2.pipesCount === 0) return this;
  if (state2.pipesCount === 1) {
    if (dest && dest !== state2.pipes) return this;
    if (!dest) dest = state2.pipes;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    if (dest) dest.emit("unpipe", this);
    return this;
  }
  if (!dest) {
    var dests = state2.pipes;
    var len = state2.pipesCount;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit("unpipe", this);
    }
    return this;
  }
  var i3 = indexOf2(state2.pipes, dest);
  if (i3 === -1) return this;
  state2.pipes.splice(i3, 1);
  state2.pipesCount -= 1;
  if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
  dest.emit("unpipe", this);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  var res = EventEmitter.prototype.on.call(this, ev, fn);
  if (ev === "data") {
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === "readable") {
    var state2 = this._readableState;
    if (!state2.endEmitted && !state2.readableListening) {
      state2.readableListening = state2.needReadable = true;
      state2.emittedReadable = false;
      if (!state2.reading) {
        nextTick(nReadingNextTick, this);
      } else if (state2.length) {
        emitReadable(this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
Readable.prototype.resume = function() {
  var state2 = this._readableState;
  if (!state2.flowing) {
    debug("resume");
    state2.flowing = true;
    resume(this, state2);
  }
  return this;
};
function resume(stream2, state2) {
  if (!state2.resumeScheduled) {
    state2.resumeScheduled = true;
    nextTick(resume_, stream2, state2);
  }
}
function resume_(stream2, state2) {
  if (!state2.reading) {
    debug("resume read 0");
    stream2.read(0);
  }
  state2.resumeScheduled = false;
  state2.awaitDrain = 0;
  stream2.emit("resume");
  flow(stream2);
  if (state2.flowing && !state2.reading) stream2.read(0);
}
Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  return this;
};
function flow(stream2) {
  var state2 = stream2._readableState;
  debug("flow", state2.flowing);
  while (state2.flowing && stream2.read() !== null) {
  }
}
Readable.prototype.wrap = function(stream2) {
  var state2 = this._readableState;
  var paused = false;
  var self2 = this;
  stream2.on("end", function() {
    debug("wrapped end");
    if (state2.decoder && !state2.ended) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) self2.push(chunk);
    }
    self2.push(null);
  });
  stream2.on("data", function(chunk) {
    debug("wrapped data");
    if (state2.decoder) chunk = state2.decoder.write(chunk);
    if (state2.objectMode && (chunk === null || chunk === void 0)) return;
    else if (!state2.objectMode && (!chunk || !chunk.length)) return;
    var ret = self2.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i3 in stream2) {
    if (this[i3] === void 0 && typeof stream2[i3] === "function") {
      this[i3] = /* @__PURE__ */ function(method) {
        return function() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i3);
    }
  }
  var events2 = ["error", "close", "destroy", "pause", "resume"];
  forEach(events2, function(ev) {
    stream2.on(ev, self2.emit.bind(self2, ev));
  });
  self2._read = function(n4) {
    debug("wrapped _read", n4);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return self2;
};
Readable._fromList = fromList;
function fromList(n4, state2) {
  if (state2.length === 0) return null;
  var ret;
  if (state2.objectMode) ret = state2.buffer.shift();
  else if (!n4 || n4 >= state2.length) {
    if (state2.decoder) ret = state2.buffer.join("");
    else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
    else ret = state2.buffer.concat(state2.length);
    state2.buffer.clear();
  } else {
    ret = fromListPartial(n4, state2.buffer, state2.decoder);
  }
  return ret;
}
function fromListPartial(n4, list, hasStrings) {
  var ret;
  if (n4 < list.head.data.length) {
    ret = list.head.data.slice(0, n4);
    list.head.data = list.head.data.slice(n4);
  } else if (n4 === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n4, list) : copyFromBuffer(n4, list);
  }
  return ret;
}
function copyFromBufferString(n4, list) {
  var p2 = list.head;
  var c3 = 1;
  var ret = p2.data;
  n4 -= ret.length;
  while (p2 = p2.next) {
    var str = p2.data;
    var nb = n4 > str.length ? str.length : n4;
    if (nb === str.length) ret += str;
    else ret += str.slice(0, n4);
    n4 -= nb;
    if (n4 === 0) {
      if (nb === str.length) {
        ++c3;
        if (p2.next) list.head = p2.next;
        else list.head = list.tail = null;
      } else {
        list.head = p2;
        p2.data = str.slice(nb);
      }
      break;
    }
    ++c3;
  }
  list.length -= c3;
  return ret;
}
function copyFromBuffer(n4, list) {
  var ret = Buffer2.allocUnsafe(n4);
  var p2 = list.head;
  var c3 = 1;
  p2.data.copy(ret);
  n4 -= p2.data.length;
  while (p2 = p2.next) {
    var buf = p2.data;
    var nb = n4 > buf.length ? buf.length : n4;
    buf.copy(ret, ret.length - n4, 0, nb);
    n4 -= nb;
    if (n4 === 0) {
      if (nb === buf.length) {
        ++c3;
        if (p2.next) list.head = p2.next;
        else list.head = list.tail = null;
      } else {
        list.head = p2;
        p2.data = buf.slice(nb);
      }
      break;
    }
    ++c3;
  }
  list.length -= c3;
  return ret;
}
function endReadable(stream2) {
  var state2 = stream2._readableState;
  if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
  if (!state2.endEmitted) {
    state2.ended = true;
    nextTick(endReadableNT, state2, stream2);
  }
}
function endReadableNT(state2, stream2) {
  if (!state2.endEmitted && state2.length === 0) {
    state2.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
  }
}
function forEach(xs, f2) {
  for (var i3 = 0, l2 = xs.length; i3 < l2; i3++) {
    f2(xs[i3], i3);
  }
}
function indexOf2(xs, x) {
  for (var i3 = 0, l2 = xs.length; i3 < l2; i3++) {
    if (xs[i3] === x) return i3;
  }
  return -1;
}
Writable.WritableState = WritableState;
inherits$1(Writable, EventEmitter);
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream2) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream2, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function") this._write = options.write;
    if (typeof options.writev === "function") this._writev = options.writev;
  }
  EventEmitter.call(this);
}
Writable.prototype.pipe = function() {
  this.emit("error", new Error("Cannot pipe, not readable"));
};
function writeAfterEnd(stream2, cb) {
  var er = new Error("write after end");
  stream2.emit("error", er);
  nextTick(cb, er);
}
function validChunk(stream2, state2, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream2.emit("error", er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}
Writable.prototype.write = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  var ret = false;
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (Buffer2.isBuffer(chunk)) encoding = "buffer";
  else if (!encoding) encoding = state2.defaultEncoding;
  if (typeof cb !== "function") cb = nop;
  if (state2.ended) writeAfterEnd(this, cb);
  else if (validChunk(this, state2, chunk, cb)) {
    state2.pendingcb++;
    ret = writeOrBuffer(this, state2, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function() {
  var state2 = this._writableState;
  state2.corked++;
};
Writable.prototype.uncork = function() {
  var state2 = this._writableState;
  if (state2.corked) {
    state2.corked--;
    if (!state2.writing && !state2.corked && !state2.finished && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  if (typeof encoding === "string") encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
function decodeChunk(state2, chunk, encoding) {
  if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream2, state2, chunk, encoding, cb) {
  chunk = decodeChunk(state2, chunk, encoding);
  if (Buffer2.isBuffer(chunk)) encoding = "buffer";
  var len = state2.objectMode ? 1 : chunk.length;
  state2.length += len;
  var ret = state2.length < state2.highWaterMark;
  if (!ret) state2.needDrain = true;
  if (state2.writing || state2.corked) {
    var last2 = state2.lastBufferedRequest;
    state2.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last2) {
      last2.next = state2.lastBufferedRequest;
    } else {
      state2.bufferedRequest = state2.lastBufferedRequest;
    }
    state2.bufferedRequestCount += 1;
  } else {
    doWrite(stream2, state2, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
  state2.writelen = len;
  state2.writecb = cb;
  state2.writing = true;
  state2.sync = true;
  if (writev) stream2._writev(chunk, state2.onwrite);
  else stream2._write(chunk, encoding, state2.onwrite);
  state2.sync = false;
}
function onwriteError(stream2, state2, sync, er, cb) {
  --state2.pendingcb;
  if (sync) nextTick(cb, er);
  else cb(er);
  stream2._writableState.errorEmitted = true;
  stream2.emit("error", er);
}
function onwriteStateUpdate(state2) {
  state2.writing = false;
  state2.writecb = null;
  state2.length -= state2.writelen;
  state2.writelen = 0;
}
function onwrite(stream2, er) {
  var state2 = stream2._writableState;
  var sync = state2.sync;
  var cb = state2.writecb;
  onwriteStateUpdate(state2);
  if (er) onwriteError(stream2, state2, sync, er, cb);
  else {
    var finished = needFinish(state2);
    if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
      clearBuffer(stream2, state2);
    }
    if (sync) {
      nextTick(afterWrite, stream2, state2, finished, cb);
    } else {
      afterWrite(stream2, state2, finished, cb);
    }
  }
}
function afterWrite(stream2, state2, finished, cb) {
  if (!finished) onwriteDrain(stream2, state2);
  state2.pendingcb--;
  cb();
  finishMaybe(stream2, state2);
}
function onwriteDrain(stream2, state2) {
  if (state2.length === 0 && state2.needDrain) {
    state2.needDrain = false;
    stream2.emit("drain");
  }
}
function clearBuffer(stream2, state2) {
  state2.bufferProcessing = true;
  var entry = state2.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l2 = state2.bufferedRequestCount;
    var buffer = new Array(l2);
    var holder = state2.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
    state2.pendingcb++;
    state2.lastBufferedRequest = null;
    if (holder.next) {
      state2.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state2.corkedRequestsFree = new CorkedRequest(state2);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state2.objectMode ? 1 : chunk.length;
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state2.writing) {
        break;
      }
    }
    if (entry === null) state2.lastBufferedRequest = null;
  }
  state2.bufferedRequestCount = 0;
  state2.bufferedRequest = entry;
  state2.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error("not implemented"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
  if (state2.corked) {
    state2.corked = 1;
    this.uncork();
  }
  if (!state2.ending && !state2.finished) endWritable(this, state2, cb);
};
function needFinish(state2) {
  return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
}
function prefinish(stream2, state2) {
  if (!state2.prefinished) {
    state2.prefinished = true;
    stream2.emit("prefinish");
  }
}
function finishMaybe(stream2, state2) {
  var need = needFinish(state2);
  if (need) {
    if (state2.pendingcb === 0) {
      prefinish(stream2, state2);
      state2.finished = true;
      stream2.emit("finish");
    } else {
      prefinish(stream2, state2);
    }
  }
  return need;
}
function endWritable(stream2, state2, cb) {
  state2.ending = true;
  finishMaybe(stream2, state2);
  if (cb) {
    if (state2.finished) nextTick(cb);
    else stream2.once("finish", cb);
  }
  state2.ended = true;
  stream2.writable = false;
}
function CorkedRequest(state2) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err2) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    if (state2.corkedRequestsFree) {
      state2.corkedRequestsFree.next = _this;
    } else {
      state2.corkedRequestsFree = _this;
    }
  };
}
inherits$1(Duplex, Readable);
var keys = Object.keys(Writable.prototype);
for (v2 = 0; v2 < keys.length; v2++) {
  method = keys[v2];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
var method;
var v2;
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended) return;
  nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
inherits$1(Transform2, Duplex);
function TransformState(stream2) {
  this.afterTransform = function(er, data2) {
    return afterTransform(stream2, er, data2);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream2, er, data2) {
  var ts = stream2._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) return stream2.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 !== null && data2 !== void 0) stream2.push(data2);
  cb(er);
  var rs = stream2._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream2._read(rs.highWaterMark);
  }
}
function Transform2(options) {
  if (!(this instanceof Transform2)) return new Transform2(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream2 = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function") this._transform = options.transform;
    if (typeof options.flush === "function") this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function") this._flush(function(er) {
      done(stream2, er);
    });
    else done(stream2);
  });
}
Transform2.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform2.prototype._transform = function(chunk, encoding, cb) {
  throw new Error("Not implemented");
};
Transform2.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};
Transform2.prototype._read = function(n4) {
  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
function done(stream2, er) {
  if (er) return stream2.emit("error", er);
  var ws = stream2._writableState;
  var ts = stream2._transformState;
  if (ws.length) throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming) throw new Error("Calling transform done when still transforming");
  return stream2.push(null);
}
inherits$1(PassThrough, Transform2);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform2.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
inherits$1(Stream, EventEmitter);
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform2;
Stream.PassThrough = PassThrough;
Stream.Stream = Stream;
function Stream() {
  EventEmitter.call(this);
}
Stream.prototype.pipe = function(dest, options) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on("end", onend3);
    source.on("close", onclose);
  }
  var didOnEnd = false;
  function onend3() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === "function") dest.destroy();
  }
  function onerror(er) {
    cleanup();
    if (EventEmitter.listenerCount(this, "error") === 0) {
      throw er;
    }
  }
  source.on("error", onerror);
  dest.on("error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend3);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
var _polyfillNode_stream = Object.freeze({
  __proto__: null,
  Duplex,
  PassThrough,
  Readable,
  Stream,
  Transform: Transform2,
  Writable,
  default: Stream
});
var require$$1 = getAugmentedNamespace(_polyfillNode_stream);
var binding = {};
function compare3(a3, b2) {
  if (a3 === b2) {
    return 0;
  }
  var x = a3.length;
  var y2 = b2.length;
  for (var i3 = 0, len = Math.min(x, y2); i3 < len; ++i3) {
    if (a3[i3] !== b2[i3]) {
      x = a3[i3];
      y2 = b2[i3];
      break;
    }
  }
  if (x < y2) {
    return -1;
  }
  if (y2 < x) {
    return 1;
  }
  return 0;
}
var hasOwn = Object.prototype.hasOwnProperty;
var objectKeys = Object.keys || function(obj) {
  var keys2 = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys2.push(key);
  }
  return keys2;
};
var pSlice = Array.prototype.slice;
var _functionsHaveNames;
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== "undefined") {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = function() {
    return (function foo() {
    }).name === "foo";
  }();
}
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer$1(arrbuf)) {
    return false;
  }
  if (typeof global$1.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
function assert(value2, message) {
  if (!value2) fail(value2, true, message, "==", ok);
}
var regex = /\s*function\s+([^\(\s]*)\s*/;
function getName(func) {
  if (!isFunction(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = AssertionError;
function AssertionError(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err2 = new Error();
    if (err2.stack) {
      var out = err2.stack;
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
inherits$1(AssertionError, Error);
function truncate(s2, n4) {
  if (typeof s2 === "string") {
    return s2.length < n4 ? s2 : s2.slice(0, n4);
  } else {
    return s2;
  }
}
function inspect2(something) {
  if (functionsHaveNames() || !isFunction(something)) {
    return inspect$1(something);
  }
  var rawname = getName(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
function getMessage(self2) {
  return truncate(inspect2(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect2(self2.expected), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
assert.fail = fail;
function ok(value2, message) {
  if (!value2) fail(value2, true, message, "==", ok);
}
assert.ok = ok;
assert.equal = equal;
function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, "==", equal);
}
assert.notEqual = notEqual;
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, "!=", notEqual);
  }
}
assert.deepEqual = deepEqual;
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "deepEqual", deepEqual);
  }
}
assert.deepStrictEqual = deepStrictEqual;
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
  }
}
function _deepEqual(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer$1(actual) && isBuffer$1(expected)) {
    return compare3(actual, expected) === 0;
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare3(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer$1(actual) !== isBuffer$1(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv(a3, b2, strict, actualVisitedObjects) {
  if (a3 === null || a3 === void 0 || b2 === null || b2 === void 0)
    return false;
  if (isPrimitive(a3) || isPrimitive(b2))
    return a3 === b2;
  if (strict && Object.getPrototypeOf(a3) !== Object.getPrototypeOf(b2))
    return false;
  var aIsArgs = isArguments(a3);
  var bIsArgs = isArguments(b2);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a3 = pSlice.call(a3);
    b2 = pSlice.call(b2);
    return _deepEqual(a3, b2, strict);
  }
  var ka = objectKeys(a3);
  var kb = objectKeys(b2);
  var key, i3;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i3 = ka.length - 1; i3 >= 0; i3--) {
    if (ka[i3] !== kb[i3])
      return false;
  }
  for (i3 = ka.length - 1; i3 >= 0; i3--) {
    key = ka[i3];
    if (!_deepEqual(a3[key], b2[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
assert.notDeepEqual = notDeepEqual;
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "notDeepEqual", notDeepEqual);
  }
}
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
  }
}
assert.strictEqual = strictEqual;
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, "===", strictEqual);
  }
}
assert.notStrictEqual = notStrictEqual;
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, "!==", notStrictEqual);
  }
}
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e3) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e3) {
    error = e3;
  }
  return error;
}
function _throws(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
assert.throws = throws;
function throws(block, error, message) {
  _throws(true, block, error, message);
}
assert.doesNotThrow = doesNotThrow;
function doesNotThrow(block, error, message) {
  _throws(false, block, error, message);
}
assert.ifError = ifError;
function ifError(err2) {
  if (err2) throw err2;
}
var _polyfillNode_assert = Object.freeze({
  __proto__: null,
  AssertionError,
  assert: ok,
  deepEqual,
  deepStrictEqual,
  default: assert,
  doesNotThrow,
  equal,
  fail,
  ifError,
  notDeepEqual,
  notDeepStrictEqual,
  notEqual,
  notStrictEqual,
  ok,
  strictEqual,
  throws
});
var require$$4 = getAugmentedNamespace(_polyfillNode_assert);
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var deflate$1 = {};
var common = {};
(function(exports) {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p2 in source) {
        if (_has(source, p2)) {
          obj[p2] = source[p2];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i3 = 0; i3 < len; i3++) {
        dest[dest_offs + i3] = src[src_offs + i3];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      var i3, l2, len, pos, chunk, result;
      len = 0;
      for (i3 = 0, l2 = chunks.length; i3 < l2; i3++) {
        len += chunks[i3].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i3 = 0, l2 = chunks.length; i3 < l2; i3++) {
        chunk = chunks[i3];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i3 = 0; i3 < len; i3++) {
        dest[dest_offs + i3] = src[src_offs + i3];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on3) {
    if (on3) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
})(common);
var trees$1 = {};
var utils$3 = common;
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
function put_short(s2, w) {
  s2.pending_buf[s2.pending++] = w & 255;
  s2.pending_buf[s2.pending++] = w >>> 8 & 255;
}
function send_bits(s2, value2, length2) {
  if (s2.bi_valid > Buf_size - length2) {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    put_short(s2, s2.bi_buf);
    s2.bi_buf = value2 >> Buf_size - s2.bi_valid;
    s2.bi_valid += length2 - Buf_size;
  } else {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    s2.bi_valid += length2;
  }
}
function send_code(s2, c3, tree) {
  send_bits(
    s2,
    tree[c3 * 2],
    tree[c3 * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}
function bi_flush(s2) {
  if (s2.bi_valid === 16) {
    put_short(s2, s2.bi_buf);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  } else if (s2.bi_valid >= 8) {
    s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
    s2.bi_buf >>= 8;
    s2.bi_valid -= 8;
  }
}
function gen_bitlen(s2, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h2;
  var n4, m;
  var bits;
  var xbits;
  var f2;
  var overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s2.bl_count[bits] = 0;
  }
  tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
  for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE$1; h2++) {
    n4 = s2.heap[h2];
    bits = tree[tree[n4 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n4 * 2 + 1] = bits;
    if (n4 > max_code) {
      continue;
    }
    s2.bl_count[bits]++;
    xbits = 0;
    if (n4 >= base) {
      xbits = extra[n4 - base];
    }
    f2 = tree[n4 * 2];
    s2.opt_len += f2 * (bits + xbits);
    if (has_stree) {
      s2.static_len += f2 * (stree[n4 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s2.bl_count[bits] === 0) {
      bits--;
    }
    s2.bl_count[bits]--;
    s2.bl_count[bits + 1] += 2;
    s2.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n4 = s2.bl_count[bits];
    while (n4 !== 0) {
      m = s2.heap[--h2];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s2.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n4--;
    }
  }
}
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS$1 + 1);
  var code = 0;
  var bits;
  var n4;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  for (n4 = 0; n4 <= max_code; n4++) {
    var len = tree[n4 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n4 * 2] = bi_reverse(next_code[len]++, len);
  }
}
function tr_static_init() {
  var n4;
  var bits;
  var length2;
  var code;
  var dist;
  var bl_count = new Array(MAX_BITS$1 + 1);
  length2 = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length2;
    for (n4 = 0; n4 < 1 << extra_lbits[code]; n4++) {
      _length_code[length2++] = code;
    }
  }
  _length_code[length2 - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n4 = 0; n4 < 1 << extra_dbits[code]; n4++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n4 = 0; n4 < 1 << extra_dbits[code] - 7; n4++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n4 = 0;
  while (n4 <= 143) {
    static_ltree[n4 * 2 + 1] = 8;
    n4++;
    bl_count[8]++;
  }
  while (n4 <= 255) {
    static_ltree[n4 * 2 + 1] = 9;
    n4++;
    bl_count[9]++;
  }
  while (n4 <= 279) {
    static_ltree[n4 * 2 + 1] = 7;
    n4++;
    bl_count[7]++;
  }
  while (n4 <= 287) {
    static_ltree[n4 * 2 + 1] = 8;
    n4++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n4 = 0; n4 < D_CODES$1; n4++) {
    static_dtree[n4 * 2 + 1] = 5;
    static_dtree[n4 * 2] = bi_reverse(n4, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
}
function init_block(s2) {
  var n4;
  for (n4 = 0; n4 < L_CODES$1; n4++) {
    s2.dyn_ltree[n4 * 2] = 0;
  }
  for (n4 = 0; n4 < D_CODES$1; n4++) {
    s2.dyn_dtree[n4 * 2] = 0;
  }
  for (n4 = 0; n4 < BL_CODES$1; n4++) {
    s2.bl_tree[n4 * 2] = 0;
  }
  s2.dyn_ltree[END_BLOCK * 2] = 1;
  s2.opt_len = s2.static_len = 0;
  s2.last_lit = s2.matches = 0;
}
function bi_windup(s2) {
  if (s2.bi_valid > 8) {
    put_short(s2, s2.bi_buf);
  } else if (s2.bi_valid > 0) {
    s2.pending_buf[s2.pending++] = s2.bi_buf;
  }
  s2.bi_buf = 0;
  s2.bi_valid = 0;
}
function copy_block(s2, buf, len, header) {
  bi_windup(s2);
  if (header) {
    put_short(s2, len);
    put_short(s2, ~len);
  }
  utils$3.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
  s2.pending += len;
}
function smaller(tree, n4, m, depth) {
  var _n2 = n4 * 2;
  var _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n4] <= depth[m];
}
function pqdownheap(s2, tree, k2) {
  var v2 = s2.heap[k2];
  var j = k2 << 1;
  while (j <= s2.heap_len) {
    if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
      j++;
    }
    if (smaller(tree, v2, s2.heap[j], s2.depth)) {
      break;
    }
    s2.heap[k2] = s2.heap[j];
    k2 = j;
    j <<= 1;
  }
  s2.heap[k2] = v2;
}
function compress_block(s2, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code;
  var extra;
  if (s2.last_lit !== 0) {
    do {
      dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
      lc = s2.pending_buf[s2.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s2, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s2, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s2, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s2, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s2, dist, extra);
        }
      }
    } while (lx < s2.last_lit);
  }
  send_code(s2, END_BLOCK, ltree);
}
function build_tree(s2, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n4, m;
  var max_code = -1;
  var node;
  s2.heap_len = 0;
  s2.heap_max = HEAP_SIZE$1;
  for (n4 = 0; n4 < elems; n4++) {
    if (tree[n4 * 2] !== 0) {
      s2.heap[++s2.heap_len] = max_code = n4;
      s2.depth[n4] = 0;
    } else {
      tree[n4 * 2 + 1] = 0;
    }
  }
  while (s2.heap_len < 2) {
    node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s2.depth[node] = 0;
    s2.opt_len--;
    if (has_stree) {
      s2.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n4 = s2.heap_len >> 1; n4 >= 1; n4--) {
    pqdownheap(s2, tree, n4);
  }
  node = elems;
  do {
    n4 = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[
      1
      /*SMALLEST*/
    ] = s2.heap[s2.heap_len--];
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
    m = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[--s2.heap_max] = n4;
    s2.heap[--s2.heap_max] = m;
    tree[node * 2] = tree[n4 * 2] + tree[m * 2];
    s2.depth[node] = (s2.depth[n4] >= s2.depth[m] ? s2.depth[n4] : s2.depth[m]) + 1;
    tree[n4 * 2 + 1] = tree[m * 2 + 1] = node;
    s2.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s2.heap_len >= 2);
  s2.heap[--s2.heap_max] = s2.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s2, desc);
  gen_codes(tree, max_code, s2.bl_count);
}
function scan_tree(s2, tree, max_code) {
  var n4;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n4 = 0; n4 <= max_code; n4++) {
    curlen = nextlen;
    nextlen = tree[(n4 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s2.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s2.bl_tree[curlen * 2]++;
      }
      s2.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s2.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s2.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree(s2, tree, max_code) {
  var n4;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n4 = 0; n4 <= max_code; n4++) {
    curlen = nextlen;
    nextlen = tree[(n4 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s2, curlen, s2.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s2, curlen, s2.bl_tree);
        count--;
      }
      send_code(s2, REP_3_6, s2.bl_tree);
      send_bits(s2, count - 3, 2);
    } else if (count <= 10) {
      send_code(s2, REPZ_3_10, s2.bl_tree);
      send_bits(s2, count - 3, 3);
    } else {
      send_code(s2, REPZ_11_138, s2.bl_tree);
      send_bits(s2, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree(s2) {
  var max_blindex;
  scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
  scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
  build_tree(s2, s2.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees(s2, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits(s2, lcodes - 257, 5);
  send_bits(s2, dcodes - 1, 5);
  send_bits(s2, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s2, s2.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s2, s2.dyn_ltree, lcodes - 1);
  send_tree(s2, s2.dyn_dtree, dcodes - 1);
}
function detect_data_type(s2) {
  var black_mask = 4093624447;
  var n4;
  for (n4 = 0; n4 <= 31; n4++, black_mask >>>= 1) {
    if (black_mask & 1 && s2.dyn_ltree[n4 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n4 = 32; n4 < LITERALS$1; n4++) {
    if (s2.dyn_ltree[n4 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}
var static_init_done = false;
function _tr_init(s2) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
  s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
  s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
  s2.bi_buf = 0;
  s2.bi_valid = 0;
  init_block(s2);
}
function _tr_stored_block(s2, buf, stored_len, last2) {
  send_bits(s2, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
  copy_block(s2, buf, stored_len, true);
}
function _tr_align(s2) {
  send_bits(s2, STATIC_TREES << 1, 3);
  send_code(s2, END_BLOCK, static_ltree);
  bi_flush(s2);
}
function _tr_flush_block(s2, buf, stored_len, last2) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s2.level > 0) {
    if (s2.strm.data_type === Z_UNKNOWN$1) {
      s2.strm.data_type = detect_data_type(s2);
    }
    build_tree(s2, s2.l_desc);
    build_tree(s2, s2.d_desc);
    max_blindex = build_bl_tree(s2);
    opt_lenb = s2.opt_len + 3 + 7 >>> 3;
    static_lenb = s2.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s2, buf, stored_len, last2);
  } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s2, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
    compress_block(s2, static_ltree, static_dtree);
  } else {
    send_bits(s2, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
    send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
  }
  init_block(s2);
  if (last2) {
    bi_windup(s2);
  }
}
function _tr_tally(s2, dist, lc) {
  s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
  s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
  s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
  s2.last_lit++;
  if (dist === 0) {
    s2.dyn_ltree[lc * 2]++;
  } else {
    s2.matches++;
    dist--;
    s2.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s2.dyn_dtree[d_code(dist) * 2]++;
  }
  return s2.last_lit === s2.lit_bufsize - 1;
}
trees$1._tr_init = _tr_init;
trees$1._tr_stored_block = _tr_stored_block;
trees$1._tr_flush_block = _tr_flush_block;
trees$1._tr_tally = _tr_tally;
trees$1._tr_align = _tr_align;
function adler32$2(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n4 = 0;
  while (len !== 0) {
    n4 = len > 2e3 ? 2e3 : len;
    len -= n4;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n4);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
var adler32_1 = adler32$2;
function makeTable() {
  var c3, table = [];
  for (var n4 = 0; n4 < 256; n4++) {
    c3 = n4;
    for (var k2 = 0; k2 < 8; k2++) {
      c3 = c3 & 1 ? 3988292384 ^ c3 >>> 1 : c3 >>> 1;
    }
    table[n4] = c3;
  }
  return table;
}
var crcTable = makeTable();
function crc32$2(crc, buf, len, pos) {
  var t3 = crcTable, end2 = pos + len;
  crc ^= -1;
  for (var i3 = pos; i3 < end2; i3++) {
    crc = crc >>> 8 ^ t3[(crc ^ buf[i3]) & 255];
  }
  return crc ^ -1;
}
var crc32_1 = crc32$2;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var utils$2 = common;
var trees = trees$1;
var adler32$1 = adler32_1;
var crc32$1 = crc32_1;
var msg = messages;
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_FULL_FLUSH = 3;
var Z_FINISH$1 = 4;
var Z_BLOCK$1 = 5;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_STREAM_ERROR$1 = -2;
var Z_DATA_ERROR$1 = -3;
var Z_BUF_ERROR$1 = -5;
var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
var Z_UNKNOWN = 2;
var Z_DEFLATED$1 = 8;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}
function rank(f2) {
  return (f2 << 1) - (f2 > 4 ? 9 : 0);
}
function zero(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function flush_pending(strm) {
  var s2 = strm.state;
  var len = s2.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  utils$2.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
  strm.next_out += len;
  s2.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s2.pending -= len;
  if (s2.pending === 0) {
    s2.pending_out = 0;
  }
}
function flush_block_only(s2, last2) {
  trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last2);
  s2.block_start = s2.strstart;
  flush_pending(s2.strm);
}
function put_byte(s2, b2) {
  s2.pending_buf[s2.pending++] = b2;
}
function putShortMSB(s2, b2) {
  s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
  s2.pending_buf[s2.pending++] = b2 & 255;
}
function read_buf(strm, buf, start2, size) {
  var len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  utils$2.arraySet(buf, strm.input, strm.next_in, len, start2);
  if (strm.state.wrap === 1) {
    strm.adler = adler32$1(strm.adler, buf, len, start2);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32$1(strm.adler, buf, len, start2);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
}
function longest_match(s2, cur_match) {
  var chain_length = s2.max_chain_length;
  var scan = s2.strstart;
  var match;
  var len;
  var best_len = s2.prev_length;
  var nice_match = s2.nice_match;
  var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
  var _win = s2.window;
  var wmask = s2.w_mask;
  var prev = s2.prev;
  var strend = s2.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s2.prev_length >= s2.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s2.lookahead) {
    nice_match = s2.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s2.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s2.lookahead) {
    return best_len;
  }
  return s2.lookahead;
}
function fill_window(s2) {
  var _w_size = s2.w_size;
  var p2, n4, m, more, str;
  do {
    more = s2.window_size - s2.lookahead - s2.strstart;
    if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils$2.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
      s2.match_start -= _w_size;
      s2.strstart -= _w_size;
      s2.block_start -= _w_size;
      n4 = s2.hash_size;
      p2 = n4;
      do {
        m = s2.head[--p2];
        s2.head[p2] = m >= _w_size ? m - _w_size : 0;
      } while (--n4);
      n4 = _w_size;
      p2 = n4;
      do {
        m = s2.prev[--p2];
        s2.prev[p2] = m >= _w_size ? m - _w_size : 0;
      } while (--n4);
      more += _w_size;
    }
    if (s2.strm.avail_in === 0) {
      break;
    }
    n4 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
    s2.lookahead += n4;
    if (s2.lookahead + s2.insert >= MIN_MATCH) {
      str = s2.strstart - s2.insert;
      s2.ins_h = s2.window[str];
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
      while (s2.insert) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
        s2.insert--;
        if (s2.lookahead + s2.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
}
function deflate_stored(s2, flush) {
  var max_block_size = 65535;
  if (max_block_size > s2.pending_buf_size - 5) {
    max_block_size = s2.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s2.lookahead <= 1) {
      fill_window(s2);
      if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.strstart += s2.lookahead;
    s2.lookahead = 0;
    var max_start = s2.block_start + max_block_size;
    if (s2.strstart === 0 || s2.strstart >= max_start) {
      s2.lookahead = s2.strstart - max_start;
      s2.strstart = max_start;
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.strstart > s2.block_start) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
}
function deflate_fast(s2, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
        s2.match_length--;
        do {
          s2.strstart++;
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        } while (--s2.match_length !== 0);
        s2.strstart++;
      } else {
        s2.strstart += s2.match_length;
        s2.match_length = 0;
        s2.ins_h = s2.window[s2.strstart];
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
      }
    } else {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_slow(s2, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    s2.prev_length = s2.match_length;
    s2.prev_match = s2.match_start;
    s2.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
      if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
        s2.match_length = MIN_MATCH - 1;
      }
    }
    if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
      max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
      bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
      s2.lookahead -= s2.prev_length - 1;
      s2.prev_length -= 2;
      do {
        if (++s2.strstart <= max_insert) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
      } while (--s2.prev_length !== 0);
      s2.match_available = 0;
      s2.match_length = MIN_MATCH - 1;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s2.match_available) {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      if (bflush) {
        flush_block_only(s2, false);
      }
      s2.strstart++;
      s2.lookahead--;
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s2.match_available = 1;
      s2.strstart++;
      s2.lookahead--;
    }
  }
  if (s2.match_available) {
    bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
    s2.match_available = 0;
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_rle(s2, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s2.window;
  for (; ; ) {
    if (s2.lookahead <= MAX_MATCH) {
      fill_window(s2);
      if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.match_length = 0;
    if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
      scan = s2.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s2.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s2.match_length = MAX_MATCH - (strend - scan);
        if (s2.match_length > s2.lookahead) {
          s2.match_length = s2.lookahead;
        }
      }
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      s2.strstart += s2.match_length;
      s2.match_length = 0;
    } else {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_huff(s2, flush) {
  var bflush;
  for (; ; ) {
    if (s2.lookahead === 0) {
      fill_window(s2);
      if (s2.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s2.match_length = 0;
    bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
    s2.lookahead--;
    s2.strstart++;
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table;
configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
function lm_init(s2) {
  s2.window_size = 2 * s2.w_size;
  zero(s2.head);
  s2.max_lazy_match = configuration_table[s2.level].max_lazy;
  s2.good_match = configuration_table[s2.level].good_length;
  s2.nice_match = configuration_table[s2.level].nice_length;
  s2.max_chain_length = configuration_table[s2.level].max_chain;
  s2.strstart = 0;
  s2.block_start = 0;
  s2.lookahead = 0;
  s2.insert = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  s2.ins_h = 0;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$1;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new utils$2.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils$2.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils$2.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new utils$2.Buf16(MAX_BITS + 1);
  this.heap = new utils$2.Buf16(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new utils$2.Buf16(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep(strm) {
  var s2;
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s2 = strm.state;
  s2.pending = 0;
  s2.pending_out = 0;
  if (s2.wrap < 0) {
    s2.wrap = -s2.wrap;
  }
  s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s2.wrap === 2 ? 0 : 1;
  s2.last_flush = Z_NO_FLUSH;
  trees._tr_init(s2);
  return Z_OK$1;
}
function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK$1) {
    lm_init(strm.state);
  }
  return ret;
}
function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$1;
  }
  strm.state.gzhead = head;
  return Z_OK$1;
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  var wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$1 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s2 = new DeflateState();
  strm.state = s2;
  s2.strm = strm;
  s2.wrap = wrap;
  s2.gzhead = null;
  s2.w_bits = windowBits;
  s2.w_size = 1 << s2.w_bits;
  s2.w_mask = s2.w_size - 1;
  s2.hash_bits = memLevel + 7;
  s2.hash_size = 1 << s2.hash_bits;
  s2.hash_mask = s2.hash_size - 1;
  s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s2.window = new utils$2.Buf8(s2.w_size * 2);
  s2.head = new utils$2.Buf16(s2.hash_size);
  s2.prev = new utils$2.Buf16(s2.w_size);
  s2.lit_bufsize = 1 << memLevel + 6;
  s2.pending_buf_size = s2.lit_bufsize * 4;
  s2.pending_buf = new utils$2.Buf8(s2.pending_buf_size);
  s2.d_buf = 1 * s2.lit_bufsize;
  s2.l_buf = (1 + 2) * s2.lit_bufsize;
  s2.level = level;
  s2.strategy = strategy;
  s2.method = method;
  return deflateReset(strm);
}
function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED$1, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}
function deflate(strm, flush) {
  var old_flush, s2;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$1) : Z_STREAM_ERROR$1;
  }
  s2 = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH$1) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$1);
  }
  s2.strm = strm;
  old_flush = s2.last_flush;
  s2.last_flush = flush;
  if (s2.status === INIT_STATE) {
    if (s2.wrap === 2) {
      strm.adler = 0;
      put_byte(s2, 31);
      put_byte(s2, 139);
      put_byte(s2, 8);
      if (!s2.gzhead) {
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, OS_CODE);
        s2.status = BUSY_STATE;
      } else {
        put_byte(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
        put_byte(s2, s2.gzhead.time & 255);
        put_byte(s2, s2.gzhead.time >> 8 & 255);
        put_byte(s2, s2.gzhead.time >> 16 & 255);
        put_byte(s2, s2.gzhead.time >> 24 & 255);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, s2.gzhead.os & 255);
        if (s2.gzhead.extra && s2.gzhead.extra.length) {
          put_byte(s2, s2.gzhead.extra.length & 255);
          put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
        }
        if (s2.gzhead.hcrc) {
          strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending, 0);
        }
        s2.gzindex = 0;
        s2.status = EXTRA_STATE;
      }
    } else {
      var header = Z_DEFLATED$1 + (s2.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
        level_flags = 0;
      } else if (s2.level < 6) {
        level_flags = 1;
      } else if (s2.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s2.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s2.status = BUSY_STATE;
      putShortMSB(s2, header);
      if (s2.strstart !== 0) {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s2.status === EXTRA_STATE) {
    if (s2.gzhead.extra) {
      beg = s2.pending;
      while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            break;
          }
        }
        put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
        s2.gzindex++;
      }
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (s2.gzindex === s2.gzhead.extra.length) {
        s2.gzindex = 0;
        s2.status = NAME_STATE;
      }
    } else {
      s2.status = NAME_STATE;
    }
  }
  if (s2.status === NAME_STATE) {
    if (s2.gzhead.name) {
      beg = s2.pending;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s2.gzindex < s2.gzhead.name.length) {
          val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (val === 0) {
        s2.gzindex = 0;
        s2.status = COMMENT_STATE;
      }
    } else {
      s2.status = COMMENT_STATE;
    }
  }
  if (s2.status === COMMENT_STATE) {
    if (s2.gzhead.comment) {
      beg = s2.pending;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s2.gzindex < s2.gzhead.comment.length) {
          val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (val === 0) {
        s2.status = HCRC_STATE;
      }
    } else {
      s2.status = HCRC_STATE;
    }
  }
  if (s2.status === HCRC_STATE) {
    if (s2.gzhead.hcrc) {
      if (s2.pending + 2 > s2.pending_buf_size) {
        flush_pending(strm);
      }
      if (s2.pending + 2 <= s2.pending_buf_size) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        strm.adler = 0;
        s2.status = BUSY_STATE;
      }
    } else {
      s2.status = BUSY_STATE;
    }
  }
  if (s2.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s2.last_flush = -1;
      return Z_OK$1;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$1) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
    var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s2.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
      }
      return Z_OK$1;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s2);
      } else if (flush !== Z_BLOCK$1) {
        trees._tr_stored_block(s2, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero(s2.head);
          if (s2.lookahead === 0) {
            s2.strstart = 0;
            s2.block_start = 0;
            s2.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK$1;
      }
    }
  }
  if (flush !== Z_FINISH$1) {
    return Z_OK$1;
  }
  if (s2.wrap <= 0) {
    return Z_STREAM_END$1;
  }
  if (s2.wrap === 2) {
    put_byte(s2, strm.adler & 255);
    put_byte(s2, strm.adler >> 8 & 255);
    put_byte(s2, strm.adler >> 16 & 255);
    put_byte(s2, strm.adler >> 24 & 255);
    put_byte(s2, strm.total_in & 255);
    put_byte(s2, strm.total_in >> 8 & 255);
    put_byte(s2, strm.total_in >> 16 & 255);
    put_byte(s2, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s2, strm.adler >>> 16);
    putShortMSB(s2, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s2.wrap > 0) {
    s2.wrap = -s2.wrap;
  }
  return s2.pending !== 0 ? Z_OK$1 : Z_STREAM_END$1;
}
function deflateEnd(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$1) : Z_OK$1;
}
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s2;
  var str, n4;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  s2 = strm.state;
  wrap = s2.wrap;
  if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
    return Z_STREAM_ERROR$1;
  }
  if (wrap === 1) {
    strm.adler = adler32$1(strm.adler, dictionary, dictLength, 0);
  }
  s2.wrap = 0;
  if (dictLength >= s2.w_size) {
    if (wrap === 0) {
      zero(s2.head);
      s2.strstart = 0;
      s2.block_start = 0;
      s2.insert = 0;
    }
    tmpDict = new utils$2.Buf8(s2.w_size);
    utils$2.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
    dictionary = tmpDict;
    dictLength = s2.w_size;
  }
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s2);
  while (s2.lookahead >= MIN_MATCH) {
    str = s2.strstart;
    n4 = s2.lookahead - (MIN_MATCH - 1);
    do {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
      s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = str;
      str++;
    } while (--n4);
    s2.strstart = str;
    s2.lookahead = MIN_MATCH - 1;
    fill_window(s2);
  }
  s2.strstart += s2.lookahead;
  s2.block_start = s2.strstart;
  s2.insert = s2.lookahead;
  s2.lookahead = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s2.wrap = wrap;
  return Z_OK$1;
}
deflate$1.deflateInit = deflateInit;
deflate$1.deflateInit2 = deflateInit2;
deflate$1.deflateReset = deflateReset;
deflate$1.deflateResetKeep = deflateResetKeep;
deflate$1.deflateSetHeader = deflateSetHeader;
deflate$1.deflate = deflate;
deflate$1.deflateEnd = deflateEnd;
deflate$1.deflateSetDictionary = deflateSetDictionary;
deflate$1.deflateInfo = "pako deflate (from Nodeca project)";
var inflate$1 = {};
var BAD$1 = 30;
var TYPE$1 = 12;
var inffast = function inflate_fast(strm, start2) {
  var state2;
  var _in;
  var last2;
  var _out;
  var beg;
  var end2;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len;
  var dist;
  var from4;
  var from_source;
  var input, output;
  state2 = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start2 - strm.avail_out);
  end2 = _out + (strm.avail_out - 257);
  dmax = state2.dmax;
  wsize = state2.wsize;
  whave = state2.whave;
  wnext = state2.wnext;
  s_window = state2.window;
  hold = state2.hold;
  bits = state2.bits;
  lcode = state2.lencode;
  dcode = state2.distcode;
  lmask = (1 << state2.lenbits) - 1;
  dmask = (1 << state2.distbits) - 1;
  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }
    here = lcode[hold & lmask];
    dolen: for (; ; ) {
      op = here >>> 24;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 255;
      if (op === 0) {
        output[_out++] = here & 65535;
      } else if (op & 16) {
        len = here & 65535;
        op &= 15;
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        }
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];
        dodist: for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op & 16) {
            dist = here & 65535;
            op &= 15;
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & (1 << op) - 1;
            if (dist > dmax) {
              strm.msg = "invalid distance too far back";
              state2.mode = BAD$1;
              break top;
            }
            hold >>>= op;
            bits -= op;
            op = _out - beg;
            if (dist > op) {
              op = dist - op;
              if (op > whave) {
                if (state2.sane) {
                  strm.msg = "invalid distance too far back";
                  state2.mode = BAD$1;
                  break top;
                }
              }
              from4 = 0;
              from_source = s_window;
              if (wnext === 0) {
                from4 += wsize - op;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from4++];
                  } while (--op);
                  from4 = _out - dist;
                  from_source = output;
                }
              } else if (wnext < op) {
                from4 += wsize + wnext - op;
                op -= wnext;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from4++];
                  } while (--op);
                  from4 = 0;
                  if (wnext < len) {
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from4++];
                    } while (--op);
                    from4 = _out - dist;
                    from_source = output;
                  }
                }
              } else {
                from4 += wnext - op;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from4++];
                  } while (--op);
                  from4 = _out - dist;
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from4++];
                output[_out++] = from_source[from4++];
                output[_out++] = from_source[from4++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from4++];
                if (len > 1) {
                  output[_out++] = from_source[from4++];
                }
              }
            } else {
              from4 = _out - dist;
              do {
                output[_out++] = output[from4++];
                output[_out++] = output[from4++];
                output[_out++] = output[from4++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from4++];
                if (len > 1) {
                  output[_out++] = output[from4++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = "invalid distance code";
            state2.mode = BAD$1;
            break top;
          }
          break;
        }
      } else if ((op & 64) === 0) {
        here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        state2.mode = TYPE$1;
        break top;
      } else {
        strm.msg = "invalid literal/length code";
        state2.mode = BAD$1;
        break top;
      }
      break;
    }
  } while (_in < last2 && _out < end2);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
  state2.hold = hold;
  state2.bits = bits;
  return;
};
var utils$1 = common;
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
var inftrees = function inflate_table(type, lens, lens_index, codes2, table, table_index, work, opts2) {
  var bits = opts2.bits;
  var len = 0;
  var sym = 0;
  var min2 = 0, max2 = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill4;
  var low;
  var mask;
  var next;
  var base = null;
  var base_index = 0;
  var end2;
  var count = new utils$1.Buf16(MAXBITS + 1);
  var offs = new utils$1.Buf16(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes2; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max2 = MAXBITS; max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts2.bits = 1;
    return 0;
  }
  for (min2 = 1; min2 < max2; min2++) {
    if (count[min2] !== 0) {
      break;
    }
  }
  if (root < min2) {
    root = min2;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max2 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes2; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    end2 = 19;
  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end2 = 256;
  } else {
    base = dbase;
    extra = dext;
    end2 = -1;
  }
  huff = 0;
  sym = 0;
  len = min2;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end2) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end2) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill4 = 1 << curr;
    min2 = fill4;
    do {
      fill4 -= incr;
      table[next + (huff >> drop) + fill4] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill4 !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max2) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min2;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts2.bits = root;
  return 0;
};
var utils = common;
var adler32 = adler32_1;
var crc32 = crc32_1;
var inflate_fast2 = inffast;
var inflate_table2 = inftrees;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
var Z_DEFLATED = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
function zswap32(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new utils.Buf16(320);
  this.work = new utils.Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  strm.total_in = strm.total_out = state2.total = 0;
  strm.msg = "";
  if (state2.wrap) {
    strm.adler = state2.wrap & 1;
  }
  state2.mode = HEAD;
  state2.last = 0;
  state2.havedict = 0;
  state2.dmax = 32768;
  state2.head = null;
  state2.hold = 0;
  state2.bits = 0;
  state2.lencode = state2.lendyn = new utils.Buf32(ENOUGH_LENS);
  state2.distcode = state2.distdyn = new utils.Buf32(ENOUGH_DISTS);
  state2.sane = 1;
  state2.back = -1;
  return Z_OK;
}
function inflateReset(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  state2.wsize = 0;
  state2.whave = 0;
  state2.wnext = 0;
  return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
  var wrap;
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state2.window !== null && state2.wbits !== windowBits) {
    state2.window = null;
  }
  state2.wrap = wrap;
  state2.wbits = windowBits;
  return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
  var ret;
  var state2;
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  state2 = new InflateState();
  strm.state = state2;
  state2.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null;
  }
  return ret;
}
function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
var virgin = true;
var lenfix;
var distfix;
function fixedtables(state2) {
  if (virgin) {
    var sym;
    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);
    sym = 0;
    while (sym < 144) {
      state2.lens[sym++] = 8;
    }
    while (sym < 256) {
      state2.lens[sym++] = 9;
    }
    while (sym < 280) {
      state2.lens[sym++] = 7;
    }
    while (sym < 288) {
      state2.lens[sym++] = 8;
    }
    inflate_table2(LENS, state2.lens, 0, 288, lenfix, 0, state2.work, {
      bits: 9
    });
    sym = 0;
    while (sym < 32) {
      state2.lens[sym++] = 5;
    }
    inflate_table2(DISTS, state2.lens, 0, 32, distfix, 0, state2.work, {
      bits: 5
    });
    virgin = false;
  }
  state2.lencode = lenfix;
  state2.lenbits = 9;
  state2.distcode = distfix;
  state2.distbits = 5;
}
function updatewindow(strm, src, end2, copy5) {
  var dist;
  var state2 = strm.state;
  if (state2.window === null) {
    state2.wsize = 1 << state2.wbits;
    state2.wnext = 0;
    state2.whave = 0;
    state2.window = new utils.Buf8(state2.wsize);
  }
  if (copy5 >= state2.wsize) {
    utils.arraySet(state2.window, src, end2 - state2.wsize, state2.wsize, 0);
    state2.wnext = 0;
    state2.whave = state2.wsize;
  } else {
    dist = state2.wsize - state2.wnext;
    if (dist > copy5) {
      dist = copy5;
    }
    utils.arraySet(state2.window, src, end2 - copy5, dist, state2.wnext);
    copy5 -= dist;
    if (copy5) {
      utils.arraySet(state2.window, src, end2 - copy5, copy5, 0);
      state2.wnext = copy5;
      state2.whave = state2.wsize;
    } else {
      state2.wnext += dist;
      if (state2.wnext === state2.wsize) {
        state2.wnext = 0;
      }
      if (state2.whave < state2.wsize) {
        state2.whave += dist;
      }
    }
  }
  return 0;
}
function inflate(strm, flush) {
  var state2;
  var input, output;
  var next;
  var put;
  var have, left;
  var hold;
  var bits;
  var _in, _out;
  var copy5;
  var from4;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len;
  var ret;
  var hbuf = new utils.Buf8(4);
  var opts2;
  var n4;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.mode === TYPE) {
    state2.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state2.hold;
  bits = state2.bits;
  _in = have;
  _out = left;
  ret = Z_OK;
  inf_leave:
    for (; ; ) {
      switch (state2.mode) {
        case HEAD:
          if (state2.wrap === 0) {
            state2.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.wrap & 2 && hold === 35615) {
            state2.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state2.mode = FLAGS;
            break;
          }
          state2.flags = 0;
          if (state2.head) {
            state2.head.done = false;
          }
          if (!(state2.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state2.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state2.wbits === 0) {
            state2.wbits = len;
          } else if (len > state2.wbits) {
            strm.msg = "invalid window size";
            state2.mode = BAD;
            break;
          }
          state2.dmax = 1 << len;
          strm.adler = state2.check = 1;
          state2.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.flags = hold;
          if ((state2.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          if (state2.flags & 57344) {
            strm.msg = "unknown header flags set";
            state2.mode = BAD;
            break;
          }
          if (state2.head) {
            state2.head.text = hold >> 8 & 1;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.time = hold;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state2.check = crc32(state2.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.xflags = hold & 255;
            state2.head.os = hold >> 8;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state2.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length = hold;
            if (state2.head) {
              state2.head.extra_len = hold;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state2.head) {
            state2.head.extra = null;
          }
          state2.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state2.flags & 1024) {
            copy5 = state2.length;
            if (copy5 > have) {
              copy5 = have;
            }
            if (copy5) {
              if (state2.head) {
                len = state2.head.extra_len - state2.length;
                if (!state2.head.extra) {
                  state2.head.extra = new Array(state2.head.extra_len);
                }
                utils.arraySet(
                  state2.head.extra,
                  input,
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy5,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state2.flags & 512) {
                state2.check = crc32(state2.check, input, copy5, next);
              }
              have -= copy5;
              next += copy5;
              state2.length -= copy5;
            }
            if (state2.length) {
              break inf_leave;
            }
          }
          state2.length = 0;
          state2.mode = NAME;
        /* falls through */
        case NAME:
          if (state2.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy5 = 0;
            do {
              len = input[next + copy5++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.name += String.fromCharCode(len);
              }
            } while (len && copy5 < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy5, next);
            }
            have -= copy5;
            next += copy5;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.name = null;
          }
          state2.length = 0;
          state2.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state2.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy5 = 0;
            do {
              len = input[next + copy5++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.comment += String.fromCharCode(len);
              }
            } while (len && copy5 < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy5, next);
            }
            have -= copy5;
            next += copy5;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.comment = null;
          }
          state2.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state2.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.check & 65535)) {
              strm.msg = "header crc mismatch";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state2.head) {
            state2.head.hcrc = state2.flags >> 9 & 1;
            state2.head.done = true;
          }
          strm.adler = state2.check = 0;
          state2.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state2.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state2.mode = DICT;
        /* falls through */
        case DICT:
          if (state2.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            return Z_NEED_DICT;
          }
          strm.adler = state2.check = 1;
          state2.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state2.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state2.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state2.mode = STORED;
              break;
            case 1:
              fixedtables(state2);
              state2.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state2.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state2.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state2.mode = BAD;
            break;
          }
          state2.length = hold & 65535;
          hold = 0;
          bits = 0;
          state2.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state2.mode = COPY;
        /* falls through */
        case COPY:
          copy5 = state2.length;
          if (copy5) {
            if (copy5 > have) {
              copy5 = have;
            }
            if (copy5 > left) {
              copy5 = left;
            }
            if (copy5 === 0) {
              break inf_leave;
            }
            utils.arraySet(output, input, next, copy5, put);
            have -= copy5;
            next += copy5;
            left -= copy5;
            put += copy5;
            state2.length -= copy5;
            break;
          }
          state2.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state2.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state2.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state2.nlen > 286 || state2.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state2.have < state2.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.lens[order[state2.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state2.have < 19) {
            state2.lens[order[state2.have++]] = 0;
          }
          state2.lencode = state2.lendyn;
          state2.lenbits = 7;
          opts2 = {
            bits: state2.lenbits
          };
          ret = inflate_table2(CODES, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts2);
          state2.lenbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state2.have < state2.nlen + state2.ndist) {
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state2.lens[state2.have++] = here_val;
            } else {
              if (here_val === 16) {
                n4 = here_bits + 2;
                while (bits < n4) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state2.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD;
                  break;
                }
                len = state2.lens[state2.have - 1];
                copy5 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n4 = here_bits + 3;
                while (bits < n4) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy5 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n4 = here_bits + 7;
                while (bits < n4) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy5 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state2.have + copy5 > state2.nlen + state2.ndist) {
                strm.msg = "invalid bit length repeat";
                state2.mode = BAD;
                break;
              }
              while (copy5--) {
                state2.lens[state2.have++] = len;
              }
            }
          }
          if (state2.mode === BAD) {
            break;
          }
          if (state2.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state2.mode = BAD;
            break;
          }
          state2.lenbits = 9;
          opts2 = {
            bits: state2.lenbits
          };
          ret = inflate_table2(LENS, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts2);
          state2.lenbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state2.mode = BAD;
            break;
          }
          state2.distbits = 6;
          state2.distcode = state2.distdyn;
          opts2 = {
            bits: state2.distbits
          };
          ret = inflate_table2(DISTS, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts2);
          state2.distbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state2.mode = BAD;
            break;
          }
          state2.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state2.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            inflate_fast2(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state2.hold;
            bits = state2.bits;
            if (state2.mode === TYPE) {
              state2.back = -1;
            }
            break;
          }
          state2.back = 0;
          for (; ; ) {
            here = state2.lencode[hold & (1 << state2.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          state2.length = here_val;
          if (here_op === 0) {
            state2.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state2.back = -1;
            state2.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD;
            break;
          }
          state2.extra = here_op & 15;
          state2.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state2.extra) {
            n4 = state2.extra;
            while (bits < n4) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          state2.was = state2.length;
          state2.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state2.distcode[hold & (1 << state2.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state2.mode = BAD;
            break;
          }
          state2.offset = here_val;
          state2.extra = here_op & 15;
          state2.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state2.extra) {
            n4 = state2.extra;
            while (bits < n4) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.offset += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          if (state2.offset > state2.dmax) {
            strm.msg = "invalid distance too far back";
            state2.mode = BAD;
            break;
          }
          state2.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy5 = _out - left;
          if (state2.offset > copy5) {
            copy5 = state2.offset - copy5;
            if (copy5 > state2.whave) {
              if (state2.sane) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD;
                break;
              }
            }
            if (copy5 > state2.wnext) {
              copy5 -= state2.wnext;
              from4 = state2.wsize - copy5;
            } else {
              from4 = state2.wnext - copy5;
            }
            if (copy5 > state2.length) {
              copy5 = state2.length;
            }
            from_source = state2.window;
          } else {
            from_source = output;
            from4 = put - state2.offset;
            copy5 = state2.length;
          }
          if (copy5 > left) {
            copy5 = left;
          }
          left -= copy5;
          state2.length -= copy5;
          do {
            output[put++] = from_source[from4++];
          } while (--copy5);
          if (state2.length === 0) {
            state2.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state2.length;
          left--;
          state2.mode = LEN;
          break;
        case CHECK:
          if (state2.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state2.total += _out;
            if (_out) {
              strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
              state2.flags ? crc32(state2.check, output, _out, put - _out) : adler32(state2.check, output, _out, put - _out);
            }
            _out = left;
            if ((state2.flags ? hold : zswap32(hold)) !== state2.check) {
              strm.msg = "incorrect data check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state2.wrap && state2.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state2.hold = hold;
  state2.bits = bits;
  if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD && (state2.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state2.total += _out;
  if (state2.wrap && _out) {
    strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state2.flags ? crc32(state2.check, output, _out, strm.next_out - _out) : adler32(state2.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  var state2 = strm.state;
  if (state2.window) {
    state2.window = null;
  }
  strm.state = null;
  return Z_OK;
}
function inflateGetHeader(strm, head) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if ((state2.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  state2.head = head;
  head.done = false;
  return Z_OK;
}
function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state2;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.wrap !== 0 && state2.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  if (state2.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state2.check) {
      return Z_DATA_ERROR;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state2.mode = MEM;
    return Z_MEM_ERROR;
  }
  state2.havedict = 1;
  return Z_OK;
}
inflate$1.inflateReset = inflateReset;
inflate$1.inflateReset2 = inflateReset2;
inflate$1.inflateResetKeep = inflateResetKeep;
inflate$1.inflateInit = inflateInit;
inflate$1.inflateInit2 = inflateInit2;
inflate$1.inflate = inflate;
inflate$1.inflateEnd = inflateEnd;
inflate$1.inflateGetHeader = inflateGetHeader;
inflate$1.inflateSetDictionary = inflateSetDictionary;
inflate$1.inflateInfo = "pako inflate (from Nodeca project)";
var constants = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
(function(exports) {
  var assert3 = require$$4;
  var Zstream = zstream;
  var zlib_deflate = deflate$1;
  var zlib_inflate = inflate$1;
  var constants$1 = constants;
  for (var key in constants$1) {
    exports[key] = constants$1[key];
  }
  exports.NONE = 0;
  exports.DEFLATE = 1;
  exports.INFLATE = 2;
  exports.GZIP = 3;
  exports.GUNZIP = 4;
  exports.DEFLATERAW = 5;
  exports.INFLATERAW = 6;
  exports.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib(mode) {
    if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert3(this.init_done, "close before init");
    assert3(this.mode <= exports.UNZIP);
    if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports.NONE;
    this.dictionary = null;
  };
  Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert3.equal(arguments.length, 8);
    assert3(this.init_done, "write before init");
    assert3(this.mode !== exports.NONE, "already finalized");
    assert3.equal(false, this.write_in_progress, "write already in progress");
    assert3.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert3.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer2.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    browser$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports.INFLATE;
              break;
            }
          // fallthrough
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports.GUNZIP;
            } else {
              this.mode = exports.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      // fallthrough
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports.Z_DATA_ERROR) {
            this.err = exports.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib.prototype._checkError = function() {
    switch (this.err) {
      case exports.Z_OK:
      case exports.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports.Z_STREAM_END:
        break;
      case exports.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert3(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert3(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert3(level >= -1 && level <= 9, "invalid compression level");
    assert3(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert3(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports.Z_NO_FLUSH;
    this.err = exports.Z_OK;
    if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
      case exports.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib.prototype._reset = function() {
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
      case exports.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports.INFLATE:
      case exports.INFLATERAW:
      case exports.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports.Zlib = Zlib;
})(binding);
var require$$3 = getAugmentedNamespace(_polyfillNode_util$1);
(function(exports) {
  var Buffer5 = require$$0.Buffer;
  var Transform3 = require$$1.Transform;
  var binding$13 = binding;
  var util = require$$3;
  var assert3 = require$$4.ok;
  var kMaxLength4 = require$$0.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength4.toString(16) + " bytes";
  binding$13.Z_MIN_WINDOWBITS = 8;
  binding$13.Z_MAX_WINDOWBITS = 15;
  binding$13.Z_DEFAULT_WINDOWBITS = 15;
  binding$13.Z_MIN_CHUNK = 64;
  binding$13.Z_MAX_CHUNK = Infinity;
  binding$13.Z_DEFAULT_CHUNK = 16 * 1024;
  binding$13.Z_MIN_MEMLEVEL = 1;
  binding$13.Z_MAX_MEMLEVEL = 9;
  binding$13.Z_DEFAULT_MEMLEVEL = 8;
  binding$13.Z_MIN_LEVEL = -1;
  binding$13.Z_MAX_LEVEL = 9;
  binding$13.Z_DEFAULT_LEVEL = binding$13.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding$13);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports, bkey, {
        enumerable: true,
        value: binding$13[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding$13.Z_OK,
    Z_STREAM_END: binding$13.Z_STREAM_END,
    Z_NEED_DICT: binding$13.Z_NEED_DICT,
    Z_ERRNO: binding$13.Z_ERRNO,
    Z_STREAM_ERROR: binding$13.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding$13.Z_DATA_ERROR,
    Z_MEM_ERROR: binding$13.Z_MEM_ERROR,
    Z_BUF_ERROR: binding$13.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding$13.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports.Deflate = Deflate;
  exports.Inflate = Inflate;
  exports.Gzip = Gzip;
  exports.Gunzip = Gunzip;
  exports.DeflateRaw = DeflateRaw;
  exports.InflateRaw = InflateRaw;
  exports.Unzip = Unzip;
  exports.createDeflate = function(o2) {
    return new Deflate(o2);
  };
  exports.createInflate = function(o2) {
    return new Inflate(o2);
  };
  exports.createDeflateRaw = function(o2) {
    return new DeflateRaw(o2);
  };
  exports.createInflateRaw = function(o2) {
    return new InflateRaw(o2);
  };
  exports.createGzip = function(o2) {
    return new Gzip(o2);
  };
  exports.createGunzip = function(o2) {
    return new Gunzip(o2);
  };
  exports.createUnzip = function(o2) {
    return new Unzip(o2);
  };
  exports.deflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Deflate(opts2), buffer, callback);
  };
  exports.deflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Deflate(opts2), buffer);
  };
  exports.gzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gzip(opts2), buffer, callback);
  };
  exports.gzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gzip(opts2), buffer);
  };
  exports.deflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new DeflateRaw(opts2), buffer, callback);
  };
  exports.deflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new DeflateRaw(opts2), buffer);
  };
  exports.unzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Unzip(opts2), buffer, callback);
  };
  exports.unzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Unzip(opts2), buffer);
  };
  exports.inflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Inflate(opts2), buffer, callback);
  };
  exports.inflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Inflate(opts2), buffer);
  };
  exports.gunzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gunzip(opts2), buffer, callback);
  };
  exports.gunzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gunzip(opts2), buffer);
  };
  exports.inflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new InflateRaw(opts2), buffer, callback);
  };
  exports.inflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new InflateRaw(opts2), buffer);
  };
  function zlibBuffer(engine2, buffer, callback) {
    var buffers = [];
    var nread = 0;
    engine2.on("error", onError);
    engine2.on("end", onEnd);
    engine2.end(buffer);
    flow3();
    function flow3() {
      var chunk;
      while (null !== (chunk = engine2.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine2.once("readable", flow3);
    }
    function onError(err2) {
      engine2.removeListener("end", onEnd);
      engine2.removeListener("readable", flow3);
      callback(err2);
    }
    function onEnd() {
      var buf;
      var err2 = null;
      if (nread >= kMaxLength4) {
        err2 = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer5.concat(buffers, nread);
      }
      buffers = [];
      engine2.close();
      callback(err2, buf);
    }
  }
  function zlibBufferSync(engine2, buffer) {
    if (typeof buffer === "string") buffer = Buffer5.from(buffer);
    if (!Buffer5.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
    var flushFlag = engine2._finishFlushFlag;
    return engine2._processChunk(buffer, flushFlag);
  }
  function Deflate(opts2) {
    if (!(this instanceof Deflate)) return new Deflate(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATE);
  }
  function Inflate(opts2) {
    if (!(this instanceof Inflate)) return new Inflate(opts2);
    Zlib.call(this, opts2, binding$13.INFLATE);
  }
  function Gzip(opts2) {
    if (!(this instanceof Gzip)) return new Gzip(opts2);
    Zlib.call(this, opts2, binding$13.GZIP);
  }
  function Gunzip(opts2) {
    if (!(this instanceof Gunzip)) return new Gunzip(opts2);
    Zlib.call(this, opts2, binding$13.GUNZIP);
  }
  function DeflateRaw(opts2) {
    if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATERAW);
  }
  function InflateRaw(opts2) {
    if (!(this instanceof InflateRaw)) return new InflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.INFLATERAW);
  }
  function Unzip(opts2) {
    if (!(this instanceof Unzip)) return new Unzip(opts2);
    Zlib.call(this, opts2, binding$13.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding$13.Z_NO_FLUSH || flag === binding$13.Z_PARTIAL_FLUSH || flag === binding$13.Z_SYNC_FLUSH || flag === binding$13.Z_FULL_FLUSH || flag === binding$13.Z_FINISH || flag === binding$13.Z_BLOCK;
  }
  function Zlib(opts2, mode) {
    var _this = this;
    this._opts = opts2 = opts2 || {};
    this._chunkSize = opts2.chunkSize || exports.Z_DEFAULT_CHUNK;
    Transform3.call(this, opts2);
    if (opts2.flush && !isValidFlushFlag(opts2.flush)) {
      throw new Error("Invalid flush flag: " + opts2.flush);
    }
    if (opts2.finishFlush && !isValidFlushFlag(opts2.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts2.finishFlush);
    }
    this._flushFlag = opts2.flush || binding$13.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts2.finishFlush !== "undefined" ? opts2.finishFlush : binding$13.Z_FINISH;
    if (opts2.chunkSize) {
      if (opts2.chunkSize < exports.Z_MIN_CHUNK || opts2.chunkSize > exports.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts2.chunkSize);
      }
    }
    if (opts2.windowBits) {
      if (opts2.windowBits < exports.Z_MIN_WINDOWBITS || opts2.windowBits > exports.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts2.windowBits);
      }
    }
    if (opts2.level) {
      if (opts2.level < exports.Z_MIN_LEVEL || opts2.level > exports.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts2.level);
      }
    }
    if (opts2.memLevel) {
      if (opts2.memLevel < exports.Z_MIN_MEMLEVEL || opts2.memLevel > exports.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts2.memLevel);
      }
    }
    if (opts2.strategy) {
      if (opts2.strategy != exports.Z_FILTERED && opts2.strategy != exports.Z_HUFFMAN_ONLY && opts2.strategy != exports.Z_RLE && opts2.strategy != exports.Z_FIXED && opts2.strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts2.strategy);
      }
    }
    if (opts2.dictionary) {
      if (!Buffer5.isBuffer(opts2.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding$13.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports.codes[errno];
      self2.emit("error", error);
    };
    var level = exports.Z_DEFAULT_COMPRESSION;
    if (typeof opts2.level === "number") level = opts2.level;
    var strategy = exports.Z_DEFAULT_STRATEGY;
    if (typeof opts2.strategy === "number") strategy = opts2.strategy;
    this._handle.init(opts2.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts2.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts2.dictionary);
    this._buffer = Buffer5.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util.inherits(Zlib, Transform3);
  Zlib.prototype.params = function(level, strategy, callback) {
    if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding$13.Z_SYNC_FLUSH, function() {
        assert3(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback) callback();
        }
      });
    } else {
      browser$1.nextTick(callback);
    }
  };
  Zlib.prototype.reset = function() {
    assert3(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib.prototype._flush = function(callback) {
    this._transform(Buffer5.alloc(0), "", callback);
  };
  Zlib.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding$13.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback) browser$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback) this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer5.alloc(0), "", callback);
    }
  };
  Zlib.prototype.close = function(callback) {
    _close(this, callback);
    browser$1.nextTick(emitCloseNT2, this);
  };
  function _close(engine2, callback) {
    if (callback) browser$1.nextTick(callback);
    if (!engine2._handle) return;
    engine2._handle.close();
    engine2._handle = null;
  }
  function emitCloseNT2(self2) {
    self2.emit("close");
  }
  Zlib.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last2 = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer5.isBuffer(chunk)) return cb(new Error("invalid input"));
    if (!this._handle) return cb(new Error("zlib binding closed"));
    if (last2) flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding$13.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er) {
        error = er;
      });
      assert3(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength4) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer5.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert3(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError) return;
      var have = availOutBefore - availOutAfter;
      assert3(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer5.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async) return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async) return false;
      cb();
    }
  };
  util.inherits(Deflate, Zlib);
  util.inherits(Inflate, Zlib);
  util.inherits(Gzip, Zlib);
  util.inherits(Gunzip, Zlib);
  util.inherits(DeflateRaw, Zlib);
  util.inherits(InflateRaw, Zlib);
  util.inherits(Unzip, Zlib);
})(lib);
var zlib = getDefaultExportFromCjs(lib);
var PNG = class {
  static decode(path, fn) {
    {
      throw new Error("PNG.decode not available in browser build");
    }
  }
  static load(path) {
    {
      throw new Error("PNG.load not available in browser build");
    }
  }
  constructor(data2) {
    let i3;
    this.data = data2;
    this.pos = 8;
    this.palette = [];
    this.imgData = [];
    this.transparency = {};
    this.text = {};
    while (true) {
      const chunkSize = this.readUInt32();
      let section = "";
      for (i3 = 0; i3 < 4; i3++) {
        section += String.fromCharCode(this.data[this.pos++]);
      }
      switch (section) {
        case "IHDR":
          this.width = this.readUInt32();
          this.height = this.readUInt32();
          this.bits = this.data[this.pos++];
          this.colorType = this.data[this.pos++];
          this.compressionMethod = this.data[this.pos++];
          this.filterMethod = this.data[this.pos++];
          this.interlaceMethod = this.data[this.pos++];
          break;
        case "PLTE":
          this.palette = this.read(chunkSize);
          break;
        case "IDAT":
          for (i3 = 0; i3 < chunkSize; i3++) {
            this.imgData.push(this.data[this.pos++]);
          }
          break;
        case "tRNS":
          this.transparency = {};
          switch (this.colorType) {
            case 3:
              this.transparency.indexed = this.read(chunkSize);
              var short = 255 - this.transparency.indexed.length;
              if (short > 0) {
                for (i3 = 0; i3 < short; i3++) {
                  this.transparency.indexed.push(255);
                }
              }
              break;
            case 0:
              this.transparency.grayscale = this.read(chunkSize)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(chunkSize);
              break;
          }
          break;
        case "tEXt":
          var text = this.read(chunkSize);
          var index3 = text.indexOf(0);
          var key = String.fromCharCode.apply(String, text.slice(0, index3));
          this.text[key] = String.fromCharCode.apply(String, text.slice(index3 + 1));
          break;
        case "IEND":
          switch (this.colorType) {
            case 0:
            case 3:
            case 4:
              this.colors = 1;
              break;
            case 2:
            case 6:
              this.colors = 3;
              break;
          }
          this.hasAlphaChannel = [4, 6].includes(this.colorType);
          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
          this.pixelBitlength = this.bits * colors;
          switch (this.colors) {
            case 1:
              this.colorSpace = "DeviceGray";
              break;
            case 3:
              this.colorSpace = "DeviceRGB";
              break;
          }
          this.imgData = Buffer2.from(this.imgData);
          return;
        default:
          this.pos += chunkSize;
      }
      this.pos += 4;
      if (this.pos > this.data.length) {
        throw new Error("Incomplete or corrupt PNG file");
      }
    }
  }
  read(bytes) {
    const result = new Array(bytes);
    for (let i3 = 0; i3 < bytes; i3++) {
      result[i3] = this.data[this.pos++];
    }
    return result;
  }
  readUInt32() {
    const b1 = this.data[this.pos++] << 24;
    const b2 = this.data[this.pos++] << 16;
    const b3 = this.data[this.pos++] << 8;
    const b4 = this.data[this.pos++];
    return b1 | b2 | b3 | b4;
  }
  readUInt16() {
    const b1 = this.data[this.pos++] << 8;
    const b2 = this.data[this.pos++];
    return b1 | b2;
  }
  decodePixels(fn) {
    return zlib.inflate(this.imgData, (err2, data2) => {
      if (err2) throw err2;
      var pos = 0;
      const {
        width,
        height: height2
      } = this;
      var pixelBytes = this.pixelBitlength / 8;
      const pixels = Buffer2.alloc(width * height2 * pixelBytes);
      function pass(x0, y0, dx, dy, singlePass) {
        if (singlePass === void 0) {
          singlePass = false;
        }
        const w = Math.ceil((width - x0) / dx);
        const h2 = Math.ceil((height2 - y0) / dy);
        const scanlineLength = pixelBytes * w;
        const buffer = singlePass ? pixels : Buffer2.alloc(scanlineLength * h2);
        let row = 0;
        let c3 = 0;
        while (row < h2 && pos < data2.length) {
          var byte;
          var col;
          var i3;
          var left;
          var upper;
          switch (data2[pos++]) {
            case 0:
              for (i3 = 0; i3 < scanlineLength; i3++) {
                buffer[c3++] = data2[pos++];
              }
              break;
            case 1:
              for (i3 = 0; i3 < scanlineLength; i3++) {
                byte = data2[pos++];
                left = i3 < pixelBytes ? 0 : buffer[c3 - pixelBytes];
                buffer[c3++] = (byte + left) % 256;
              }
              break;
            case 2:
              for (i3 = 0; i3 < scanlineLength; i3++) {
                byte = data2[pos++];
                col = (i3 - i3 % pixelBytes) / pixelBytes;
                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i3 % pixelBytes];
                buffer[c3++] = (upper + byte) % 256;
              }
              break;
            case 3:
              for (i3 = 0; i3 < scanlineLength; i3++) {
                byte = data2[pos++];
                col = (i3 - i3 % pixelBytes) / pixelBytes;
                left = i3 < pixelBytes ? 0 : buffer[c3 - pixelBytes];
                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i3 % pixelBytes];
                buffer[c3++] = (byte + Math.floor((left + upper) / 2)) % 256;
              }
              break;
            case 4:
              for (i3 = 0; i3 < scanlineLength; i3++) {
                var paeth;
                var upperLeft;
                byte = data2[pos++];
                col = (i3 - i3 % pixelBytes) / pixelBytes;
                left = i3 < pixelBytes ? 0 : buffer[c3 - pixelBytes];
                if (row === 0) {
                  upper = upperLeft = 0;
                } else {
                  upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i3 % pixelBytes];
                  upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i3 % pixelBytes];
                }
                const p2 = left + upper - upperLeft;
                const pa = Math.abs(p2 - left);
                const pb = Math.abs(p2 - upper);
                const pc = Math.abs(p2 - upperLeft);
                if (pa <= pb && pa <= pc) {
                  paeth = left;
                } else if (pb <= pc) {
                  paeth = upper;
                } else {
                  paeth = upperLeft;
                }
                buffer[c3++] = (byte + paeth) % 256;
              }
              break;
            default:
              throw new Error(`Invalid filter algorithm: ${data2[pos - 1]}`);
          }
          if (!singlePass) {
            let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;
            let bufferPos = row * scanlineLength;
            for (i3 = 0; i3 < w; i3++) {
              for (let j = 0; j < pixelBytes; j++) pixels[pixelsPos++] = buffer[bufferPos++];
              pixelsPos += (dx - 1) * pixelBytes;
            }
          }
          row++;
        }
      }
      if (this.interlaceMethod === 1) {
        pass(0, 0, 8, 8);
        pass(4, 0, 8, 8);
        pass(0, 4, 4, 8);
        pass(2, 0, 4, 4);
        pass(0, 2, 2, 4);
        pass(1, 0, 2, 2);
        pass(0, 1, 1, 2);
      } else {
        pass(0, 0, 1, 1, true);
      }
      return fn(pixels);
    });
  }
  decodePalette() {
    const {
      palette
    } = this;
    const {
      length: length2
    } = palette;
    const transparency = this.transparency.indexed || [];
    const ret = Buffer2.alloc(transparency.length + length2);
    let pos = 0;
    let c3 = 0;
    for (let i3 = 0; i3 < length2; i3 += 3) {
      var left;
      ret[pos++] = palette[i3];
      ret[pos++] = palette[i3 + 1];
      ret[pos++] = palette[i3 + 2];
      ret[pos++] = (left = transparency[c3++]) != null ? left : 255;
    }
    return ret;
  }
  copyToImageData(imageData, pixels) {
    let j;
    var k2;
    let {
      colors
    } = this;
    let palette = null;
    let alpha = this.hasAlphaChannel;
    if (this.palette.length) {
      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());
      colors = 4;
      alpha = true;
    }
    const data2 = imageData.data || imageData;
    const {
      length: length2
    } = data2;
    const input = palette || pixels;
    let i3 = j = 0;
    if (colors === 1) {
      while (i3 < length2) {
        k2 = palette ? pixels[i3 / 4] * 4 : j;
        const v2 = input[k2++];
        data2[i3++] = v2;
        data2[i3++] = v2;
        data2[i3++] = v2;
        data2[i3++] = alpha ? input[k2++] : 255;
        j = k2;
      }
    } else {
      while (i3 < length2) {
        k2 = palette ? pixels[i3 / 4] * 4 : j;
        data2[i3++] = input[k2++];
        data2[i3++] = input[k2++];
        data2[i3++] = input[k2++];
        data2[i3++] = alpha ? input[k2++] : 255;
        j = k2;
      }
    }
  }
  decode(fn) {
    const ret = Buffer2.alloc(this.width * this.height * 4);
    return this.decodePixels((pixels) => {
      this.copyToImageData(ret, pixels);
      return fn(ret);
    });
  }
};

// node_modules/@react-pdf/pdfkit/lib/pdfkit.browser.js
var import_crypto_js = __toESM(require_crypto_js());
var global$12 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup2 = [];
var revLookup2 = [];
var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited2 = false;
function init2() {
  inited2 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i3 = 0, len = code.length; i3 < len; ++i3) {
    lookup2[i3] = code[i3];
    revLookup2[code.charCodeAt(i3)] = i3;
  }
  revLookup2["-".charCodeAt(0)] = 62;
  revLookup2["_".charCodeAt(0)] = 63;
}
function toByteArray2(b64) {
  if (!inited2) {
    init2();
  }
  var i3, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr2(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i3 = 0, j = 0; i3 < l2; i3 += 4, j += 3) {
    tmp = revLookup2[b64.charCodeAt(i3)] << 18 | revLookup2[b64.charCodeAt(i3 + 1)] << 12 | revLookup2[b64.charCodeAt(i3 + 2)] << 6 | revLookup2[b64.charCodeAt(i3 + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup2[b64.charCodeAt(i3)] << 2 | revLookup2[b64.charCodeAt(i3 + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup2[b64.charCodeAt(i3)] << 10 | revLookup2[b64.charCodeAt(i3 + 1)] << 4 | revLookup2[b64.charCodeAt(i3 + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase642(num) {
  return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
}
function encodeChunk2(uint82, start2, end2) {
  var tmp;
  var output = [];
  for (var i3 = start2; i3 < end2; i3 += 3) {
    tmp = (uint82[i3] << 16) + (uint82[i3 + 1] << 8) + uint82[i3 + 2];
    output.push(tripletToBase642(tmp));
  }
  return output.join("");
}
function fromByteArray2(uint82) {
  if (!inited2) {
    init2();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i3 = 0, len2 = len - extraBytes; i3 < len2; i3 += maxChunkLength) {
    parts.push(encodeChunk2(uint82, i3, i3 + maxChunkLength > len2 ? len2 : i3 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup2[tmp >> 2];
    output += lookup2[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup2[tmp >> 10];
    output += lookup2[tmp >> 4 & 63];
    output += lookup2[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read2(buffer, offset2, isLE, mLen, nBytes) {
  var e3, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i3 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer[offset2 + i3];
  i3 += d2;
  e3 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e3 = e3 * 256 + buffer[offset2 + i3], i3 += d2, nBits -= 8) {
  }
  m = e3 & (1 << -nBits) - 1;
  e3 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset2 + i3], i3 += d2, nBits -= 8) {
  }
  if (e3 === 0) {
    e3 = 1 - eBias;
  } else if (e3 === eMax) {
    return m ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e3 = e3 - eBias;
  }
  return (s2 ? -1 : 1) * m * Math.pow(2, e3 - mLen);
}
function write3(buffer, value2, offset2, isLE, mLen, nBytes) {
  var e3, m, c3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i3 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m = isNaN(value2) ? 1 : 0;
    e3 = eMax;
  } else {
    e3 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c3 = Math.pow(2, -e3)) < 1) {
      e3--;
      c3 *= 2;
    }
    if (e3 + eBias >= 1) {
      value2 += rt / c3;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c3 >= 2) {
      e3++;
      c3 /= 2;
    }
    if (e3 + eBias >= eMax) {
      m = 0;
      e3 = eMax;
    } else if (e3 + eBias >= 1) {
      m = (value2 * c3 - 1) * Math.pow(2, mLen);
      e3 = e3 + eBias;
    } else {
      m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e3 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset2 + i3] = m & 255, i3 += d2, m /= 256, mLen -= 8) {
  }
  e3 = e3 << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset2 + i3] = e3 & 255, i3 += d2, e3 /= 256, eLen -= 8) {
  }
  buffer[offset2 + i3 - d2] |= s2 * 128;
}
var toString3 = {}.toString;
var isArray$12 = Array.isArray || function(arr) {
  return toString3.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES2 = 50;
Buffer$2.TYPED_ARRAY_SUPPORT = global$12.TYPED_ARRAY_SUPPORT !== void 0 ? global$12.TYPED_ARRAY_SUPPORT : true;
var _kMaxLength2 = kMaxLength2();
function kMaxLength2() {
  return Buffer$2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer2(that, length2) {
  if (kMaxLength2() < length2) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length2);
    that.__proto__ = Buffer$2.prototype;
  } else {
    if (that === null) {
      that = new Buffer$2(length2);
    }
    that.length = length2;
  }
  return that;
}
function Buffer$2(arg, encodingOrOffset, length2) {
  if (!Buffer$2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$2)) {
    return new Buffer$2(arg, encodingOrOffset, length2);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe2(this, arg);
  }
  return from$1(this, arg, encodingOrOffset, length2);
}
Buffer$2.poolSize = 8192;
Buffer$2._augment = function(arr) {
  arr.__proto__ = Buffer$2.prototype;
  return arr;
};
function from$1(that, value2, encodingOrOffset, length2) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer2(that, value2, encodingOrOffset, length2);
  }
  if (typeof value2 === "string") {
    return fromString2(that, value2, encodingOrOffset);
  }
  return fromObject2(that, value2);
}
Buffer$2.from = function(value2, encodingOrOffset, length2) {
  return from$1(null, value2, encodingOrOffset, length2);
};
if (Buffer$2.TYPED_ARRAY_SUPPORT) {
  Buffer$2.prototype.__proto__ = Uint8Array.prototype;
  Buffer$2.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer$2[Symbol.species] === Buffer$2) ;
}
function assertSize2(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc2(that, size, fill4, encoding) {
  assertSize2(size);
  if (size <= 0) {
    return createBuffer2(that, size);
  }
  if (fill4 !== void 0) {
    return typeof encoding === "string" ? createBuffer2(that, size).fill(fill4, encoding) : createBuffer2(that, size).fill(fill4);
  }
  return createBuffer2(that, size);
}
Buffer$2.alloc = function(size, fill4, encoding) {
  return alloc2(null, size, fill4, encoding);
};
function allocUnsafe2(that, size) {
  assertSize2(size);
  that = createBuffer2(that, size < 0 ? 0 : checked2(size) | 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (var i3 = 0; i3 < size; ++i3) {
      that[i3] = 0;
    }
  }
  return that;
}
Buffer$2.allocUnsafe = function(size) {
  return allocUnsafe2(null, size);
};
Buffer$2.allocUnsafeSlow = function(size) {
  return allocUnsafe2(null, size);
};
function fromString2(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer$2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length2 = byteLength3(string, encoding) | 0;
  that = createBuffer2(that, length2);
  var actual = that.write(string, encoding);
  if (actual !== length2) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike2(that, array) {
  var length2 = array.length < 0 ? 0 : checked2(array.length) | 0;
  that = createBuffer2(that, length2);
  for (var i3 = 0; i3 < length2; i3 += 1) {
    that[i3] = array[i3] & 255;
  }
  return that;
}
function fromArrayBuffer2(that, array, byteOffset, length2) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length2 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length2 === void 0) {
    array = new Uint8Array(array);
  } else if (length2 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length2);
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer$2.prototype;
  } else {
    that = fromArrayLike2(that, array);
  }
  return that;
}
function fromObject2(that, obj) {
  if (internalIsBuffer2(obj)) {
    var len = checked2(obj.length) | 0;
    that = createBuffer2(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan2(obj.length)) {
        return createBuffer2(that, 0);
      }
      return fromArrayLike2(that, obj);
    }
    if (obj.type === "Buffer" && isArray$12(obj.data)) {
      return fromArrayLike2(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked2(length2) {
  if (length2 >= kMaxLength2()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2().toString(16) + " bytes");
  }
  return length2 | 0;
}
function SlowBuffer2(length2) {
  if (+length2 != length2) {
    length2 = 0;
  }
  return Buffer$2.alloc(+length2);
}
Buffer$2.isBuffer = isBuffer$12;
function internalIsBuffer2(b2) {
  return !!(b2 != null && b2._isBuffer);
}
Buffer$2.compare = function compare4(a3, b2) {
  if (!internalIsBuffer2(a3) || !internalIsBuffer2(b2)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a3 === b2) return 0;
  var x = a3.length;
  var y2 = b2.length;
  for (var i3 = 0, len = Math.min(x, y2); i3 < len; ++i3) {
    if (a3[i3] !== b2[i3]) {
      x = a3[i3];
      y2 = b2[i3];
      break;
    }
  }
  if (x < y2) return -1;
  if (y2 < x) return 1;
  return 0;
};
Buffer$2.isEncoding = function isEncoding2(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer$2.concat = function concat2(list, length2) {
  if (!isArray$12(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$2.alloc(0);
  }
  var i3;
  if (length2 === void 0) {
    length2 = 0;
    for (i3 = 0; i3 < list.length; ++i3) {
      length2 += list[i3].length;
    }
  }
  var buffer = Buffer$2.allocUnsafe(length2);
  var pos = 0;
  for (i3 = 0; i3 < list.length; ++i3) {
    var buf = list[i3];
    if (!internalIsBuffer2(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength3(string, encoding) {
  if (internalIsBuffer2(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes2(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes2(string).length;
      default:
        if (loweredCase) return utf8ToBytes2(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.byteLength = byteLength3;
function slowToString2(encoding, start2, end2) {
  var loweredCase = false;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (start2 > this.length) {
    return "";
  }
  if (end2 === void 0 || end2 > this.length) {
    end2 = this.length;
  }
  if (end2 <= 0) {
    return "";
  }
  end2 >>>= 0;
  start2 >>>= 0;
  if (end2 <= start2) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice2(this, start2, end2);
      case "utf8":
      case "utf-8":
        return utf8Slice2(this, start2, end2);
      case "ascii":
        return asciiSlice2(this, start2, end2);
      case "latin1":
      case "binary":
        return latin1Slice2(this, start2, end2);
      case "base64":
        return base64Slice2(this, start2, end2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice2(this, start2, end2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.prototype._isBuffer = true;
function swap2(b2, n4, m) {
  var i3 = b2[n4];
  b2[n4] = b2[m];
  b2[m] = i3;
}
Buffer$2.prototype.swap16 = function swap162() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i3 = 0; i3 < len; i3 += 2) {
    swap2(this, i3, i3 + 1);
  }
  return this;
};
Buffer$2.prototype.swap32 = function swap322() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i3 = 0; i3 < len; i3 += 4) {
    swap2(this, i3, i3 + 3);
    swap2(this, i3 + 1, i3 + 2);
  }
  return this;
};
Buffer$2.prototype.swap64 = function swap642() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i3 = 0; i3 < len; i3 += 8) {
    swap2(this, i3, i3 + 7);
    swap2(this, i3 + 1, i3 + 6);
    swap2(this, i3 + 2, i3 + 5);
    swap2(this, i3 + 3, i3 + 4);
  }
  return this;
};
Buffer$2.prototype.toString = function toString4() {
  var length2 = this.length | 0;
  if (length2 === 0) return "";
  if (arguments.length === 0) return utf8Slice2(this, 0, length2);
  return slowToString2.apply(this, arguments);
};
Buffer$2.prototype.equals = function equals2(b2) {
  if (!internalIsBuffer2(b2)) throw new TypeError("Argument must be a Buffer");
  if (this === b2) return true;
  return Buffer$2.compare(this, b2) === 0;
};
Buffer$2.prototype.inspect = function inspect3() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES2;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2) str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer$2.prototype.compare = function compare5(target, start2, end2, thisStart, thisEnd) {
  if (!internalIsBuffer2(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start2 === void 0) {
    start2 = 0;
  }
  if (end2 === void 0) {
    end2 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start2 >= end2) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start2 >= end2) {
    return 1;
  }
  start2 >>>= 0;
  end2 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y2 = end2 - start2;
  var len = Math.min(x, y2);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start2, end2);
  for (var i3 = 0; i3 < len; ++i3) {
    if (thisCopy[i3] !== targetCopy[i3]) {
      x = thisCopy[i3];
      y2 = targetCopy[i3];
      break;
    }
  }
  if (x < y2) return -1;
  if (y2 < x) return 1;
  return 0;
};
function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer$2.from(val, encoding);
  }
  if (internalIsBuffer2(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf2(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer$2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf2(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read4(buf, i4) {
    if (indexSize === 1) {
      return buf[i4];
    } else {
      return buf.readUInt16BE(i4 * indexSize);
    }
  }
  var i3;
  if (dir) {
    var foundIndex = -1;
    for (i3 = byteOffset; i3 < arrLength; i3++) {
      if (read4(arr, i3) === read4(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i3;
        if (i3 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i3 -= i3 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i3 = byteOffset; i3 >= 0; i3--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read4(arr, i3 + j) !== read4(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i3;
    }
  }
  return -1;
}
Buffer$2.prototype.includes = function includes2(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer$2.prototype.indexOf = function indexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
};
Buffer$2.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
};
function hexWrite2(buf, string, offset2, length2) {
  offset2 = Number(offset2) || 0;
  var remaining = buf.length - offset2;
  if (!length2) {
    length2 = remaining;
  } else {
    length2 = Number(length2);
    if (length2 > remaining) {
      length2 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length2 > strLen / 2) {
    length2 = strLen / 2;
  }
  for (var i3 = 0; i3 < length2; ++i3) {
    var parsed = parseInt(string.substr(i3 * 2, 2), 16);
    if (isNaN(parsed)) return i3;
    buf[offset2 + i3] = parsed;
  }
  return i3;
}
function utf8Write2(buf, string, offset2, length2) {
  return blitBuffer2(utf8ToBytes2(string, buf.length - offset2), buf, offset2, length2);
}
function asciiWrite2(buf, string, offset2, length2) {
  return blitBuffer2(asciiToBytes2(string), buf, offset2, length2);
}
function latin1Write2(buf, string, offset2, length2) {
  return asciiWrite2(buf, string, offset2, length2);
}
function base64Write2(buf, string, offset2, length2) {
  return blitBuffer2(base64ToBytes2(string), buf, offset2, length2);
}
function ucs2Write2(buf, string, offset2, length2) {
  return blitBuffer2(utf16leToBytes2(string, buf.length - offset2), buf, offset2, length2);
}
Buffer$2.prototype.write = function write4(string, offset2, length2, encoding) {
  if (offset2 === void 0) {
    encoding = "utf8";
    length2 = this.length;
    offset2 = 0;
  } else if (length2 === void 0 && typeof offset2 === "string") {
    encoding = offset2;
    length2 = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length2)) {
      length2 = length2 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length2;
      length2 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset2;
  if (length2 === void 0 || length2 > remaining) length2 = remaining;
  if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite2(this, string, offset2, length2);
      case "utf8":
      case "utf-8":
        return utf8Write2(this, string, offset2, length2);
      case "ascii":
        return asciiWrite2(this, string, offset2, length2);
      case "latin1":
      case "binary":
        return latin1Write2(this, string, offset2, length2);
      case "base64":
        return base64Write2(this, string, offset2, length2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write2(this, string, offset2, length2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$2.prototype.toJSON = function toJSON2() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice2(buf, start2, end2) {
  if (start2 === 0 && end2 === buf.length) {
    return fromByteArray2(buf);
  } else {
    return fromByteArray2(buf.slice(start2, end2));
  }
}
function utf8Slice2(buf, start2, end2) {
  end2 = Math.min(buf.length, end2);
  var res = [];
  var i3 = start2;
  while (i3 < end2) {
    var firstByte = buf[i3];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i3 + bytesPerSequence <= end2) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i3 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i3 + 1];
          thirdByte = buf[i3 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i3 + 1];
          thirdByte = buf[i3 + 2];
          fourthByte = buf[i3 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i3 += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
var MAX_ARGUMENTS_LENGTH2 = 4096;
function decodeCodePointsArray2(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i3 = 0;
  while (i3 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}
function asciiSlice2(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i3 = start2; i3 < end2; ++i3) {
    ret += String.fromCharCode(buf[i3] & 127);
  }
  return ret;
}
function latin1Slice2(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i3 = start2; i3 < end2; ++i3) {
    ret += String.fromCharCode(buf[i3]);
  }
  return ret;
}
function hexSlice2(buf, start2, end2) {
  var len = buf.length;
  if (!start2 || start2 < 0) start2 = 0;
  if (!end2 || end2 < 0 || end2 > len) end2 = len;
  var out = "";
  for (var i3 = start2; i3 < end2; ++i3) {
    out += toHex$1(buf[i3]);
  }
  return out;
}
function utf16leSlice2(buf, start2, end2) {
  var bytes = buf.slice(start2, end2);
  var res = "";
  for (var i3 = 0; i3 < bytes.length; i3 += 2) {
    res += String.fromCharCode(bytes[i3] + bytes[i3 + 1] * 256);
  }
  return res;
}
Buffer$2.prototype.slice = function slice2(start2, end2) {
  var len = this.length;
  start2 = ~~start2;
  end2 = end2 === void 0 ? len : ~~end2;
  if (start2 < 0) {
    start2 += len;
    if (start2 < 0) start2 = 0;
  } else if (start2 > len) {
    start2 = len;
  }
  if (end2 < 0) {
    end2 += len;
    if (end2 < 0) end2 = 0;
  } else if (end2 > len) {
    end2 = len;
  }
  if (end2 < start2) end2 = start2;
  var newBuf;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start2, end2);
    newBuf.__proto__ = Buffer$2.prototype;
  } else {
    var sliceLen = end2 - start2;
    newBuf = new Buffer$2(sliceLen, void 0);
    for (var i3 = 0; i3 < sliceLen; ++i3) {
      newBuf[i3] = this[i3 + start2];
    }
  }
  return newBuf;
};
function checkOffset2(offset2, ext, length2) {
  if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
  if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
}
Buffer$2.prototype.readUIntLE = function readUIntLE2(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset2(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i3 = 0;
  while (++i3 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i3] * mul;
  }
  return val;
};
Buffer$2.prototype.readUIntBE = function readUIntBE2(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset2(offset2, byteLength5, this.length);
  }
  var val = this[offset2 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset2 + --byteLength5] * mul;
  }
  return val;
};
Buffer$2.prototype.readUInt8 = function readUInt83(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 1, this.length);
  return this[offset2];
};
Buffer$2.prototype.readUInt16LE = function readUInt16LE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 2, this.length);
  return this[offset2] | this[offset2 + 1] << 8;
};
Buffer$2.prototype.readUInt16BE = function readUInt16BE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 2, this.length);
  return this[offset2] << 8 | this[offset2 + 1];
};
Buffer$2.prototype.readUInt32LE = function readUInt32LE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
};
Buffer$2.prototype.readUInt32BE = function readUInt32BE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
};
Buffer$2.prototype.readIntLE = function readIntLE2(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset2(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i3 = 0;
  while (++i3 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i3] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer$2.prototype.readIntBE = function readIntBE2(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset2(offset2, byteLength5, this.length);
  var i3 = byteLength5;
  var mul = 1;
  var val = this[offset2 + --i3];
  while (i3 > 0 && (mul *= 256)) {
    val += this[offset2 + --i3] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer$2.prototype.readInt8 = function readInt82(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 1, this.length);
  if (!(this[offset2] & 128)) return this[offset2];
  return (255 - this[offset2] + 1) * -1;
};
Buffer$2.prototype.readInt16LE = function readInt16LE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 2, this.length);
  var val = this[offset2] | this[offset2 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt16BE = function readInt16BE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 2, this.length);
  var val = this[offset2 + 1] | this[offset2] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt32LE = function readInt32LE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
};
Buffer$2.prototype.readInt32BE = function readInt32BE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
};
Buffer$2.prototype.readFloatLE = function readFloatLE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return read2(this, offset2, true, 23, 4);
};
Buffer$2.prototype.readFloatBE = function readFloatBE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return read2(this, offset2, false, 23, 4);
};
Buffer$2.prototype.readDoubleLE = function readDoubleLE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 8, this.length);
  return read2(this, offset2, true, 52, 8);
};
Buffer$2.prototype.readDoubleBE = function readDoubleBE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 8, this.length);
  return read2(this, offset2, false, 52, 8);
};
function checkInt2(buf, value2, offset2, ext, max2, min2) {
  if (!internalIsBuffer2(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max2 || value2 < min2) throw new RangeError('"value" argument is out of bounds');
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer$2.prototype.writeUIntLE = function writeUIntLE2(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt2(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i3 = 0;
  this[offset2] = value2 & 255;
  while (++i3 < byteLength5 && (mul *= 256)) {
    this[offset2 + i3] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
};
Buffer$2.prototype.writeUIntBE = function writeUIntBE2(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt2(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var i3 = byteLength5 - 1;
  var mul = 1;
  this[offset2 + i3] = value2 & 255;
  while (--i3 >= 0 && (mul *= 256)) {
    this[offset2 + i3] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
};
Buffer$2.prototype.writeUInt8 = function writeUInt82(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 1, 255, 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
function objectWriteUInt162(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i3 = 0, j = Math.min(buf.length - offset2, 2); i3 < j; ++i3) {
    buf[offset2 + i3] = (value2 & 255 << 8 * (littleEndian ? i3 : 1 - i3)) >>> (littleEndian ? i3 : 1 - i3) * 8;
  }
}
Buffer$2.prototype.writeUInt16LE = function writeUInt16LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt162(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer$2.prototype.writeUInt16BE = function writeUInt16BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt162(this, value2, offset2, false);
  }
  return offset2 + 2;
};
function objectWriteUInt322(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i3 = 0, j = Math.min(buf.length - offset2, 4); i3 < j; ++i3) {
    buf[offset2 + i3] = value2 >>> (littleEndian ? i3 : 3 - i3) * 8 & 255;
  }
}
Buffer$2.prototype.writeUInt32LE = function writeUInt32LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer$2.prototype.writeUInt32BE = function writeUInt32BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset2, false);
  }
  return offset2 + 4;
};
Buffer$2.prototype.writeIntLE = function writeIntLE2(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt2(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i3 = 0;
  var mul = 1;
  var sub = 0;
  this[offset2] = value2 & 255;
  while (++i3 < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i3 - 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i3] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
};
Buffer$2.prototype.writeIntBE = function writeIntBE2(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt2(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i3 = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset2 + i3] = value2 & 255;
  while (--i3 >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i3 + 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i3] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
};
Buffer$2.prototype.writeInt8 = function writeInt82(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 1, 127, -128);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
Buffer$2.prototype.writeInt16LE = function writeInt16LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt162(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer$2.prototype.writeInt16BE = function writeInt16BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt162(this, value2, offset2, false);
  }
  return offset2 + 2;
};
Buffer$2.prototype.writeInt32LE = function writeInt32LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 4, 2147483647, -2147483648);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt322(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer$2.prototype.writeInt32BE = function writeInt32BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset2, false);
  }
  return offset2 + 4;
};
function checkIEEE7542(buf, value2, offset2, ext, max2, min2) {
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset2 < 0) throw new RangeError("Index out of range");
}
function writeFloat2(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value2, offset2, 4);
  }
  write3(buf, value2, offset2, littleEndian, 23, 4);
  return offset2 + 4;
}
Buffer$2.prototype.writeFloatLE = function writeFloatLE2(value2, offset2, noAssert) {
  return writeFloat2(this, value2, offset2, true, noAssert);
};
Buffer$2.prototype.writeFloatBE = function writeFloatBE2(value2, offset2, noAssert) {
  return writeFloat2(this, value2, offset2, false, noAssert);
};
function writeDouble2(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value2, offset2, 8);
  }
  write3(buf, value2, offset2, littleEndian, 52, 8);
  return offset2 + 8;
}
Buffer$2.prototype.writeDoubleLE = function writeDoubleLE2(value2, offset2, noAssert) {
  return writeDouble2(this, value2, offset2, true, noAssert);
};
Buffer$2.prototype.writeDoubleBE = function writeDoubleBE2(value2, offset2, noAssert) {
  return writeDouble2(this, value2, offset2, false, noAssert);
};
Buffer$2.prototype.copy = function copy2(target, targetStart, start2, end2) {
  if (!start2) start2 = 0;
  if (!end2 && end2 !== 0) end2 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end2 > 0 && end2 < start2) end2 = start2;
  if (end2 === start2) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start2 < 0 || start2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end2 > this.length) end2 = this.length;
  if (target.length - targetStart < end2 - start2) {
    end2 = target.length - targetStart + start2;
  }
  var len = end2 - start2;
  var i3;
  if (this === target && start2 < targetStart && targetStart < end2) {
    for (i3 = len - 1; i3 >= 0; --i3) {
      target[i3 + targetStart] = this[i3 + start2];
    }
  } else if (len < 1e3 || !Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (i3 = 0; i3 < len; ++i3) {
      target[i3 + targetStart] = this[i3 + start2];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start2, start2 + len),
      targetStart
    );
  }
  return len;
};
Buffer$2.prototype.fill = function fill2(val, start2, end2, encoding) {
  if (typeof val === "string") {
    if (typeof start2 === "string") {
      encoding = start2;
      start2 = 0;
      end2 = this.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer$2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start2 < 0 || this.length < start2 || this.length < end2) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start2) {
    return this;
  }
  start2 = start2 >>> 0;
  end2 = end2 === void 0 ? this.length : end2 >>> 0;
  if (!val) val = 0;
  var i3;
  if (typeof val === "number") {
    for (i3 = start2; i3 < end2; ++i3) {
      this[i3] = val;
    }
  } else {
    var bytes = internalIsBuffer2(val) ? val : utf8ToBytes2(new Buffer$2(val, encoding).toString());
    var len = bytes.length;
    for (i3 = 0; i3 < end2 - start2; ++i3) {
      this[i3 + start2] = bytes[i3 % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE2 = /[^+\/0-9A-Za-z-_]/g;
function base64clean2(str) {
  str = stringtrim2(str).replace(INVALID_BASE64_RE2, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim2(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex$1(n4) {
  if (n4 < 16) return "0" + n4.toString(16);
  return n4.toString(16);
}
function utf8ToBytes2(string, units) {
  units = units || Infinity;
  var codePoint;
  var length2 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i3 = 0; i3 < length2; ++i3) {
    codePoint = string.charCodeAt(i3);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i3 + 1 === length2) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes2(str) {
  var byteArray = [];
  for (var i3 = 0; i3 < str.length; ++i3) {
    byteArray.push(str.charCodeAt(i3) & 255);
  }
  return byteArray;
}
function utf16leToBytes2(str, units) {
  var c3, hi, lo;
  var byteArray = [];
  for (var i3 = 0; i3 < str.length; ++i3) {
    if ((units -= 2) < 0) break;
    c3 = str.charCodeAt(i3);
    hi = c3 >> 8;
    lo = c3 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes2(str) {
  return toByteArray2(base64clean2(str));
}
function blitBuffer2(src, dst, offset2, length2) {
  for (var i3 = 0; i3 < length2; ++i3) {
    if (i3 + offset2 >= dst.length || i3 >= src.length) break;
    dst[i3 + offset2] = src[i3];
  }
  return i3;
}
function isnan2(val) {
  return val !== val;
}
function isBuffer$12(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer2(obj) || isSlowBuffer2(obj));
}
function isFastBuffer2(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer2(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer2(obj.slice(0, 0));
}
var _polyfillNode_buffer2 = Object.freeze({
  __proto__: null,
  Buffer: Buffer$2,
  INSPECT_MAX_BYTES: INSPECT_MAX_BYTES2,
  SlowBuffer: SlowBuffer2,
  isBuffer: isBuffer$12,
  kMaxLength: _kMaxLength2
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace2(n4) {
  if (n4.__esModule) return n4;
  var f2 = n4.default;
  if (typeof f2 == "function") {
    var a3 = function a4() {
      if (this instanceof a4) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a3.prototype = f2.prototype;
  } else a3 = {};
  Object.defineProperty(a3, "__esModule", { value: true });
  Object.keys(n4).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n4, k2);
    Object.defineProperty(a3, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n4[k2];
      }
    });
  });
  return a3;
}
var readableBrowser = { exports: {} };
var _registry = {};
function defaultSetTimout2() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout2() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout2 = defaultSetTimout2;
var cachedClearTimeout2 = defaultClearTimeout2;
if (typeof global$12.setTimeout === "function") {
  cachedSetTimeout2 = setTimeout;
}
if (typeof global$12.clearTimeout === "function") {
  cachedClearTimeout2 = clearTimeout;
}
function runTimeout2(fun) {
  if (cachedSetTimeout2 === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
    cachedSetTimeout2 = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout2(fun, 0);
  } catch (e3) {
    try {
      return cachedSetTimeout2.call(null, fun, 0);
    } catch (e4) {
      return cachedSetTimeout2.call(this, fun, 0);
    }
  }
}
function runClearTimeout2(marker) {
  if (cachedClearTimeout2 === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
    cachedClearTimeout2 = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout2(marker);
  } catch (e3) {
    try {
      return cachedClearTimeout2.call(null, marker);
    } catch (e4) {
      return cachedClearTimeout2.call(this, marker);
    }
  }
}
var queue2 = [];
var draining2 = false;
var currentQueue2;
var queueIndex2 = -1;
function cleanUpNextTick2() {
  if (!draining2 || !currentQueue2) {
    return;
  }
  draining2 = false;
  if (currentQueue2.length) {
    queue2 = currentQueue2.concat(queue2);
  } else {
    queueIndex2 = -1;
  }
  if (queue2.length) {
    drainQueue2();
  }
}
function drainQueue2() {
  if (draining2) {
    return;
  }
  var timeout = runTimeout2(cleanUpNextTick2);
  draining2 = true;
  var len = queue2.length;
  while (len) {
    currentQueue2 = queue2;
    queue2 = [];
    while (++queueIndex2 < len) {
      if (currentQueue2) {
        currentQueue2[queueIndex2].run();
      }
    }
    queueIndex2 = -1;
    len = queue2.length;
  }
  currentQueue2 = null;
  draining2 = false;
  runClearTimeout2(timeout);
}
function nextTick2(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      args[i3 - 1] = arguments[i3];
    }
  }
  queue2.push(new Item2(fun, args));
  if (queue2.length === 1 && !draining2) {
    runTimeout2(drainQueue2);
  }
}
function Item2(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title2 = "browser";
var platform2 = "browser";
var browser$12 = true;
var env2 = {};
var argv2 = [];
var version2 = "";
var versions2 = {};
var release2 = {};
var config$1 = {};
function noop$2() {
}
var on2 = noop$2;
var addListener3 = noop$2;
var once$2 = noop$2;
var off2 = noop$2;
var removeListener3 = noop$2;
var removeAllListeners3 = noop$2;
var emit3 = noop$2;
function binding$12(name) {
  throw new Error("process.binding is not supported");
}
function cwd2() {
  return "/";
}
function chdir2(dir) {
  throw new Error("process.chdir is not supported");
}
function umask2() {
  return 0;
}
var performance3 = global$12.performance || {};
var performanceNow2 = performance3.now || performance3.mozNow || performance3.msNow || performance3.oNow || performance3.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime2(previousTimestamp) {
  var clocktime = performanceNow2.call(performance3) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime2 = /* @__PURE__ */ new Date();
function uptime2() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime2;
  return dif / 1e3;
}
var browser$1$1 = {
  nextTick: nextTick2,
  title: title2,
  browser: browser$12,
  env: env2,
  argv: argv2,
  version: version2,
  versions: versions2,
  on: on2,
  addListener: addListener3,
  once: once$2,
  off: off2,
  removeListener: removeListener3,
  removeAllListeners: removeAllListeners3,
  emit: emit3,
  binding: binding$12,
  cwd: cwd2,
  chdir: chdir2,
  umask: umask2,
  hrtime: hrtime2,
  platform: platform2,
  release: release2,
  config: config$1,
  uptime: uptime2
};
var domain2;
function EventHandlers2() {
}
EventHandlers2.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter2() {
  EventEmitter2.init.call(this);
}
EventEmitter2.EventEmitter = EventEmitter2;
EventEmitter2.usingDomains = false;
EventEmitter2.prototype.domain = void 0;
EventEmitter2.prototype._events = void 0;
EventEmitter2.prototype._maxListeners = void 0;
EventEmitter2.defaultMaxListeners = 10;
EventEmitter2.init = function() {
  this.domain = null;
  if (EventEmitter2.usingDomains) {
    if (domain2.active && !(this instanceof domain2.Domain)) {
      this.domain = domain2.active;
    }
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers2();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter2.prototype.setMaxListeners = function setMaxListeners2(n4) {
  if (typeof n4 !== "number" || n4 < 0 || isNaN(n4))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n4;
  return this;
};
function $getMaxListeners2(that) {
  if (that._maxListeners === void 0)
    return EventEmitter2.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter2.prototype.getMaxListeners = function getMaxListeners2() {
  return $getMaxListeners2(this);
};
function emitNone2(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i3 = 0; i3 < len; ++i3)
      listeners3[i3].call(self2);
  }
}
function emitOne2(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i3 = 0; i3 < len; ++i3)
      listeners3[i3].call(self2, arg1);
  }
}
function emitTwo2(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i3 = 0; i3 < len; ++i3)
      listeners3[i3].call(self2, arg1, arg2);
  }
}
function emitThree2(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i3 = 0; i3 < len; ++i3)
      listeners3[i3].call(self2, arg1, arg2, arg3);
  }
}
function emitMany2(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i3 = 0; i3 < len; ++i3)
      listeners3[i3].apply(self2, args);
  }
}
EventEmitter2.prototype.emit = function emit4(type) {
  var er, handler, len, args, i3, events2, domain3;
  var doError = type === "error";
  events2 = this._events;
  if (events2)
    doError = doError && events2.error == null;
  else if (!doError)
    return false;
  domain3 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain3) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain3;
      er.domainThrown = false;
      domain3.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err2 = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err2.context = er;
      throw err2;
    }
    return false;
  }
  handler = events2[type];
  if (!handler)
    return false;
  var isFn = typeof handler === "function";
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone2(handler, isFn, this);
      break;
    case 2:
      emitOne2(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo2(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree2(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i3 = 1; i3 < len; i3++)
        args[i3 - 1] = arguments[i3];
      emitMany2(handler, isFn, this, args);
  }
  return true;
};
function _addListener2(target, type, listener, prepend) {
  var m;
  var events2;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = target._events;
  if (!events2) {
    events2 = target._events = new EventHandlers2();
    target._eventsCount = 0;
  } else {
    if (events2.newListener) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (!existing) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners2(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning2(w);
      }
    }
  }
  return target;
}
function emitWarning2(e3) {
  typeof console.warn === "function" ? console.warn(e3) : console.log(e3);
}
EventEmitter2.prototype.addListener = function addListener4(type, listener) {
  return _addListener2(this, type, listener, false);
};
EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
EventEmitter2.prototype.prependListener = function prependListener3(type, listener) {
  return _addListener2(this, type, listener, true);
};
function _onceWrap2(target, type, listener) {
  var fired = false;
  function g2() {
    target.removeListener(type, g2);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g2.listener = listener;
  return g2;
}
EventEmitter2.prototype.once = function once3(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap2(this, type, listener));
  return this;
};
EventEmitter2.prototype.prependOnceListener = function prependOnceListener2(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap2(this, type, listener));
  return this;
};
EventEmitter2.prototype.removeListener = function removeListener4(type, listener) {
  var list, events2, position, i3, originalListener;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = this._events;
  if (!events2)
    return this;
  list = events2[type];
  if (!list)
    return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers2();
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i3 = list.length; i3-- > 0; ) {
      if (list[i3] === listener || list[i3].listener && list[i3].listener === listener) {
        originalListener = list[i3].listener;
        position = i3;
        break;
      }
    }
    if (position < 0)
      return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers2();
        return this;
      } else {
        delete events2[type];
      }
    } else {
      spliceOne2(list, position);
    }
    if (events2.removeListener)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter2.prototype.off = function(type, listener) {
  return this.removeListener(type, listener);
};
EventEmitter2.prototype.removeAllListeners = function removeAllListeners4(type) {
  var listeners3, events2;
  events2 = this._events;
  if (!events2)
    return this;
  if (!events2.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers2();
      this._eventsCount = 0;
    } else if (events2[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers2();
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    for (var i3 = 0, key; i3 < keys2.length; ++i3) {
      key = keys2[i3];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers2();
    this._eventsCount = 0;
    return this;
  }
  listeners3 = events2[type];
  if (typeof listeners3 === "function") {
    this.removeListener(type, listeners3);
  } else if (listeners3) {
    do {
      this.removeListener(type, listeners3[listeners3.length - 1]);
    } while (listeners3[0]);
  }
  return this;
};
EventEmitter2.prototype.listeners = function listeners2(type) {
  var evlistener;
  var ret;
  var events2 = this._events;
  if (!events2)
    ret = [];
  else {
    evlistener = events2[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === "function")
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners2(evlistener);
  }
  return ret;
};
EventEmitter2.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount2.call(emitter, type);
  }
};
EventEmitter2.prototype.listenerCount = listenerCount2;
function listenerCount2(type) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter2.prototype.eventNames = function eventNames2() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function spliceOne2(list, index3) {
  for (var i3 = index3, k2 = i3 + 1, n4 = list.length; k2 < n4; i3 += 1, k2 += 1)
    list[i3] = list[k2];
  list.pop();
}
function arrayClone2(arr, i3) {
  var copy5 = new Array(i3);
  while (i3--)
    copy5[i3] = arr[i3];
  return copy5;
}
function unwrapListeners2(arr) {
  var ret = new Array(arr.length);
  for (var i3 = 0; i3 < ret.length; ++i3) {
    ret[i3] = arr[i3].listener || arr[i3];
  }
  return ret;
}
var _polyfillNode_events = Object.freeze({
  __proto__: null,
  EventEmitter: EventEmitter2,
  default: EventEmitter2
});
var require$$1$1 = getAugmentedNamespace2(_polyfillNode_events);
var streamBrowser = require$$1$1.EventEmitter;
var require$$02 = getAugmentedNamespace2(_polyfillNode_buffer2);
var inherits$2;
if (typeof Object.create === "function") {
  inherits$2 = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits$2 = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var getOwnPropertyDescriptors3 = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors4(obj) {
  var keys2 = Object.keys(obj);
  var descriptors = {};
  for (var i3 = 0; i3 < keys2.length; i3++) {
    descriptors[keys2[i3]] = Object.getOwnPropertyDescriptor(obj, keys2[i3]);
  }
  return descriptors;
};
var formatRegExp2 = /%[sdj%]/g;
function format2(f2) {
  if (!isString2(f2)) {
    var objects = [];
    for (var i3 = 0; i3 < arguments.length; i3++) {
      objects.push(inspect$12(arguments[i3]));
    }
    return objects.join(" ");
  }
  var i3 = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f2).replace(formatRegExp2, function(x2) {
    if (x2 === "%%") return "%";
    if (i3 >= len) return x2;
    switch (x2) {
      case "%s":
        return String(args[i3++]);
      case "%d":
        return Number(args[i3++]);
      case "%j":
        try {
          return JSON.stringify(args[i3++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i3]; i3 < len; x = args[++i3]) {
    if (isNull2(x) || !isObject2(x)) {
      str += " " + x;
    } else {
      str += " " + inspect$12(x);
    }
  }
  return str;
}
function deprecate$1(fn, msg2) {
  if (isUndefined2(global$12.process)) {
    return function() {
      return deprecate$1(fn, msg2).apply(this, arguments);
    };
  }
  if (browser$1$1.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1$1.throwDeprecation) {
        throw new Error(msg2);
      } else if (browser$1$1.traceDeprecation) {
        console.trace(msg2);
      } else {
        console.error(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs2 = {};
var debugEnviron2;
function debuglog2(set5) {
  if (isUndefined2(debugEnviron2))
    debugEnviron2 = browser$1$1.env.NODE_DEBUG || "";
  set5 = set5.toUpperCase();
  if (!debugs2[set5]) {
    if (new RegExp("\\b" + set5 + "\\b", "i").test(debugEnviron2)) {
      var pid = 0;
      debugs2[set5] = function() {
        var msg2 = format2.apply(null, arguments);
        console.error("%s %d: %s", set5, pid, msg2);
      };
    } else {
      debugs2[set5] = function() {
      };
    }
  }
  return debugs2[set5];
}
function inspect$12(obj, opts2) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor2
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean2(opts2)) {
    ctx.showHidden = opts2;
  } else if (opts2) {
    _extend2(ctx, opts2);
  }
  if (isUndefined2(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined2(ctx.depth)) ctx.depth = 2;
  if (isUndefined2(ctx.colors)) ctx.colors = false;
  if (isUndefined2(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor2;
  return formatValue2(ctx, obj, ctx.depth);
}
inspect$12.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect$12.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor2(str, styleType) {
  var style = inspect$12.styles[styleType];
  if (style) {
    return "\x1B[" + inspect$12.colors[style][0] + "m" + str + "\x1B[" + inspect$12.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor2(str, styleType) {
  return str;
}
function arrayToHash2(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue2(ctx, value2, recurseTimes) {
  if (ctx.customInspect && value2 && isFunction2(value2.inspect) && // Filter out the util module, it's inspect function is special
  value2.inspect !== inspect$12 && // Also filter out any prototype objects using the circular check.
  !(value2.constructor && value2.constructor.prototype === value2)) {
    var ret = value2.inspect(recurseTimes, ctx);
    if (!isString2(ret)) {
      ret = formatValue2(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive2(ctx, value2);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value2);
  var visibleKeys = arrayToHash2(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value2);
  }
  if (isError2(value2) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError2(value2);
  }
  if (keys2.length === 0) {
    if (isFunction2(value2)) {
      var name = value2.name ? ": " + value2.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp2(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    }
    if (isDate2(value2)) {
      return ctx.stylize(Date.prototype.toString.call(value2), "date");
    }
    if (isError2(value2)) {
      return formatError2(value2);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray2(value2)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction2(value2)) {
    var n4 = value2.name ? ": " + value2.name : "";
    base = " [Function" + n4 + "]";
  }
  if (isRegExp2(value2)) {
    base = " " + RegExp.prototype.toString.call(value2);
  }
  if (isDate2(value2)) {
    base = " " + Date.prototype.toUTCString.call(value2);
  }
  if (isError2(value2)) {
    base = " " + formatError2(value2);
  }
  if (keys2.length === 0 && (!array || value2.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp2(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value2);
  var output;
  if (array) {
    output = formatArray2(ctx, value2, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty2(ctx, value2, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString2(output, base, braces);
}
function formatPrimitive2(ctx, value2) {
  if (isUndefined2(value2))
    return ctx.stylize("undefined", "undefined");
  if (isString2(value2)) {
    var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber2(value2))
    return ctx.stylize("" + value2, "number");
  if (isBoolean2(value2))
    return ctx.stylize("" + value2, "boolean");
  if (isNull2(value2))
    return ctx.stylize("null", "null");
}
function formatError2(value2) {
  return "[" + Error.prototype.toString.call(value2) + "]";
}
function formatArray2(ctx, value2, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i3 = 0, l2 = value2.length; i3 < l2; ++i3) {
    if (hasOwnProperty2(value2, String(i3))) {
      output.push(formatProperty2(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        String(i3),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty2(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty2(ctx, value2, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty2(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull2(recurseTimes)) {
        str = formatValue2(ctx, desc.value, null);
      } else {
        str = formatValue2(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line2) {
            return "  " + line2;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line2) {
            return "   " + line2;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined2(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString2(output, base, braces) {
  var length2 = output.reduce(function(prev, cur) {
    if (cur.indexOf("\n") >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length2 > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray2(ar) {
  return Array.isArray(ar);
}
function isBoolean2(arg) {
  return typeof arg === "boolean";
}
function isNull2(arg) {
  return arg === null;
}
function isNullOrUndefined2(arg) {
  return arg == null;
}
function isNumber2(arg) {
  return typeof arg === "number";
}
function isString2(arg) {
  return typeof arg === "string";
}
function isSymbol2(arg) {
  return typeof arg === "symbol";
}
function isUndefined2(arg) {
  return arg === void 0;
}
function isRegExp2(re) {
  return isObject2(re) && objectToString2(re) === "[object RegExp]";
}
function isObject2(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate2(d2) {
  return isObject2(d2) && objectToString2(d2) === "[object Date]";
}
function isError2(e3) {
  return isObject2(e3) && (objectToString2(e3) === "[object Error]" || e3 instanceof Error);
}
function isFunction2(arg) {
  return typeof arg === "function";
}
function isPrimitive2(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
function isBuffer2(maybeBuf) {
  return Buffer$2.isBuffer(maybeBuf);
}
function objectToString2(o2) {
  return Object.prototype.toString.call(o2);
}
function pad$1(n4) {
  return n4 < 10 ? "0" + n4.toString(10) : n4.toString(10);
}
var months2 = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp2() {
  var d2 = /* @__PURE__ */ new Date();
  var time = [
    pad$1(d2.getHours()),
    pad$1(d2.getMinutes()),
    pad$1(d2.getSeconds())
  ].join(":");
  return [d2.getDate(), months2[d2.getMonth()], time].join(" ");
}
function log2() {
  console.log("%s - %s", timestamp2(), format2.apply(null, arguments));
}
function _extend2(origin, add2) {
  if (!add2 || !isObject2(add2)) return origin;
  var keys2 = Object.keys(add2);
  var i3 = keys2.length;
  while (i3--) {
    origin[keys2[i3]] = add2[keys2[i3]];
  }
  return origin;
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol2 = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
function promisify2(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol2 && original[kCustomPromisifiedSymbol2]) {
    var fn = original[kCustomPromisifiedSymbol2];
    if (typeof fn !== "function") {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol2, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }
  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function(resolve3, reject) {
      promiseResolve = resolve3;
      promiseReject = reject;
    });
    var args = [];
    for (var i3 = 0; i3 < arguments.length; i3++) {
      args.push(arguments[i3]);
    }
    args.push(function(err2, value2) {
      if (err2) {
        promiseReject(err2);
      } else {
        promiseResolve(value2);
      }
    });
    try {
      original.apply(this, args);
    } catch (err2) {
      promiseReject(err2);
    }
    return promise;
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol2) Object.defineProperty(fn, kCustomPromisifiedSymbol2, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors3(original)
  );
}
promisify2.custom = kCustomPromisifiedSymbol2;
function callbackifyOnRejected2(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
function callbackify2(original) {
  if (typeof original !== "function") {
    throw new TypeError('The "original" argument must be of type Function');
  }
  function callbackified() {
    var args = [];
    for (var i3 = 0; i3 < arguments.length; i3++) {
      args.push(arguments[i3]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new TypeError("The last argument must be of type Function");
    }
    var self2 = this;
    var cb = function() {
      return maybeCb.apply(self2, arguments);
    };
    original.apply(this, args).then(
      function(ret) {
        browser$1$1.nextTick(cb.bind(null, null, ret));
      },
      function(rej) {
        browser$1$1.nextTick(callbackifyOnRejected2.bind(null, rej, cb));
      }
    );
  }
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors3(original));
  return callbackified;
}
var _polyfillNode_util2 = {
  inherits: inherits$2,
  _extend: _extend2,
  log: log2,
  isBuffer: isBuffer2,
  isPrimitive: isPrimitive2,
  isFunction: isFunction2,
  isError: isError2,
  isDate: isDate2,
  isObject: isObject2,
  isRegExp: isRegExp2,
  isUndefined: isUndefined2,
  isSymbol: isSymbol2,
  isString: isString2,
  isNumber: isNumber2,
  isNullOrUndefined: isNullOrUndefined2,
  isNull: isNull2,
  isBoolean: isBoolean2,
  isArray: isArray2,
  inspect: inspect$12,
  deprecate: deprecate$1,
  format: format2,
  debuglog: debuglog2,
  promisify: promisify2,
  callbackify: callbackify2
};
var _polyfillNode_util$12 = Object.freeze({
  __proto__: null,
  _extend: _extend2,
  callbackify: callbackify2,
  debuglog: debuglog2,
  default: _polyfillNode_util2,
  deprecate: deprecate$1,
  format: format2,
  inherits: inherits$2,
  inspect: inspect$12,
  isArray: isArray2,
  isBoolean: isBoolean2,
  isBuffer: isBuffer2,
  isDate: isDate2,
  isError: isError2,
  isFunction: isFunction2,
  isNull: isNull2,
  isNullOrUndefined: isNullOrUndefined2,
  isNumber: isNumber2,
  isObject: isObject2,
  isPrimitive: isPrimitive2,
  isRegExp: isRegExp2,
  isString: isString2,
  isSymbol: isSymbol2,
  isUndefined: isUndefined2,
  log: log2,
  promisify: promisify2
});
var require$$32 = getAugmentedNamespace2(_polyfillNode_util$12);
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3] != null ? arguments[i3] : {};
      if (i3 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    return Constructor;
  }
  var _require2 = require$$02, Buffer5 = _require2.Buffer;
  var _require22 = require$$32, inspect6 = _require22.inspect;
  var custom = inspect6 && inspect6.custom || "inspect";
  function copyBuffer(src, target, offset2) {
    Buffer5.prototype.copy.call(src, target, offset2);
  }
  buffer_list = function() {
    function BufferList3() {
      _classCallCheck(this, BufferList3);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList3, [{
      key: "push",
      value: function push(v2) {
        var entry = {
          data: v2,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v2) {
        var entry = {
          data: v2,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s2) {
        if (this.length === 0) return "";
        var p2 = this.head;
        var ret = "" + p2.data;
        while (p2 = p2.next) {
          ret += s2 + p2.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat5(n4) {
        if (this.length === 0) return Buffer5.alloc(0);
        var ret = Buffer5.allocUnsafe(n4 >>> 0);
        var p2 = this.head;
        var i3 = 0;
        while (p2) {
          copyBuffer(p2.data, ret, i3);
          i3 += p2.data.length;
          p2 = p2.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n4, hasStrings) {
        var ret;
        if (n4 < this.head.data.length) {
          ret = this.head.data.slice(0, n4);
          this.head.data = this.head.data.slice(n4);
        } else if (n4 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n4) : this._getBuffer(n4);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n4) {
        var p2 = this.head;
        var c3 = 1;
        var ret = p2.data;
        n4 -= ret.length;
        while (p2 = p2.next) {
          var str = p2.data;
          var nb = n4 > str.length ? str.length : n4;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n4);
          n4 -= nb;
          if (n4 === 0) {
            if (nb === str.length) {
              ++c3;
              if (p2.next) this.head = p2.next;
              else this.head = this.tail = null;
            } else {
              this.head = p2;
              p2.data = str.slice(nb);
            }
            break;
          }
          ++c3;
        }
        this.length -= c3;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n4) {
        var ret = Buffer5.allocUnsafe(n4);
        var p2 = this.head;
        var c3 = 1;
        p2.data.copy(ret);
        n4 -= p2.data.length;
        while (p2 = p2.next) {
          var buf = p2.data;
          var nb = n4 > buf.length ? buf.length : n4;
          buf.copy(ret, ret.length - n4, 0, nb);
          n4 -= nb;
          if (n4 === 0) {
            if (nb === buf.length) {
              ++c3;
              if (p2.next) this.head = p2.next;
              else this.head = this.tail = null;
            } else {
              this.head = p2;
              p2.data = buf.slice(nb);
            }
            break;
          }
          ++c3;
        }
        this.length -= c3;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value2(_, options) {
        return inspect6(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList3;
  }();
  return buffer_list;
}
function destroy(err2, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err2);
    } else if (err2) {
      if (!this._writableState) {
        browser$1$1.nextTick(emitErrorNT, this, err2);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        browser$1$1.nextTick(emitErrorNT, this, err2);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err2 || null, function(err3) {
    if (!cb && err3) {
      if (!_this._writableState) {
        browser$1$1.nextTick(emitErrorAndCloseNT, _this, err3);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        browser$1$1.nextTick(emitErrorAndCloseNT, _this, err3);
      } else {
        browser$1$1.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      browser$1$1.nextTick(emitCloseNT, _this);
      cb(err3);
    } else {
      browser$1$1.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self2, err2) {
  emitErrorNT(self2, err2);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  if (self2._writableState && !self2._writableState.emitClose) return;
  if (self2._readableState && !self2._readableState.emitClose) return;
  self2.emit("close");
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self2, err2) {
  self2.emit("error", err2);
}
function errorOrDestroy$2(stream2, err2) {
  var rState = stream2._readableState;
  var wState = stream2._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream2.destroy(err2);
  else stream2.emit("error", err2);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy: errorOrDestroy$2
};
var errorsBrowser = {};
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code, message, Base2) {
  if (!Base2) {
    Base2 = Error;
  }
  function getMessage3(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = function(_Base) {
    _inheritsLoose(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      return _Base.call(this, getMessage3(arg1, arg2, arg3)) || this;
    }
    return NodeError2;
  }(Base2);
  NodeError.prototype.name = Base2.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
}
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function(i3) {
      return String(i3);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith(str, search, pos) {
  return str.substr(0, search.length) === search;
}
function endsWith(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes3(str, search, start2) {
  if (typeof start2 !== "number") {
    start2 = 0;
  }
  if (start2 + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start2) !== -1;
  }
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name, value2) {
  return 'The value "' + value2 + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
  var determiner;
  if (typeof expected === "string" && startsWith(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg2;
  if (endsWith(name, " argument")) {
    msg2 = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  } else {
    var type = includes3(name, ".") ? "property" : "argument";
    msg2 = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  }
  msg2 += ". Received type ".concat(typeof actual);
  return msg2;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
  return "The " + name + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name) {
  return "Cannot call " + name + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
  return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark$2(state2, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }
  return state2.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark: getHighWaterMark$2
};
var inherits2;
if (typeof Object.create === "function") {
  inherits2 = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits2 = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$12 = inherits2;
var _polyfillNode_inherits = Object.freeze({
  __proto__: null,
  default: inherits$12
});
var require$$12 = getAugmentedNamespace2(_polyfillNode_inherits);
var isBufferEncoding2 = Buffer$2.isEncoding || function(encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function assertEncoding2(encoding) {
  if (encoding && !isBufferEncoding2(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder$1(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding2(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar2;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar2;
      break;
    default:
      this.write = passThroughWrite2;
      return;
  }
  this.charBuffer = new Buffer$2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
StringDecoder$1.prototype.write = function(buffer) {
  var charStr = "";
  while (this.charLength) {
    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      return "";
    }
    buffer = buffer.slice(available, buffer.length);
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 55296 && charCode <= 56319) {
      this.charLength += this.surrogateSize;
      charStr = "";
      continue;
    }
    this.charReceived = this.charLength = 0;
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }
  this.detectIncompleteChar(buffer);
  var end2 = buffer.length;
  if (this.charLength) {
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end2);
    end2 -= this.charReceived;
  }
  charStr += buffer.toString(this.encoding, 0, end2);
  var end2 = charStr.length - 1;
  var charCode = charStr.charCodeAt(end2);
  if (charCode >= 55296 && charCode <= 56319) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end2);
  }
  return charStr;
};
StringDecoder$1.prototype.detectIncompleteChar = function(buffer) {
  var i3 = buffer.length >= 3 ? 3 : buffer.length;
  for (; i3 > 0; i3--) {
    var c3 = buffer[buffer.length - i3];
    if (i3 == 1 && c3 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (i3 <= 2 && c3 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (i3 <= 3 && c3 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i3;
};
StringDecoder$1.prototype.end = function(buffer) {
  var res = "";
  if (buffer && buffer.length)
    res = this.write(buffer);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite2(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar2(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar2(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var _polyfillNode_string_decoder = Object.freeze({
  __proto__: null,
  StringDecoder: StringDecoder$1
});
var require$$10 = getAugmentedNamespace2(_polyfillNode_string_decoder);
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(callback) {
  var called = false;
  return function() {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop$1() {
}
function isRequest$1(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function eos$1(stream2, opts2, callback) {
  if (typeof opts2 === "function") return eos$1(stream2, null, opts2);
  if (!opts2) opts2 = {};
  callback = once$1(callback || noop$1);
  var readable = opts2.readable || opts2.readable !== false && stream2.readable;
  var writable = opts2.writable || opts2.writable !== false && stream2.writable;
  var onlegacyfinish = function onlegacyfinish2() {
    if (!stream2.writable) onfinish();
  };
  var writableEnded = stream2._writableState && stream2._writableState.finished;
  var onfinish = function onfinish2() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream2);
  };
  var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
  var onend3 = function onend4() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream2);
  };
  var onerror = function onerror2(err2) {
    callback.call(stream2, err2);
  };
  var onclose = function onclose2() {
    var err2;
    if (readable && !readableEnded) {
      if (!stream2._readableState || !stream2._readableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err2);
    }
    if (writable && !writableEnded) {
      if (!stream2._writableState || !stream2._writableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err2);
    }
  };
  var onrequest = function onrequest2() {
    stream2.req.on("finish", onfinish);
  };
  if (isRequest$1(stream2)) {
    stream2.on("complete", onfinish);
    stream2.on("abort", onclose);
    if (stream2.req) onrequest();
    else stream2.on("request", onrequest);
  } else if (writable && !stream2._writableState) {
    stream2.on("end", onlegacyfinish);
    stream2.on("close", onlegacyfinish);
  }
  stream2.on("end", onend3);
  stream2.on("finish", onfinish);
  if (opts2.error !== false) stream2.on("error", onerror);
  stream2.on("close", onclose);
  return function() {
    stream2.removeListener("complete", onfinish);
    stream2.removeListener("abort", onclose);
    stream2.removeListener("request", onrequest);
    if (stream2.req) stream2.req.removeListener("finish", onfinish);
    stream2.removeListener("end", onlegacyfinish);
    stream2.removeListener("close", onlegacyfinish);
    stream2.removeListener("finish", onfinish);
    stream2.removeListener("end", onend3);
    stream2.removeListener("error", onerror);
    stream2.removeListener("close", onclose);
  };
}
var endOfStream = eos$1;
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  var finished = endOfStream;
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value2, done3) {
    return {
      value: value2,
      done: done3
    };
  }
  function readAndResolve(iter) {
    var resolve3 = iter[kLastResolve];
    if (resolve3 !== null) {
      var data2 = iter[kStream].read();
      if (data2 !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve3(createIterResult(data2, false));
      }
    }
  }
  function onReadable(iter) {
    browser$1$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve3, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve3(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve3, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve3, reject) {
          browser$1$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve3(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data2 = this[kStream].read();
        if (data2 !== null) {
          return Promise.resolve(createIterResult(data2, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve3, reject) {
      _this2[kStream].destroy(null, function(err2) {
        if (err2) {
          reject(err2);
          return;
        }
        resolve3(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator2 = function createReadableStreamAsyncIterator3(stream2) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value2(resolve3, reject) {
        var data2 = iterator[kStream].read();
        if (data2) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve3(createIterResult(data2, false));
        } else {
          iterator[kLastResolve] = resolve3;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream2, function(err2) {
      if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err2);
        }
        iterator[kError] = err2;
        return;
      }
      var resolve3 = iterator[kLastResolve];
      if (resolve3 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve3(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator2;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var Registry$4 = _registry;
Registry$4.Readable = Readable2;
Readable2.ReadableState = ReadableState2;
require$$1$1.EventEmitter;
var EElistenerCount = function EElistenerCount2(emitter, type) {
  return emitter.listeners(type).length;
};
var Stream$1 = streamBrowser;
var Buffer$1 = require$$02.Buffer;
var OurUint8Array$1 = commonjsGlobal.Uint8Array || function() {
};
function _uint8ArrayToBuffer$1(chunk) {
  return Buffer$1.from(chunk);
}
function _isUint8Array$1(obj) {
  return Buffer$1.isBuffer(obj) || obj instanceof OurUint8Array$1;
}
var debugUtil = require$$32;
var debug2;
if (debugUtil && debugUtil.debuglog) {
  debug2 = debugUtil.debuglog("stream");
} else {
  debug2 = function debug3() {
  };
}
var BufferList2 = requireBuffer_list();
var destroyImpl$1 = destroy_1;
var _require$1 = state;
var getHighWaterMark$1 = _require$1.getHighWaterMark;
var _require$codes$3 = errorsBrowser.codes;
var ERR_INVALID_ARG_TYPE$1 = _require$codes$3.ERR_INVALID_ARG_TYPE;
var ERR_STREAM_PUSH_AFTER_EOF = _require$codes$3.ERR_STREAM_PUSH_AFTER_EOF;
var ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$3.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
var StringDecoder2;
var createReadableStreamAsyncIterator;
var from2;
require$$12(Readable2, Stream$1);
var errorOrDestroy$1 = destroyImpl$1.errorOrDestroy;
var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
function prependListener4(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
  else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
  else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState2(options, stream2, isDuplex) {
  options = options || {};
  if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Registry$4.Duplex;
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
  this.highWaterMark = getHighWaterMark$1(this, options, "readableHighWaterMark", isDuplex);
  this.buffer = new BufferList2();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.destroyed = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder2) StringDecoder2 = require$$10.StringDecoder;
    this.decoder = new StringDecoder2(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable2(options) {
  if (!(this instanceof Readable2)) return new Readable2(options);
  var isDuplex = this instanceof Registry$4.Duplex;
  this._readableState = new ReadableState2(options, this, isDuplex);
  this.readable = true;
  if (options) {
    if (typeof options.read === "function") this._read = options.read;
    if (typeof options.destroy === "function") this._destroy = options.destroy;
  }
  Stream$1.call(this);
}
Object.defineProperty(Readable2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get2() {
    if (this._readableState === void 0) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value2) {
    if (!this._readableState) {
      return;
    }
    this._readableState.destroyed = value2;
  }
});
Readable2.prototype.destroy = destroyImpl$1.destroy;
Readable2.prototype._undestroy = destroyImpl$1.undestroy;
Readable2.prototype._destroy = function(err2, cb) {
  cb(err2);
};
Readable2.prototype.push = function(chunk, encoding) {
  var state2 = this._readableState;
  var skipChunkCheck;
  if (!state2.objectMode) {
    if (typeof chunk === "string") {
      encoding = encoding || state2.defaultEncoding;
      if (encoding !== state2.encoding) {
        chunk = Buffer$1.from(chunk, encoding);
        encoding = "";
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
};
Readable2.prototype.unshift = function(chunk) {
  return readableAddChunk2(this, chunk, null, true, false);
};
function readableAddChunk2(stream2, chunk, encoding, addToFront, skipChunkCheck) {
  debug2("readableAddChunk", chunk);
  var state2 = stream2._readableState;
  if (chunk === null) {
    state2.reading = false;
    onEofChunk2(stream2, state2);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid2(state2, chunk);
    if (er) {
      errorOrDestroy$1(stream2, er);
    } else if (state2.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer$1.prototype) {
        chunk = _uint8ArrayToBuffer$1(chunk);
      }
      if (addToFront) {
        if (state2.endEmitted) errorOrDestroy$1(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
        else addChunk(stream2, state2, chunk, true);
      } else if (state2.ended) {
        errorOrDestroy$1(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state2.destroyed) {
        return false;
      } else {
        state2.reading = false;
        if (state2.decoder && !encoding) {
          chunk = state2.decoder.write(chunk);
          if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
          else maybeReadMore2(stream2, state2);
        } else {
          addChunk(stream2, state2, chunk, false);
        }
      }
    } else if (!addToFront) {
      state2.reading = false;
      maybeReadMore2(stream2, state2);
    }
  }
  return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
}
function addChunk(stream2, state2, chunk, addToFront) {
  if (state2.flowing && state2.length === 0 && !state2.sync) {
    state2.awaitDrain = 0;
    stream2.emit("data", chunk);
  } else {
    state2.length += state2.objectMode ? 1 : chunk.length;
    if (addToFront) state2.buffer.unshift(chunk);
    else state2.buffer.push(chunk);
    if (state2.needReadable) emitReadable2(stream2);
  }
  maybeReadMore2(stream2, state2);
}
function chunkInvalid2(state2, chunk) {
  var er;
  if (!_isUint8Array$1(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
    er = new ERR_INVALID_ARG_TYPE$1("chunk", ["string", "Buffer", "Uint8Array"], chunk);
  }
  return er;
}
Readable2.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
Readable2.prototype.setEncoding = function(enc) {
  if (!StringDecoder2) StringDecoder2 = require$$10.StringDecoder;
  var decoder2 = new StringDecoder2(enc);
  this._readableState.decoder = decoder2;
  this._readableState.encoding = this._readableState.decoder.encoding;
  var p2 = this._readableState.buffer.head;
  var content = "";
  while (p2 !== null) {
    content += decoder2.write(p2.data);
    p2 = p2.next;
  }
  this._readableState.buffer.clear();
  if (content !== "") this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};
var MAX_HWM2 = 1073741824;
function computeNewHighWaterMark2(n4) {
  if (n4 >= MAX_HWM2) {
    n4 = MAX_HWM2;
  } else {
    n4--;
    n4 |= n4 >>> 1;
    n4 |= n4 >>> 2;
    n4 |= n4 >>> 4;
    n4 |= n4 >>> 8;
    n4 |= n4 >>> 16;
    n4++;
  }
  return n4;
}
function howMuchToRead2(n4, state2) {
  if (n4 <= 0 || state2.length === 0 && state2.ended) return 0;
  if (state2.objectMode) return 1;
  if (n4 !== n4) {
    if (state2.flowing && state2.length) return state2.buffer.head.data.length;
    else return state2.length;
  }
  if (n4 > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark2(n4);
  if (n4 <= state2.length) return n4;
  if (!state2.ended) {
    state2.needReadable = true;
    return 0;
  }
  return state2.length;
}
Readable2.prototype.read = function(n4) {
  debug2("read", n4);
  n4 = parseInt(n4, 10);
  var state2 = this._readableState;
  var nOrig = n4;
  if (n4 !== 0) state2.emittedReadable = false;
  if (n4 === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
    debug2("read: emitReadable", state2.length, state2.ended);
    if (state2.length === 0 && state2.ended) endReadable2(this);
    else emitReadable2(this);
    return null;
  }
  n4 = howMuchToRead2(n4, state2);
  if (n4 === 0 && state2.ended) {
    if (state2.length === 0) endReadable2(this);
    return null;
  }
  var doRead = state2.needReadable;
  debug2("need readable", doRead);
  if (state2.length === 0 || state2.length - n4 < state2.highWaterMark) {
    doRead = true;
    debug2("length less than watermark", doRead);
  }
  if (state2.ended || state2.reading) {
    doRead = false;
    debug2("reading or ended", doRead);
  } else if (doRead) {
    debug2("do read");
    state2.reading = true;
    state2.sync = true;
    if (state2.length === 0) state2.needReadable = true;
    this._read(state2.highWaterMark);
    state2.sync = false;
    if (!state2.reading) n4 = howMuchToRead2(nOrig, state2);
  }
  var ret;
  if (n4 > 0) ret = fromList2(n4, state2);
  else ret = null;
  if (ret === null) {
    state2.needReadable = state2.length <= state2.highWaterMark;
    n4 = 0;
  } else {
    state2.length -= n4;
    state2.awaitDrain = 0;
  }
  if (state2.length === 0) {
    if (!state2.ended) state2.needReadable = true;
    if (nOrig !== n4 && state2.ended) endReadable2(this);
  }
  if (ret !== null) this.emit("data", ret);
  return ret;
};
function onEofChunk2(stream2, state2) {
  debug2("onEofChunk");
  if (state2.ended) return;
  if (state2.decoder) {
    var chunk = state2.decoder.end();
    if (chunk && chunk.length) {
      state2.buffer.push(chunk);
      state2.length += state2.objectMode ? 1 : chunk.length;
    }
  }
  state2.ended = true;
  if (state2.sync) {
    emitReadable2(stream2);
  } else {
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      state2.emittedReadable = true;
      emitReadable_2(stream2);
    }
  }
}
function emitReadable2(stream2) {
  var state2 = stream2._readableState;
  debug2("emitReadable", state2.needReadable, state2.emittedReadable);
  state2.needReadable = false;
  if (!state2.emittedReadable) {
    debug2("emitReadable", state2.flowing);
    state2.emittedReadable = true;
    browser$1$1.nextTick(emitReadable_2, stream2);
  }
}
function emitReadable_2(stream2) {
  var state2 = stream2._readableState;
  debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
  if (!state2.destroyed && (state2.length || state2.ended)) {
    stream2.emit("readable");
    state2.emittedReadable = false;
  }
  state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
  flow2(stream2);
}
function maybeReadMore2(stream2, state2) {
  if (!state2.readingMore) {
    state2.readingMore = true;
    browser$1$1.nextTick(maybeReadMore_2, stream2, state2);
  }
}
function maybeReadMore_2(stream2, state2) {
  while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
    var len = state2.length;
    debug2("maybeReadMore read 0");
    stream2.read(0);
    if (len === state2.length)
      break;
  }
  state2.readingMore = false;
}
Readable2.prototype._read = function(n4) {
  errorOrDestroy$1(this, new ERR_METHOD_NOT_IMPLEMENTED$2("_read()"));
};
Readable2.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state2 = this._readableState;
  switch (state2.pipesCount) {
    case 0:
      state2.pipes = dest;
      break;
    case 1:
      state2.pipes = [state2.pipes, dest];
      break;
    default:
      state2.pipes.push(dest);
      break;
  }
  state2.pipesCount += 1;
  debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== browser$1$1.stdout && dest !== browser$1$1.stderr;
  var endFn = doEnd ? onend3 : unpipe;
  if (state2.endEmitted) browser$1$1.nextTick(endFn);
  else src.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug2("onunpipe");
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend3() {
    debug2("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain2(src);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug2("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend3);
    src.removeListener("end", unpipe);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on("data", ondata);
  function ondata(chunk) {
    debug2("ondata");
    var ret = dest.write(chunk);
    debug2("dest.write", ret);
    if (ret === false) {
      if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf4(state2.pipes, dest) !== -1) && !cleanedUp) {
        debug2("false write response, pause", state2.awaitDrain);
        state2.awaitDrain++;
      }
      src.pause();
    }
  }
  function onerror(er) {
    debug2("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (EElistenerCount(dest, "error") === 0) errorOrDestroy$1(dest, er);
  }
  prependListener4(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug2("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug2("unpipe");
    src.unpipe(dest);
  }
  dest.emit("pipe", src);
  if (!state2.flowing) {
    debug2("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain2(src) {
  return function pipeOnDrainFunctionResult() {
    var state2 = src._readableState;
    debug2("pipeOnDrain", state2.awaitDrain);
    if (state2.awaitDrain) state2.awaitDrain--;
    if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
      state2.flowing = true;
      flow2(src);
    }
  };
}
Readable2.prototype.unpipe = function(dest) {
  var state2 = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };
  if (state2.pipesCount === 0) return this;
  if (state2.pipesCount === 1) {
    if (dest && dest !== state2.pipes) return this;
    if (!dest) dest = state2.pipes;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    if (dest) dest.emit("unpipe", this, unpipeInfo);
    return this;
  }
  if (!dest) {
    var dests = state2.pipes;
    var len = state2.pipesCount;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    for (var i3 = 0; i3 < len; i3++) {
      dests[i3].emit("unpipe", this, {
        hasUnpiped: false
      });
    }
    return this;
  }
  var index3 = indexOf4(state2.pipes, dest);
  if (index3 === -1) return this;
  state2.pipes.splice(index3, 1);
  state2.pipesCount -= 1;
  if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
  dest.emit("unpipe", this, unpipeInfo);
  return this;
};
Readable2.prototype.on = function(ev, fn) {
  var res = Stream$1.prototype.on.call(this, ev, fn);
  var state2 = this._readableState;
  if (ev === "data") {
    state2.readableListening = this.listenerCount("readable") > 0;
    if (state2.flowing !== false) this.resume();
  } else if (ev === "readable") {
    if (!state2.endEmitted && !state2.readableListening) {
      state2.readableListening = state2.needReadable = true;
      state2.flowing = false;
      state2.emittedReadable = false;
      debug2("on readable", state2.length, state2.reading);
      if (state2.length) {
        emitReadable2(this);
      } else if (!state2.reading) {
        browser$1$1.nextTick(nReadingNextTick2, this);
      }
    }
  }
  return res;
};
Readable2.prototype.addListener = Readable2.prototype.on;
Readable2.prototype.removeListener = function(ev, fn) {
  var res = Stream$1.prototype.removeListener.call(this, ev, fn);
  if (ev === "readable") {
    browser$1$1.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable2.prototype.removeAllListeners = function(ev) {
  var res = Stream$1.prototype.removeAllListeners.apply(this, arguments);
  if (ev === "readable" || ev === void 0) {
    browser$1$1.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self2) {
  var state2 = self2._readableState;
  state2.readableListening = self2.listenerCount("readable") > 0;
  if (state2.resumeScheduled && !state2.paused) {
    state2.flowing = true;
  } else if (self2.listenerCount("data") > 0) {
    self2.resume();
  }
}
function nReadingNextTick2(self2) {
  debug2("readable nexttick read 0");
  self2.read(0);
}
Readable2.prototype.resume = function() {
  var state2 = this._readableState;
  if (!state2.flowing) {
    debug2("resume");
    state2.flowing = !state2.readableListening;
    resume2(this, state2);
  }
  state2.paused = false;
  return this;
};
function resume2(stream2, state2) {
  if (!state2.resumeScheduled) {
    state2.resumeScheduled = true;
    browser$1$1.nextTick(resume_2, stream2, state2);
  }
}
function resume_2(stream2, state2) {
  debug2("resume", state2.reading);
  if (!state2.reading) {
    stream2.read(0);
  }
  state2.resumeScheduled = false;
  stream2.emit("resume");
  flow2(stream2);
  if (state2.flowing && !state2.reading) stream2.read(0);
}
Readable2.prototype.pause = function() {
  debug2("call pause flowing=%j", this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug2("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  this._readableState.paused = true;
  return this;
};
function flow2(stream2) {
  var state2 = stream2._readableState;
  debug2("flow", state2.flowing);
  while (state2.flowing && stream2.read() !== null) {
  }
}
Readable2.prototype.wrap = function(stream2) {
  var _this = this;
  var state2 = this._readableState;
  var paused = false;
  stream2.on("end", function() {
    debug2("wrapped end");
    if (state2.decoder && !state2.ended) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream2.on("data", function(chunk) {
    debug2("wrapped data");
    if (state2.decoder) chunk = state2.decoder.write(chunk);
    if (state2.objectMode && (chunk === null || chunk === void 0)) return;
    else if (!state2.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i3 in stream2) {
    if (this[i3] === void 0 && typeof stream2[i3] === "function") {
      this[i3] = /* @__PURE__ */ function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i3);
    }
  }
  for (var n4 = 0; n4 < kProxyEvents.length; n4++) {
    stream2.on(kProxyEvents[n4], this.emit.bind(this, kProxyEvents[n4]));
  }
  this._read = function(n5) {
    debug2("wrapped _read", n5);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return this;
};
if (typeof Symbol === "function") {
  Readable2.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator === void 0) {
      createReadableStreamAsyncIterator = requireAsync_iterator();
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get3() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable2.prototype, "readableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get4() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable2.prototype, "readableFlowing", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get5() {
    return this._readableState.flowing;
  },
  set: function set2(state2) {
    if (this._readableState) {
      this._readableState.flowing = state2;
    }
  }
});
Readable2._fromList = fromList2;
Object.defineProperty(Readable2.prototype, "readableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get6() {
    return this._readableState.length;
  }
});
function fromList2(n4, state2) {
  if (state2.length === 0) return null;
  var ret;
  if (state2.objectMode) ret = state2.buffer.shift();
  else if (!n4 || n4 >= state2.length) {
    if (state2.decoder) ret = state2.buffer.join("");
    else if (state2.buffer.length === 1) ret = state2.buffer.first();
    else ret = state2.buffer.concat(state2.length);
    state2.buffer.clear();
  } else {
    ret = state2.buffer.consume(n4, state2.decoder);
  }
  return ret;
}
function endReadable2(stream2) {
  var state2 = stream2._readableState;
  debug2("endReadable", state2.endEmitted);
  if (!state2.endEmitted) {
    state2.ended = true;
    browser$1$1.nextTick(endReadableNT2, state2, stream2);
  }
}
function endReadableNT2(state2, stream2) {
  debug2("endReadableNT", state2.endEmitted, state2.length);
  if (!state2.endEmitted && state2.length === 0) {
    state2.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
    if (state2.autoDestroy) {
      var wState = stream2._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream2.destroy();
      }
    }
  }
}
if (typeof Symbol === "function") {
  Readable2.from = function(iterable, opts2) {
    if (from2 === void 0) {
      from2 = requireFromBrowser();
    }
    return from2(Readable2, iterable, opts2);
  };
}
function indexOf4(xs, x) {
  for (var i3 = 0, l2 = xs.length; i3 < l2; i3++) {
    if (xs[i3] === x) return i3;
  }
  return -1;
}
var browser2 = deprecate2;
function deprecate2(fn, msg2) {
  if (config2("noDeprecation")) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config2("throwDeprecation")) {
        throw new Error(msg2);
      } else if (config2("traceDeprecation")) {
        console.trace(msg2);
      } else {
        console.warn(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function config2(name) {
  try {
    if (!commonjsGlobal.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = commonjsGlobal.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === "true";
}
var Registry$3 = _registry;
Registry$3.Writable = Writable2;
function CorkedRequest2(state2) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function() {
    onCorkedFinish(_this, state2);
  };
}
Writable2.WritableState = WritableState2;
var internalUtil = {
  deprecate: browser2
};
var Stream2 = streamBrowser;
var Buffer3 = require$$02.Buffer;
var OurUint8Array = commonjsGlobal.Uint8Array || function() {
};
function _uint8ArrayToBuffer(chunk) {
  return Buffer3.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = destroy_1;
var _require = state;
var getHighWaterMark = _require.getHighWaterMark;
var _require$codes$2 = errorsBrowser.codes;
var ERR_INVALID_ARG_TYPE = _require$codes$2.ERR_INVALID_ARG_TYPE;
var ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_MULTIPLE_CALLBACK$1 = _require$codes$2.ERR_MULTIPLE_CALLBACK;
var ERR_STREAM_CANNOT_PIPE = _require$codes$2.ERR_STREAM_CANNOT_PIPE;
var ERR_STREAM_DESTROYED$1 = _require$codes$2.ERR_STREAM_DESTROYED;
var ERR_STREAM_NULL_VALUES = _require$codes$2.ERR_STREAM_NULL_VALUES;
var ERR_STREAM_WRITE_AFTER_END = _require$codes$2.ERR_STREAM_WRITE_AFTER_END;
var ERR_UNKNOWN_ENCODING = _require$codes$2.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require$$12(Writable2, Stream2);
function nop2() {
}
function WritableState2(options, stream2, isDuplex) {
  options = options || {};
  if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Registry$3.Duplex;
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
  this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
  this.finalCalled = false;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  this.destroyed = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite2(stream2, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest2(this);
}
WritableState2.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function() {
  try {
    Object.defineProperty(WritableState2.prototype, "buffer", {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
    });
  } catch (_) {
  }
})();
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable2, Symbol.hasInstance, {
    value: function value2(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable2) return false;
      return object && object._writableState instanceof WritableState2;
    }
  });
} else {
  realHasInstance = function realHasInstance2(object) {
    return object instanceof this;
  };
}
function Writable2(options) {
  var isDuplex = this instanceof Registry$3.Duplex;
  if (!isDuplex && !realHasInstance.call(Writable2, this)) return new Writable2(options);
  this._writableState = new WritableState2(options, this, isDuplex);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function") this._write = options.write;
    if (typeof options.writev === "function") this._writev = options.writev;
    if (typeof options.destroy === "function") this._destroy = options.destroy;
    if (typeof options.final === "function") this._final = options.final;
  }
  Stream2.call(this);
}
Writable2.prototype.pipe = function() {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd2(stream2, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  errorOrDestroy(stream2, er);
  browser$1$1.nextTick(cb, er);
}
function validChunk2(stream2, state2, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== "string" && !state2.objectMode) {
    er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
  }
  if (er) {
    errorOrDestroy(stream2, er);
    browser$1$1.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable2.prototype.write = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  var ret = false;
  var isBuf = !state2.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer3.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = "buffer";
  else if (!encoding) encoding = state2.defaultEncoding;
  if (typeof cb !== "function") cb = nop2;
  if (state2.ending) writeAfterEnd2(this, cb);
  else if (isBuf || validChunk2(this, state2, chunk, cb)) {
    state2.pendingcb++;
    ret = writeOrBuffer2(this, state2, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable2.prototype.cork = function() {
  this._writableState.corked++;
};
Writable2.prototype.uncork = function() {
  var state2 = this._writableState;
  if (state2.corked) {
    state2.corked--;
    if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer2(this, state2);
  }
};
Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
  if (typeof encoding === "string") encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable2.prototype, "writableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get7() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk2(state2, chunk, encoding) {
  if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer3.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get8() {
    return this._writableState.highWaterMark;
  }
});
function writeOrBuffer2(stream2, state2, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk2(state2, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = "buffer";
      chunk = newChunk;
    }
  }
  var len = state2.objectMode ? 1 : chunk.length;
  state2.length += len;
  var ret = state2.length < state2.highWaterMark;
  if (!ret) state2.needDrain = true;
  if (state2.writing || state2.corked) {
    var last2 = state2.lastBufferedRequest;
    state2.lastBufferedRequest = {
      chunk,
      encoding,
      isBuf,
      callback: cb,
      next: null
    };
    if (last2) {
      last2.next = state2.lastBufferedRequest;
    } else {
      state2.bufferedRequest = state2.lastBufferedRequest;
    }
    state2.bufferedRequestCount += 1;
  } else {
    doWrite2(stream2, state2, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite2(stream2, state2, writev, len, chunk, encoding, cb) {
  state2.writelen = len;
  state2.writecb = cb;
  state2.writing = true;
  state2.sync = true;
  if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED$1("write"));
  else if (writev) stream2._writev(chunk, state2.onwrite);
  else stream2._write(chunk, encoding, state2.onwrite);
  state2.sync = false;
}
function onwriteError2(stream2, state2, sync, er, cb) {
  --state2.pendingcb;
  if (sync) {
    browser$1$1.nextTick(cb, er);
    browser$1$1.nextTick(finishMaybe2, stream2, state2);
    stream2._writableState.errorEmitted = true;
    errorOrDestroy(stream2, er);
  } else {
    cb(er);
    stream2._writableState.errorEmitted = true;
    errorOrDestroy(stream2, er);
    finishMaybe2(stream2, state2);
  }
}
function onwriteStateUpdate2(state2) {
  state2.writing = false;
  state2.writecb = null;
  state2.length -= state2.writelen;
  state2.writelen = 0;
}
function onwrite2(stream2, er) {
  var state2 = stream2._writableState;
  var sync = state2.sync;
  var cb = state2.writecb;
  if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK$1();
  onwriteStateUpdate2(state2);
  if (er) onwriteError2(stream2, state2, sync, er, cb);
  else {
    var finished = needFinish2(state2) || stream2.destroyed;
    if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
      clearBuffer2(stream2, state2);
    }
    if (sync) {
      browser$1$1.nextTick(afterWrite2, stream2, state2, finished, cb);
    } else {
      afterWrite2(stream2, state2, finished, cb);
    }
  }
}
function afterWrite2(stream2, state2, finished, cb) {
  if (!finished) onwriteDrain2(stream2, state2);
  state2.pendingcb--;
  cb();
  finishMaybe2(stream2, state2);
}
function onwriteDrain2(stream2, state2) {
  if (state2.length === 0 && state2.needDrain) {
    state2.needDrain = false;
    stream2.emit("drain");
  }
}
function clearBuffer2(stream2, state2) {
  state2.bufferProcessing = true;
  var entry = state2.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l2 = state2.bufferedRequestCount;
    var buffer = new Array(l2);
    var holder = state2.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite2(stream2, state2, true, state2.length, buffer, "", holder.finish);
    state2.pendingcb++;
    state2.lastBufferedRequest = null;
    if (holder.next) {
      state2.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state2.corkedRequestsFree = new CorkedRequest2(state2);
    }
    state2.bufferedRequestCount = 0;
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state2.objectMode ? 1 : chunk.length;
      doWrite2(stream2, state2, false, len, chunk, encoding, cb);
      entry = entry.next;
      state2.bufferedRequestCount--;
      if (state2.writing) {
        break;
      }
    }
    if (entry === null) state2.lastBufferedRequest = null;
  }
  state2.bufferedRequest = entry;
  state2.bufferProcessing = false;
}
Writable2.prototype._write = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED$1("_write()"));
};
Writable2.prototype._writev = null;
Writable2.prototype.end = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
  if (state2.corked) {
    state2.corked = 1;
    this.uncork();
  }
  if (!state2.ending) endWritable2(this, state2, cb);
  return this;
};
Object.defineProperty(Writable2.prototype, "writableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get9() {
    return this._writableState.length;
  }
});
function needFinish2(state2) {
  return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
}
function callFinal(stream2, state2) {
  stream2._final(function(err2) {
    state2.pendingcb--;
    if (err2) {
      errorOrDestroy(stream2, err2);
    }
    state2.prefinished = true;
    stream2.emit("prefinish");
    finishMaybe2(stream2, state2);
  });
}
function prefinish$1(stream2, state2) {
  if (!state2.prefinished && !state2.finalCalled) {
    if (typeof stream2._final === "function" && !state2.destroyed) {
      state2.pendingcb++;
      state2.finalCalled = true;
      browser$1$1.nextTick(callFinal, stream2, state2);
    } else {
      state2.prefinished = true;
      stream2.emit("prefinish");
    }
  }
}
function finishMaybe2(stream2, state2) {
  var need = needFinish2(state2);
  if (need) {
    prefinish$1(stream2, state2);
    if (state2.pendingcb === 0) {
      state2.finished = true;
      stream2.emit("finish");
      if (state2.autoDestroy) {
        var rState = stream2._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream2.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable2(stream2, state2, cb) {
  state2.ending = true;
  finishMaybe2(stream2, state2);
  if (cb) {
    if (state2.finished) browser$1$1.nextTick(cb);
    else stream2.once("finish", cb);
  }
  state2.ended = true;
  stream2.writable = false;
}
function onCorkedFinish(corkReq, state2, err2) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state2.pendingcb--;
    cb(err2);
    entry = entry.next;
  }
  state2.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get10() {
    if (this._writableState === void 0) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set3(value2) {
    if (!this._writableState) {
      return;
    }
    this._writableState.destroyed = value2;
  }
});
Writable2.prototype.destroy = destroyImpl.destroy;
Writable2.prototype._undestroy = destroyImpl.undestroy;
Writable2.prototype._destroy = function(err2, cb) {
  cb(err2);
};
var objectKeys$1 = Object.keys || function(obj) {
  var keys2 = [];
  for (var key in obj) {
    keys2.push(key);
  }
  return keys2;
};
var Registry$2 = _registry;
Registry$2.Duplex = Duplex2;
require$$12(Duplex2, Registry$2.Readable);
{
  keys2 = objectKeys$1(Registry$2.Writable.prototype);
  for (v2 = 0; v2 < keys2.length; v2++) {
    method = keys2[v2];
    if (!Duplex2.prototype[method]) Duplex2.prototype[method] = Registry$2.Writable.prototype[method];
  }
}
var keys2;
var method;
var v2;
function Duplex2(options) {
  if (!(this instanceof Duplex2)) return new Duplex2(options);
  Registry$2.Readable.call(this, options);
  Registry$2.Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once("end", onend2);
    }
  }
}
Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get11() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex2.prototype, "writableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get12() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex2.prototype, "writableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get13() {
    return this._writableState.length;
  }
});
function onend2() {
  if (this._writableState.ended) return;
  browser$1$1.nextTick(onEndNT2, this);
}
function onEndNT2(self2) {
  self2.end();
}
Object.defineProperty(Duplex2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get14() {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set4(value2) {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return;
    }
    this._readableState.destroyed = value2;
    this._writableState.destroyed = value2;
  }
});
var Registry$1 = _registry;
Registry$1.Transform = Transform$1;
var _require$codes$1 = errorsBrowser.codes;
var ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK;
var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING;
var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
require$$12(Transform$1, Registry$1.Duplex);
function afterTransform2(er, data2) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 != null)
    this.push(data2);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform$1(options) {
  if (!(this instanceof Transform$1)) return new Transform$1(options);
  Registry$1.Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform2.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function") this._transform = options.transform;
    if (typeof options.flush === "function") this._flush = options.flush;
  }
  this.on("prefinish", prefinish2);
}
function prefinish2() {
  var _this = this;
  if (typeof this._flush === "function" && !this._readableState.destroyed) {
    this._flush(function(er, data2) {
      done2(_this, er, data2);
    });
  } else {
    done2(this, null, null);
  }
}
Transform$1.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Registry$1.Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$1.prototype._transform = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};
Transform$1.prototype._read = function(n4) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
Transform$1.prototype._destroy = function(err2, cb) {
  Registry$1.Duplex.prototype._destroy.call(this, err2, function(err22) {
    cb(err22);
  });
};
function done2(stream2, er, data2) {
  if (er) return stream2.emit("error", er);
  if (data2 != null)
    stream2.push(data2);
  if (stream2._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream2._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream2.push(null);
}
var Registry = _registry;
Registry.PassThrough = PassThrough2;
require$$12(PassThrough2, Registry.Transform);
function PassThrough2(options) {
  if (!(this instanceof PassThrough2)) return new PassThrough2(options);
  Transform.call(this, options);
}
PassThrough2.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
var eos;
function once4(callback) {
  var called = false;
  return function() {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = errorsBrowser.codes;
var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop3(err2) {
  if (err2) throw err2;
}
function isRequest(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function destroyer(stream2, reading, writing, callback) {
  callback = once4(callback);
  var closed = false;
  stream2.on("close", function() {
    closed = true;
  });
  if (eos === void 0) eos = endOfStream;
  eos(stream2, {
    readable: reading,
    writable: writing
  }, function(err2) {
    if (err2) return callback(err2);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err2) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;
    if (isRequest(stream2)) return stream2.abort();
    if (typeof stream2.destroy === "function") return stream2.destroy();
    callback(err2 || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function call(fn) {
  fn();
}
function pipe(from4, to) {
  return from4.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop3;
  if (typeof streams[streams.length - 1] !== "function") return noop3;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  var error;
  var destroys = streams.map(function(stream2, i3) {
    var reading = i3 < streams.length - 1;
    var writing = i3 > 0;
    return destroyer(stream2, reading, writing, function(err2) {
      if (!error) error = err2;
      if (err2) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(module, exports) {
  const Registry2 = _registry;
  exports = module.exports = Registry2.Readable;
  exports.Stream = Registry2.Readable;
  exports.Readable = Registry2.Readable;
  exports.Writable = Registry2.Writable;
  exports.Duplex = Registry2.Duplex;
  exports.Transform = Registry2.Transform;
  exports.PassThrough = Registry2.PassThrough;
  exports.finished = endOfStream;
  exports.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports;
var stream = getDefaultExportFromCjs2(readableBrowserExports);
var lib2 = {};
var binding2 = {};
function compare6(a3, b2) {
  if (a3 === b2) {
    return 0;
  }
  var x = a3.length;
  var y2 = b2.length;
  for (var i3 = 0, len = Math.min(x, y2); i3 < len; ++i3) {
    if (a3[i3] !== b2[i3]) {
      x = a3[i3];
      y2 = b2[i3];
      break;
    }
  }
  if (x < y2) {
    return -1;
  }
  if (y2 < x) {
    return 1;
  }
  return 0;
}
var hasOwn2 = Object.prototype.hasOwnProperty;
var objectKeys2 = Object.keys || function(obj) {
  var keys2 = [];
  for (var key in obj) {
    if (hasOwn2.call(obj, key)) keys2.push(key);
  }
  return keys2;
};
var pSlice2 = Array.prototype.slice;
var _functionsHaveNames2;
function functionsHaveNames2() {
  if (typeof _functionsHaveNames2 !== "undefined") {
    return _functionsHaveNames2;
  }
  return _functionsHaveNames2 = function() {
    return (function foo() {
    }).name === "foo";
  }();
}
function pToString2(obj) {
  return Object.prototype.toString.call(obj);
}
function isView2(arrbuf) {
  if (isBuffer$12(arrbuf)) {
    return false;
  }
  if (typeof global$12.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
function assert2(value2, message) {
  if (!value2) fail2(value2, true, message, "==", ok2);
}
var regex2 = /\s*function\s+([^\(\s]*)\s*/;
function getName2(func) {
  if (!isFunction2(func)) {
    return;
  }
  if (functionsHaveNames2()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex2);
  return match && match[1];
}
assert2.AssertionError = AssertionError2;
function AssertionError2(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage2(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail2;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err2 = new Error();
    if (err2.stack) {
      var out = err2.stack;
      var fn_name = getName2(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
inherits$2(AssertionError2, Error);
function truncate2(s2, n4) {
  if (typeof s2 === "string") {
    return s2.length < n4 ? s2 : s2.slice(0, n4);
  } else {
    return s2;
  }
}
function inspect4(something) {
  if (functionsHaveNames2() || !isFunction2(something)) {
    return inspect$12(something);
  }
  var rawname = getName2(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
function getMessage2(self2) {
  return truncate2(inspect4(self2.actual), 128) + " " + self2.operator + " " + truncate2(inspect4(self2.expected), 128);
}
function fail2(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError2({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
assert2.fail = fail2;
function ok2(value2, message) {
  if (!value2) fail2(value2, true, message, "==", ok2);
}
assert2.ok = ok2;
assert2.equal = equal2;
function equal2(actual, expected, message) {
  if (actual != expected) fail2(actual, expected, message, "==", equal2);
}
assert2.notEqual = notEqual2;
function notEqual2(actual, expected, message) {
  if (actual == expected) {
    fail2(actual, expected, message, "!=", notEqual2);
  }
}
assert2.deepEqual = deepEqual2;
function deepEqual2(actual, expected, message) {
  if (!_deepEqual2(actual, expected, false)) {
    fail2(actual, expected, message, "deepEqual", deepEqual2);
  }
}
assert2.deepStrictEqual = deepStrictEqual2;
function deepStrictEqual2(actual, expected, message) {
  if (!_deepEqual2(actual, expected, true)) {
    fail2(actual, expected, message, "deepStrictEqual", deepStrictEqual2);
  }
}
function _deepEqual2(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer$12(actual) && isBuffer$12(expected)) {
    return compare6(actual, expected) === 0;
  } else if (isDate2(actual) && isDate2(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp2(actual) && isRegExp2(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView2(actual) && isView2(expected) && pToString2(actual) === pToString2(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare6(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer$12(actual) !== isBuffer$12(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv2(actual, expected, strict, memos);
  }
}
function isArguments2(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv2(a3, b2, strict, actualVisitedObjects) {
  if (a3 === null || a3 === void 0 || b2 === null || b2 === void 0)
    return false;
  if (isPrimitive2(a3) || isPrimitive2(b2))
    return a3 === b2;
  if (strict && Object.getPrototypeOf(a3) !== Object.getPrototypeOf(b2))
    return false;
  var aIsArgs = isArguments2(a3);
  var bIsArgs = isArguments2(b2);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a3 = pSlice2.call(a3);
    b2 = pSlice2.call(b2);
    return _deepEqual2(a3, b2, strict);
  }
  var ka = objectKeys2(a3);
  var kb = objectKeys2(b2);
  var key, i3;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i3 = ka.length - 1; i3 >= 0; i3--) {
    if (ka[i3] !== kb[i3])
      return false;
  }
  for (i3 = ka.length - 1; i3 >= 0; i3--) {
    key = ka[i3];
    if (!_deepEqual2(a3[key], b2[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
assert2.notDeepEqual = notDeepEqual2;
function notDeepEqual2(actual, expected, message) {
  if (_deepEqual2(actual, expected, false)) {
    fail2(actual, expected, message, "notDeepEqual", notDeepEqual2);
  }
}
assert2.notDeepStrictEqual = notDeepStrictEqual2;
function notDeepStrictEqual2(actual, expected, message) {
  if (_deepEqual2(actual, expected, true)) {
    fail2(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual2);
  }
}
assert2.strictEqual = strictEqual2;
function strictEqual2(actual, expected, message) {
  if (actual !== expected) {
    fail2(actual, expected, message, "===", strictEqual2);
  }
}
assert2.notStrictEqual = notStrictEqual2;
function notStrictEqual2(actual, expected, message) {
  if (actual === expected) {
    fail2(actual, expected, message, "!==", notStrictEqual2);
  }
}
function expectedException2(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e3) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock2(block) {
  var error;
  try {
    block();
  } catch (e3) {
    error = e3;
  }
  return error;
}
function _throws2(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock2(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail2(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError2(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException2(actual, expected) || isUnexpectedException) {
    fail2(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException2(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
assert2.throws = throws2;
function throws2(block, error, message) {
  _throws2(true, block, error, message);
}
assert2.doesNotThrow = doesNotThrow2;
function doesNotThrow2(block, error, message) {
  _throws2(false, block, error, message);
}
assert2.ifError = ifError2;
function ifError2(err2) {
  if (err2) throw err2;
}
var _polyfillNode_assert2 = Object.freeze({
  __proto__: null,
  AssertionError: AssertionError2,
  assert: ok2,
  deepEqual: deepEqual2,
  deepStrictEqual: deepStrictEqual2,
  default: assert2,
  doesNotThrow: doesNotThrow2,
  equal: equal2,
  fail: fail2,
  ifError: ifError2,
  notDeepEqual: notDeepEqual2,
  notDeepStrictEqual: notDeepStrictEqual2,
  notEqual: notEqual2,
  notStrictEqual: notStrictEqual2,
  ok: ok2,
  strictEqual: strictEqual2,
  throws: throws2
});
var require$$42 = getAugmentedNamespace2(_polyfillNode_assert2);
(function(exports) {
  var assert3 = require$$42;
  var Zstream = import_zstream.default;
  var zlib_deflate = import_deflate.default;
  var zlib_inflate = import_inflate.default;
  var constants3 = import_constants.default;
  for (var key in constants3) {
    exports[key] = constants3[key];
  }
  exports.NONE = 0;
  exports.DEFLATE = 1;
  exports.INFLATE = 2;
  exports.GZIP = 3;
  exports.GUNZIP = 4;
  exports.DEFLATERAW = 5;
  exports.INFLATERAW = 6;
  exports.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib(mode) {
    if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert3(this.init_done, "close before init");
    assert3(this.mode <= exports.UNZIP);
    if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports.NONE;
    this.dictionary = null;
  };
  Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert3.equal(arguments.length, 8);
    assert3(this.init_done, "write before init");
    assert3(this.mode !== exports.NONE, "already finalized");
    assert3.equal(false, this.write_in_progress, "write already in progress");
    assert3.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert3.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer$2.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    browser$1$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports.INFLATE;
              break;
            }
          // fallthrough
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports.GUNZIP;
            } else {
              this.mode = exports.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      // fallthrough
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports.Z_DATA_ERROR) {
            this.err = exports.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib.prototype._checkError = function() {
    switch (this.err) {
      case exports.Z_OK:
      case exports.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports.Z_STREAM_END:
        break;
      case exports.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert3(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert3(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert3(level >= -1 && level <= 9, "invalid compression level");
    assert3(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert3(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports.Z_NO_FLUSH;
    this.err = exports.Z_OK;
    if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
      case exports.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib.prototype._reset = function() {
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
      case exports.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports.INFLATE:
      case exports.INFLATERAW:
      case exports.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports.Zlib = Zlib;
})(binding2);
(function(exports) {
  var Buffer5 = require$$02.Buffer;
  var Transform3 = readableBrowserExports.Transform;
  var binding$13 = binding2;
  var util = require$$32;
  var assert3 = require$$42.ok;
  var kMaxLength4 = require$$02.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength4.toString(16) + " bytes";
  binding$13.Z_MIN_WINDOWBITS = 8;
  binding$13.Z_MAX_WINDOWBITS = 15;
  binding$13.Z_DEFAULT_WINDOWBITS = 15;
  binding$13.Z_MIN_CHUNK = 64;
  binding$13.Z_MAX_CHUNK = Infinity;
  binding$13.Z_DEFAULT_CHUNK = 16 * 1024;
  binding$13.Z_MIN_MEMLEVEL = 1;
  binding$13.Z_MAX_MEMLEVEL = 9;
  binding$13.Z_DEFAULT_MEMLEVEL = 8;
  binding$13.Z_MIN_LEVEL = -1;
  binding$13.Z_MAX_LEVEL = 9;
  binding$13.Z_DEFAULT_LEVEL = binding$13.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding$13);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports, bkey, {
        enumerable: true,
        value: binding$13[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding$13.Z_OK,
    Z_STREAM_END: binding$13.Z_STREAM_END,
    Z_NEED_DICT: binding$13.Z_NEED_DICT,
    Z_ERRNO: binding$13.Z_ERRNO,
    Z_STREAM_ERROR: binding$13.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding$13.Z_DATA_ERROR,
    Z_MEM_ERROR: binding$13.Z_MEM_ERROR,
    Z_BUF_ERROR: binding$13.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding$13.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports.Deflate = Deflate;
  exports.Inflate = Inflate;
  exports.Gzip = Gzip;
  exports.Gunzip = Gunzip;
  exports.DeflateRaw = DeflateRaw;
  exports.InflateRaw = InflateRaw;
  exports.Unzip = Unzip;
  exports.createDeflate = function(o2) {
    return new Deflate(o2);
  };
  exports.createInflate = function(o2) {
    return new Inflate(o2);
  };
  exports.createDeflateRaw = function(o2) {
    return new DeflateRaw(o2);
  };
  exports.createInflateRaw = function(o2) {
    return new InflateRaw(o2);
  };
  exports.createGzip = function(o2) {
    return new Gzip(o2);
  };
  exports.createGunzip = function(o2) {
    return new Gunzip(o2);
  };
  exports.createUnzip = function(o2) {
    return new Unzip(o2);
  };
  exports.deflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Deflate(opts2), buffer, callback);
  };
  exports.deflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Deflate(opts2), buffer);
  };
  exports.gzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gzip(opts2), buffer, callback);
  };
  exports.gzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gzip(opts2), buffer);
  };
  exports.deflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new DeflateRaw(opts2), buffer, callback);
  };
  exports.deflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new DeflateRaw(opts2), buffer);
  };
  exports.unzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Unzip(opts2), buffer, callback);
  };
  exports.unzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Unzip(opts2), buffer);
  };
  exports.inflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Inflate(opts2), buffer, callback);
  };
  exports.inflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Inflate(opts2), buffer);
  };
  exports.gunzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gunzip(opts2), buffer, callback);
  };
  exports.gunzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gunzip(opts2), buffer);
  };
  exports.inflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new InflateRaw(opts2), buffer, callback);
  };
  exports.inflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new InflateRaw(opts2), buffer);
  };
  function zlibBuffer(engine2, buffer, callback) {
    var buffers = [];
    var nread = 0;
    engine2.on("error", onError);
    engine2.on("end", onEnd);
    engine2.end(buffer);
    flow3();
    function flow3() {
      var chunk;
      while (null !== (chunk = engine2.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine2.once("readable", flow3);
    }
    function onError(err2) {
      engine2.removeListener("end", onEnd);
      engine2.removeListener("readable", flow3);
      callback(err2);
    }
    function onEnd() {
      var buf;
      var err2 = null;
      if (nread >= kMaxLength4) {
        err2 = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer5.concat(buffers, nread);
      }
      buffers = [];
      engine2.close();
      callback(err2, buf);
    }
  }
  function zlibBufferSync(engine2, buffer) {
    if (typeof buffer === "string") buffer = Buffer5.from(buffer);
    if (!Buffer5.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
    var flushFlag = engine2._finishFlushFlag;
    return engine2._processChunk(buffer, flushFlag);
  }
  function Deflate(opts2) {
    if (!(this instanceof Deflate)) return new Deflate(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATE);
  }
  function Inflate(opts2) {
    if (!(this instanceof Inflate)) return new Inflate(opts2);
    Zlib.call(this, opts2, binding$13.INFLATE);
  }
  function Gzip(opts2) {
    if (!(this instanceof Gzip)) return new Gzip(opts2);
    Zlib.call(this, opts2, binding$13.GZIP);
  }
  function Gunzip(opts2) {
    if (!(this instanceof Gunzip)) return new Gunzip(opts2);
    Zlib.call(this, opts2, binding$13.GUNZIP);
  }
  function DeflateRaw(opts2) {
    if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATERAW);
  }
  function InflateRaw(opts2) {
    if (!(this instanceof InflateRaw)) return new InflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.INFLATERAW);
  }
  function Unzip(opts2) {
    if (!(this instanceof Unzip)) return new Unzip(opts2);
    Zlib.call(this, opts2, binding$13.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding$13.Z_NO_FLUSH || flag === binding$13.Z_PARTIAL_FLUSH || flag === binding$13.Z_SYNC_FLUSH || flag === binding$13.Z_FULL_FLUSH || flag === binding$13.Z_FINISH || flag === binding$13.Z_BLOCK;
  }
  function Zlib(opts2, mode) {
    var _this = this;
    this._opts = opts2 = opts2 || {};
    this._chunkSize = opts2.chunkSize || exports.Z_DEFAULT_CHUNK;
    Transform3.call(this, opts2);
    if (opts2.flush && !isValidFlushFlag(opts2.flush)) {
      throw new Error("Invalid flush flag: " + opts2.flush);
    }
    if (opts2.finishFlush && !isValidFlushFlag(opts2.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts2.finishFlush);
    }
    this._flushFlag = opts2.flush || binding$13.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts2.finishFlush !== "undefined" ? opts2.finishFlush : binding$13.Z_FINISH;
    if (opts2.chunkSize) {
      if (opts2.chunkSize < exports.Z_MIN_CHUNK || opts2.chunkSize > exports.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts2.chunkSize);
      }
    }
    if (opts2.windowBits) {
      if (opts2.windowBits < exports.Z_MIN_WINDOWBITS || opts2.windowBits > exports.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts2.windowBits);
      }
    }
    if (opts2.level) {
      if (opts2.level < exports.Z_MIN_LEVEL || opts2.level > exports.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts2.level);
      }
    }
    if (opts2.memLevel) {
      if (opts2.memLevel < exports.Z_MIN_MEMLEVEL || opts2.memLevel > exports.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts2.memLevel);
      }
    }
    if (opts2.strategy) {
      if (opts2.strategy != exports.Z_FILTERED && opts2.strategy != exports.Z_HUFFMAN_ONLY && opts2.strategy != exports.Z_RLE && opts2.strategy != exports.Z_FIXED && opts2.strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts2.strategy);
      }
    }
    if (opts2.dictionary) {
      if (!Buffer5.isBuffer(opts2.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding$13.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports.codes[errno];
      self2.emit("error", error);
    };
    var level = exports.Z_DEFAULT_COMPRESSION;
    if (typeof opts2.level === "number") level = opts2.level;
    var strategy = exports.Z_DEFAULT_STRATEGY;
    if (typeof opts2.strategy === "number") strategy = opts2.strategy;
    this._handle.init(opts2.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts2.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts2.dictionary);
    this._buffer = Buffer5.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util.inherits(Zlib, Transform3);
  Zlib.prototype.params = function(level, strategy, callback) {
    if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding$13.Z_SYNC_FLUSH, function() {
        assert3(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback) callback();
        }
      });
    } else {
      browser$1$1.nextTick(callback);
    }
  };
  Zlib.prototype.reset = function() {
    assert3(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib.prototype._flush = function(callback) {
    this._transform(Buffer5.alloc(0), "", callback);
  };
  Zlib.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding$13.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback) browser$1$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback) this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer5.alloc(0), "", callback);
    }
  };
  Zlib.prototype.close = function(callback) {
    _close(this, callback);
    browser$1$1.nextTick(emitCloseNT2, this);
  };
  function _close(engine2, callback) {
    if (callback) browser$1$1.nextTick(callback);
    if (!engine2._handle) return;
    engine2._handle.close();
    engine2._handle = null;
  }
  function emitCloseNT2(self2) {
    self2.emit("close");
  }
  Zlib.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last2 = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer5.isBuffer(chunk)) return cb(new Error("invalid input"));
    if (!this._handle) return cb(new Error("zlib binding closed"));
    if (last2) flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding$13.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er) {
        error = er;
      });
      assert3(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength4) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer5.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert3(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError) return;
      var have = availOutBefore - availOutAfter;
      assert3(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer5.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async) return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async) return false;
      cb();
    }
  };
  util.inherits(Deflate, Zlib);
  util.inherits(Inflate, Zlib);
  util.inherits(Gzip, Zlib);
  util.inherits(Gunzip, Zlib);
  util.inherits(DeflateRaw, Zlib);
  util.inherits(InflateRaw, Zlib);
  util.inherits(Unzip, Zlib);
})(lib2);
var zlib2 = getDefaultExportFromCjs2(lib2);
var PDFReference = class extends stream.Writable {
  constructor(document2, id, data2) {
    super({
      decodeStrings: false
    });
    this.finalize = this.finalize.bind(this);
    this.document = document2;
    this.id = id;
    if (data2 == null) {
      data2 = {};
    }
    this.data = data2;
    this.gen = 0;
    this.deflate = null;
    this.compress = this.document.compress && !this.data.Filter;
    this.uncompressedLength = 0;
    this.chunks = [];
  }
  initDeflate() {
    this.data.Filter = "FlateDecode";
    this.deflate = zlib2.createDeflate();
    this.deflate.on("data", (chunk) => {
      this.chunks.push(chunk);
      return this.data.Length += chunk.length;
    });
    return this.deflate.on("end", this.finalize);
  }
  _write(chunk, encoding, callback) {
    if (!(chunk instanceof Uint8Array)) {
      chunk = Buffer$2.from(chunk + "\n", "binary");
    }
    this.uncompressedLength += chunk.length;
    if (this.data.Length == null) {
      this.data.Length = 0;
    }
    if (this.compress) {
      if (!this.deflate) {
        this.initDeflate();
      }
      this.deflate.write(chunk);
    } else {
      this.chunks.push(chunk);
      this.data.Length += chunk.length;
    }
    return callback();
  }
  end() {
    super.end(...arguments);
    if (this.deflate) {
      return this.deflate.end();
    }
    return this.finalize();
  }
  finalize() {
    this.offset = this.document._offset;
    this.document._write(`${this.id} ${this.gen} obj`);
    this.document._write(PDFObject.convert(this.data));
    if (this.chunks.length) {
      this.document._write("stream");
      for (let chunk of Array.from(this.chunks)) {
        this.document._write(chunk);
      }
      this.chunks.length = 0;
      this.document._write("\nendstream");
    }
    this.document._write("endobj");
    return this.document._refEnd(this);
  }
  toString() {
    return `${this.id} ${this.gen} R`;
  }
};
var PDFTree = class {
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    this._items = {};
    this.limits = typeof options.limits === "boolean" ? options.limits : true;
  }
  add(key, val) {
    return this._items[key] = val;
  }
  get(key) {
    return this._items[key];
  }
  toString() {
    const sortedKeys = Object.keys(this._items).sort((a3, b2) => this._compareKeys(a3, b2));
    const out = ["<<"];
    if (this.limits && sortedKeys.length > 1) {
      const first = sortedKeys[0], last2 = sortedKeys[sortedKeys.length - 1];
      out.push(`  /Limits ${PDFObject.convert([this._dataForKey(first), this._dataForKey(last2)])}`);
    }
    out.push(`  /${this._keysName()} [`);
    for (let key of sortedKeys) {
      out.push(`    ${PDFObject.convert(this._dataForKey(key))} ${PDFObject.convert(this._items[key])}`);
    }
    out.push("]");
    out.push(">>");
    return out.join("\n");
  }
  _compareKeys() {
    throw new Error("Must be implemented by subclasses");
  }
  _keysName() {
    throw new Error("Must be implemented by subclasses");
  }
  _dataForKey() {
    throw new Error("Must be implemented by subclasses");
  }
};
var PDFNameTree = class extends PDFTree {
  _compareKeys(a3, b2) {
    return a3.localeCompare(b2);
  }
  _keysName() {
    return "Names";
  }
  _dataForKey(k2) {
    return new String(k2);
  }
};
var pad2 = (str, length2) => (Array(length2 + 1).join("0") + str).slice(-length2);
var escapableRe = /[\n\r\t\b\f()\\]/g;
var escapable = {
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\b": "\\b",
  "\f": "\\f",
  "\\": "\\\\",
  "(": "\\(",
  ")": "\\)"
};
var swapBytes = function(buff) {
  const l2 = buff.length;
  if (l2 & 1) {
    throw new Error("Buffer length must be even");
  } else {
    for (let i3 = 0, end2 = l2 - 1; i3 < end2; i3 += 2) {
      const a3 = buff[i3];
      buff[i3] = buff[i3 + 1];
      buff[i3 + 1] = a3;
    }
  }
  return buff;
};
var PDFObject = class _PDFObject {
  static convert(object) {
    if (typeof object === "string") {
      return `/${object}`;
    }
    if (object instanceof String) {
      let string = object;
      let isUnicode = false;
      for (let i3 = 0, end2 = string.length; i3 < end2; i3++) {
        if (string.charCodeAt(i3) > 127) {
          isUnicode = true;
          break;
        }
      }
      if (isUnicode) {
        string = swapBytes(Buffer$2.from(`\uFEFF${string}`, "utf16le")).toString("binary");
      }
      string = string.replace(escapableRe, (c3) => escapable[c3]);
      return `(${string})`;
    }
    if (Buffer$2.isBuffer(object)) {
      return `<${object.toString("hex")}>`;
    }
    if (object instanceof PDFReference || object instanceof PDFNameTree) {
      return object.toString();
    }
    if (object instanceof Date) {
      return `(D:${pad2(object.getUTCFullYear(), 4)}` + pad2(object.getUTCMonth() + 1, 2) + pad2(object.getUTCDate(), 2) + pad2(object.getUTCHours(), 2) + pad2(object.getUTCMinutes(), 2) + pad2(object.getUTCSeconds(), 2) + "Z)";
    }
    if (Array.isArray(object)) {
      const items = Array.from(object).map((e3) => _PDFObject.convert(e3)).join(" ");
      return `[${items}]`;
    }
    if ({}.toString.call(object) === "[object Object]") {
      const out = ["<<"];
      for (let key in object) {
        const val = object[key];
        out.push(`/${key} ${_PDFObject.convert(val)}`);
      }
      out.push(">>");
      return out.join("\n");
    }
    if (typeof object === "number") {
      return _PDFObject.number(object);
    }
    return `${object}`;
  }
  static number(n4) {
    if (n4 > -1e21 && n4 < 1e21) {
      return Math.round(n4 * 1e6) / 1e6;
    }
    throw new Error(`unsupported number: ${n4}`);
  }
};
var DEFAULT_MARGINS = {
  top: 72,
  left: 72,
  bottom: 72,
  right: 72
};
var SIZES = {
  "4A0": [4767.87, 6740.79],
  "2A0": [3370.39, 4767.87],
  A0: [2383.94, 3370.39],
  A1: [1683.78, 2383.94],
  A2: [1190.55, 1683.78],
  A3: [841.89, 1190.55],
  A4: [595.28, 841.89],
  A5: [419.53, 595.28],
  A6: [297.64, 419.53],
  A7: [209.76, 297.64],
  A8: [147.4, 209.76],
  A9: [104.88, 147.4],
  A10: [73.7, 104.88],
  B0: [2834.65, 4008.19],
  B1: [2004.09, 2834.65],
  B2: [1417.32, 2004.09],
  B3: [1000.63, 1417.32],
  B4: [708.66, 1000.63],
  B5: [498.9, 708.66],
  B6: [354.33, 498.9],
  B7: [249.45, 354.33],
  B8: [175.75, 249.45],
  B9: [124.72, 175.75],
  B10: [87.87, 124.72],
  C0: [2599.37, 3676.54],
  C1: [1836.85, 2599.37],
  C2: [1298.27, 1836.85],
  C3: [918.43, 1298.27],
  C4: [649.13, 918.43],
  C5: [459.21, 649.13],
  C6: [323.15, 459.21],
  C7: [229.61, 323.15],
  C8: [161.57, 229.61],
  C9: [113.39, 161.57],
  C10: [79.37, 113.39],
  RA0: [2437.8, 3458.27],
  RA1: [1729.13, 2437.8],
  RA2: [1218.9, 1729.13],
  RA3: [864.57, 1218.9],
  RA4: [609.45, 864.57],
  SRA0: [2551.18, 3628.35],
  SRA1: [1814.17, 2551.18],
  SRA2: [1275.59, 1814.17],
  SRA3: [907.09, 1275.59],
  SRA4: [637.8, 907.09],
  EXECUTIVE: [521.86, 756],
  FOLIO: [612, 936],
  LEGAL: [612, 1008],
  LETTER: [612, 792],
  TABLOID: [792, 1224]
};
var PDFPage = class {
  constructor(document2, options) {
    if (options === void 0) {
      options = {};
    }
    this.document = document2;
    this._options = options;
    this.size = options.size || "letter";
    this.layout = options.layout || "portrait";
    this.userUnit = options.userUnit || 1;
    if (typeof options.margin === "number") {
      this.margins = {
        top: options.margin,
        left: options.margin,
        bottom: options.margin,
        right: options.margin
      };
    } else {
      this.margins = options.margins || DEFAULT_MARGINS;
    }
    const dimensions = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];
    this.width = dimensions[this.layout === "portrait" ? 0 : 1];
    this.height = dimensions[this.layout === "portrait" ? 1 : 0];
    this.content = this.document.ref();
    if (options.font) document2.font(options.font, options.fontFamily);
    if (options.fontSize) document2.fontSize(options.fontSize);
    this.resources = this.document.ref({
      ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"]
    });
    this.dictionary = this.document.ref({
      Type: "Page",
      Parent: this.document._root.data.Pages,
      MediaBox: [0, 0, this.width, this.height],
      Contents: this.content,
      Resources: this.resources,
      UserUnit: this.userUnit
    });
    this.markings = [];
  }
  // Lazily create these objects
  get fonts() {
    const data2 = this.resources.data;
    return data2.Font != null ? data2.Font : data2.Font = {};
  }
  get xobjects() {
    const data2 = this.resources.data;
    return data2.XObject != null ? data2.XObject : data2.XObject = {};
  }
  get ext_gstates() {
    const data2 = this.resources.data;
    return data2.ExtGState != null ? data2.ExtGState : data2.ExtGState = {};
  }
  get patterns() {
    const data2 = this.resources.data;
    return data2.Pattern != null ? data2.Pattern : data2.Pattern = {};
  }
  get colorSpaces() {
    const data2 = this.resources.data;
    return data2.ColorSpace || (data2.ColorSpace = {});
  }
  get annotations() {
    const data2 = this.dictionary.data;
    return data2.Annots != null ? data2.Annots : data2.Annots = [];
  }
  get structParentTreeKey() {
    const data2 = this.dictionary.data;
    return data2.StructParents != null ? data2.StructParents : data2.StructParents = this.document.createStructParentTreeNextKey();
  }
  maxY() {
    return this.height - this.margins.bottom;
  }
  write(chunk) {
    return this.content.write(chunk);
  }
  // Set tab order if document is tagged for accessibility.
  _setTabOrder() {
    if (!this.dictionary.Tabs && this.document.hasMarkInfoDictionary()) {
      this.dictionary.data.Tabs = "S";
    }
  }
  end() {
    this._setTabOrder();
    this.dictionary.end();
    this.resources.data.ColorSpace = this.resources.data.ColorSpace || {};
    for (let color of Object.values(this.document.spotColors)) {
      this.resources.data.ColorSpace[color.id] = color;
    }
    this.resources.end();
    return this.content.end();
  }
};
var wordArrayToBuffer = (wordArray) => {
  const byteArray = [];
  for (let i3 = 0; i3 < wordArray.sigBytes; i3++) {
    byteArray.push(wordArray.words[Math.floor(i3 / 4)] >> 8 * (3 - i3 % 4) & 255);
  }
  return Buffer$2.from(byteArray);
};
var PDFSecurity = class {
  static generateFileID(info) {
    if (info === void 0) {
      info = {};
    }
    let infoStr = `${info.CreationDate.getTime()}
`;
    for (let key in info) {
      if (!info.hasOwnProperty(key)) continue;
      infoStr += `${key}: ${info[key].valueOf()}
`;
    }
    return wordArrayToBuffer((0, import_md5.default)(infoStr));
  }
};
var {
  number: number$2
} = PDFObject;
var PDFGradient$1 = class PDFGradient {
  constructor(doc) {
    this.doc = doc;
    this.stops = [];
    this.embedded = false;
    this.transform = [1, 0, 0, 1, 0, 0];
  }
  stop(pos, color, opacity) {
    if (opacity == null) {
      opacity = 1;
    }
    color = this.doc._normalizeColor(color);
    if (this.stops.length === 0) {
      if (color.length === 3) {
        this._colorSpace = "DeviceRGB";
      } else if (color.length === 4) {
        this._colorSpace = "DeviceCMYK";
      } else if (color.length === 1) {
        this._colorSpace = "DeviceGray";
      } else {
        throw new Error("Unknown color space");
      }
    } else if (this._colorSpace === "DeviceRGB" && color.length !== 3 || this._colorSpace === "DeviceCMYK" && color.length !== 4 || this._colorSpace === "DeviceGray" && color.length !== 1) {
      throw new Error("All gradient stops must use the same color space");
    }
    opacity = Math.max(0, Math.min(1, opacity));
    this.stops.push([pos, color, opacity]);
    return this;
  }
  setTransform(m11, m12, m21, m22, dx, dy) {
    this.transform = [m11, m12, m21, m22, dx, dy];
    return this;
  }
  embed(m) {
    let fn;
    const stopsLength = this.stops.length;
    if (stopsLength === 0) {
      return;
    }
    this.embedded = true;
    this.matrix = m;
    const last2 = this.stops[stopsLength - 1];
    if (last2[0] < 1) {
      this.stops.push([1, last2[1], last2[2]]);
    }
    const bounds = [];
    const encode = [];
    const stops = [];
    for (let i3 = 0; i3 < stopsLength - 1; i3++) {
      encode.push(0, 1);
      if (i3 + 2 !== stopsLength) {
        bounds.push(this.stops[i3 + 1][0]);
      }
      fn = this.doc.ref({
        FunctionType: 2,
        Domain: [0, 1],
        C0: this.stops[i3 + 0][1],
        C1: this.stops[i3 + 1][1],
        N: 1
      });
      stops.push(fn);
      fn.end();
    }
    if (stopsLength === 1) {
      fn = stops[0];
    } else {
      fn = this.doc.ref({
        FunctionType: 3,
        // stitching function
        Domain: [0, 1],
        Functions: stops,
        Bounds: bounds,
        Encode: encode
      });
      fn.end();
    }
    this.id = `Sh${++this.doc._gradCount}`;
    const shader = this.shader(fn);
    shader.end();
    const pattern3 = this.doc.ref({
      Type: "Pattern",
      PatternType: 2,
      Shading: shader,
      Matrix: this.matrix.map(number$2)
    });
    pattern3.end();
    if (this.stops.some((stop) => stop[2] < 1)) {
      let grad = this.opacityGradient();
      grad._colorSpace = "DeviceGray";
      for (let stop of this.stops) {
        grad.stop(stop[0], [stop[2]]);
      }
      grad = grad.embed(this.matrix);
      const pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];
      const form = this.doc.ref({
        Type: "XObject",
        Subtype: "Form",
        FormType: 1,
        BBox: pageBBox,
        Group: {
          Type: "Group",
          S: "Transparency",
          CS: "DeviceGray"
        },
        Resources: {
          ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
          Pattern: {
            Sh1: grad
          }
        }
      });
      form.write("/Pattern cs /Sh1 scn");
      form.end(`${pageBBox.join(" ")} re f`);
      const gstate = this.doc.ref({
        Type: "ExtGState",
        SMask: {
          Type: "Mask",
          S: "Luminosity",
          G: form
        }
      });
      gstate.end();
      const opacityPattern = this.doc.ref({
        Type: "Pattern",
        PatternType: 1,
        PaintType: 1,
        TilingType: 2,
        BBox: pageBBox,
        XStep: pageBBox[2],
        YStep: pageBBox[3],
        Resources: {
          ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
          Pattern: {
            Sh1: pattern3
          },
          ExtGState: {
            Gs1: gstate
          }
        }
      });
      opacityPattern.write("/Gs1 gs /Pattern cs /Sh1 scn");
      opacityPattern.end(`${pageBBox.join(" ")} re f`);
      this.doc.page.patterns[this.id] = opacityPattern;
    } else {
      this.doc.page.patterns[this.id] = pattern3;
    }
    return pattern3;
  }
  apply(stroke) {
    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;
    const [m11, m12, m21, m22, dx, dy] = this.transform;
    const m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];
    if (!this.embedded || m.join(" ") !== this.matrix.join(" ")) {
      this.embed(m);
    }
    this.doc._setColorSpace("Pattern", stroke);
    const op = stroke ? "SCN" : "scn";
    return this.doc.addContent(`/${this.id} ${op}`);
  }
};
var PDFLinearGradient$1 = class PDFLinearGradient extends PDFGradient$1 {
  constructor(doc, x1, y1, x2, y2) {
    super(doc);
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }
  shader(fn) {
    return this.doc.ref({
      ShadingType: 2,
      ColorSpace: this._colorSpace,
      Coords: [this.x1, this.y1, this.x2, this.y2],
      Function: fn,
      Extend: [true, true]
    });
  }
  opacityGradient() {
    return new PDFLinearGradient(this.doc, this.x1, this.y1, this.x2, this.y2);
  }
};
var PDFRadialGradient$1 = class PDFRadialGradient extends PDFGradient$1 {
  constructor(doc, x1, y1, r1, x2, y2, r22) {
    super(doc);
    this.doc = doc;
    this.x1 = x1;
    this.y1 = y1;
    this.r1 = r1;
    this.x2 = x2;
    this.y2 = y2;
    this.r2 = r22;
  }
  shader(fn) {
    return this.doc.ref({
      ShadingType: 3,
      ColorSpace: this._colorSpace,
      Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],
      Function: fn,
      Extend: [true, true]
    });
  }
  opacityGradient() {
    return new PDFRadialGradient(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
  }
};
var Gradient = {
  PDFGradient: PDFGradient$1,
  PDFLinearGradient: PDFLinearGradient$1,
  PDFRadialGradient: PDFRadialGradient$1
};
var underlyingColorSpaces = ["DeviceCMYK", "DeviceRGB"];
var PDFTilingPattern$1 = class PDFTilingPattern {
  constructor(doc, bBox, xStep, yStep, stream2) {
    this.doc = doc;
    this.bBox = bBox;
    this.xStep = xStep;
    this.yStep = yStep;
    this.stream = stream2;
  }
  createPattern() {
    const resources = this.doc.ref();
    resources.end();
    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;
    const [m11, m12, m21, m22, dx, dy] = [1, 0, 0, 1, 0, 0];
    const m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];
    const pattern3 = this.doc.ref({
      Type: "Pattern",
      PatternType: 1,
      // tiling
      PaintType: 2,
      // 1-colored, 2-uncolored
      TilingType: 2,
      // 2-no distortion
      BBox: this.bBox,
      XStep: this.xStep,
      YStep: this.yStep,
      Matrix: m.map((v2) => +v2.toFixed(5)),
      Resources: resources
    });
    pattern3.end(this.stream);
    return pattern3;
  }
  embedPatternColorSpaces() {
    underlyingColorSpaces.forEach((csName) => {
      const csId = this.getPatternColorSpaceId(csName);
      if (this.doc.page.colorSpaces[csId]) return;
      const cs = this.doc.ref(["Pattern", csName]);
      cs.end();
      this.doc.page.colorSpaces[csId] = cs;
    });
  }
  getPatternColorSpaceId(underlyingColorspace) {
    return `CsP${underlyingColorspace}`;
  }
  embed() {
    if (!this.id) {
      this.doc._patternCount = this.doc._patternCount + 1;
      this.id = "P" + this.doc._patternCount;
      this.pattern = this.createPattern();
    }
    if (!this.doc.page.patterns[this.id]) {
      this.doc.page.patterns[this.id] = this.pattern;
    }
  }
  apply(stroke, patternColor) {
    this.embedPatternColorSpaces();
    this.embed();
    const normalizedColor = this.doc._normalizeColor(patternColor);
    if (!normalizedColor) throw Error(`invalid pattern color. (value: ${patternColor})`);
    const csId = this.getPatternColorSpaceId(this.doc._getColorSpace(normalizedColor));
    this.doc._setColorSpace(csId, stroke);
    const op = stroke ? "SCN" : "scn";
    return this.doc.addContent(`${normalizedColor.join(" ")} /${this.id} ${op}`);
  }
};
var pattern = {
  PDFTilingPattern: PDFTilingPattern$1
};
var SpotColor = class {
  constructor(doc, name, C, M, Y, K) {
    this.id = "CS" + Object.keys(doc.spotColors).length;
    this.name = name;
    this.values = [C, M, Y, K];
    this.ref = doc.ref(["Separation", this.name, "DeviceCMYK", {
      Range: [0, 1, 0, 1, 0, 1, 0, 1],
      C0: [0, 0, 0, 0],
      C1: this.values.map((value2) => value2 / 100),
      FunctionType: 2,
      Domain: [0, 1],
      N: 1
    }]);
    this.ref.end();
  }
  toString() {
    return `${this.ref.id} 0 R`;
  }
};
var {
  PDFGradient: PDFGradient2,
  PDFLinearGradient: PDFLinearGradient2,
  PDFRadialGradient: PDFRadialGradient2
} = Gradient;
var {
  PDFTilingPattern: PDFTilingPattern2
} = pattern;
var ColorMixin = {
  initColor() {
    this.spotColors = {};
    this._opacityRegistry = {};
    this._opacityCount = 0;
    this._patternCount = 0;
    return this._gradCount = 0;
  },
  _normalizeColor(color) {
    if (typeof color === "string") {
      if (color.charAt(0) === "#") {
        if (color.length === 4) {
          color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, "#$1$1$2$2$3$3");
        }
        const hex = parseInt(color.slice(1), 16);
        color = [hex >> 16, hex >> 8 & 255, hex & 255];
      } else if (namedColors[color]) {
        color = namedColors[color];
      } else if (this.spotColors[color]) {
        return this.spotColors[color];
      }
    }
    if (Array.isArray(color)) {
      if (color.length === 3) {
        color = color.map((part) => part / 255);
      } else if (color.length === 4) {
        color = color.map((part) => part / 100);
      }
      return color;
    }
    return null;
  },
  _setColor(color, stroke) {
    if (color instanceof PDFGradient2) {
      color.apply(stroke);
      return true;
    } else if (Array.isArray(color) && color[0] instanceof PDFTilingPattern2) {
      color[0].apply(stroke, color[1]);
      return true;
    }
    return this._setColorCore(color, stroke);
  },
  _setColorCore(color, stroke) {
    color = this._normalizeColor(color);
    if (!color) {
      return false;
    }
    const op = stroke ? "SCN" : "scn";
    const space = this._getColorSpace(color);
    this._setColorSpace(space, stroke);
    if (color instanceof SpotColor) {
      this.page.colorSpaces[color.id] = color.ref;
      this.addContent(`1 ${op}`);
    } else {
      this.addContent(`${color.join(" ")} ${op}`);
    }
    return true;
  },
  _setColorSpace(space, stroke) {
    const op = stroke ? "CS" : "cs";
    return this.addContent(`/${space} ${op}`);
  },
  _getColorSpace(color) {
    if (color instanceof SpotColor) {
      return color.id;
    }
    return color.length === 4 ? "DeviceCMYK" : "DeviceRGB";
  },
  fillColor(color, opacity) {
    const set5 = this._setColor(color, false);
    if (set5) {
      this.fillOpacity(opacity);
    }
    this._fillColor = [color, opacity];
    return this;
  },
  strokeColor(color, opacity) {
    const set5 = this._setColor(color, true);
    if (set5) {
      this.strokeOpacity(opacity);
    }
    return this;
  },
  opacity(opacity) {
    this._doOpacity(opacity, opacity);
    return this;
  },
  fillOpacity(opacity) {
    this._doOpacity(opacity, null);
    return this;
  },
  strokeOpacity(opacity) {
    this._doOpacity(null, opacity);
    return this;
  },
  _doOpacity(fillOpacity, strokeOpacity) {
    let dictionary, name;
    if (fillOpacity == null && strokeOpacity == null) {
      return;
    }
    if (fillOpacity != null) {
      fillOpacity = Math.max(0, Math.min(1, fillOpacity));
    }
    if (strokeOpacity != null) {
      strokeOpacity = Math.max(0, Math.min(1, strokeOpacity));
    }
    const key = `${fillOpacity}_${strokeOpacity}`;
    if (this._opacityRegistry[key]) {
      [dictionary, name] = this._opacityRegistry[key];
    } else {
      dictionary = {
        Type: "ExtGState"
      };
      if (fillOpacity != null) {
        dictionary.ca = fillOpacity;
      }
      if (strokeOpacity != null) {
        dictionary.CA = strokeOpacity;
      }
      dictionary = this.ref(dictionary);
      dictionary.end();
      const id = ++this._opacityCount;
      name = `Gs${id}`;
      this._opacityRegistry[key] = [dictionary, name];
    }
    this.page.ext_gstates[name] = dictionary;
    return this.addContent(`/${name} gs`);
  },
  linearGradient(x1, y1, x2, y2) {
    return new PDFLinearGradient2(this, x1, y1, x2, y2);
  },
  radialGradient(x1, y1, r1, x2, y2, r22) {
    return new PDFRadialGradient2(this, x1, y1, r1, x2, y2, r22);
  },
  pattern(bbox, xStep, yStep, stream2) {
    return new PDFTilingPattern2(this, bbox, xStep, yStep, stream2);
  },
  addSpotColor(name, C, M, Y, K) {
    const color = new SpotColor(this, name, C, M, Y, K);
    this.spotColors[name] = color;
    return this;
  }
};
var namedColors = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var cx;
var cy;
var px;
var py;
var sx;
var sy;
cx = cy = px = py = sx = sy = 0;
var argsCountPerCommand = {
  M: 2,
  m: 2,
  Z: 0,
  z: 0,
  L: 2,
  l: 2,
  H: 1,
  h: 1,
  V: 1,
  v: 1,
  C: 6,
  c: 6,
  S: 4,
  s: 4,
  Q: 4,
  q: 4,
  T: 2,
  t: 2,
  A: 7,
  a: 7
};
var isCommand = (c3) => {
  return c3 in argsCountPerCommand;
};
var isWsp = (c3) => {
  const codePoint = c3.codePointAt(0);
  return codePoint === 32 || codePoint === 9 || codePoint === 13 || codePoint === 10;
};
var isDigit = (c3) => {
  const codePoint = c3.codePointAt(0);
  if (codePoint == null) {
    return false;
  }
  return 48 <= codePoint && codePoint <= 57;
};
var readNumber = (string, cursor) => {
  let i3 = cursor;
  let value2 = "";
  let state2 = (
    /** @type {ReadNumberState} */
    "none"
  );
  for (; i3 < string.length; i3 += 1) {
    const c3 = string[i3];
    if (c3 === "+" || c3 === "-") {
      if (state2 === "none") {
        state2 = "sign";
        value2 += c3;
        continue;
      }
      if (state2 === "e") {
        state2 = "exponent_sign";
        value2 += c3;
        continue;
      }
    }
    if (isDigit(c3)) {
      if (state2 === "none" || state2 === "sign" || state2 === "whole") {
        state2 = "whole";
        value2 += c3;
        continue;
      }
      if (state2 === "decimal_point" || state2 === "decimal") {
        state2 = "decimal";
        value2 += c3;
        continue;
      }
      if (state2 === "e" || state2 === "exponent_sign" || state2 === "exponent") {
        state2 = "exponent";
        value2 += c3;
        continue;
      }
    }
    if (c3 === ".") {
      if (state2 === "none" || state2 === "sign" || state2 === "whole") {
        state2 = "decimal_point";
        value2 += c3;
        continue;
      }
    }
    if (c3 === "E" || c3 === "e") {
      if (state2 === "whole" || state2 === "decimal_point" || state2 === "decimal") {
        state2 = "e";
        value2 += c3;
        continue;
      }
    }
    break;
  }
  const number3 = Number.parseFloat(value2);
  if (Number.isNaN(number3)) {
    return [cursor, null];
  }
  return [i3 - 1, number3];
};
var parsePathData = (string) => {
  const pathData = [];
  let command = null;
  let args = (
    /** @type {number[]} */
    []
  );
  let argsCount = 0;
  let canHaveComma = false;
  let hadComma = false;
  for (let i3 = 0; i3 < string.length; i3 += 1) {
    const c3 = string.charAt(i3);
    if (isWsp(c3)) {
      continue;
    }
    if (canHaveComma && c3 === ",") {
      if (hadComma) {
        break;
      }
      hadComma = true;
      continue;
    }
    if (isCommand(c3)) {
      if (hadComma) {
        return pathData;
      }
      if (command == null) {
        if (c3 !== "M" && c3 !== "m") {
          return pathData;
        }
      } else {
        if (args.length !== 0) {
          return pathData;
        }
      }
      command = c3;
      args = [];
      argsCount = argsCountPerCommand[command];
      canHaveComma = false;
      if (argsCount === 0) {
        pathData.push({
          command,
          args
        });
      }
      continue;
    }
    if (command == null) {
      return pathData;
    }
    let newCursor = i3;
    let number3 = null;
    if (command === "A" || command === "a") {
      const position = args.length;
      if (position === 0 || position === 1) {
        if (c3 !== "+" && c3 !== "-") {
          [newCursor, number3] = readNumber(string, i3);
        }
      }
      if (position === 2 || position === 5 || position === 6) {
        [newCursor, number3] = readNumber(string, i3);
      }
      if (position === 3 || position === 4) {
        if (c3 === "0") {
          number3 = 0;
        }
        if (c3 === "1") {
          number3 = 1;
        }
      }
    } else {
      [newCursor, number3] = readNumber(string, i3);
    }
    if (number3 == null) {
      return pathData;
    }
    args.push(number3);
    canHaveComma = true;
    hadComma = false;
    i3 = newCursor;
    if (args.length === argsCount) {
      pathData.push({
        command,
        args
      });
      if (command === "M") {
        command = "L";
      }
      if (command === "m") {
        command = "l";
      }
      args = [];
    }
  }
  return pathData;
};
var apply = function(commands, doc) {
  cx = cy = px = py = sx = sy = 0;
  for (let i3 = 0; i3 < commands.length; i3++) {
    const {
      command,
      args
    } = commands[i3];
    if (typeof runners[command] === "function") {
      runners[command](doc, args);
    }
  }
};
var runners = {
  M(doc, a3) {
    cx = a3[0];
    cy = a3[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return doc.moveTo(cx, cy);
  },
  m(doc, a3) {
    cx += a3[0];
    cy += a3[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return doc.moveTo(cx, cy);
  },
  C(doc, a3) {
    cx = a3[4];
    cy = a3[5];
    px = a3[2];
    py = a3[3];
    return doc.bezierCurveTo(...a3);
  },
  c(doc, a3) {
    doc.bezierCurveTo(a3[0] + cx, a3[1] + cy, a3[2] + cx, a3[3] + cy, a3[4] + cx, a3[5] + cy);
    px = cx + a3[2];
    py = cy + a3[3];
    cx += a3[4];
    return cy += a3[5];
  },
  S(doc, a3) {
    if (px === null) {
      px = cx;
      py = cy;
    }
    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a3[0], a3[1], a3[2], a3[3]);
    px = a3[0];
    py = a3[1];
    cx = a3[2];
    return cy = a3[3];
  },
  s(doc, a3) {
    if (px === null) {
      px = cx;
      py = cy;
    }
    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a3[0], cy + a3[1], cx + a3[2], cy + a3[3]);
    px = cx + a3[0];
    py = cy + a3[1];
    cx += a3[2];
    return cy += a3[3];
  },
  Q(doc, a3) {
    px = a3[0];
    py = a3[1];
    cx = a3[2];
    cy = a3[3];
    return doc.quadraticCurveTo(a3[0], a3[1], cx, cy);
  },
  q(doc, a3) {
    doc.quadraticCurveTo(a3[0] + cx, a3[1] + cy, a3[2] + cx, a3[3] + cy);
    px = cx + a3[0];
    py = cy + a3[1];
    cx += a3[2];
    return cy += a3[3];
  },
  T(doc, a3) {
    if (px === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    doc.quadraticCurveTo(px, py, a3[0], a3[1]);
    px = cx - (px - cx);
    py = cy - (py - cy);
    cx = a3[0];
    return cy = a3[1];
  },
  t(doc, a3) {
    if (px === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    doc.quadraticCurveTo(px, py, cx + a3[0], cy + a3[1]);
    cx += a3[0];
    return cy += a3[1];
  },
  A(doc, a3) {
    solveArc(doc, cx, cy, a3);
    cx = a3[5];
    return cy = a3[6];
  },
  a(doc, a3) {
    a3[5] += cx;
    a3[6] += cy;
    solveArc(doc, cx, cy, a3);
    cx = a3[5];
    return cy = a3[6];
  },
  L(doc, a3) {
    cx = a3[0];
    cy = a3[1];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  l(doc, a3) {
    cx += a3[0];
    cy += a3[1];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  H(doc, a3) {
    cx = a3[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  h(doc, a3) {
    cx += a3[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  V(doc, a3) {
    cy = a3[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  v(doc, a3) {
    cy += a3[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  Z(doc) {
    doc.closePath();
    cx = sx;
    return cy = sy;
  },
  z(doc) {
    doc.closePath();
    cx = sx;
    return cy = sy;
  }
};
var solveArc = function(doc, x, y2, coords) {
  const [rx, ry, rot, large, sweep, ex, ey] = coords;
  const segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y2);
  for (let seg of segs) {
    const bez = segmentToBezier(...seg);
    doc.bezierCurveTo(...bez);
  }
};
var arcToSegments = function(x, y2, rx, ry, large, sweep, rotateX, ox, oy) {
  const th = rotateX * (Math.PI / 180);
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y2) * 0.5;
  py = cos_th * (oy - y2) * 0.5 - sin_th * (ox - x) * 0.5;
  let pl = px * px / (rx * rx) + py * py / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x0 = a00 * ox + a01 * oy;
  const y0 = a10 * ox + a11 * oy;
  const x1 = a00 * x + a01 * y2;
  const y1 = a10 * x + a11 * y2;
  const d2 = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
  let sfactor_sq = 1 / d2 - 0.25;
  if (sfactor_sq < 0) {
    sfactor_sq = 0;
  }
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep === large) {
    sfactor = -sfactor;
  }
  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
  const th0 = Math.atan2(y0 - yc, x0 - xc);
  const th1 = Math.atan2(y1 - yc, x1 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += 2 * Math.PI;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= 2 * Math.PI;
  }
  const segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 1e-3)));
  const result = [];
  for (let i3 = 0; i3 < segments; i3++) {
    const th2 = th0 + i3 * th_arc / segments;
    const th3 = th0 + (i3 + 1) * th_arc / segments;
    result[i3] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return result;
};
var segmentToBezier = function(cx2, cy2, th0, th1, rx, ry, sin_th, cos_th) {
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const th_half = 0.5 * (th1 - th0);
  const t3 = 8 / 3 * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);
  const x1 = cx2 + Math.cos(th0) - t3 * Math.sin(th0);
  const y1 = cy2 + Math.sin(th0) + t3 * Math.cos(th0);
  const x3 = cx2 + Math.cos(th1);
  const y3 = cy2 + Math.sin(th1);
  const x2 = x3 + t3 * Math.sin(th1);
  const y2 = y3 - t3 * Math.cos(th1);
  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
};
var SVGPath = class {
  static apply(doc, path) {
    const commands = parsePathData(path);
    apply(commands, doc);
  }
};
var {
  number: number$1
} = PDFObject;
var KAPPA2 = 4 * ((Math.sqrt(2) - 1) / 3);
var VectorMixin = {
  initVector() {
    this._ctm = [1, 0, 0, 1, 0, 0];
    return this._ctmStack = [];
  },
  save() {
    this._ctmStack.push(this._ctm.slice());
    return this.addContent("q");
  },
  restore() {
    this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];
    return this.addContent("Q");
  },
  closePath() {
    return this.addContent("h");
  },
  lineWidth(w) {
    return this.addContent(`${number$1(w)} w`);
  },
  _CAP_STYLES: {
    BUTT: 0,
    ROUND: 1,
    SQUARE: 2
  },
  lineCap(c3) {
    if (typeof c3 === "string") {
      c3 = this._CAP_STYLES[c3.toUpperCase()];
    }
    return this.addContent(`${c3} J`);
  },
  _JOIN_STYLES: {
    MITER: 0,
    ROUND: 1,
    BEVEL: 2
  },
  lineJoin(j) {
    if (typeof j === "string") {
      j = this._JOIN_STYLES[j.toUpperCase()];
    }
    return this.addContent(`${j} j`);
  },
  miterLimit(m) {
    return this.addContent(`${number$1(m)} M`);
  },
  dash(length2, options) {
    if (options === void 0) {
      options = {};
    }
    const originalLength = length2;
    if (!Array.isArray(length2)) {
      length2 = [length2, options.space || length2];
    }
    const valid = length2.every((x) => Number.isFinite(x) && x > 0);
    if (!valid) {
      throw new Error(`dash(${JSON.stringify(originalLength)}, ${JSON.stringify(options)}) invalid, lengths must be numeric and greater than zero`);
    }
    length2 = length2.map(number$1).join(" ");
    return this.addContent(`[${length2}] ${number$1(options.phase || 0)} d`);
  },
  undash() {
    return this.addContent("[] 0 d");
  },
  moveTo(x, y2) {
    return this.addContent(`${number$1(x)} ${number$1(y2)} m`);
  },
  lineTo(x, y2) {
    return this.addContent(`${number$1(x)} ${number$1(y2)} l`);
  },
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y2) {
    return this.addContent(`${number$1(cp1x)} ${number$1(cp1y)} ${number$1(cp2x)} ${number$1(cp2y)} ${number$1(x)} ${number$1(y2)} c`);
  },
  quadraticCurveTo(cpx, cpy, x, y2) {
    return this.addContent(`${number$1(cpx)} ${number$1(cpy)} ${number$1(x)} ${number$1(y2)} v`);
  },
  rect(x, y2, w, h2) {
    return this.addContent(`${number$1(x)} ${number$1(y2)} ${number$1(w)} ${number$1(h2)} re`);
  },
  roundedRect(x, y2, w, h2, r3) {
    if (r3 == null) {
      r3 = 0;
    }
    r3 = Math.min(r3, 0.5 * w, 0.5 * h2);
    const c3 = r3 * (1 - KAPPA2);
    this.moveTo(x + r3, y2);
    this.lineTo(x + w - r3, y2);
    this.bezierCurveTo(x + w - c3, y2, x + w, y2 + c3, x + w, y2 + r3);
    this.lineTo(x + w, y2 + h2 - r3);
    this.bezierCurveTo(x + w, y2 + h2 - c3, x + w - c3, y2 + h2, x + w - r3, y2 + h2);
    this.lineTo(x + r3, y2 + h2);
    this.bezierCurveTo(x + c3, y2 + h2, x, y2 + h2 - c3, x, y2 + h2 - r3);
    this.lineTo(x, y2 + r3);
    this.bezierCurveTo(x, y2 + c3, x + c3, y2, x + r3, y2);
    return this.closePath();
  },
  ellipse(x, y2, r1, r22) {
    if (r22 == null) {
      r22 = r1;
    }
    x -= r1;
    y2 -= r22;
    const ox = r1 * KAPPA2;
    const oy = r22 * KAPPA2;
    const xe = x + r1 * 2;
    const ye = y2 + r22 * 2;
    const xm = x + r1;
    const ym = y2 + r22;
    this.moveTo(x, ym);
    this.bezierCurveTo(x, ym - oy, xm - ox, y2, xm, y2);
    this.bezierCurveTo(xm + ox, y2, xe, ym - oy, xe, ym);
    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
    return this.closePath();
  },
  circle(x, y2, radius) {
    return this.ellipse(x, y2, radius);
  },
  arc(x, y2, radius, startAngle, endAngle, anticlockwise) {
    if (anticlockwise == null) {
      anticlockwise = false;
    }
    const TWO_PI = 2 * Math.PI;
    const HALF_PI = 0.5 * Math.PI;
    let deltaAng = endAngle - startAngle;
    if (Math.abs(deltaAng) > TWO_PI) {
      deltaAng = TWO_PI;
    } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {
      const dir = anticlockwise ? -1 : 1;
      deltaAng = dir * TWO_PI + deltaAng;
    }
    const numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);
    const segAng = deltaAng / numSegs;
    const handleLen = segAng / HALF_PI * KAPPA2 * radius;
    let curAng = startAngle;
    let deltaCx = -Math.sin(curAng) * handleLen;
    let deltaCy = Math.cos(curAng) * handleLen;
    let ax = x + Math.cos(curAng) * radius;
    let ay = y2 + Math.sin(curAng) * radius;
    this.moveTo(ax, ay);
    for (let segIdx = 0; segIdx < numSegs; segIdx++) {
      const cp1x = ax + deltaCx;
      const cp1y = ay + deltaCy;
      curAng += segAng;
      ax = x + Math.cos(curAng) * radius;
      ay = y2 + Math.sin(curAng) * radius;
      deltaCx = -Math.sin(curAng) * handleLen;
      deltaCy = Math.cos(curAng) * handleLen;
      const cp2x = ax - deltaCx;
      const cp2y = ay - deltaCy;
      this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);
    }
    return this;
  },
  polygon() {
    for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
      points[_key] = arguments[_key];
    }
    this.moveTo(...points.shift() || []);
    for (let point of points) {
      this.lineTo(...point || []);
    }
    return this.closePath();
  },
  path(path) {
    SVGPath.apply(this, path);
    return this;
  },
  _windingRule(rule) {
    if (/even-?odd/.test(rule)) {
      return "*";
    }
    return "";
  },
  fill(color, rule) {
    if (/(even-?odd)|(non-?zero)/.test(color)) {
      rule = color;
      color = null;
    }
    if (color) {
      this.fillColor(color);
    }
    return this.addContent(`f${this._windingRule(rule)}`);
  },
  stroke(color) {
    if (color) {
      this.strokeColor(color);
    }
    return this.addContent("S");
  },
  fillAndStroke(fillColor, strokeColor, rule) {
    if (strokeColor == null) {
      strokeColor = fillColor;
    }
    const isFillRule = /(even-?odd)|(non-?zero)/;
    if (isFillRule.test(fillColor)) {
      rule = fillColor;
      fillColor = null;
    }
    if (isFillRule.test(strokeColor)) {
      rule = strokeColor;
      strokeColor = fillColor;
    }
    if (fillColor) {
      this.fillColor(fillColor);
      this.strokeColor(strokeColor);
    }
    return this.addContent(`B${this._windingRule(rule)}`);
  },
  clip(rule) {
    return this.addContent(`W${this._windingRule(rule)} n`);
  },
  transform(m11, m12, m21, m22, dx, dy) {
    if (m11 === 1 && m12 === 0 && m21 === 0 && m22 === 1 && dx === 0 && dy === 0) {
      return this;
    }
    const m = this._ctm;
    const [m0, m1, m2, m3, m4, m5] = m;
    m[0] = m0 * m11 + m2 * m12;
    m[1] = m1 * m11 + m3 * m12;
    m[2] = m0 * m21 + m2 * m22;
    m[3] = m1 * m21 + m3 * m22;
    m[4] = m0 * dx + m2 * dy + m4;
    m[5] = m1 * dx + m3 * dy + m5;
    const values = [m11, m12, m21, m22, dx, dy].map((v2) => number$1(v2)).join(" ");
    return this.addContent(`${values} cm`);
  },
  translate(x, y2) {
    return this.transform(1, 0, 0, 1, x, y2);
  },
  rotate(angle, options) {
    if (options === void 0) {
      options = {};
    }
    let y2;
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    let x = y2 = 0;
    if (options.origin != null) {
      [x, y2] = options.origin;
      const x1 = x * cos - y2 * sin;
      const y1 = x * sin + y2 * cos;
      x -= x1;
      y2 -= y1;
    }
    return this.transform(cos, sin, -sin, cos, x, y2);
  },
  scale(xFactor, yFactor, options) {
    if (options === void 0) {
      options = {};
    }
    let y2;
    if (yFactor == null) {
      yFactor = xFactor;
    }
    if (typeof yFactor === "object") {
      options = yFactor;
      yFactor = xFactor;
    }
    let x = y2 = 0;
    if (options.origin != null) {
      [x, y2] = options.origin;
      x -= xFactor * x;
      y2 -= yFactor * y2;
    }
    return this.transform(xFactor, 0, 0, yFactor, x, y2);
  }
};
var fs = {};
var range = (left, right, inclusive) => {
  let range2 = [];
  let end2 = right + 1;
  for (let i3 = left; i3 < end2; i3++) {
    range2.push(i3);
  }
  return range2;
};
var WIN_ANSI_MAP = {
  402: 131,
  8211: 150,
  8212: 151,
  8216: 145,
  8217: 146,
  8218: 130,
  8220: 147,
  8221: 148,
  8222: 132,
  8224: 134,
  8225: 135,
  8226: 149,
  8230: 133,
  8364: 128,
  8240: 137,
  8249: 139,
  8250: 155,
  710: 136,
  8482: 153,
  338: 140,
  339: 156,
  732: 152,
  352: 138,
  353: 154,
  376: 159,
  381: 142,
  382: 158
};
var characters = `.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef

space         exclam         quotedbl       numbersign
dollar        percent        ampersand      quotesingle
parenleft     parenright     asterisk       plus
comma         hyphen         period         slash
zero          one            two            three
four          five           six            seven
eight         nine           colon          semicolon
less          equal          greater        question

at            A              B              C
D             E              F              G
H             I              J              K
L             M              N              O
P             Q              R              S
T             U              V              W
X             Y              Z              bracketleft
backslash     bracketright   asciicircum    underscore

grave         a              b              c
d             e              f              g
h             i              j              k
l             m              n              o
p             q              r              s
t             u              v              w
x             y              z              braceleft
bar           braceright     asciitilde     .notdef

Euro          .notdef        quotesinglbase florin
quotedblbase  ellipsis       dagger         daggerdbl
circumflex    perthousand    Scaron         guilsinglleft
OE            .notdef        Zcaron         .notdef
.notdef       quoteleft      quoteright     quotedblleft
quotedblright bullet         endash         emdash
tilde         trademark      scaron         guilsinglright
oe            .notdef        zcaron         ydieresis

space         exclamdown     cent           sterling
currency      yen            brokenbar      section
dieresis      copyright      ordfeminine    guillemotleft
logicalnot    hyphen         registered     macron
degree        plusminus      twosuperior    threesuperior
acute         mu             paragraph      periodcentered
cedilla       onesuperior    ordmasculine   guillemotright
onequarter    onehalf        threequarters  questiondown

Agrave        Aacute         Acircumflex    Atilde
Adieresis     Aring          AE             Ccedilla
Egrave        Eacute         Ecircumflex    Edieresis
Igrave        Iacute         Icircumflex    Idieresis
Eth           Ntilde         Ograve         Oacute
Ocircumflex   Otilde         Odieresis      multiply
Oslash        Ugrave         Uacute         Ucircumflex
Udieresis     Yacute         Thorn          germandbls

agrave        aacute         acircumflex    atilde
adieresis     aring          ae             ccedilla
egrave        eacute         ecircumflex    edieresis
igrave        iacute         icircumflex    idieresis
eth           ntilde         ograve         oacute
ocircumflex   otilde         odieresis      divide
oslash        ugrave         uacute         ucircumflex
udieresis     yacute         thorn          ydieresis`.split(/\s+/);
function parse(contents) {
  const obj = {
    attributes: {},
    glyphWidths: {},
    kernPairs: {}
  };
  let section = "";
  for (let line2 of contents.split("\n")) {
    var match;
    var a3;
    if (match = line2.match(/^Start(\w+)/)) {
      section = match[1];
      continue;
    } else if (match = line2.match(/^End(\w+)/)) {
      section = "";
      continue;
    }
    switch (section) {
      case "FontMetrics":
        match = line2.match(/(^\w+)\s+(.*)/);
        var key = match[1];
        var value2 = match[2];
        if (a3 = obj.attributes[key]) {
          if (!Array.isArray(a3)) {
            a3 = obj.attributes[key] = [a3];
          }
          a3.push(value2);
        } else {
          obj.attributes[key] = value2;
        }
        break;
      case "CharMetrics":
        if (!/^CH?\s/.test(line2)) {
          continue;
        }
        var name = line2.match(/\bN\s+(\.?\w+)\s*;/)[1];
        obj.glyphWidths[name] = +line2.match(/\bWX\s+(\d+)\s*;/)[1];
        break;
      case "KernPairs":
        match = line2.match(/^KPX\s+(\.?\w+)\s+(\.?\w+)\s+(-?\d+)/);
        if (match) {
          obj.kernPairs[match[1] + match[2]] = parseInt(match[3]);
        }
        break;
    }
  }
  return obj;
}
var AFMFont = class _AFMFont {
  static open(filename) {
    {
      throw new Error("AFMFont.open not available on browser build");
    }
  }
  static fromJson(json) {
    return new _AFMFont(json);
  }
  constructor(contents) {
    if (typeof contents === "string") {
      this.contents = contents;
      this.parse();
    } else {
      this.attributes = contents.attributes;
      this.glyphWidths = contents.glyphWidths;
      this.kernPairs = contents.kernPairs;
    }
    this.charWidths = range(0, 255).map((i3) => this.glyphWidths[characters[i3]]);
    this.bbox = Array.from(this.attributes.FontBBox.split(/\s+/)).map((e3) => +e3);
    this.ascender = +(this.attributes.Ascender || 0);
    this.descender = +(this.attributes.Descender || 0);
    this.xHeight = +(this.attributes.XHeight || 0);
    this.capHeight = +(this.attributes.CapHeight || 0);
    this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);
  }
  parse() {
    const parsed = parse(this.contents);
    this.attributes = parsed.attributes;
    this.glyphWidths = parsed.glyphWidths;
    this.kernPairs = parsed.kernPairs;
  }
  encodeText(text) {
    const res = [];
    for (let i3 = 0, end2 = text.length, asc = 0 <= end2; asc ? i3 < end2 : i3 > end2; asc ? i3++ : i3--) {
      let char = text.charCodeAt(i3);
      char = WIN_ANSI_MAP[char] || char;
      res.push(char.toString(16));
    }
    return res;
  }
  glyphsForString(string) {
    const glyphs = [];
    for (let i3 = 0, end2 = string.length, asc = 0 <= end2; asc ? i3 < end2 : i3 > end2; asc ? i3++ : i3--) {
      const charCode = string.charCodeAt(i3);
      glyphs.push(this.characterToGlyph(charCode));
    }
    return glyphs;
  }
  characterToGlyph(character) {
    return characters[WIN_ANSI_MAP[character] || character] || ".notdef";
  }
  widthOfGlyph(glyph) {
    return this.glyphWidths[glyph] || 0;
  }
  getKernPair(left, right) {
    return this.kernPairs[left + right] || 0;
  }
  advancesForGlyphs(glyphs) {
    const advances = [];
    for (let index3 = 0; index3 < glyphs.length; index3++) {
      const left = glyphs[index3];
      const right = glyphs[index3 + 1];
      advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));
    }
    return advances;
  }
};
var attributes = [
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:43:52 1997",
      "UniqueID 43052",
      "VMusage 37169 48194"
    ],
    FontName: "Helvetica-Bold",
    FullName: "Helvetica Bold",
    FamilyName: "Helvetica",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-170 -228 1003 962 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "532",
    Ascender: "718",
    Descender: "-207",
    StdHW: "118",
    StdVW: "140"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:45:12 1997",
      "UniqueID 43053",
      "VMusage 14482 68586"
    ],
    FontName: "Helvetica-BoldOblique",
    FullName: "Helvetica Bold Oblique",
    FamilyName: "Helvetica",
    Weight: "Bold",
    ItalicAngle: "-12",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-174 -228 1114 962",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "532",
    Ascender: "718",
    Descender: "-207",
    StdHW: "118",
    StdVW: "140"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:44:31 1997",
      "UniqueID 43055",
      "VMusage 14960 69346"
    ],
    FontName: "Helvetica-Oblique",
    FullName: "Helvetica Oblique",
    FamilyName: "Helvetica",
    Weight: "Medium",
    ItalicAngle: "-12",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-170 -225 1116 931 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "523",
    Ascender: "718",
    Descender: "-207",
    StdHW: "76",
    StdVW: "88"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:38:23 1997",
      "UniqueID 43054",
      "VMusage 37069 48094"
    ],
    FontName: "Helvetica",
    FullName: "Helvetica",
    FamilyName: "Helvetica",
    Weight: "Medium",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-166 -225 1000 931 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "523",
    Ascender: "718",
    Descender: "-207",
    StdHW: "76",
    StdVW: "88"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:52:56 1997",
      "UniqueID 43065",
      "VMusage 41636 52661"
    ],
    FontName: "Times-Bold",
    FullName: "Times Bold",
    FamilyName: "Times",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-168 -218 1000 935 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "676",
    XHeight: "461",
    Ascender: "683",
    Descender: "-217",
    StdHW: "44",
    StdVW: "139"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 13:04:06 1997",
      "UniqueID 43066",
      "VMusage 45874 56899"
    ],
    FontName: "Times-BoldItalic",
    FullName: "Times Bold Italic",
    FamilyName: "Times",
    Weight: "Bold",
    ItalicAngle: "-15",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-200 -218 996 921",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "669",
    XHeight: "462",
    Ascender: "683",
    Descender: "-217",
    StdHW: "42",
    StdVW: "121"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:56:55 1997",
      "UniqueID 43067",
      "VMusage 47727 58752"
    ],
    FontName: "Times-Italic",
    FullName: "Times Italic",
    FamilyName: "Times",
    Weight: "Medium",
    ItalicAngle: "-15.5",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-169 -217 1010 883 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "653",
    XHeight: "441",
    Ascender: "683",
    Descender: "-217",
    StdHW: "32",
    StdVW: "76"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:49:17 1997",
      "UniqueID 43068",
      "VMusage 43909 54934"
    ],
    FontName: "Times-Roman",
    FullName: "Times Roman",
    FamilyName: "Times",
    Weight: "Roman",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-168 -218 1000 898 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "662",
    XHeight: "450",
    Ascender: "683",
    Descender: "-217",
    StdHW: "28",
    StdVW: "84"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Mon Jun 23 16:28:00 1997",
      "UniqueID 43048",
      "VMusage 41139 52164"
    ],
    FontName: "Courier-Bold",
    FullName: "Courier Bold",
    FamilyName: "Courier",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-113 -250 749 801 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "439",
    Ascender: "629",
    Descender: "-157",
    StdHW: "84",
    StdVW: "106"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Mon Jun 23 16:28:46 1997",
      "UniqueID 43049",
      "VMusage 17529 79244"
    ],
    FontName: "Courier-BoldOblique",
    FullName: "Courier Bold Oblique",
    FamilyName: "Courier",
    Weight: "Bold",
    ItalicAngle: "-12",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-57 -250 869 801",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "439",
    Ascender: "629",
    Descender: "-157",
    StdHW: "84",
    StdVW: "106"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 17:37:52 1997",
      "UniqueID 43051",
      "VMusage 16248 75829"
    ],
    FontName: "Courier-Oblique",
    FullName: "Courier Oblique",
    FamilyName: "Courier",
    Weight: "Medium",
    ItalicAngle: "-12",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-27 -250 849 805 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "426",
    Ascender: "629",
    Descender: "-157",
    StdHW: "51",
    StdVW: "51"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 17:27:09 1997",
      "UniqueID 43050",
      "VMusage 39754 50779"
    ],
    FontName: "Courier",
    FullName: "Courier",
    FamilyName: "Courier",
    Weight: "Medium",
    ItalicAngle: "0",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-23 -250 715 805 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "426",
    Ascender: "629",
    Descender: "-157",
    StdHW: "51",
    StdVW: "51"
  }
];
var glyphWidths = {
  space: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  exclam: [
    333,
    333,
    278,
    278,
    333,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  quotedbl: [
    474,
    474,
    355,
    355,
    555,
    555,
    420,
    408,
    600,
    600,
    600,
    600
  ],
  numbersign: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  dollar: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  percent: [
    889,
    889,
    889,
    889,
    1e3,
    833,
    833,
    833,
    600,
    600,
    600,
    600
  ],
  ampersand: [
    722,
    722,
    667,
    667,
    833,
    778,
    778,
    778,
    600,
    600,
    600,
    600
  ],
  quoteright: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  parenleft: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  parenright: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  asterisk: [
    389,
    389,
    389,
    389,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  plus: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  comma: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  hyphen: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  period: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  slash: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  zero: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  one: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  two: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  three: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  four: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  five: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  six: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  seven: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  eight: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  nine: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  colon: [
    333,
    333,
    278,
    278,
    333,
    333,
    333,
    278,
    600,
    600,
    600,
    600
  ],
  semicolon: [
    333,
    333,
    278,
    278,
    333,
    333,
    333,
    278,
    600,
    600,
    600,
    600
  ],
  less: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  equal: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  greater: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  question: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  at: [
    975,
    975,
    1015,
    1015,
    930,
    832,
    920,
    921,
    600,
    600,
    600,
    600
  ],
  A: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  B: [
    722,
    722,
    667,
    667,
    667,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  C: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  D: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  E: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  F: [
    611,
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  G: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  H: [
    722,
    722,
    722,
    722,
    778,
    778,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  I: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  J: [
    556,
    556,
    500,
    500,
    500,
    500,
    444,
    389,
    600,
    600,
    600,
    600
  ],
  K: [
    722,
    722,
    667,
    667,
    778,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  L: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  M: [
    833,
    833,
    833,
    833,
    944,
    889,
    833,
    889,
    600,
    600,
    600,
    600
  ],
  N: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  O: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  P: [
    667,
    667,
    667,
    667,
    611,
    611,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  Q: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  R: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  S: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  T: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  U: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  V: [
    667,
    667,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  W: [
    944,
    944,
    944,
    944,
    1e3,
    889,
    833,
    944,
    600,
    600,
    600,
    600
  ],
  X: [
    667,
    667,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Y: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  Z: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  bracketleft: [
    333,
    333,
    278,
    278,
    333,
    333,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  backslash: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  bracketright: [
    333,
    333,
    278,
    278,
    333,
    333,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  asciicircum: [
    584,
    584,
    469,
    469,
    581,
    570,
    422,
    469,
    600,
    600,
    600,
    600
  ],
  underscore: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  quoteleft: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  a: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  b: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  c: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  d: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  e: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  f: [
    333,
    333,
    278,
    278,
    333,
    333,
    278,
    333,
    600,
    600,
    600,
    600
  ],
  g: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  h: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  i: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  j: [
    278,
    278,
    222,
    222,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  k: [
    556,
    556,
    500,
    500,
    556,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  l: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  m: [
    889,
    889,
    833,
    833,
    833,
    778,
    722,
    778,
    600,
    600,
    600,
    600
  ],
  n: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  o: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  p: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  q: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  r: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  s: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  t: [
    333,
    333,
    278,
    278,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  u: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  v: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  w: [
    778,
    778,
    722,
    722,
    722,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  x: [
    556,
    556,
    500,
    500,
    500,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  y: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  z: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  braceleft: [
    389,
    389,
    334,
    334,
    394,
    348,
    400,
    480,
    600,
    600,
    600,
    600
  ],
  bar: [
    280,
    280,
    260,
    260,
    220,
    220,
    275,
    200,
    600,
    600,
    600,
    600
  ],
  braceright: [
    389,
    389,
    334,
    334,
    394,
    348,
    400,
    480,
    600,
    600,
    600,
    600
  ],
  asciitilde: [
    584,
    584,
    584,
    584,
    520,
    570,
    541,
    541,
    600,
    600,
    600,
    600
  ],
  exclamdown: [
    333,
    333,
    333,
    333,
    333,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  cent: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  sterling: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  fraction: [
    167,
    167,
    167,
    167,
    167,
    167,
    167,
    167,
    600,
    600,
    600,
    600
  ],
  yen: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  florin: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  section: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  currency: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  quotesingle: [
    238,
    238,
    191,
    191,
    278,
    278,
    214,
    180,
    600,
    600,
    600,
    600
  ],
  quotedblleft: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  guillemotleft: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  guilsinglleft: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  guilsinglright: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  fi: [
    611,
    611,
    500,
    500,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  fl: [
    611,
    611,
    500,
    500,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  endash: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  dagger: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  daggerdbl: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  periodcentered: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  paragraph: [
    556,
    556,
    537,
    537,
    540,
    500,
    523,
    453,
    600,
    600,
    600,
    600
  ],
  bullet: [
    350,
    350,
    350,
    350,
    350,
    350,
    350,
    350,
    600,
    600,
    600,
    600
  ],
  quotesinglbase: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  quotedblbase: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  quotedblright: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  guillemotright: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ellipsis: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    889,
    1e3,
    600,
    600,
    600,
    600
  ],
  perthousand: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    600,
    600,
    600,
    600
  ],
  questiondown: [
    611,
    611,
    611,
    611,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  grave: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  acute: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  circumflex: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  tilde: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  macron: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  breve: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  dotaccent: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  dieresis: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ring: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  cedilla: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  hungarumlaut: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ogonek: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  caron: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  emdash: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    889,
    1e3,
    600,
    600,
    600,
    600
  ],
  AE: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    944,
    889,
    889,
    600,
    600,
    600,
    600
  ],
  ordfeminine: [
    370,
    370,
    370,
    370,
    300,
    266,
    276,
    276,
    600,
    600,
    600,
    600
  ],
  Lslash: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Oslash: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  OE: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    944,
    944,
    889,
    600,
    600,
    600,
    600
  ],
  ordmasculine: [
    365,
    365,
    365,
    365,
    330,
    300,
    310,
    310,
    600,
    600,
    600,
    600
  ],
  ae: [
    889,
    889,
    889,
    889,
    722,
    722,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  dotlessi: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  lslash: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  oslash: [
    611,
    611,
    611,
    611,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  oe: [
    944,
    944,
    944,
    944,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  germandbls: [
    611,
    611,
    611,
    611,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Idieresis: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  eacute: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  abreve: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  uhungarumlaut: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ecaron: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Ydieresis: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  divide: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  Yacute: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  Acircumflex: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  aacute: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Ucircumflex: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  yacute: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  scommaaccent: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  ecircumflex: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Uring: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Udieresis: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  aogonek: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Uacute: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  uogonek: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Edieresis: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  Dcroat: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  commaaccent: [
    250,
    250,
    250,
    250,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  copyright: [
    737,
    737,
    737,
    737,
    747,
    747,
    760,
    760,
    600,
    600,
    600,
    600
  ],
  Emacron: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  ccaron: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  aring: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Ncommaaccent: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  lacute: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  agrave: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Tcommaaccent: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Cacute: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  atilde: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Edotaccent: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  scaron: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  scedilla: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  iacute: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  lozenge: [
    494,
    494,
    471,
    471,
    494,
    494,
    471,
    471,
    600,
    600,
    600,
    600
  ],
  Rcaron: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Gcommaaccent: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  ucircumflex: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  acircumflex: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Amacron: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  rcaron: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  ccedilla: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Zdotaccent: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Thorn: [
    667,
    667,
    667,
    667,
    611,
    611,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  Omacron: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Racute: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Sacute: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  dcaron: [
    743,
    743,
    643,
    643,
    672,
    608,
    544,
    588,
    600,
    600,
    600,
    600
  ],
  Umacron: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  uring: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  threesuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  Ograve: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Agrave: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Abreve: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  multiply: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  uacute: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Tcaron: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  partialdiff: [
    494,
    494,
    476,
    476,
    494,
    494,
    476,
    476,
    600,
    600,
    600,
    600
  ],
  ydieresis: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  Nacute: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  icircumflex: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Ecircumflex: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  adieresis: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  edieresis: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  cacute: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  nacute: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  umacron: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Ncaron: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  Iacute: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  plusminus: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  brokenbar: [
    280,
    280,
    260,
    260,
    220,
    220,
    275,
    200,
    600,
    600,
    600,
    600
  ],
  registered: [
    737,
    737,
    737,
    737,
    747,
    747,
    760,
    760,
    600,
    600,
    600,
    600
  ],
  Gbreve: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Idotaccent: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  summation: [
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600
  ],
  Egrave: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  racute: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  omacron: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Zacute: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Zcaron: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  greaterequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  Eth: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Ccedilla: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  lcommaaccent: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  tcaron: [
    389,
    389,
    317,
    317,
    416,
    366,
    300,
    326,
    600,
    600,
    600,
    600
  ],
  eogonek: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Uogonek: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Aacute: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Adieresis: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  egrave: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  zacute: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  iogonek: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Oacute: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  oacute: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  amacron: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  sacute: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  idieresis: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Ocircumflex: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Ugrave: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Delta: [
    612,
    612,
    612,
    612,
    612,
    612,
    612,
    612,
    600,
    600,
    600,
    600
  ],
  thorn: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  twosuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  Odieresis: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  mu: [
    611,
    611,
    556,
    556,
    556,
    576,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  igrave: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  ohungarumlaut: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Eogonek: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  dcroat: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  threequarters: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  Scedilla: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  lcaron: [
    400,
    400,
    299,
    299,
    394,
    382,
    300,
    344,
    600,
    600,
    600,
    600
  ],
  Kcommaaccent: [
    722,
    722,
    667,
    667,
    778,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  Lacute: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  trademark: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    980,
    980,
    600,
    600,
    600,
    600
  ],
  edotaccent: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Igrave: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  Imacron: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  Lcaron: [
    611,
    611,
    556,
    556,
    667,
    611,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  onehalf: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  lessequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  ocircumflex: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ntilde: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Uhungarumlaut: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Eacute: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  emacron: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  gbreve: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  onequarter: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  Scaron: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  Scommaaccent: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  Ohungarumlaut: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  degree: [
    400,
    400,
    400,
    400,
    400,
    400,
    400,
    400,
    600,
    600,
    600,
    600
  ],
  ograve: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Ccaron: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  ugrave: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  radical: [
    549,
    549,
    453,
    453,
    549,
    549,
    453,
    453,
    600,
    600,
    600,
    600
  ],
  Dcaron: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  rcommaaccent: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  Ntilde: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  otilde: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Rcommaaccent: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Lcommaaccent: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Atilde: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Aogonek: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Aring: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Otilde: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  zdotaccent: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  Ecaron: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  Iogonek: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  kcommaaccent: [
    556,
    556,
    500,
    500,
    556,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  minus: [
    584,
    584,
    584,
    584,
    570,
    606,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  Icircumflex: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ncaron: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  tcommaaccent: [
    333,
    333,
    278,
    278,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  logicalnot: [
    584,
    584,
    584,
    584,
    570,
    606,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  odieresis: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  udieresis: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  notequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  gcommaaccent: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  eth: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  zcaron: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  ncommaaccent: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  onesuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  imacron: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Euro: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ]
};
var kernPairs = {
  AC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  ATcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  ATcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Au: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Audieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Augrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Av: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Ay: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Ayacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AacuteC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AacuteT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AacuteW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AacuteY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AacuteYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AacuteYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aacuteu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacutev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aacutew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Aacutey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aacuteyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aacuteydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AbreveC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AbreveT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AbreveW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AbreveY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AbreveYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AbreveYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Abreveu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abrevev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Abrevew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Abrevey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Abreveyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Abreveydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AcircumflexC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AcircumflexT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AcircumflexW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AcircumflexY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AcircumflexYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AcircumflexYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Acircumflexu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Acircumflexw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Acircumflexy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Acircumflexyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Acircumflexydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AdieresisC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AdieresisT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AdieresisW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AdieresisY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AdieresisYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AdieresisYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Adieresisu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Adieresisw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Adieresisy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Adieresisyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Adieresisydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AgraveC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AgraveT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AgraveW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AgraveY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AgraveYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AgraveYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Agraveu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agravev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Agravew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Agravey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Agraveyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Agraveydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AmacronC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AmacronT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AmacronW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AmacronY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AmacronYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AmacronYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Amacronu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Amacronw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Amacrony: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Amacronyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Amacronydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AogonekC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AogonekT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AogonekW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AogonekY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AogonekYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AogonekYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aogoneku: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aogonekw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -52
  ],
  Aogoneky: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  Aogonekyacute: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  Aogonekydieresis: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  AringC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AringT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AringW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AringY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AringYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AringYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aringu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aringw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Aringy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aringyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aringydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AtildeC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AtildeT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AtildeW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AtildeY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AtildeYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AtildeYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Atildeu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Atildew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Atildey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Atildeyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Atildeydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  BA: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAacute: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAbreve: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAcircumflex: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAdieresis: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAgrave: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAmacron: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAogonek: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAring: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAtilde: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BU: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUacute: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUcircumflex: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUdieresis: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUgrave: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUhungarumlaut: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUmacron: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUogonek: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUring: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  DA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  DcaronA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DcaronW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DcaronY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcaronYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcaronYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcaroncomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dcaronperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  DcroatA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DcroatW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DcroatY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcroatYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcroatYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcroatcomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dcroatperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  FA: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAacute: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAbreve: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAcircumflex: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAdieresis: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAgrave: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAmacron: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAogonek: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAring: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAtilde: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  Fa: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faacute: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fabreve: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Facircumflex: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fadieresis: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fagrave: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Famacron: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faogonek: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faring: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fatilde: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fcomma: [
    -100,
    -100,
    -150,
    -150,
    -92,
    -129,
    -135,
    -80
  ],
  Fperiod: [
    -100,
    -100,
    -150,
    -150,
    -110,
    -129,
    -135,
    -80
  ],
  JA: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAbreve: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAogonek: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAring: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  Jcomma: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    -25
  ],
  Jperiod: [
    -20,
    -20,
    -30,
    -30,
    -20,
    -10,
    -25
  ],
  Ju: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juacute: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jucircumflex: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Judieresis: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jugrave: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jumacron: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juogonek: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juring: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  KO: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOacute: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOcircumflex: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOdieresis: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOgrave: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOhungarumlaut: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOmacron: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOslash: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOtilde: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  Ke: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Keacute: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kecaron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kecircumflex: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kedieresis: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kedotaccent: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kegrave: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kemacron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Keogonek: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Ko: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Koacute: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kocircumflex: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kodieresis: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kograve: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kohungarumlaut: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Komacron: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Koslash: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kotilde: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Ku: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuacute: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kudieresis: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kugrave: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kumacron: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuogonek: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuring: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Ky: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kyacute: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kydieresis: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  KcommaaccentO: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOacute: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOcircumflex: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOdieresis: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOgrave: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOhungarumlaut: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOmacron: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOslash: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOtilde: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  Kcommaaccente: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccenteacute: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentecaron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentecircumflex: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentedieresis: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentedotaccent: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentegrave: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentemacron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccenteogonek: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccento: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentoacute: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentocircumflex: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentodieresis: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentograve: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentohungarumlaut: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentomacron: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentoslash: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentotilde: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentu: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuacute: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentudieresis: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentugrave: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentumacron: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuogonek: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccenturing: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccenty: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kcommaaccentyacute: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kcommaaccentydieresis: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  LT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Ly: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LacuteT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LacuteW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LacuteY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LacuteYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LacuteYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lacutequotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lacutequoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lacutey: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lacuteyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lacuteydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LcommaaccentT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LcommaaccentW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LcommaaccentY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LcommaaccentYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LcommaaccentYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lcommaaccentquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lcommaaccentquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lcommaaccenty: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lcommaaccentyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lcommaaccentydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LslashT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LslashW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LslashY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LslashYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LslashYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lslashquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lslashquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lslashy: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lslashyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lslashydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  OA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ocomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Operiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OacuteA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OacuteX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Oacutecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Oacuteperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OcircumflexX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ocircumflexcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ocircumflexperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OdieresisX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Odieresiscomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Odieresisperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OgraveA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OgraveX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ogravecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ograveperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OhungarumlautX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ohungarumlautcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ohungarumlautperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OmacronA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OmacronX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Omacroncomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Omacronperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OslashA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OslashW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OslashX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OslashY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OslashYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OslashYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Oslashcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Oslashperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OtildeA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OtildeX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Otildecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Otildeperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  PA: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAacute: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAbreve: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAcircumflex: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAdieresis: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAgrave: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAmacron: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAogonek: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAring: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAtilde: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  Pa: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paacute: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pabreve: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pacircumflex: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Padieresis: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pagrave: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pamacron: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paogonek: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paring: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Patilde: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pcomma: [
    -120,
    -120,
    -180,
    -180,
    -92,
    -129,
    -135,
    -111
  ],
  Pe: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Peacute: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pecaron: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pecircumflex: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pedieresis: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pedotaccent: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pegrave: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pemacron: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Peogonek: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Po: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Poacute: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pocircumflex: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Podieresis: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pograve: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pohungarumlaut: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pomacron: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Poslash: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Potilde: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pperiod: [
    -120,
    -120,
    -180,
    -180,
    -110,
    -129,
    -135,
    -111
  ],
  QU: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUacute: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUcircumflex: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUdieresis: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUgrave: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUhungarumlaut: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUmacron: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUogonek: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUring: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  Qcomma: [
    20,
    20
  ],
  Qperiod: [
    20,
    20,
    0,
    0,
    -20
  ],
  RO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RacuteW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RacuteY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RcaronW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RcaronY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RcommaaccentW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RcommaaccentY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  TA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Ta: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Taacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Taogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Taring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Te: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Teacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -70
  ],
  Tedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Temacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Teogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Thyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  To: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Toacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Todieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Toslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Totilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Trcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Turing: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Ty: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  TcaronA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Tcarona: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronaacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tcaronacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tcaronadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronaogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronaring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaroncolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcaroncomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Tcarone: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaroneacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -30
  ],
  Tcaronedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tcaronedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Tcaronemacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Tcaroneogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronhyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  Tcarono: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronoacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronodieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronoslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronotilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tcaronr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronrcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tcaronu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuring: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Tcarony: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcaronyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcaronydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  TcommaaccentA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Tcommaaccenta: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentaacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tcommaaccentacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tcommaaccentadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentaogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentaring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentcolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcommaaccentcomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Tcommaaccente: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccenteacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -30
  ],
  Tcommaaccentedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tcommaaccentedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Tcommaaccentemacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Tcommaaccenteogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccenthyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  Tcommaaccento: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentoacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentodieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentoslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentotilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tcommaaccentr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentrcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tcommaaccentu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccenturing: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Tcommaaccenty: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcommaaccentyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcommaaccentydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  UA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ucomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UacuteA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uacutecomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uacuteperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UcircumflexA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ucircumflexcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Ucircumflexperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UdieresisA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Udieresiscomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Udieresisperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UgraveA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ugravecomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Ugraveperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UhungarumlautA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uhungarumlautcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uhungarumlautperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UmacronA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Umacroncomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Umacronperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UogonekA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uogonekcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uogonekperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UringA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uringcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uringperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  VA: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAacute: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAbreve: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAcircumflex: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAdieresis: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAgrave: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAmacron: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAogonek: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAring: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAtilde: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VG: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VGbreve: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VGcommaaccent: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VO: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOacute: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOdieresis: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOgrave: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOhungarumlaut: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOmacron: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOslash: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOtilde: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  Va: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vaacute: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vabreve: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vacircumflex: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vadieresis: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vagrave: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vamacron: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vaogonek: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Varing: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vatilde: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vcolon: [
    -40,
    -40,
    -40,
    -40,
    -92,
    -74,
    -65,
    -74
  ],
  Vcomma: [
    -120,
    -120,
    -125,
    -125,
    -129,
    -129,
    -129,
    -129
  ],
  Ve: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Veacute: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vecaron: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -71
  ],
  Vecircumflex: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -71
  ],
  Vedieresis: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Vedotaccent: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vegrave: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Vemacron: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Veogonek: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vhyphen: [
    -80,
    -80,
    -80,
    -80,
    -74,
    -70,
    -55,
    -100
  ],
  Vo: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Voacute: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vocircumflex: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vodieresis: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vograve: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vohungarumlaut: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vomacron: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Voslash: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Votilde: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vperiod: [
    -120,
    -120,
    -125,
    -125,
    -145,
    -129,
    -129,
    -129
  ],
  Vsemicolon: [
    -40,
    -40,
    -40,
    -40,
    -92,
    -74,
    -74,
    -74
  ],
  Vu: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuacute: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vucircumflex: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vudieresis: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vugrave: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuhungarumlaut: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vumacron: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuogonek: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuring: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  WA: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAacute: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAbreve: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAcircumflex: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAdieresis: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAgrave: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAmacron: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAogonek: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAring: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAtilde: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WO: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOacute: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOgrave: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOmacron: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOslash: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOtilde: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  Wa: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waacute: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wabreve: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wacircumflex: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wadieresis: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wagrave: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wamacron: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waogonek: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waring: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Watilde: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wcolon: [
    -10,
    -10,
    0,
    0,
    -55,
    -55,
    -65,
    -37
  ],
  Wcomma: [
    -80,
    -80,
    -80,
    -80,
    -92,
    -74,
    -92,
    -92
  ],
  We: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Weacute: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wecaron: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wecircumflex: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wedieresis: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Wedotaccent: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wegrave: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Wemacron: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Weogonek: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Whyphen: [
    -40,
    -40,
    -40,
    -40,
    -37,
    -50,
    -37,
    -65
  ],
  Wo: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Woacute: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wocircumflex: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wodieresis: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wograve: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wohungarumlaut: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Womacron: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Woslash: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wotilde: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wperiod: [
    -80,
    -80,
    -80,
    -80,
    -92,
    -74,
    -92,
    -92
  ],
  Wsemicolon: [
    -10,
    -10,
    0,
    0,
    -55,
    -55,
    -65,
    -37
  ],
  Wu: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuacute: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wucircumflex: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wudieresis: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wugrave: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuhungarumlaut: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wumacron: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuogonek: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuring: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wy: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  Wyacute: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  Wydieresis: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  YA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Ya: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Yacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yaring: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yatilde: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ycolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ycomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Ye: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yeacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Yedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Yeogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yo: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yomacron: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Ysemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  YacuteA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Yacutea: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacutearing: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteatilde: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yacutecolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yacutecomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Yacutee: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteeacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Yacuteedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteeogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteo: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteomacron: [
    -100,
    -100,
    -70,
    -70,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Yacutesemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yacuteu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  YdieresisA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Ydieresisa: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisaring: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisatilde: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresiscolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ydieresiscomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Ydieresise: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresiseacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Ydieresisedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresisedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresisemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresiseogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresiso: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisomacron: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Ydieresissemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ydieresisu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  ag: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  av: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  ay: [
    -20,
    -20,
    -30,
    -30
  ],
  ayacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aacutew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aacutey: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  abrevew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  abrevey: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  acircumflexw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  acircumflexy: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  adieresisw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  adieresisy: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  agravew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  agravey: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  amacrong: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacrongbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacrongcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacronv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  amacronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  amacrony: [
    -20,
    -20,
    -30,
    -30
  ],
  amacronyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  amacronydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aogonekw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aogoneky: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aringg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aringw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aringy: [
    -20,
    -20,
    -30,
    -30
  ],
  aringyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aringydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  atildew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  atildey: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  bl: [
    -10,
    -10,
    -20,
    -20
  ],
  blacute: [
    -10,
    -10,
    -20,
    -20
  ],
  blcommaaccent: [
    -10,
    -10,
    -20,
    -20
  ],
  blslash: [
    -10,
    -10,
    -20,
    -20
  ],
  bu: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buacute: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bucircumflex: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  budieresis: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bugrave: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bumacron: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buogonek: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buring: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bv: [
    -20,
    -20,
    -20,
    -20,
    -15,
    0,
    0,
    -15
  ],
  by: [
    -20,
    -20,
    -20,
    -20
  ],
  byacute: [
    -20,
    -20,
    -20,
    -20
  ],
  bydieresis: [
    -20,
    -20,
    -20,
    -20
  ],
  ch: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ck: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ckcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cl: [
    -20,
    -20
  ],
  clacute: [
    -20,
    -20
  ],
  clcommaaccent: [
    -20,
    -20
  ],
  clslash: [
    -20,
    -20
  ],
  cy: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteh: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  cacutek: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cacutekcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cacutel: [
    -20,
    -20
  ],
  cacutelacute: [
    -20,
    -20
  ],
  cacutelcommaaccent: [
    -20,
    -20
  ],
  cacutelslash: [
    -20,
    -20
  ],
  cacutey: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronh: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ccaronk: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccaronkcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccaronl: [
    -20,
    -20
  ],
  ccaronlacute: [
    -20,
    -20
  ],
  ccaronlcommaaccent: [
    -20,
    -20
  ],
  ccaronlslash: [
    -20,
    -20
  ],
  ccarony: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillah: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ccedillak: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccedillakcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccedillal: [
    -20,
    -20
  ],
  ccedillalacute: [
    -20,
    -20
  ],
  ccedillalcommaaccent: [
    -20,
    -20
  ],
  ccedillalslash: [
    -20,
    -20
  ],
  ccedillay: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillayacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillaydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  colonspace: [
    -40,
    -40,
    -50,
    -50
  ],
  commaquotedblright: [
    -120,
    -120,
    -100,
    -100,
    -45,
    -95,
    -140,
    -70
  ],
  commaquoteright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  commaspace: [
    -40,
    -40
  ],
  dd: [
    -10,
    -10
  ],
  ddcroat: [
    -10,
    -10
  ],
  dv: [
    -15,
    -15
  ],
  dw: [
    -15,
    -15,
    0,
    0,
    -15
  ],
  dy: [
    -15,
    -15
  ],
  dyacute: [
    -15,
    -15
  ],
  dydieresis: [
    -15,
    -15
  ],
  dcroatd: [
    -10,
    -10
  ],
  dcroatdcroat: [
    -10,
    -10
  ],
  dcroatv: [
    -15,
    -15
  ],
  dcroatw: [
    -15,
    -15,
    0,
    0,
    -15
  ],
  dcroaty: [
    -15,
    -15
  ],
  dcroatyacute: [
    -15,
    -15
  ],
  dcroatydieresis: [
    -15,
    -15
  ],
  ecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacutecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eacuteperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  eacutev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  eacutew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  eacutex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  eacutey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacuteyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacuteydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaroncomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  ecaronperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ecaronv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ecaronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ecaronx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ecarony: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaronyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaronydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  ecircumflexperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ecircumflexv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ecircumflexw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ecircumflexx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ecircumflexy: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresiscomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  edieresisperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  edieresisv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  edieresisw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  edieresisx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  edieresisy: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresisyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresisydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  edotaccentperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  edotaccentv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  edotaccentw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  edotaccentx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  edotaccenty: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egravecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  egraveperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  egravev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  egravew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  egravex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  egravey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egraveyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egraveydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacroncomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  emacronperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  emacronv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  emacronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  emacronx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  emacrony: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacronyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacronydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eogonekperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  eogonekv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  eogonekw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  eogonekx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  eogoneky: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  fcomma: [
    -10,
    -10,
    -30,
    -30,
    -15,
    -10,
    -10
  ],
  fe: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  feacute: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fecaron: [
    -10,
    -10,
    -30,
    -30
  ],
  fecircumflex: [
    -10,
    -10,
    -30,
    -30
  ],
  fedieresis: [
    -10,
    -10,
    -30,
    -30
  ],
  fedotaccent: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fegrave: [
    -10,
    -10,
    -30,
    -30
  ],
  femacron: [
    -10,
    -10,
    -30,
    -30
  ],
  feogonek: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fo: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  foacute: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  focircumflex: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fodieresis: [
    -20,
    -20,
    -30,
    -30,
    -25
  ],
  fograve: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fohungarumlaut: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fomacron: [
    -20,
    -20,
    -30,
    -30,
    -25
  ],
  foslash: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fotilde: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fperiod: [
    -10,
    -10,
    -30,
    -30,
    -15,
    -10,
    -15
  ],
  fquotedblright: [
    30,
    30,
    60,
    60,
    50
  ],
  fquoteright: [
    30,
    30,
    50,
    50,
    55,
    55,
    92,
    55
  ],
  ge: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  geacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  geogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  ggbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  ggcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevee: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveeacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveeogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccente: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccenteacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccenteogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  hy: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  hyacute: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  hydieresis: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  ko: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  koacute: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kocircumflex: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kodieresis: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kograve: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kohungarumlaut: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  komacron: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  koslash: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kotilde: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccento: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentoacute: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentocircumflex: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentodieresis: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentograve: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentohungarumlaut: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentomacron: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentoslash: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentotilde: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  lw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ly: [
    -15,
    -15
  ],
  lyacute: [
    -15,
    -15
  ],
  lydieresis: [
    -15,
    -15
  ],
  lacutew: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lacutey: [
    -15,
    -15
  ],
  lacuteyacute: [
    -15,
    -15
  ],
  lacuteydieresis: [
    -15,
    -15
  ],
  lcommaaccentw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lcommaaccenty: [
    -15,
    -15
  ],
  lcommaaccentyacute: [
    -15,
    -15
  ],
  lcommaaccentydieresis: [
    -15,
    -15
  ],
  lslashw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lslashy: [
    -15,
    -15
  ],
  lslashyacute: [
    -15,
    -15
  ],
  lslashydieresis: [
    -15,
    -15
  ],
  mu: [
    -20,
    -20,
    -10,
    -10
  ],
  muacute: [
    -20,
    -20,
    -10,
    -10
  ],
  mucircumflex: [
    -20,
    -20,
    -10,
    -10
  ],
  mudieresis: [
    -20,
    -20,
    -10,
    -10
  ],
  mugrave: [
    -20,
    -20,
    -10,
    -10
  ],
  muhungarumlaut: [
    -20,
    -20,
    -10,
    -10
  ],
  mumacron: [
    -20,
    -20,
    -10,
    -10
  ],
  muogonek: [
    -20,
    -20,
    -10,
    -10
  ],
  muring: [
    -20,
    -20,
    -10,
    -10
  ],
  my: [
    -30,
    -30,
    -15,
    -15
  ],
  myacute: [
    -30,
    -30,
    -15,
    -15
  ],
  mydieresis: [
    -30,
    -30,
    -15,
    -15
  ],
  nu: [
    -10,
    -10,
    -10,
    -10
  ],
  nuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  nucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  nudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  nugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  nuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  numacron: [
    -10,
    -10,
    -10,
    -10
  ],
  nuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  nuring: [
    -10,
    -10,
    -10,
    -10
  ],
  nv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ny: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteu: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuring: [
    -10,
    -10,
    -10,
    -10
  ],
  nacutev: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  nacutey: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronu: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuring: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ncarony: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentu: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccenturing: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ncommaaccenty: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeu: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuring: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildev: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ntildey: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ov: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ow: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ox: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  oy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacutev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  oacutew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  oacutex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  oacutey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacuteyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacuteydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ocircumflexw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ocircumflexx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ocircumflexy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  odieresisw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  odieresisx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  odieresisy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ogravev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ogravew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ogravex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ogravey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ograveyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ograveydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ohungarumlautw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ohungarumlautx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ohungarumlauty: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  omacronw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  omacronx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  omacrony: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oslashv: [
    -20,
    -20,
    -70,
    -70,
    -10,
    -15,
    -10,
    -15
  ],
  oslashw: [
    -15,
    -15,
    -70,
    -70,
    -10,
    -25,
    0,
    -25
  ],
  oslashx: [
    -30,
    -30,
    -85,
    -85,
    0,
    -10
  ],
  oslashy: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  oslashyacute: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  oslashydieresis: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  otildev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  otildew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  otildex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  otildey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  otildeyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  otildeydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  py: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  pyacute: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  pydieresis: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  periodquotedblright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  periodquoteright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  periodspace: [
    -40,
    -40,
    -60,
    -60
  ],
  quotedblrightspace: [
    -80,
    -80,
    -40,
    -40
  ],
  quoteleftquoteleft: [
    -46,
    -46,
    -57,
    -57,
    -63,
    -74,
    -111,
    -74
  ],
  quoterightd: [
    -80,
    -80,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightdcroat: [
    -80,
    -80,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightl: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlacute: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlcommaaccent: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlslash: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightquoteright: [
    -46,
    -46,
    -57,
    -57,
    -63,
    -74,
    -111,
    -74
  ],
  quoterightr: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightracute: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightrcaron: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightrcommaaccent: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterights: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightsacute: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscaron: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscedilla: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscommaaccent: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightspace: [
    -80,
    -80,
    -70,
    -70,
    -74,
    -74,
    -111,
    -74
  ],
  quoterightv: [
    -20,
    -20,
    0,
    0,
    -20,
    -15,
    -10,
    -50
  ],
  rc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rd: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rdcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rgbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rgcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rhyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  ro: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  roacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  romacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  roslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rs: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rt: [
    20,
    20,
    40,
    40
  ],
  rtcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rv: [
    10,
    10,
    30,
    30,
    -10
  ],
  ry: [
    10,
    10,
    30,
    30
  ],
  ryacute: [
    10,
    10,
    30,
    30
  ],
  rydieresis: [
    10,
    10,
    30,
    30
  ],
  racutec: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutecacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutecomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  racuted: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  racutedcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  racuteg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutegbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutegcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutehyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  racuteo: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  racuteq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutes: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutesacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutet: [
    20,
    20,
    40,
    40
  ],
  racutetcommaaccent: [
    20,
    20,
    40,
    40
  ],
  racutev: [
    10,
    10,
    30,
    30,
    -10
  ],
  racutey: [
    10,
    10,
    30,
    30
  ],
  racuteyacute: [
    10,
    10,
    30,
    30
  ],
  racuteydieresis: [
    10,
    10,
    30,
    30
  ],
  rcaronc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroncacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroncomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rcarond: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcarondcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcarong: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcarongbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcarongcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcaronhyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  rcarono: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rcaronq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcarons: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaront: [
    20,
    20,
    40,
    40
  ],
  rcarontcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rcaronv: [
    10,
    10,
    30,
    30,
    -10
  ],
  rcarony: [
    10,
    10,
    30,
    30
  ],
  rcaronyacute: [
    10,
    10,
    30,
    30
  ],
  rcaronydieresis: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentcacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentcomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rcommaaccentd: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcommaaccentdcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcommaaccentg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccentgbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccentgcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccenthyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  rcommaaccento: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rcommaaccentq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccents: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentt: [
    20,
    20,
    40,
    40
  ],
  rcommaaccenttcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rcommaaccentv: [
    10,
    10,
    30,
    30,
    -10
  ],
  rcommaaccenty: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentyacute: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentydieresis: [
    10,
    10,
    30,
    30
  ],
  sw: [
    -15,
    -15,
    -30,
    -30
  ],
  sacutew: [
    -15,
    -15,
    -30,
    -30
  ],
  scaronw: [
    -15,
    -15,
    -30,
    -30
  ],
  scedillaw: [
    -15,
    -15,
    -30,
    -30
  ],
  scommaaccentw: [
    -15,
    -15,
    -30,
    -30
  ],
  semicolonspace: [
    -40,
    -40,
    -50,
    -50
  ],
  spaceT: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceTcaron: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceTcommaaccent: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceV: [
    -80,
    -80,
    -50,
    -50,
    -45,
    -70,
    -35,
    -50
  ],
  spaceW: [
    -80,
    -80,
    -40,
    -40,
    -30,
    -70,
    -40,
    -30
  ],
  spaceY: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spaceYacute: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spaceYdieresis: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spacequotedblleft: [
    -80,
    -80,
    -30,
    -30
  ],
  spacequoteleft: [
    -60,
    -60,
    -60,
    -60
  ],
  va: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vaacute: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vabreve: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vacircumflex: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vadieresis: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vagrave: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vamacron: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vaogonek: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  varing: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vatilde: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vcomma: [
    -80,
    -80,
    -80,
    -80,
    -55,
    -37,
    -74,
    -65
  ],
  vo: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  voacute: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vocircumflex: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vodieresis: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vograve: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vohungarumlaut: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vomacron: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  voslash: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  votilde: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vperiod: [
    -80,
    -80,
    -80,
    -80,
    -70,
    -37,
    -74,
    -65
  ],
  wcomma: [
    -40,
    -40,
    -60,
    -60,
    -55,
    -37,
    -74,
    -65
  ],
  wo: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  woacute: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wocircumflex: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wodieresis: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wograve: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wohungarumlaut: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  womacron: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  woslash: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wotilde: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wperiod: [
    -40,
    -40,
    -60,
    -60,
    -70,
    -37,
    -74,
    -65
  ],
  xe: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xeacute: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xecaron: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xecircumflex: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xedieresis: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xedotaccent: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xegrave: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xemacron: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xeogonek: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  ya: [
    -30,
    -30,
    -20,
    -20
  ],
  yaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  yabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  yacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  yadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  yagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  yamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  yaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  yaring: [
    -30,
    -30,
    -20,
    -20
  ],
  yatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  ycomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  ye: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yeacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yeogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yo: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  yacutea: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  yacutearing: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  yacutecomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  yacutee: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteeacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteeogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteo: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  ydieresisa: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaring: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresiscomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  ydieresise: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiseacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiseogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiso: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  ze: [
    10,
    10,
    -15,
    -15
  ],
  zeacute: [
    10,
    10,
    -15,
    -15
  ],
  zecaron: [
    10,
    10,
    -15,
    -15
  ],
  zecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zegrave: [
    10,
    10,
    -15,
    -15
  ],
  zemacron: [
    10,
    10,
    -15,
    -15
  ],
  zeogonek: [
    10,
    10,
    -15,
    -15
  ],
  zacutee: [
    10,
    10,
    -15,
    -15
  ],
  zacuteeacute: [
    10,
    10,
    -15,
    -15
  ],
  zacuteecaron: [
    10,
    10,
    -15,
    -15
  ],
  zacuteecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zacuteedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zacuteedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zacuteegrave: [
    10,
    10,
    -15,
    -15
  ],
  zacuteemacron: [
    10,
    10,
    -15,
    -15
  ],
  zacuteeogonek: [
    10,
    10,
    -15,
    -15
  ],
  zcarone: [
    10,
    10,
    -15,
    -15
  ],
  zcaroneacute: [
    10,
    10,
    -15,
    -15
  ],
  zcaronecaron: [
    10,
    10,
    -15,
    -15
  ],
  zcaronecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zcaronedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zcaronedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zcaronegrave: [
    10,
    10,
    -15,
    -15
  ],
  zcaronemacron: [
    10,
    10,
    -15,
    -15
  ],
  zcaroneogonek: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccente: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccenteacute: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentecaron: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentegrave: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentemacron: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccenteogonek: [
    10,
    10,
    -15,
    -15
  ],
  Bcomma: [
    0,
    0,
    -20,
    -20
  ],
  Bperiod: [
    0,
    0,
    -20,
    -20
  ],
  Ccomma: [
    0,
    0,
    -30,
    -30
  ],
  Cperiod: [
    0,
    0,
    -30,
    -30
  ],
  Cacutecomma: [
    0,
    0,
    -30,
    -30
  ],
  Cacuteperiod: [
    0,
    0,
    -30,
    -30
  ],
  Ccaroncomma: [
    0,
    0,
    -30,
    -30
  ],
  Ccaronperiod: [
    0,
    0,
    -30,
    -30
  ],
  Ccedillacomma: [
    0,
    0,
    -30,
    -30
  ],
  Ccedillaperiod: [
    0,
    0,
    -30,
    -30
  ],
  Fe: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Feacute: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fecaron: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fecircumflex: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fedieresis: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fedotaccent: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fegrave: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Femacron: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Feogonek: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fo: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Foacute: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Focircumflex: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fodieresis: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fograve: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fohungarumlaut: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fomacron: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Foslash: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fotilde: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fr: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Fracute: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Frcaron: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Frcommaaccent: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Ja: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaacute: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jabreve: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jacircumflex: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jadieresis: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jagrave: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jamacron: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaogonek: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaring: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jatilde: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  LcaronT: [
    0,
    0,
    -110,
    -110
  ],
  LcaronTcaron: [
    0,
    0,
    -110,
    -110
  ],
  LcaronTcommaaccent: [
    0,
    0,
    -110,
    -110
  ],
  LcaronV: [
    0,
    0,
    -110,
    -110
  ],
  LcaronW: [
    0,
    0,
    -70,
    -70
  ],
  LcaronY: [
    0,
    0,
    -140,
    -140
  ],
  LcaronYacute: [
    0,
    0,
    -140,
    -140
  ],
  LcaronYdieresis: [
    0,
    0,
    -140,
    -140
  ],
  Lcaronquotedblright: [
    0,
    0,
    -140,
    -140
  ],
  Lcaronquoteright: [
    0,
    0,
    -160,
    -160,
    0,
    0,
    0,
    -92
  ],
  Lcarony: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Lcaronyacute: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Lcaronydieresis: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Scomma: [
    0,
    0,
    -20,
    -20
  ],
  Speriod: [
    0,
    0,
    -20,
    -20
  ],
  Sacutecomma: [
    0,
    0,
    -20,
    -20
  ],
  Sacuteperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scaroncomma: [
    0,
    0,
    -20,
    -20
  ],
  Scaronperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scedillacomma: [
    0,
    0,
    -20,
    -20
  ],
  Scedillaperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scommaaccentcomma: [
    0,
    0,
    -20,
    -20
  ],
  Scommaaccentperiod: [
    0,
    0,
    -20,
    -20
  ],
  Trcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronrcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentrcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Yhyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Yi: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacutehyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Yacutei: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacuteiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacuteiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresishyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Ydieresisi: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresisiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresisiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  bb: [
    0,
    0,
    -10,
    -10,
    -10,
    -10
  ],
  bcomma: [
    0,
    0,
    -40,
    -40
  ],
  bperiod: [
    0,
    0,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  ccomma: [
    0,
    0,
    -15,
    -15
  ],
  cacutecomma: [
    0,
    0,
    -15,
    -15
  ],
  ccaroncomma: [
    0,
    0,
    -15,
    -15
  ],
  ccedillacomma: [
    0,
    0,
    -15,
    -15
  ],
  fa: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faacute: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fabreve: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  facircumflex: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fadieresis: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fagrave: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  famacron: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faogonek: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faring: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fatilde: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fdotlessi: [
    0,
    0,
    -28,
    -28,
    -35,
    -30,
    -60,
    -50
  ],
  gr: [
    0,
    0,
    -10,
    -10
  ],
  gracute: [
    0,
    0,
    -10,
    -10
  ],
  grcaron: [
    0,
    0,
    -10,
    -10
  ],
  grcommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  gbrever: [
    0,
    0,
    -10,
    -10
  ],
  gbreveracute: [
    0,
    0,
    -10,
    -10
  ],
  gbrevercaron: [
    0,
    0,
    -10,
    -10
  ],
  gbrevercommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentr: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentracute: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentrcaron: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentrcommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  ke: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  keacute: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kecaron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kecircumflex: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kedieresis: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kedotaccent: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kegrave: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kemacron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  keogonek: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccente: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccenteacute: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentecaron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentecircumflex: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentedieresis: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentedotaccent: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentegrave: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentemacron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccenteogonek: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  ocomma: [
    0,
    0,
    -40,
    -40
  ],
  operiod: [
    0,
    0,
    -40,
    -40
  ],
  oacutecomma: [
    0,
    0,
    -40,
    -40
  ],
  oacuteperiod: [
    0,
    0,
    -40,
    -40
  ],
  ocircumflexcomma: [
    0,
    0,
    -40,
    -40
  ],
  ocircumflexperiod: [
    0,
    0,
    -40,
    -40
  ],
  odieresiscomma: [
    0,
    0,
    -40,
    -40
  ],
  odieresisperiod: [
    0,
    0,
    -40,
    -40
  ],
  ogravecomma: [
    0,
    0,
    -40,
    -40
  ],
  ograveperiod: [
    0,
    0,
    -40,
    -40
  ],
  ohungarumlautcomma: [
    0,
    0,
    -40,
    -40
  ],
  ohungarumlautperiod: [
    0,
    0,
    -40,
    -40
  ],
  omacroncomma: [
    0,
    0,
    -40,
    -40
  ],
  omacronperiod: [
    0,
    0,
    -40,
    -40
  ],
  oslasha: [
    0,
    0,
    -55,
    -55
  ],
  oslashaacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashabreve: [
    0,
    0,
    -55,
    -55
  ],
  oslashacircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashadieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashagrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashamacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashaogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslasharing: [
    0,
    0,
    -55,
    -55
  ],
  oslashatilde: [
    0,
    0,
    -55,
    -55
  ],
  oslashb: [
    0,
    0,
    -55,
    -55
  ],
  oslashc: [
    0,
    0,
    -55,
    -55
  ],
  oslashcacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashccaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashccedilla: [
    0,
    0,
    -55,
    -55
  ],
  oslashcomma: [
    0,
    0,
    -95,
    -95
  ],
  oslashd: [
    0,
    0,
    -55,
    -55
  ],
  oslashdcroat: [
    0,
    0,
    -55,
    -55
  ],
  oslashe: [
    0,
    0,
    -55,
    -55
  ],
  oslasheacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashecaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashecircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashedieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashedotaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashegrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashemacron: [
    0,
    0,
    -55,
    -55
  ],
  oslasheogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashf: [
    0,
    0,
    -55,
    -55
  ],
  oslashg: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashgbreve: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashgcommaaccent: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashh: [
    0,
    0,
    -55,
    -55
  ],
  oslashi: [
    0,
    0,
    -55,
    -55
  ],
  oslashiacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashicircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashidieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashigrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashimacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashiogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashj: [
    0,
    0,
    -55,
    -55
  ],
  oslashk: [
    0,
    0,
    -55,
    -55
  ],
  oslashkcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashl: [
    0,
    0,
    -55,
    -55
  ],
  oslashlacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashlcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashlslash: [
    0,
    0,
    -55,
    -55
  ],
  oslashm: [
    0,
    0,
    -55,
    -55
  ],
  oslashn: [
    0,
    0,
    -55,
    -55
  ],
  oslashnacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashncaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashncommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashntilde: [
    0,
    0,
    -55,
    -55
  ],
  oslasho: [
    0,
    0,
    -55,
    -55
  ],
  oslashoacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashocircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashodieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashograve: [
    0,
    0,
    -55,
    -55
  ],
  oslashohungarumlaut: [
    0,
    0,
    -55,
    -55
  ],
  oslashomacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashoslash: [
    0,
    0,
    -55,
    -55
  ],
  oslashotilde: [
    0,
    0,
    -55,
    -55
  ],
  oslashp: [
    0,
    0,
    -55,
    -55
  ],
  oslashperiod: [
    0,
    0,
    -95,
    -95
  ],
  oslashq: [
    0,
    0,
    -55,
    -55
  ],
  oslashr: [
    0,
    0,
    -55,
    -55
  ],
  oslashracute: [
    0,
    0,
    -55,
    -55
  ],
  oslashrcaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashrcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashs: [
    0,
    0,
    -55,
    -55
  ],
  oslashsacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashscaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashscedilla: [
    0,
    0,
    -55,
    -55
  ],
  oslashscommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslasht: [
    0,
    0,
    -55,
    -55
  ],
  oslashtcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashu: [
    0,
    0,
    -55,
    -55
  ],
  oslashuacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashucircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashudieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashugrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashuhungarumlaut: [
    0,
    0,
    -55,
    -55
  ],
  oslashumacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashuogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashuring: [
    0,
    0,
    -55,
    -55
  ],
  oslashz: [
    0,
    0,
    -55,
    -55
  ],
  oslashzacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashzcaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashzdotaccent: [
    0,
    0,
    -55,
    -55
  ],
  otildecomma: [
    0,
    0,
    -40,
    -40
  ],
  otildeperiod: [
    0,
    0,
    -40,
    -40
  ],
  pcomma: [
    0,
    0,
    -35,
    -35
  ],
  pperiod: [
    0,
    0,
    -35,
    -35
  ],
  ra: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  radieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ragrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ramacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ratilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcolon: [
    0,
    0,
    30,
    30
  ],
  ri: [
    0,
    0,
    15,
    15
  ],
  riacute: [
    0,
    0,
    15,
    15
  ],
  ricircumflex: [
    0,
    0,
    15,
    15
  ],
  ridieresis: [
    0,
    0,
    15,
    15
  ],
  rigrave: [
    0,
    0,
    15,
    15
  ],
  rimacron: [
    0,
    0,
    15,
    15
  ],
  riogonek: [
    0,
    0,
    15,
    15
  ],
  rk: [
    0,
    0,
    15,
    15
  ],
  rkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rl: [
    0,
    0,
    15,
    15
  ],
  rlacute: [
    0,
    0,
    15,
    15
  ],
  rlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rlslash: [
    0,
    0,
    15,
    15
  ],
  rm: [
    0,
    0,
    25,
    25
  ],
  rn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rsemicolon: [
    0,
    0,
    30,
    30
  ],
  ru: [
    0,
    0,
    15,
    15
  ],
  ruacute: [
    0,
    0,
    15,
    15
  ],
  rucircumflex: [
    0,
    0,
    15,
    15
  ],
  rudieresis: [
    0,
    0,
    15,
    15
  ],
  rugrave: [
    0,
    0,
    15,
    15
  ],
  ruhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rumacron: [
    0,
    0,
    15,
    15
  ],
  ruogonek: [
    0,
    0,
    15,
    15
  ],
  ruring: [
    0,
    0,
    15,
    15
  ],
  racutea: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racutearing: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racutecolon: [
    0,
    0,
    30,
    30
  ],
  racutei: [
    0,
    0,
    15,
    15
  ],
  racuteiacute: [
    0,
    0,
    15,
    15
  ],
  racuteicircumflex: [
    0,
    0,
    15,
    15
  ],
  racuteidieresis: [
    0,
    0,
    15,
    15
  ],
  racuteigrave: [
    0,
    0,
    15,
    15
  ],
  racuteimacron: [
    0,
    0,
    15,
    15
  ],
  racuteiogonek: [
    0,
    0,
    15,
    15
  ],
  racutek: [
    0,
    0,
    15,
    15
  ],
  racutekcommaaccent: [
    0,
    0,
    15,
    15
  ],
  racutel: [
    0,
    0,
    15,
    15
  ],
  racutelacute: [
    0,
    0,
    15,
    15
  ],
  racutelcommaaccent: [
    0,
    0,
    15,
    15
  ],
  racutelslash: [
    0,
    0,
    15,
    15
  ],
  racutem: [
    0,
    0,
    25,
    25
  ],
  racuten: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutenacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutencaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutencommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutentilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutep: [
    0,
    0,
    30,
    30,
    -10
  ],
  racutesemicolon: [
    0,
    0,
    30,
    30
  ],
  racuteu: [
    0,
    0,
    15,
    15
  ],
  racuteuacute: [
    0,
    0,
    15,
    15
  ],
  racuteucircumflex: [
    0,
    0,
    15,
    15
  ],
  racuteudieresis: [
    0,
    0,
    15,
    15
  ],
  racuteugrave: [
    0,
    0,
    15,
    15
  ],
  racuteuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  racuteumacron: [
    0,
    0,
    15,
    15
  ],
  racuteuogonek: [
    0,
    0,
    15,
    15
  ],
  racuteuring: [
    0,
    0,
    15,
    15
  ],
  rcarona: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaroncolon: [
    0,
    0,
    30,
    30
  ],
  rcaroni: [
    0,
    0,
    15,
    15
  ],
  rcaroniacute: [
    0,
    0,
    15,
    15
  ],
  rcaronicircumflex: [
    0,
    0,
    15,
    15
  ],
  rcaronidieresis: [
    0,
    0,
    15,
    15
  ],
  rcaronigrave: [
    0,
    0,
    15,
    15
  ],
  rcaronimacron: [
    0,
    0,
    15,
    15
  ],
  rcaroniogonek: [
    0,
    0,
    15,
    15
  ],
  rcaronk: [
    0,
    0,
    15,
    15
  ],
  rcaronkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcaronl: [
    0,
    0,
    15,
    15
  ],
  rcaronlacute: [
    0,
    0,
    15,
    15
  ],
  rcaronlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcaronlslash: [
    0,
    0,
    15,
    15
  ],
  rcaronm: [
    0,
    0,
    25,
    25
  ],
  rcaronn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rcaronsemicolon: [
    0,
    0,
    30,
    30
  ],
  rcaronu: [
    0,
    0,
    15,
    15
  ],
  rcaronuacute: [
    0,
    0,
    15,
    15
  ],
  rcaronucircumflex: [
    0,
    0,
    15,
    15
  ],
  rcaronudieresis: [
    0,
    0,
    15,
    15
  ],
  rcaronugrave: [
    0,
    0,
    15,
    15
  ],
  rcaronuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rcaronumacron: [
    0,
    0,
    15,
    15
  ],
  rcaronuogonek: [
    0,
    0,
    15,
    15
  ],
  rcaronuring: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenta: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentcolon: [
    0,
    0,
    30,
    30
  ],
  rcommaaccenti: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentiacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenticircumflex: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentidieresis: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentigrave: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentimacron: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentiogonek: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentk: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentl: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlslash: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentm: [
    0,
    0,
    25,
    25
  ],
  rcommaaccentn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rcommaaccentsemicolon: [
    0,
    0,
    30,
    30
  ],
  rcommaaccentu: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentucircumflex: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentudieresis: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentugrave: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentumacron: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuogonek: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenturing: [
    0,
    0,
    15,
    15
  ],
  scomma: [
    0,
    0,
    -15,
    -15
  ],
  speriod: [
    0,
    0,
    -15,
    -15
  ],
  sacutecomma: [
    0,
    0,
    -15,
    -15
  ],
  sacuteperiod: [
    0,
    0,
    -15,
    -15
  ],
  scaroncomma: [
    0,
    0,
    -15,
    -15
  ],
  scaronperiod: [
    0,
    0,
    -15,
    -15
  ],
  scedillacomma: [
    0,
    0,
    -15,
    -15
  ],
  scedillaperiod: [
    0,
    0,
    -15,
    -15
  ],
  scommaaccentcomma: [
    0,
    0,
    -15,
    -15
  ],
  scommaaccentperiod: [
    0,
    0,
    -15,
    -15
  ],
  ve: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  veacute: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vecaron: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vecircumflex: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vedieresis: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vedotaccent: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vegrave: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vemacron: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  veogonek: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  wa: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waacute: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wabreve: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wacircumflex: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wadieresis: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wagrave: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wamacron: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waogonek: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waring: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  watilde: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  we: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  weacute: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wecaron: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wecircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wedieresis: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wedotaccent: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wegrave: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wemacron: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  weogonek: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  zo: [
    0,
    0,
    -15,
    -15
  ],
  zoacute: [
    0,
    0,
    -15,
    -15
  ],
  zocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zograve: [
    0,
    0,
    -15,
    -15
  ],
  zohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zomacron: [
    0,
    0,
    -15,
    -15
  ],
  zoslash: [
    0,
    0,
    -15,
    -15
  ],
  zotilde: [
    0,
    0,
    -15,
    -15
  ],
  zacuteo: [
    0,
    0,
    -15,
    -15
  ],
  zacuteoacute: [
    0,
    0,
    -15,
    -15
  ],
  zacuteocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zacuteodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zacuteograve: [
    0,
    0,
    -15,
    -15
  ],
  zacuteohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zacuteomacron: [
    0,
    0,
    -15,
    -15
  ],
  zacuteoslash: [
    0,
    0,
    -15,
    -15
  ],
  zacuteotilde: [
    0,
    0,
    -15,
    -15
  ],
  zcarono: [
    0,
    0,
    -15,
    -15
  ],
  zcaronoacute: [
    0,
    0,
    -15,
    -15
  ],
  zcaronocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zcaronodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zcaronograve: [
    0,
    0,
    -15,
    -15
  ],
  zcaronohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zcaronomacron: [
    0,
    0,
    -15,
    -15
  ],
  zcaronoslash: [
    0,
    0,
    -15,
    -15
  ],
  zcaronotilde: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccento: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentoacute: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentograve: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentomacron: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentoslash: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentotilde: [
    0,
    0,
    -15,
    -15
  ],
  Ap: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aacutep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aacutequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Abrevep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Abrevequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Acircumflexp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Acircumflexquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Adieresisp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Adieresisquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Agravep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Agravequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Amacronp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Amacronquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aogonekp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aogonekquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aringp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aringquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Atildep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Atildequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Je: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jeacute: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jecaron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jecircumflex: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jedieresis: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jedotaccent: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jegrave: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jemacron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jeogonek: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jo: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Joacute: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jocircumflex: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jodieresis: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jograve: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Johungarumlaut: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jomacron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Joslash: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jotilde: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  NA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  Ti: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroni: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroniacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroniogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccenti: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccentiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccentiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Vi: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Viacute: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Vicircumflex: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vidieresis: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vigrave: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vimacron: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Viogonek: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Wi: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  Wiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  Wiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  fi: [
    0,
    0,
    0,
    0,
    -25,
    0,
    -20,
    -20
  ],
  gperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  gbreveperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  gcommaaccentperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  iv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  iacutev: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  icircumflexv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  idieresisv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  igravev: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  imacronv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  iogonekv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  ky: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kyacute: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kydieresis: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccenty: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccentyacute: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccentydieresis: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  quotedblleftA: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAacute: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAbreve: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAcircumflex: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAdieresis: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAgrave: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAmacron: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAogonek: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAring: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAtilde: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftA: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAacute: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAbreve: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAcircumflex: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAdieresis: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAgrave: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAmacron: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAogonek: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAring: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAtilde: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  re: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  reacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  recaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  recircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  redieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  redotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  regrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  remacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  reogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutee: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteeacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteeogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcarone: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroneacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroneogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccente: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccenteacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccenteogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  spaceA: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAacute: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAbreve: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAcircumflex: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAdieresis: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAgrave: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAmacron: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAogonek: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAring: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAtilde: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  Fi: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fiacute: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Ficircumflex: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fidieresis: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Figrave: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fimacron: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fiogonek: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  eb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  eacuteb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ecaronb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ecircumflexb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  edieresisb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  edotaccentb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  egraveb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  emacronb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  eogonekb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ff: [
    0,
    0,
    0,
    0,
    0,
    -18,
    -18,
    -25
  ],
  quoterightt: [
    0,
    0,
    0,
    0,
    0,
    -37,
    -30,
    -18
  ],
  quoterighttcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    -37,
    -30,
    -18
  ],
  Yicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  eg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacuteg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacutegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacutegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egraveg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egravegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egravegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  fiogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    -20
  ],
  gcomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevecomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentcomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  og: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacuteg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacutegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacutegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ograveg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogravegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogravegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildeg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  fiacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -20
  ],
  ga: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  garing: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbrevea: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbrevearing: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccenta: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaring: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ]
};
var data = {
  attributes,
  glyphWidths,
  kernPairs
};
var initFont = (font) => {
  return [font.FontName, {
    attributes: font,
    glyphWidths: {},
    kernPairs: {}
  }];
};
var expandData = (data2) => {
  const {
    attributes: attributes2,
    glyphWidths: glyphWidths2,
    kernPairs: kernPairs2
  } = data2;
  const fonts = attributes2.map(initFont);
  Object.keys(glyphWidths2).forEach((key) => {
    glyphWidths2[key].forEach((value2, index3) => {
      if (value2) fonts[index3][1].glyphWidths[key] = value2;
    });
  });
  Object.keys(kernPairs2).forEach((key) => {
    kernPairs2[key].forEach((value2, index3) => {
      if (value2) fonts[index3][1].kernPairs[key] = value2;
    });
  });
  return Object.fromEntries(fonts);
};
var STANDARD_FONTS = expandData(data);
var createStandardFont = (PDFFont2) => class StandardFont extends PDFFont2 {
  constructor(document2, name, id) {
    super();
    this.document = document2;
    this.name = name;
    this.id = id;
    this.font = AFMFont.fromJson(STANDARD_FONTS[this.name]);
    this.ascender = this.font.ascender;
    this.descender = this.font.descender;
    this.bbox = this.font.bbox;
    this.lineGap = this.font.lineGap;
  }
  embed() {
    this.dictionary.data = {
      Type: "Font",
      BaseFont: this.name,
      Subtype: "Type1",
      Encoding: "WinAnsiEncoding"
    };
    return this.dictionary.end();
  }
  encode(text) {
    const encoded = this.font.encodeText(text);
    const glyphs = this.font.glyphsForString(`${text}`);
    const advances = this.font.advancesForGlyphs(glyphs);
    const positions = [];
    for (let i3 = 0; i3 < glyphs.length; i3++) {
      const glyph = glyphs[i3];
      positions.push({
        xAdvance: advances[i3],
        yAdvance: 0,
        xOffset: 0,
        yOffset: 0,
        advanceWidth: this.font.widthOfGlyph(glyph)
      });
    }
    return [encoded, positions];
  }
  encodeGlyphs(glyphs) {
    const res = [];
    for (let glyph of Array.from(glyphs)) {
      res.push(`00${glyph.id.toString(16)}`.slice(-2));
    }
    return res;
  }
  widthOfString(string, size) {
    const glyphs = this.font.glyphsForString(`${string}`);
    const advances = this.font.advancesForGlyphs(glyphs);
    let width = 0;
    for (let advance of Array.from(advances)) {
      width += advance;
    }
    const scale2 = size / 1e3;
    return width * scale2;
  }
  static isStandardFont(name) {
    return name in STANDARD_FONTS;
  }
};
var toHex2 = function() {
  for (var _len = arguments.length, codePoints = new Array(_len), _key = 0; _key < _len; _key++) {
    codePoints[_key] = arguments[_key];
  }
  const codes2 = Array.from(codePoints).map((code) => `0000${code.toString(16)}`.slice(-4));
  return codes2.join("");
};
var createEmbeddedFont = (PDFFont2) => class EmbeddedFont extends PDFFont2 {
  constructor(document2, font, id) {
    super();
    this.document = document2;
    this.font = font;
    this.id = id;
    this.subset = this.font.createSubset();
    this.unicode = [[0]];
    this.widths = [this.font.getGlyph(0).advanceWidth];
    this.name = this.font.postscriptName;
    this.scale = 1e3 / this.font.unitsPerEm;
    this.ascender = this.font.ascent * this.scale;
    this.descender = this.font.descent * this.scale;
    this.xHeight = this.font.xHeight * this.scale;
    this.capHeight = this.font.capHeight * this.scale;
    this.lineGap = this.font.lineGap * this.scale;
    this.bbox = this.font.bbox;
    this.layoutCache = /* @__PURE__ */ Object.create(null);
  }
  layoutRun(text, features) {
    const run = this.font.layout(text, features, void 0, void 0, "ltr");
    for (let i3 = 0; i3 < run.positions.length; i3++) {
      const position = run.positions[i3];
      for (let key in position) {
        position[key] *= this.scale;
      }
      position.advanceWidth = run.glyphs[i3].advanceWidth * this.scale;
    }
    return run;
  }
  layoutCached(text) {
    let cached;
    if (cached = this.layoutCache[text]) {
      return cached;
    }
    const run = this.layoutRun(text);
    this.layoutCache[text] = run;
    return run;
  }
  layout(text, features, onlyWidth) {
    if (onlyWidth == null) {
      onlyWidth = false;
    }
    if (features) {
      return this.layoutRun(text, features);
    }
    const glyphs = onlyWidth ? null : [];
    const positions = onlyWidth ? null : [];
    let advanceWidth2 = 0;
    let last2 = 0;
    let index3 = 0;
    while (index3 <= text.length) {
      let needle;
      if (index3 === text.length && last2 < index3 || (needle = text.charAt(index3), [" ", "	"].includes(needle))) {
        const run = this.layoutCached(text.slice(last2, ++index3));
        if (!onlyWidth) {
          glyphs.push(...Array.from(run.glyphs || []));
          positions.push(...Array.from(run.positions || []));
        }
        advanceWidth2 += run.advanceWidth;
        last2 = index3;
      } else {
        index3++;
      }
    }
    return {
      glyphs,
      positions,
      advanceWidth: advanceWidth2
    };
  }
  encode(text, features) {
    const {
      glyphs,
      positions
    } = this.layout(text, features);
    const res = [];
    for (let i3 = 0; i3 < glyphs.length; i3++) {
      const glyph = glyphs[i3];
      const gid = this.subset.includeGlyph(glyph.id);
      res.push(`0000${gid.toString(16)}`.slice(-4));
      if (this.widths[gid] == null) {
        this.widths[gid] = glyph.advanceWidth * this.scale;
      }
      if (this.unicode[gid] == null) {
        this.unicode[gid] = glyph.codePoints;
      }
    }
    return [res, positions];
  }
  encodeGlyphs(glyphs) {
    const res = [];
    for (let i3 = 0; i3 < glyphs.length; i3++) {
      const glyph = glyphs[i3];
      const gid = this.subset.includeGlyph(glyph.id);
      res.push(`0000${gid.toString(16)}`.slice(-4));
      if (this.widths[gid] == null) {
        this.widths[gid] = glyph.advanceWidth * this.scale;
      }
      if (this.unicode[gid] == null) {
        this.unicode[gid] = glyph.codePoints;
      }
    }
    return res;
  }
  widthOfString(string, size, features) {
    const width = this.layout(string, features, true).advanceWidth;
    const scale2 = size / 1e3;
    return width * scale2;
  }
  embed() {
    const isCFF = this.subset.cff != null;
    const fontFile = this.document.ref();
    if (isCFF) {
      fontFile.data.Subtype = "CIDFontType0C";
    }
    fontFile.end(this.subset.encode());
    const familyClass = ((this.font["OS/2"] != null ? this.font["OS/2"].sFamilyClass : void 0) || 0) >> 8;
    let flags = 0;
    if (this.font.post.isFixedPitch) {
      flags |= 1 << 0;
    }
    if (1 <= familyClass && familyClass <= 7) {
      flags |= 1 << 1;
    }
    flags |= 1 << 2;
    if (familyClass === 10) {
      flags |= 1 << 3;
    }
    if (this.font.head.macStyle.italic) {
      flags |= 1 << 6;
    }
    const tag = [0, 1, 2, 3, 4, 5].map(() => String.fromCharCode(Math.random() * 26 + 65)).join("");
    const name = tag + "+" + this.font.postscriptName;
    const {
      bbox
    } = this.font;
    const descriptor = this.document.ref({
      Type: "FontDescriptor",
      FontName: name,
      Flags: flags,
      FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],
      ItalicAngle: this.font.italicAngle,
      Ascent: this.ascender,
      Descent: this.descender,
      CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,
      XHeight: (this.font.xHeight || 0) * this.scale,
      StemV: 0
    });
    if (isCFF) {
      descriptor.data.FontFile3 = fontFile;
    } else {
      descriptor.data.FontFile2 = fontFile;
    }
    descriptor.end();
    const descendantFontData = {
      Type: "Font",
      Subtype: "CIDFontType0",
      BaseFont: name,
      CIDSystemInfo: {
        Registry: new String("Adobe"),
        Ordering: new String("Identity"),
        Supplement: 0
      },
      FontDescriptor: descriptor,
      W: [0, this.widths]
    };
    if (!isCFF) {
      descendantFontData.Subtype = "CIDFontType2";
      descendantFontData.CIDToGIDMap = "Identity";
    }
    const descendantFont = this.document.ref(descendantFontData);
    descendantFont.end();
    this.dictionary.data = {
      Type: "Font",
      Subtype: "Type0",
      BaseFont: name,
      Encoding: "Identity-H",
      DescendantFonts: [descendantFont],
      ToUnicode: this.toUnicodeCmap()
    };
    return this.dictionary.end();
  }
  // Maps the glyph ids encoded in the PDF back to unicode strings
  // Because of ligature substitutions and the like, there may be one or more
  // unicode characters represented by each glyph.
  toUnicodeCmap() {
    const cmap = this.document.ref();
    let entries = [];
    let unicodeMap = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange";
    for (let [index3, codePoints] of this.unicode.entries()) {
      const encoded = [];
      if (entries.length >= 100) {
        unicodeMap += "\n" + entries.length + " beginbfchar\n" + entries.join("\n") + "\nendbfchar";
        entries = [];
      }
      for (let value2 of codePoints) {
        if (value2 > 65535) {
          value2 -= 65536;
          encoded.push(toHex2(value2 >>> 10 & 1023 | 55296));
          value2 = 56320 | value2 & 1023;
        }
        encoded.push(toHex2(value2));
      }
      entries.push("<" + toHex2(index3) + "><" + encoded.join(" ") + ">");
    }
    if (entries.length) {
      unicodeMap += "\n" + entries.length + " beginbfchar\n" + entries.join("\n") + "\nendbfchar\n";
    }
    unicodeMap += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
    cmap.end(unicodeMap);
    return cmap;
  }
};
var PDFFont = class {
  static open(document2, src, family, id) {
    let font;
    if (typeof src === "string") {
      if (StandardFont.isStandardFont(src)) {
        return new StandardFont(document2, src, id);
      }
      {
        throw new Error(`Can't open ${src} in browser build`);
      }
    } else if (src instanceof Uint8Array) {
      font = $d636bc798e7178db$export$185802fd694ee1f5(src, family);
    } else if (src instanceof ArrayBuffer) {
      font = $d636bc798e7178db$export$185802fd694ee1f5(new Uint8Array(src), family);
    } else if (typeof src === "object") {
      font = src;
    }
    if (font == null) {
      throw new Error("Not a supported font format or standard PDF font.");
    }
    return new EmbeddedFont(document2, font, id);
  }
  encode() {
    throw new Error("Must be implemented by subclasses");
  }
  widthOfString() {
    throw new Error("Must be implemented by subclasses");
  }
  ref() {
    return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();
  }
  finalize() {
    if (this.embedded || this.dictionary == null) {
      return;
    }
    this.embed();
    return this.embedded = true;
  }
  embed() {
    throw new Error("Must be implemented by subclasses");
  }
  lineHeight(size, includeGap) {
    if (includeGap == null) {
      includeGap = false;
    }
    const gap = includeGap ? this.lineGap : 0;
    return (this.ascender + gap - this.descender) / 1e3 * size;
  }
};
var StandardFont = createStandardFont(PDFFont);
var EmbeddedFont = createEmbeddedFont(PDFFont);
var FontsMixin = {
  initFonts() {
    this._fontFamilies = {};
    this._fontCount = 0;
    this._fontSize = 12;
    this._font = null;
    this._registeredFonts = {};
    return this.font("Helvetica");
  },
  font(src, family, size) {
    let cacheKey;
    let font;
    if (typeof family === "number") {
      size = family;
      family = null;
    }
    if (typeof src === "string" && this._registeredFonts[src]) {
      cacheKey = src;
      ({
        src,
        family
      } = this._registeredFonts[src]);
    } else {
      cacheKey = family || src;
      if (typeof cacheKey !== "string") {
        cacheKey = null;
      }
    }
    if (size != null) {
      this.fontSize(size);
    }
    if (font = this._fontFamilies[cacheKey]) {
      this._font = font;
      return this;
    }
    const id = `F${++this._fontCount}`;
    this._font = PDFFont.open(this, src, family, id);
    if (font = this._fontFamilies[this._font.name]) {
      this._font = font;
      return this;
    }
    if (cacheKey) {
      this._fontFamilies[cacheKey] = this._font;
    }
    if (this._font.name) {
      this._fontFamilies[this._font.name] = this._font;
    }
    return this;
  },
  fontSize(_fontSize) {
    this._fontSize = _fontSize;
    return this;
  },
  currentLineHeight(includeGap) {
    if (includeGap == null) {
      includeGap = false;
    }
    return this._font.lineHeight(this._fontSize, includeGap);
  },
  registerFont(name, src, family) {
    this._registeredFonts[name] = {
      src,
      family
    };
    return this;
  }
};
function PDFNumber(n4) {
  return Math.fround(n4);
}
var SOFT_HYPHEN = "";
var HYPHEN = "-";
var LineWrapper = class extends EventEmitter2 {
  constructor(document2, options) {
    super();
    this.document = document2;
    this.horizontalScaling = options.horizontalScaling || 100;
    this.indent = (options.indent || 0) * this.horizontalScaling / 100;
    this.characterSpacing = (options.characterSpacing || 0) * this.horizontalScaling / 100;
    this.wordSpacing = (options.wordSpacing === 0) * this.horizontalScaling / 100;
    this.columns = options.columns || 1;
    this.columnGap = (options.columnGap != null ? options.columnGap : 18) * this.horizontalScaling / 100;
    this.lineWidth = (options.width * this.horizontalScaling / 100 - this.columnGap * (this.columns - 1)) / this.columns;
    this.spaceLeft = this.lineWidth;
    this.startX = this.document.x;
    this.startY = this.document.y;
    this.column = 1;
    this.ellipsis = options.ellipsis;
    this.continuedX = 0;
    this.features = options.features;
    if (options.height != null) {
      this.height = options.height;
      this.maxY = PDFNumber(this.startY + options.height);
    } else {
      this.maxY = PDFNumber(this.document.page.maxY());
    }
    this.on("firstLine", (options2) => {
      const indent = this.continuedX || this.indent;
      this.document.x += indent;
      this.lineWidth -= indent;
      if (options2.indentAllLines) {
        return;
      }
      return this.once("line", () => {
        this.document.x -= indent;
        this.lineWidth += indent;
        if (options2.continued && !this.continuedX) {
          this.continuedX = this.indent;
        }
        if (!options2.continued) {
          return this.continuedX = 0;
        }
      });
    });
    this.on("lastLine", (options2) => {
      const {
        align
      } = options2;
      if (align === "justify") {
        options2.align = "left";
      }
      this.lastLine = true;
      return this.once("line", () => {
        this.document.y += options2.paragraphGap || 0;
        options2.align = align;
        return this.lastLine = false;
      });
    });
  }
  wordWidth(word) {
    return this.document.widthOfString(word, this) + this.characterSpacing + this.wordSpacing;
  }
  canFit(word, w) {
    if (word[word.length - 1] != SOFT_HYPHEN) {
      return w <= this.spaceLeft;
    }
    return w + this.wordWidth(HYPHEN) <= this.spaceLeft;
  }
  eachWord(text, fn) {
    let bk;
    const breaker = new $557adaaeb0c7885f$exports(text);
    let last2 = null;
    const wordWidths = /* @__PURE__ */ Object.create(null);
    while (bk = breaker.nextBreak()) {
      var shouldContinue;
      let word = text.slice((last2 != null ? last2.position : void 0) || 0, bk.position);
      let w = wordWidths[word] != null ? wordWidths[word] : wordWidths[word] = this.wordWidth(word);
      if (w > this.lineWidth + this.continuedX) {
        let lbk = last2;
        const fbk = {};
        while (word.length) {
          var l2, mightGrow;
          if (w > this.spaceLeft) {
            l2 = Math.ceil(this.spaceLeft / (w / word.length));
            w = this.wordWidth(word.slice(0, l2));
            mightGrow = w <= this.spaceLeft && l2 < word.length;
          } else {
            l2 = word.length;
          }
          let mustShrink = w > this.spaceLeft && l2 > 0;
          while (mustShrink || mightGrow) {
            if (mustShrink) {
              w = this.wordWidth(word.slice(0, --l2));
              mustShrink = w > this.spaceLeft && l2 > 0;
            } else {
              w = this.wordWidth(word.slice(0, ++l2));
              mustShrink = w > this.spaceLeft && l2 > 0;
              mightGrow = w <= this.spaceLeft && l2 < word.length;
            }
          }
          if (l2 === 0 && this.spaceLeft === this.lineWidth) {
            l2 = 1;
          }
          fbk.required = bk.required || l2 < word.length;
          shouldContinue = fn(word.slice(0, l2), w, fbk, lbk);
          lbk = {
            required: false
          };
          word = word.slice(l2);
          w = this.wordWidth(word);
          if (shouldContinue === false) {
            break;
          }
        }
      } else {
        shouldContinue = fn(word, w, bk, last2);
      }
      if (shouldContinue === false) {
        break;
      }
      last2 = bk;
    }
  }
  wrap(text, options) {
    this.horizontalScaling = options.horizontalScaling || 100;
    if (options.indent != null) {
      this.indent = options.indent * this.horizontalScaling / 100;
    }
    if (options.characterSpacing != null) {
      this.characterSpacing = options.characterSpacing * this.horizontalScaling / 100;
    }
    if (options.wordSpacing != null) {
      this.wordSpacing = options.wordSpacing * this.horizontalScaling / 100;
    }
    if (options.ellipsis != null) {
      this.ellipsis = options.ellipsis;
    }
    const nextY = this.document.y + this.document.currentLineHeight(true);
    if (this.document.y > this.maxY || nextY > this.maxY) {
      this.nextSection();
    }
    let buffer = "";
    let textWidth = 0;
    let wc = 0;
    let lc = 0;
    let {
      y: y2
    } = this.document;
    const emitLine = () => {
      options.textWidth = textWidth + this.wordSpacing * (wc - 1);
      options.wordCount = wc;
      options.lineWidth = this.lineWidth;
      ({
        y: y2
      } = this.document);
      this.emit("line", buffer, options, this);
      return lc++;
    };
    this.emit("sectionStart", options, this);
    this.eachWord(text, (word, w, bk, last2) => {
      if (last2 == null || last2.required) {
        this.emit("firstLine", options, this);
        this.spaceLeft = this.lineWidth;
      }
      if (this.canFit(word, w)) {
        buffer += word;
        textWidth += w;
        wc++;
      }
      if (bk.required || !this.canFit(word, w)) {
        const lh = this.document.currentLineHeight(true);
        if (this.height != null && this.ellipsis && PDFNumber(this.document.y + lh * 2) > this.maxY && this.column >= this.columns) {
          if (this.ellipsis === true) {
            this.ellipsis = "";
          }
          buffer = buffer.replace(/\s+$/, "");
          textWidth = this.wordWidth(buffer + this.ellipsis);
          while (buffer && textWidth > this.lineWidth) {
            buffer = buffer.slice(0, -1).replace(/\s+$/, "");
            textWidth = this.wordWidth(buffer + this.ellipsis);
          }
          if (textWidth <= this.lineWidth) {
            buffer = buffer + this.ellipsis;
          }
          textWidth = this.wordWidth(buffer);
        }
        if (bk.required) {
          if (w > this.spaceLeft) {
            emitLine();
            buffer = word;
            textWidth = w;
            wc = 1;
          }
          this.emit("lastLine", options, this);
        }
        if (buffer[buffer.length - 1] == SOFT_HYPHEN) {
          buffer = buffer.slice(0, -1) + HYPHEN;
          this.spaceLeft -= this.wordWidth(HYPHEN);
        }
        emitLine();
        if (PDFNumber(this.document.y + lh) > this.maxY) {
          const shouldContinue = this.nextSection();
          if (!shouldContinue) {
            wc = 0;
            buffer = "";
            return false;
          }
        }
        if (bk.required) {
          this.spaceLeft = this.lineWidth;
          buffer = "";
          textWidth = 0;
          return wc = 0;
        } else {
          this.spaceLeft = this.lineWidth - w;
          buffer = word;
          textWidth = w;
          return wc = 1;
        }
      } else {
        return this.spaceLeft -= w;
      }
    });
    if (wc > 0) {
      this.emit("lastLine", options, this);
      emitLine();
    }
    this.emit("sectionEnd", options, this);
    if (options.continued === true) {
      if (lc > 1) {
        this.continuedX = 0;
      }
      this.continuedX += options.textWidth || 0;
      return this.document.y = y2;
    } else {
      return this.document.x = this.startX;
    }
  }
  nextSection(options) {
    this.emit("sectionEnd", options, this);
    if (++this.column > this.columns) {
      if (this.height != null) {
        return false;
      }
      this.document.continueOnNewPage();
      this.column = 1;
      this.startY = this.document.page.margins.top;
      this.maxY = this.document.page.maxY();
      this.document.x = this.startX;
      if (this.document._fillColor) {
        this.document.fillColor(...this.document._fillColor);
      }
      this.emit("pageBreak", options, this);
    } else {
      this.document.x += this.lineWidth + this.columnGap;
      this.document.y = this.startY;
      this.emit("columnBreak", options, this);
    }
    this.emit("sectionStart", options, this);
    return true;
  }
};
var {
  number: number2
} = PDFObject;
var TextMixin = {
  initText() {
    this._line = this._line.bind(this);
    this.x = 0;
    this.y = 0;
    return this._lineGap = 0;
  },
  lineGap(_lineGap) {
    this._lineGap = _lineGap;
    return this;
  },
  moveDown(lines) {
    if (lines == null) {
      lines = 1;
    }
    this.y += this.currentLineHeight(true) * lines + this._lineGap;
    return this;
  },
  moveUp(lines) {
    if (lines == null) {
      lines = 1;
    }
    this.y -= this.currentLineHeight(true) * lines + this._lineGap;
    return this;
  },
  _text(text, x, y2, options, lineCallback) {
    options = this._initOptions(x, y2, options);
    text = text == null ? "" : `${text}`;
    if (options.wordSpacing) {
      text = text.replace(/\s{2,}/g, " ");
    }
    const addStructure = () => {
      if (options.structParent) {
        options.structParent.add(this.struct(options.structType || "P", [this.markStructureContent(options.structType || "P")]));
      }
    };
    if (options.rotation !== 0) {
      this.save();
      this.rotate(-options.rotation, {
        origin: [this.x, this.y]
      });
    }
    if (options.width) {
      let wrapper = this._wrapper;
      if (!wrapper) {
        wrapper = new LineWrapper(this, options);
        wrapper.on("line", lineCallback);
        wrapper.on("firstLine", addStructure);
      }
      this._wrapper = options.continued ? wrapper : null;
      this._textOptions = options.continued ? options : null;
      wrapper.wrap(text, options);
    } else {
      for (let line2 of text.split("\n")) {
        addStructure();
        lineCallback(line2, options);
      }
    }
    if (options.rotation !== 0) this.restore();
    return this;
  },
  text(text, x, y2, options) {
    return this._text(text, x, y2, options, this._line);
  },
  widthOfString(string, options) {
    if (options === void 0) {
      options = {};
    }
    const horizontalScaling = options.horizontalScaling || 100;
    return (this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1)) * horizontalScaling / 100;
  },
  /**
   * Compute the bounding box of a string
   * based on what will actually be rendered by `doc.text()`
   *
   * @param string - The string
   * @param x - X position of text (defaults to this.x)
   * @param y - Y position of text (defaults to this.y)
   * @param options - Any text options (The same you would apply to `doc.text()`)
   * @returns {{x: number, y: number, width: number, height: number}}
   */
  boundsOfString(string, x, y2, options) {
  },
  heightOfString(text, options) {
    const {
      x,
      y: y2
    } = this;
    options = this._initOptions(options);
    options.height = Infinity;
    const lineGap2 = options.lineGap || this._lineGap || 0;
    this._text(text, this.x, this.y, options, () => {
      return this.y += this.currentLineHeight(true) + lineGap2;
    });
    const height2 = this.y - y2;
    this.x = x;
    this.y = y2;
    return height2;
  },
  list(list, x, y2, options, wrapper) {
    options = this._initOptions(x, y2, options);
    const listType = options.listType || "bullet";
    const unit = Math.round(this._font.ascender / 1e3 * this._fontSize);
    const midLine = unit / 2;
    const r3 = options.bulletRadius || unit / 3;
    const indent = options.textIndent || (listType === "bullet" ? r3 * 5 : unit * 2);
    const itemIndent = options.bulletIndent || (listType === "bullet" ? r3 * 8 : unit * 2);
    let level = 1;
    const items = [];
    const levels = [];
    const numbers = [];
    var flatten3 = function(list2) {
      let n4 = 1;
      for (let i3 = 0; i3 < list2.length; i3++) {
        const item = list2[i3];
        if (Array.isArray(item)) {
          level++;
          flatten3(item);
          level--;
        } else {
          items.push(item);
          levels.push(level);
          if (listType !== "bullet") {
            numbers.push(n4++);
          }
        }
      }
    };
    flatten3(list);
    const label = function(n4) {
      switch (listType) {
        case "numbered":
          return `${n4}.`;
        case "lettered":
          var letter = String.fromCharCode((n4 - 1) % 26 + 65);
          var times = Math.floor((n4 - 1) / 26 + 1);
          var text = Array(times + 1).join(letter);
          return `${text}.`;
      }
    };
    const drawListItem = function(listItem, i3) {
      wrapper = new LineWrapper(this, options);
      wrapper.on("line", this._line);
      level = 1;
      wrapper.once("firstLine", () => {
        let item, itemType, labelType, bodyType;
        if (options.structParent) {
          if (options.structTypes) {
            [itemType, labelType, bodyType] = options.structTypes;
          } else {
            [itemType, labelType, bodyType] = ["LI", "Lbl", "LBody"];
          }
        }
        if (itemType) {
          item = this.struct(itemType);
          options.structParent.add(item);
        } else if (options.structParent) {
          item = options.structParent;
        }
        let l2;
        if ((l2 = levels[i3++]) !== level) {
          const diff = itemIndent * (l2 - level);
          this.x += diff;
          wrapper.lineWidth -= diff;
          level = l2;
        }
        if (item && (labelType || bodyType)) {
          item.add(this.struct(labelType || bodyType, [this.markStructureContent(labelType || bodyType)]));
        }
        switch (listType) {
          case "bullet":
            this.circle(this.x - indent + r3, this.y + midLine, r3);
            this.fill();
            break;
          case "numbered":
          case "lettered":
            var text = label(numbers[i3 - 1]);
            this._fragment(text, this.x - indent, this.y, options);
            break;
        }
        if (item && labelType && bodyType) {
          item.add(this.struct(bodyType, [this.markStructureContent(bodyType)]));
        }
        if (item && item !== options.structParent) {
          item.end();
        }
      });
      wrapper.on("sectionStart", () => {
        const pos = indent + itemIndent * (level - 1);
        this.x += pos;
        return wrapper.lineWidth -= pos;
      });
      wrapper.on("sectionEnd", () => {
        const pos = indent + itemIndent * (level - 1);
        this.x -= pos;
        return wrapper.lineWidth += pos;
      });
      wrapper.wrap(listItem, options);
    };
    for (let i3 = 0; i3 < items.length; i3++) {
      drawListItem.call(this, items[i3], i3);
    }
    return this;
  },
  _initOptions(x, y2, options) {
    if (x === void 0) {
      x = {};
    }
    if (options === void 0) {
      options = {};
    }
    if (typeof x === "object") {
      options = x;
      x = null;
    }
    const result = Object.assign({}, options);
    if (this._textOptions) {
      for (let key in this._textOptions) {
        const val = this._textOptions[key];
        if (key !== "continued") {
          if (result[key] === void 0) {
            result[key] = val;
          }
        }
      }
    }
    if (x != null) {
      this.x = x;
    }
    if (y2 != null) {
      this.y = y2;
    }
    if (result.lineBreak !== false) {
      if (result.width == null) {
        result.width = this.page.width - this.x - this.page.margins.right;
      }
      result.width = Math.max(result.width, 0);
    }
    if (!result.columns) {
      result.columns = 0;
    }
    if (result.columnGap == null) {
      result.columnGap = 18;
    }
    result.rotation = Number(options.rotation ?? 0) % 360;
    if (result.rotation < 0) result.rotation += 360;
    return result;
  },
  _line(text, options, wrapper) {
    if (options === void 0) {
      options = {};
    }
    this._fragment(text, this.x, this.y, options);
    const lineGap2 = options.lineGap || this._lineGap || 0;
    if (!wrapper) {
      return this.x += this.widthOfString(text, options);
    } else {
      return this.y += this.currentLineHeight(true) + lineGap2;
    }
  },
  _fragment(text, x, y2, options) {
    let dy, encoded, i3, positions, textWidth, words;
    text = `${text}`.replace(/\n/g, "");
    if (text.length === 0) {
      return;
    }
    const align = options.align || "left";
    let wordSpacing = options.wordSpacing || 0;
    const characterSpacing = options.characterSpacing || 0;
    const horizontalScaling = options.horizontalScaling || 100;
    if (options.width) {
      switch (align) {
        case "right":
          textWidth = this.widthOfString(text.replace(/\s+$/, ""), options);
          x += options.lineWidth - textWidth;
          break;
        case "center":
          x += options.lineWidth / 2 - options.textWidth / 2;
          break;
        case "justify":
          words = text.trim().split(/\s+/);
          textWidth = this.widthOfString(text.replace(/\s+/g, ""), options);
          var spaceWidth = this.widthOfString(" ") + characterSpacing;
          wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);
          break;
      }
    }
    if (typeof options.baseline === "number") {
      dy = -options.baseline;
    } else {
      switch (options.baseline) {
        case "svg-middle":
          dy = 0.5 * this._font.xHeight;
          break;
        case "middle":
        case "svg-central":
          dy = 0.5 * (this._font.descender + this._font.ascender);
          break;
        case "bottom":
        case "ideographic":
          dy = this._font.descender;
          break;
        case "alphabetic":
          dy = 0;
          break;
        case "mathematical":
          dy = 0.5 * this._font.ascender;
          break;
        case "hanging":
          dy = 0.8 * this._font.ascender;
          break;
        case "top":
          dy = this._font.ascender;
          break;
        default:
          dy = this._font.ascender;
      }
      dy = dy / 1e3 * this._fontSize;
    }
    const renderedWidth = options.textWidth + wordSpacing * (options.wordCount - 1) + characterSpacing * (text.length - 1);
    if (options.link != null) {
      this.link(x, y2, renderedWidth, this.currentLineHeight(), options.link);
    }
    if (options.goTo != null) {
      this.goTo(x, y2, renderedWidth, this.currentLineHeight(), options.goTo);
    }
    if (options.destination != null) {
      this.addNamedDestination(options.destination, "XYZ", x, y2, null);
    }
    if (options.underline) {
      this.save();
      if (!options.stroke) {
        this.strokeColor(...this._fillColor || []);
      }
      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
      this.lineWidth(lineWidth);
      let lineY = y2 + this.currentLineHeight() - lineWidth;
      this.moveTo(x, lineY);
      this.lineTo(x + renderedWidth, lineY);
      this.stroke();
      this.restore();
    }
    if (options.strike) {
      this.save();
      if (!options.stroke) {
        this.strokeColor(...this._fillColor || []);
      }
      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
      this.lineWidth(lineWidth);
      let lineY = y2 + this.currentLineHeight() / 2;
      this.moveTo(x, lineY);
      this.lineTo(x + renderedWidth, lineY);
      this.stroke();
      this.restore();
    }
    this.save();
    if (options.oblique) {
      let skew;
      if (typeof options.oblique === "number") {
        skew = -Math.tan(options.oblique * Math.PI / 180);
      } else {
        skew = -0.25;
      }
      this.transform(1, 0, 0, 1, x, y2);
      this.transform(1, 0, skew, 1, -skew * dy, 0);
      this.transform(1, 0, 0, 1, -x, -y2);
    }
    this.transform(1, 0, 0, -1, 0, this.page.height);
    y2 = this.page.height - y2 - dy;
    if (this.page.fonts[this._font.id] == null) {
      this.page.fonts[this._font.id] = this._font.ref();
    }
    this.addContent("BT");
    this.addContent(`1 0 0 1 ${number2(x)} ${number2(y2)} Tm`);
    this.addContent(`/${this._font.id} ${number2(this._fontSize)} Tf`);
    const mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;
    if (mode) {
      this.addContent(`${mode} Tr`);
    }
    if (characterSpacing) {
      this.addContent(`${number2(characterSpacing)} Tc`);
    }
    if (horizontalScaling !== 100) {
      this.addContent(`${horizontalScaling} Tz`);
    }
    if (wordSpacing) {
      words = text.trim().split(/\s+/);
      wordSpacing += this.widthOfString(" ") + characterSpacing;
      wordSpacing *= 1e3 / this._fontSize;
      encoded = [];
      positions = [];
      for (let word of words) {
        const [encodedWord, positionsWord] = this._font.encode(word, options.features);
        encoded = encoded.concat(encodedWord);
        positions = positions.concat(positionsWord);
        const space = {};
        const object = positions[positions.length - 1];
        for (let key in object) {
          const val = object[key];
          space[key] = val;
        }
        space.xAdvance += wordSpacing;
        positions[positions.length - 1] = space;
      }
    } else {
      [encoded, positions] = this._font.encode(text, options.features);
    }
    const scale2 = this._fontSize / 1e3;
    const commands = [];
    let last2 = 0;
    let hadOffset = false;
    const addSegment = (cur) => {
      if (last2 < cur) {
        const hex = encoded.slice(last2, cur).join("");
        const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
        commands.push(`<${hex}> ${number2(-advance)}`);
      }
      return last2 = cur;
    };
    const flush = (i4) => {
      addSegment(i4);
      if (commands.length > 0) {
        this.addContent(`[${commands.join(" ")}] TJ`);
        return commands.length = 0;
      }
    };
    for (i3 = 0; i3 < positions.length; i3++) {
      const pos = positions[i3];
      if (pos.xOffset || pos.yOffset) {
        flush(i3);
        this.addContent(`1 0 0 1 ${number2(x + pos.xOffset * scale2)} ${number2(y2 + pos.yOffset * scale2)} Tm`);
        flush(i3 + 1);
        hadOffset = true;
      } else {
        if (hadOffset) {
          this.addContent(`1 0 0 1 ${number2(x)} ${number2(y2)} Tm`);
          hadOffset = false;
        }
        if (pos.xAdvance - pos.advanceWidth !== 0) {
          addSegment(i3 + 1);
        }
      }
      x += pos.xAdvance * scale2;
    }
    flush(i3);
    this.addContent("ET");
    return this.restore();
  }
};
var COLOR_SPACE_MAP = {
  1: "DeviceGray",
  3: "DeviceRGB",
  4: "DeviceCMYK"
};
var JPEG2 = class {
  constructor(data2, label) {
    this.data = data2;
    this.label = label;
    this.orientation = 1;
    if (this.data.readUInt16BE(0) !== 65496) {
      throw "SOI not found in JPEG";
    }
    const markers = src_default.decode(this.data);
    for (let i3 = 0; i3 < markers.length; i3 += 1) {
      const marker = markers[i3];
      if (marker.name === "EXIF" && marker.entries.orientation) {
        this.orientation = marker.entries.orientation;
      }
      if (marker.name === "SOF") {
        this.bits || (this.bits = marker.precision);
        this.width || (this.width = marker.width);
        this.height || (this.height = marker.height);
        this.colorSpace || (this.colorSpace = COLOR_SPACE_MAP[marker.numberOfComponents]);
      }
    }
    this.obj = null;
  }
  embed(document2) {
    if (this.obj) {
      return;
    }
    this.obj = document2.ref({
      Type: "XObject",
      Subtype: "Image",
      BitsPerComponent: this.bits,
      Width: this.width,
      Height: this.height,
      ColorSpace: this.colorSpace,
      Filter: "DCTDecode"
    });
    if (this.colorSpace === "DeviceCMYK") {
      this.obj.data["Decode"] = [1, 0, 1, 0, 1, 0, 1, 0];
    }
    this.obj.end(this.data);
    return this.data = null;
  }
};
var PNGImage = class {
  constructor(data2, label) {
    this.label = label;
    this.image = new PNG(data2);
    this.width = this.image.width;
    this.height = this.image.height;
    this.imgData = this.image.imgData;
    this.obj = null;
  }
  embed(document2) {
    let dataDecoded = false;
    this.document = document2;
    if (this.obj) {
      return;
    }
    const hasAlphaChannel = this.image.hasAlphaChannel;
    const isInterlaced = this.image.interlaceMethod === 1;
    this.obj = this.document.ref({
      Type: "XObject",
      Subtype: "Image",
      BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,
      Width: this.width,
      Height: this.height,
      Filter: "FlateDecode"
    });
    if (!hasAlphaChannel) {
      const params = this.document.ref({
        Predictor: isInterlaced ? 1 : 15,
        Colors: this.image.colors,
        BitsPerComponent: this.image.bits,
        Columns: this.width
      });
      this.obj.data.DecodeParms = params;
      params.end();
    }
    if (this.image.palette.length === 0) {
      this.obj.data.ColorSpace = this.image.colorSpace;
    } else {
      const palette = this.document.ref();
      palette.end(Buffer$2.from(this.image.palette));
      this.obj.data.ColorSpace = ["Indexed", "DeviceRGB", this.image.palette.length / 3 - 1, palette];
    }
    if (this.image.transparency.grayscale != null) {
      const val = this.image.transparency.grayscale;
      this.obj.data.Mask = [val, val];
    } else if (this.image.transparency.rgb) {
      const {
        rgb
      } = this.image.transparency;
      const mask = [];
      for (let x of rgb) {
        mask.push(x, x);
      }
      this.obj.data.Mask = mask;
    } else if (this.image.transparency.indexed) {
      dataDecoded = true;
      return this.loadIndexedAlphaChannel();
    } else if (hasAlphaChannel) {
      dataDecoded = true;
      return this.splitAlphaChannel();
    }
    if (isInterlaced && !dataDecoded) {
      return this.decodeData();
    }
    this.finalize();
  }
  finalize() {
    if (this.alphaChannel) {
      const sMask = this.document.ref({
        Type: "XObject",
        Subtype: "Image",
        Height: this.height,
        Width: this.width,
        BitsPerComponent: 8,
        Filter: "FlateDecode",
        ColorSpace: "DeviceGray",
        Decode: [0, 1]
      });
      sMask.end(this.alphaChannel);
      this.obj.data.SMask = sMask;
    }
    this.obj.end(this.imgData);
    this.image = null;
    return this.imgData = null;
  }
  splitAlphaChannel() {
    return this.image.decodePixels((pixels) => {
      let a3;
      let p2;
      const colorCount = this.image.colors;
      const pixelCount = this.width * this.height;
      const imgData = Buffer$2.alloc(pixelCount * colorCount);
      const alphaChannel = Buffer$2.alloc(pixelCount);
      let i3 = p2 = a3 = 0;
      const len = pixels.length;
      const skipByteCount = this.image.bits === 16 ? 1 : 0;
      while (i3 < len) {
        for (let colorIndex = 0; colorIndex < colorCount; colorIndex++) {
          imgData[p2++] = pixels[i3++];
          i3 += skipByteCount;
        }
        alphaChannel[a3++] = pixels[i3++];
        i3 += skipByteCount;
      }
      this.imgData = zlib2.deflateSync(imgData);
      this.alphaChannel = zlib2.deflateSync(alphaChannel);
      return this.finalize();
    });
  }
  loadIndexedAlphaChannel() {
    const transparency = this.image.transparency.indexed;
    return this.image.decodePixels((pixels) => {
      const alphaChannel = Buffer$2.alloc(this.width * this.height);
      let i3 = 0;
      for (let j = 0, end2 = pixels.length; j < end2; j++) {
        alphaChannel[i3++] = transparency[pixels[j]];
      }
      this.alphaChannel = zlib2.deflateSync(alphaChannel);
      return this.finalize();
    });
  }
  decodeData() {
    this.image.decodePixels((pixels) => {
      this.imgData = zlib2.deflateSync(pixels);
      this.finalize();
    });
  }
};
var PDFImage = class {
  static open(src, label) {
    let data2;
    if (Buffer$2.isBuffer(src)) {
      data2 = src;
    } else if (src instanceof ArrayBuffer) {
      data2 = Buffer$2.from(new Uint8Array(src));
    } else {
      let match;
      if (match = /^data:.+?;base64,(.*)$/.exec(src)) {
        data2 = Buffer$2.from(match[1], "base64");
      } else {
        data2 = fs.readFileSync(src);
        if (!data2) {
          return;
        }
      }
    }
    if (data2[0] === 255 && data2[1] === 216) {
      return new JPEG2(data2, label);
    } else if (data2[0] === 137 && data2.toString("ascii", 1, 4) === "PNG") {
      return new PNGImage(data2, label);
    } else {
      throw new Error("Unknown image format.");
    }
  }
};
var ImagesMixin = {
  initImages() {
    this._imageRegistry = {};
    return this._imageCount = 0;
  },
  image(src, x, y2, options) {
    if (options === void 0) {
      options = {};
    }
    let bh, bp, bw, image, ip, left, left1, rotateAngle, originX, originY;
    if (typeof x === "object") {
      options = x;
      x = null;
    }
    const ignoreOrientation = options.ignoreOrientation || options.ignoreOrientation !== false && this.options.ignoreOrientation;
    x = (left = x != null ? x : options.x) != null ? left : this.x;
    y2 = (left1 = y2 != null ? y2 : options.y) != null ? left1 : this.y;
    if (typeof src === "string") {
      image = this._imageRegistry[src];
    }
    if (!image) {
      if (src.width && src.height) {
        image = src;
      } else {
        image = this.openImage(src);
      }
    }
    if (!image.obj) {
      image.embed(this);
    }
    if (this.page.xobjects[image.label] == null) {
      this.page.xobjects[image.label] = image.obj;
    }
    let {
      width,
      height: height2
    } = image;
    if (!ignoreOrientation && image.orientation > 4) {
      [width, height2] = [height2, width];
    }
    let w = options.width || width;
    let h2 = options.height || height2;
    if (options.width && !options.height) {
      const wp = w / width;
      w = width * wp;
      h2 = height2 * wp;
    } else if (options.height && !options.width) {
      const hp = h2 / height2;
      w = width * hp;
      h2 = height2 * hp;
    } else if (options.scale) {
      w = width * options.scale;
      h2 = height2 * options.scale;
    } else if (options.fit) {
      [bw, bh] = options.fit;
      bp = bw / bh;
      ip = width / height2;
      if (ip > bp) {
        w = bw;
        h2 = bw / ip;
      } else {
        h2 = bh;
        w = bh * ip;
      }
    } else if (options.cover) {
      [bw, bh] = options.cover;
      bp = bw / bh;
      ip = width / height2;
      if (ip > bp) {
        h2 = bh;
        w = bh * ip;
      } else {
        w = bw;
        h2 = bw / ip;
      }
    }
    if (options.fit || options.cover) {
      if (options.align === "center") {
        x = x + bw / 2 - w / 2;
      } else if (options.align === "right") {
        x = x + bw - w;
      }
      if (options.valign === "center") {
        y2 = y2 + bh / 2 - h2 / 2;
      } else if (options.valign === "bottom") {
        y2 = y2 + bh - h2;
      }
    }
    if (!ignoreOrientation) {
      switch (image.orientation) {
        // No orientation (need to flip image, though, because of the default transform matrix on the document)
        default:
        case 1:
          h2 = -h2;
          y2 -= h2;
          rotateAngle = 0;
          break;
        // Flip Horizontal
        case 2:
          w = -w;
          h2 = -h2;
          x -= w;
          y2 -= h2;
          rotateAngle = 0;
          break;
        // Rotate 180 degrees
        case 3:
          originX = x;
          originY = y2;
          h2 = -h2;
          x -= w;
          rotateAngle = 180;
          break;
        // Flip vertical
        case 4:
          break;
        // Flip horizontally and rotate 270 degrees CW
        case 5:
          originX = x;
          originY = y2;
          [w, h2] = [h2, w];
          y2 -= h2;
          rotateAngle = 90;
          break;
        // Rotate 90 degrees CW
        case 6:
          originX = x;
          originY = y2;
          [w, h2] = [h2, w];
          h2 = -h2;
          rotateAngle = 90;
          break;
        // Flip horizontally and rotate 90 degrees CW
        case 7:
          originX = x;
          originY = y2;
          [w, h2] = [h2, w];
          h2 = -h2;
          w = -w;
          x -= w;
          rotateAngle = 90;
          break;
        // Rotate 270 degrees CW
        case 8:
          originX = x;
          originY = y2;
          [w, h2] = [h2, w];
          h2 = -h2;
          x -= w;
          y2 -= h2;
          rotateAngle = -90;
          break;
      }
    } else {
      h2 = -h2;
      y2 -= h2;
      rotateAngle = 0;
    }
    if (options.link != null) {
      this.link(x, y2, w, h2, options.link);
    }
    if (options.goTo != null) {
      this.goTo(x, y2, w, h2, options.goTo);
    }
    if (options.destination != null) {
      this.addNamedDestination(options.destination, "XYZ", x, y2, null);
    }
    if (this.y === y2) {
      this.y += h2;
    }
    this.save();
    if (rotateAngle) {
      this.rotate(rotateAngle, {
        origin: [originX, originY]
      });
    }
    this.transform(w, 0, 0, h2, x, y2);
    this.addContent(`/${image.label} Do`);
    this.restore();
    return this;
  },
  openImage(src) {
    let image;
    if (typeof src === "string") {
      image = this._imageRegistry[src];
    }
    if (!image) {
      image = PDFImage.open(src, `I${++this._imageCount}`);
      if (typeof src === "string") {
        this._imageRegistry[src] = image;
      }
    }
    return image;
  }
};
var AnnotationsMixin = {
  annotate(x, y2, w, h2, options) {
    options.Type = "Annot";
    options.Rect = this._convertRect(x, y2, w, h2);
    options.Border = [0, 0, 0];
    if (options.Subtype === "Link" && typeof options.F === "undefined") {
      options.F = 1 << 2;
    }
    if (options.Subtype !== "Link") {
      if (options.C == null) {
        options.C = this._normalizeColor(options.color || [0, 0, 0]);
      }
    }
    delete options.color;
    if (typeof options.Dest === "string") {
      options.Dest = new String(options.Dest);
    }
    for (let key in options) {
      const val = options[key];
      options[key[0].toUpperCase() + key.slice(1)] = val;
    }
    const ref = this.ref(options);
    this.page.annotations.push(ref);
    ref.end();
    return this;
  },
  note(x, y2, w, h2, contents, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Text";
    options.Contents = new String(contents);
    if (options.Name == null) {
      options.Name = "Comment";
    }
    if (options.color == null) {
      options.color = [243, 223, 92];
    }
    return this.annotate(x, y2, w, h2, options);
  },
  goTo(x, y2, w, h2, name, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Link";
    options.A = this.ref({
      S: "GoTo",
      D: new String(name)
    });
    options.A.end();
    return this.annotate(x, y2, w, h2, options);
  },
  link(x, y2, w, h2, url, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Link";
    if (typeof url === "number") {
      const pages = this._root.data.Pages.data;
      if (url >= 0 && url < pages.Kids.length) {
        options.A = this.ref({
          S: "GoTo",
          D: [pages.Kids[url], "XYZ", null, null, null]
        });
        options.A.end();
      } else {
        throw new Error(`The document has no page ${url}`);
      }
    } else {
      options.A = this.ref({
        S: "URI",
        URI: new String(url)
      });
      options.A.end();
    }
    return this.annotate(x, y2, w, h2, options);
  },
  _markup(x, y2, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    const [x1, y1, x2, y22] = this._convertRect(x, y2, w, h2);
    options.QuadPoints = [x1, y22, x2, y22, x1, y1, x2, y1];
    options.Contents = new String();
    return this.annotate(x, y2, w, h2, options);
  },
  highlight(x, y2, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Highlight";
    if (options.color == null) {
      options.color = [241, 238, 148];
    }
    return this._markup(x, y2, w, h2, options);
  },
  underline(x, y2, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Underline";
    return this._markup(x, y2, w, h2, options);
  },
  strike(x, y2, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "StrikeOut";
    return this._markup(x, y2, w, h2, options);
  },
  lineAnnotation(x1, y1, x2, y2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Line";
    options.Contents = new String();
    options.L = [x1, this.page.height - y1, x2, this.page.height - y2];
    return this.annotate(x1, y1, x2, y2, options);
  },
  rectAnnotation(x, y2, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Square";
    options.Contents = new String();
    return this.annotate(x, y2, w, h2, options);
  },
  ellipseAnnotation(x, y2, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Circle";
    options.Contents = new String();
    return this.annotate(x, y2, w, h2, options);
  },
  textAnnotation(x, y2, w, h2, text, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "FreeText";
    options.Contents = new String(text);
    options.DA = new String();
    return this.annotate(x, y2, w, h2, options);
  },
  fileAnnotation(x, y2, w, h2, file, options) {
    if (file === void 0) {
      file = {};
    }
    if (options === void 0) {
      options = {};
    }
    const filespec = this.file(file.src, Object.assign({
      hidden: true
    }, file));
    options.Subtype = "FileAttachment";
    options.FS = filespec;
    if (options.Contents) {
      options.Contents = new String(options.Contents);
    } else if (filespec.data.Desc) {
      options.Contents = filespec.data.Desc;
    }
    return this.annotate(x, y2, w, h2, options);
  },
  _convertRect(x1, y1, w, h2) {
    let y2 = y1;
    y1 += h2;
    let x2 = x1 + w;
    const [m0, m1, m2, m3, m4, m5] = this._ctm;
    x1 = m0 * x1 + m2 * y1 + m4;
    y1 = m1 * x1 + m3 * y1 + m5;
    x2 = m0 * x2 + m2 * y2 + m4;
    y2 = m1 * x2 + m3 * y2 + m5;
    return [x1, y1, x2, y2];
  }
};
var PDFOutline = class _PDFOutline {
  constructor(document2, parent, title3, dest, options) {
    if (options === void 0) {
      options = {
        expanded: false
      };
    }
    this.document = document2;
    this.options = options;
    this.outlineData = {};
    if (dest !== null) {
      this.outlineData["Dest"] = [dest.dictionary, "Fit"];
    }
    if (parent !== null) {
      this.outlineData["Parent"] = parent;
    }
    if (title3 !== null) {
      this.outlineData["Title"] = new String(title3);
    }
    this.dictionary = this.document.ref(this.outlineData);
    this.children = [];
  }
  addItem(title3, options) {
    if (options === void 0) {
      options = {
        expanded: false
      };
    }
    const result = new _PDFOutline(this.document, this.dictionary, title3, this.document.page, options);
    this.children.push(result);
    return result;
  }
  endOutline() {
    if (this.children.length > 0) {
      if (this.options.expanded) {
        this.outlineData.Count = this.children.length;
      }
      const first = this.children[0], last2 = this.children[this.children.length - 1];
      this.outlineData.First = first.dictionary;
      this.outlineData.Last = last2.dictionary;
      for (let i3 = 0, len = this.children.length; i3 < len; i3++) {
        const child = this.children[i3];
        if (i3 > 0) {
          child.outlineData.Prev = this.children[i3 - 1].dictionary;
        }
        if (i3 < this.children.length - 1) {
          child.outlineData.Next = this.children[i3 + 1].dictionary;
        }
        child.endOutline();
      }
    }
    return this.dictionary.end();
  }
};
var OutlineMixin = {
  initOutline() {
    return this.outline = new PDFOutline(this, null, null, null);
  },
  endOutline() {
    this.outline.endOutline();
    if (this.outline.children.length > 0) {
      this._root.data.Outlines = this.outline.dictionary;
      return this._root.data.PageMode = "UseOutlines";
    }
  }
};
var PDFStructureContent = class {
  constructor(pageRef, mcid) {
    this.refs = [{
      pageRef,
      mcid
    }];
  }
  push(structContent) {
    structContent.refs.forEach((ref) => this.refs.push(ref));
  }
};
var PDFStructureElement = class _PDFStructureElement {
  constructor(document2, type, options, children) {
    if (options === void 0) {
      options = {};
    }
    if (children === void 0) {
      children = null;
    }
    this.document = document2;
    this._attached = false;
    this._ended = false;
    this._flushed = false;
    this.dictionary = document2.ref({
      // Type: "StructElem",
      S: type
    });
    const data2 = this.dictionary.data;
    if (Array.isArray(options) || this._isValidChild(options)) {
      children = options;
      options = {};
    }
    if (typeof options.title !== "undefined") {
      data2.T = new String(options.title);
    }
    if (typeof options.lang !== "undefined") {
      data2.Lang = new String(options.lang);
    }
    if (typeof options.alt !== "undefined") {
      data2.Alt = new String(options.alt);
    }
    if (typeof options.expanded !== "undefined") {
      data2.E = new String(options.expanded);
    }
    if (typeof options.actual !== "undefined") {
      data2.ActualText = new String(options.actual);
    }
    this._children = [];
    if (children) {
      if (!Array.isArray(children)) {
        children = [children];
      }
      children.forEach((child) => this.add(child));
      this.end();
    }
  }
  add(child) {
    if (this._ended) {
      throw new Error(`Cannot add child to already-ended structure element`);
    }
    if (!this._isValidChild(child)) {
      throw new Error(`Invalid structure element child`);
    }
    if (child instanceof _PDFStructureElement) {
      child.setParent(this.dictionary);
      if (this._attached) {
        child.setAttached();
      }
    }
    if (child instanceof PDFStructureContent) {
      this._addContentToParentTree(child);
    }
    if (typeof child === "function" && this._attached) {
      child = this._contentForClosure(child);
    }
    this._children.push(child);
    return this;
  }
  _addContentToParentTree(content) {
    content.refs.forEach((_ref) => {
      let {
        pageRef,
        mcid
      } = _ref;
      const pageStructParents = this.document.getStructParentTree().get(pageRef.data.StructParents);
      pageStructParents[mcid] = this.dictionary;
    });
  }
  setParent(parentRef) {
    if (this.dictionary.data.P) {
      throw new Error(`Structure element added to more than one parent`);
    }
    this.dictionary.data.P = parentRef;
    this._flush();
  }
  setAttached() {
    if (this._attached) {
      return;
    }
    this._children.forEach((child, index3) => {
      if (child instanceof _PDFStructureElement) {
        child.setAttached();
      }
      if (typeof child === "function") {
        this._children[index3] = this._contentForClosure(child);
      }
    });
    this._attached = true;
    this._flush();
  }
  end() {
    if (this._ended) {
      return;
    }
    this._children.filter((child) => child instanceof _PDFStructureElement).forEach((child) => child.end());
    this._ended = true;
    this._flush();
  }
  _isValidChild(child) {
    return child instanceof _PDFStructureElement || child instanceof PDFStructureContent || typeof child === "function";
  }
  _contentForClosure(closure) {
    const content = this.document.markStructureContent(this.dictionary.data.S);
    closure();
    this.document.endMarkedContent();
    this._addContentToParentTree(content);
    return content;
  }
  _isFlushable() {
    if (!this.dictionary.data.P || !this._ended) {
      return false;
    }
    return this._children.every((child) => {
      if (typeof child === "function") {
        return false;
      }
      if (child instanceof _PDFStructureElement) {
        return child._isFlushable();
      }
      return true;
    });
  }
  _flush() {
    if (this._flushed || !this._isFlushable()) {
      return;
    }
    this.dictionary.data.K = [];
    this._children.forEach((child) => this._flushChild(child));
    this.dictionary.end();
    this._children = [];
    this.dictionary.data.K = null;
    this._flushed = true;
  }
  _flushChild(child) {
    if (child instanceof _PDFStructureElement) {
      this.dictionary.data.K.push(child.dictionary);
    }
    if (child instanceof PDFStructureContent) {
      child.refs.forEach((_ref2) => {
        let {
          pageRef,
          mcid
        } = _ref2;
        if (!this.dictionary.data.Pg) {
          this.dictionary.data.Pg = pageRef;
        }
        if (this.dictionary.data.Pg === pageRef) {
          this.dictionary.data.K.push(mcid);
        } else {
          this.dictionary.data.K.push({
            Type: "MCR",
            Pg: pageRef,
            MCID: mcid
          });
        }
      });
    }
  }
};
var PDFNumberTree = class extends PDFTree {
  _compareKeys(a3, b2) {
    return parseInt(a3) - parseInt(b2);
  }
  _keysName() {
    return "Nums";
  }
  _dataForKey(k2) {
    return parseInt(k2);
  }
};
var MarkingsMixin = {
  initMarkings(options) {
    this.structChildren = [];
    if (options.tagged) {
      this.getMarkInfoDictionary().data.Marked = true;
      this.getStructTreeRoot();
    }
  },
  markContent(tag, options) {
    if (options === void 0) {
      options = null;
    }
    if (tag === "Artifact" || options && options.mcid) {
      let toClose = 0;
      this.page.markings.forEach((marking) => {
        if (toClose || marking.structContent || marking.tag === "Artifact") {
          toClose++;
        }
      });
      while (toClose--) {
        this.endMarkedContent();
      }
    }
    if (!options) {
      this.page.markings.push({
        tag
      });
      this.addContent(`/${tag} BMC`);
      return this;
    }
    this.page.markings.push({
      tag,
      options
    });
    const dictionary = {};
    if (typeof options.mcid !== "undefined") {
      dictionary.MCID = options.mcid;
    }
    if (tag === "Artifact") {
      if (typeof options.type === "string") {
        dictionary.Type = options.type;
      }
      if (Array.isArray(options.bbox)) {
        dictionary.BBox = [options.bbox[0], this.page.height - options.bbox[3], options.bbox[2], this.page.height - options.bbox[1]];
      }
      if (Array.isArray(options.attached) && options.attached.every((val) => typeof val === "string")) {
        dictionary.Attached = options.attached;
      }
    }
    if (tag === "Span") {
      if (options.lang) {
        dictionary.Lang = new String(options.lang);
      }
      if (options.alt) {
        dictionary.Alt = new String(options.alt);
      }
      if (options.expanded) {
        dictionary.E = new String(options.expanded);
      }
      if (options.actual) {
        dictionary.ActualText = new String(options.actual);
      }
    }
    this.addContent(`/${tag} ${PDFObject.convert(dictionary)} BDC`);
    return this;
  },
  markStructureContent(tag, options) {
    if (options === void 0) {
      options = {};
    }
    const pageStructParents = this.getStructParentTree().get(this.page.structParentTreeKey);
    const mcid = pageStructParents.length;
    pageStructParents.push(null);
    this.markContent(tag, {
      ...options,
      mcid
    });
    const structContent = new PDFStructureContent(this.page.dictionary, mcid);
    this.page.markings.slice(-1)[0].structContent = structContent;
    return structContent;
  },
  endMarkedContent() {
    this.page.markings.pop();
    this.addContent("EMC");
    return this;
  },
  struct(type, options, children) {
    if (options === void 0) {
      options = {};
    }
    if (children === void 0) {
      children = null;
    }
    return new PDFStructureElement(this, type, options, children);
  },
  addStructure(structElem) {
    const structTreeRoot = this.getStructTreeRoot();
    structElem.setParent(structTreeRoot);
    structElem.setAttached();
    this.structChildren.push(structElem);
    if (!structTreeRoot.data.K) {
      structTreeRoot.data.K = [];
    }
    structTreeRoot.data.K.push(structElem.dictionary);
    return this;
  },
  initPageMarkings(pageMarkings) {
    pageMarkings.forEach((marking) => {
      if (marking.structContent) {
        const structContent = marking.structContent;
        const newStructContent = this.markStructureContent(marking.tag, marking.options);
        structContent.push(newStructContent);
        this.page.markings.slice(-1)[0].structContent = structContent;
      } else {
        this.markContent(marking.tag, marking.options);
      }
    });
  },
  endPageMarkings(page) {
    const pageMarkings = page.markings;
    pageMarkings.forEach(() => page.write("EMC"));
    page.markings = [];
    return pageMarkings;
  },
  getMarkInfoDictionary() {
    if (!this._root.data.MarkInfo) {
      this._root.data.MarkInfo = this.ref({});
    }
    return this._root.data.MarkInfo;
  },
  hasMarkInfoDictionary() {
    return !!this._root.data.MarkInfo;
  },
  getStructTreeRoot() {
    if (!this._root.data.StructTreeRoot) {
      this._root.data.StructTreeRoot = this.ref({
        Type: "StructTreeRoot",
        ParentTree: new PDFNumberTree(),
        ParentTreeNextKey: 0
      });
    }
    return this._root.data.StructTreeRoot;
  },
  getStructParentTree() {
    return this.getStructTreeRoot().data.ParentTree;
  },
  createStructParentTreeNextKey() {
    this.getMarkInfoDictionary();
    const structTreeRoot = this.getStructTreeRoot();
    const key = structTreeRoot.data.ParentTreeNextKey++;
    structTreeRoot.data.ParentTree.add(key, []);
    return key;
  },
  endMarkings() {
    const structTreeRoot = this._root.data.StructTreeRoot;
    if (structTreeRoot) {
      structTreeRoot.end();
      this.structChildren.forEach((structElem) => structElem.end());
    }
    if (this._root.data.MarkInfo) {
      this._root.data.MarkInfo.end();
    }
  }
};
var FIELD_FLAGS = {
  readOnly: 1,
  required: 2,
  noExport: 4,
  multiline: 4096,
  password: 8192,
  toggleToOffButton: 16384,
  radioButton: 32768,
  pushButton: 65536,
  combo: 131072,
  edit: 262144,
  sort: 524288,
  multiSelect: 2097152,
  noSpell: 4194304
};
var FIELD_JUSTIFY = {
  left: 0,
  center: 1,
  right: 2
};
var VALUE_MAP = {
  value: "V",
  defaultValue: "DV"
};
var FORMAT_SPECIAL = {
  zip: "0",
  zipPlus4: "1",
  zip4: "1",
  phone: "2",
  ssn: "3"
};
var FORMAT_DEFAULT = {
  number: {
    nDec: 0,
    sepComma: false,
    negStyle: "MinusBlack",
    currency: "",
    currencyPrepend: true
  },
  percent: {
    nDec: 0,
    sepComma: false
  }
};
var AcroFormMixin = {
  /**
   * Must call if adding AcroForms to a document. Must also call font() before
   * this method to set the default font.
   */
  initForm() {
    if (!this._font) {
      throw new Error("Must set a font before calling initForm method");
    }
    this._acroform = {
      fonts: {},
      defaultFont: this._font.name
    };
    this._acroform.fonts[this._font.id] = this._font.ref();
    let data2 = {
      Fields: [],
      NeedAppearances: true,
      DA: new String(`/${this._font.id} 0 Tf 0 g`),
      DR: {
        Font: {}
      }
    };
    data2.DR.Font[this._font.id] = this._font.ref();
    const AcroForm = this.ref(data2);
    this._root.data.AcroForm = AcroForm;
    return this;
  },
  /**
   * Called automatically by document.js
   */
  endAcroForm() {
    if (this._root.data.AcroForm) {
      if (!Object.keys(this._acroform.fonts).length && !this._acroform.defaultFont) {
        throw new Error("No fonts specified for PDF form");
      }
      let fontDict = this._root.data.AcroForm.data.DR.Font;
      Object.keys(this._acroform.fonts).forEach((name) => {
        fontDict[name] = this._acroform.fonts[name];
      });
      this._root.data.AcroForm.data.Fields.forEach((fieldRef) => {
        this._endChild(fieldRef);
      });
      this._root.data.AcroForm.end();
    }
    return this;
  },
  _endChild(ref) {
    if (Array.isArray(ref.data.Kids)) {
      ref.data.Kids.forEach((childRef) => {
        this._endChild(childRef);
      });
      ref.end();
    }
    return this;
  },
  /**
   * Creates and adds a form field to the document. Form fields are intermediate
   * nodes in a PDF form that are used to specify form name heirarchy and form
   * value defaults.
   * @param {string} name - field name (T attribute in field dictionary)
   * @param {object} options  - other attributes to include in field dictionary
   */
  formField(name, options) {
    if (options === void 0) {
      options = {};
    }
    let fieldDict = this._fieldDict(name, null, options);
    let fieldRef = this.ref(fieldDict);
    this._addToParent(fieldRef);
    return fieldRef;
  },
  /**
   * Creates and adds a Form Annotation to the document. Form annotations are
   * called Widget annotations internally within a PDF file.
   * @param {string} name - form field name (T attribute of widget annotation
   * dictionary)
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @param {object} options
   */
  formAnnotation(name, type, x, y2, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    let fieldDict = this._fieldDict(name, type, options);
    fieldDict.Subtype = "Widget";
    if (fieldDict.F === void 0) {
      fieldDict.F = 4;
    }
    this.annotate(x, y2, w, h2, fieldDict);
    let annotRef = this.page.annotations[this.page.annotations.length - 1];
    return this._addToParent(annotRef);
  },
  formText(name, x, y2, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "text", x, y2, w, h2, options);
  },
  formPushButton(name, x, y2, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "pushButton", x, y2, w, h2, options);
  },
  formCombo(name, x, y2, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "combo", x, y2, w, h2, options);
  },
  formList(name, x, y2, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "list", x, y2, w, h2, options);
  },
  formRadioButton(name, x, y2, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "radioButton", x, y2, w, h2, options);
  },
  formCheckbox(name, x, y2, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "checkbox", x, y2, w, h2, options);
  },
  _addToParent(fieldRef) {
    let parent = fieldRef.data.Parent;
    if (parent) {
      if (!parent.data.Kids) {
        parent.data.Kids = [];
      }
      parent.data.Kids.push(fieldRef);
    } else {
      this._root.data.AcroForm.data.Fields.push(fieldRef);
    }
    return this;
  },
  _fieldDict(name, type, options) {
    if (options === void 0) {
      options = {};
    }
    if (!this._acroform) {
      throw new Error("Call document.initForm() method before adding form elements to document");
    }
    let opts2 = Object.assign({}, options);
    if (type !== null) {
      opts2 = this._resolveType(type, options);
    }
    opts2 = this._resolveFlags(opts2);
    opts2 = this._resolveJustify(opts2);
    opts2 = this._resolveFont(opts2);
    opts2 = this._resolveStrings(opts2);
    opts2 = this._resolveColors(opts2);
    opts2 = this._resolveFormat(opts2);
    opts2.T = new String(name);
    if (opts2.parent) {
      opts2.Parent = opts2.parent;
      delete opts2.parent;
    }
    return opts2;
  },
  _resolveType(type, opts2) {
    if (type === "text") {
      opts2.FT = "Tx";
    } else if (type === "pushButton") {
      opts2.FT = "Btn";
      opts2.pushButton = true;
    } else if (type === "radioButton") {
      opts2.FT = "Btn";
      opts2.radioButton = true;
    } else if (type === "checkbox") {
      opts2.FT = "Btn";
    } else if (type === "combo") {
      opts2.FT = "Ch";
      opts2.combo = true;
    } else if (type === "list") {
      opts2.FT = "Ch";
    } else {
      throw new Error(`Invalid form annotation type '${type}'`);
    }
    return opts2;
  },
  _resolveFormat(opts2) {
    const f2 = opts2.format;
    if (f2 && f2.type) {
      let fnKeystroke;
      let fnFormat;
      let params = "";
      if (FORMAT_SPECIAL[f2.type] !== void 0) {
        fnKeystroke = `AFSpecial_Keystroke`;
        fnFormat = `AFSpecial_Format`;
        params = FORMAT_SPECIAL[f2.type];
      } else {
        let format3 = f2.type.charAt(0).toUpperCase() + f2.type.slice(1);
        fnKeystroke = `AF${format3}_Keystroke`;
        fnFormat = `AF${format3}_Format`;
        if (f2.type === "date") {
          fnKeystroke += "Ex";
          params = String(f2.param);
        } else if (f2.type === "time") {
          params = String(f2.param);
        } else if (f2.type === "number") {
          let p2 = Object.assign({}, FORMAT_DEFAULT.number, f2);
          params = String([String(p2.nDec), p2.sepComma ? "0" : "1", '"' + p2.negStyle + '"', "null", '"' + p2.currency + '"', String(p2.currencyPrepend)].join(","));
        } else if (f2.type === "percent") {
          let p2 = Object.assign({}, FORMAT_DEFAULT.percent, f2);
          params = String([String(p2.nDec), p2.sepComma ? "0" : "1"].join(","));
        }
      }
      opts2.AA = opts2.AA ? opts2.AA : {};
      opts2.AA.K = {
        S: "JavaScript",
        JS: new String(`${fnKeystroke}(${params});`)
      };
      opts2.AA.F = {
        S: "JavaScript",
        JS: new String(`${fnFormat}(${params});`)
      };
    }
    delete opts2.format;
    return opts2;
  },
  _resolveColors(opts2) {
    let color = this._normalizeColor(opts2.backgroundColor);
    if (color) {
      if (!opts2.MK) {
        opts2.MK = {};
      }
      opts2.MK.BG = color;
    }
    color = this._normalizeColor(opts2.borderColor);
    if (color) {
      if (!opts2.MK) {
        opts2.MK = {};
      }
      opts2.MK.BC = color;
    }
    delete opts2.backgroundColor;
    delete opts2.borderColor;
    return opts2;
  },
  _resolveFlags(options) {
    let result = 0;
    Object.keys(options).forEach((key) => {
      if (FIELD_FLAGS[key]) {
        if (options[key]) {
          result |= FIELD_FLAGS[key];
        }
        delete options[key];
      }
    });
    if (result !== 0) {
      options.Ff = options.Ff ? options.Ff : 0;
      options.Ff |= result;
    }
    return options;
  },
  _resolveJustify(options) {
    let result = 0;
    if (options.align !== void 0) {
      if (typeof FIELD_JUSTIFY[options.align] === "number") {
        result = FIELD_JUSTIFY[options.align];
      }
      delete options.align;
    }
    if (result !== 0) {
      options.Q = result;
    }
    return options;
  },
  _resolveFont(options) {
    if (this._acroform.fonts[this._font.id] == null) {
      this._acroform.fonts[this._font.id] = this._font.ref();
    }
    if (this._acroform.defaultFont !== this._font.name) {
      options.DR = {
        Font: {}
      };
      const fontSize = options.fontSize || 0;
      options.DR.Font[this._font.id] = this._font.ref();
      options.DA = new String(`/${this._font.id} ${fontSize} Tf 0 g`);
    }
    return options;
  },
  _resolveStrings(options) {
    let select = [];
    function appendChoices(a3) {
      if (Array.isArray(a3)) {
        for (let idx = 0; idx < a3.length; idx++) {
          if (typeof a3[idx] === "string") {
            select.push(new String(a3[idx]));
          } else {
            select.push(a3[idx]);
          }
        }
      }
    }
    appendChoices(options.Opt);
    if (options.select) {
      appendChoices(options.select);
      delete options.select;
    }
    if (select.length) {
      options.Opt = select;
    }
    Object.keys(VALUE_MAP).forEach((key) => {
      if (options[key] !== void 0) {
        options[VALUE_MAP[key]] = options[key];
        delete options[key];
      }
    });
    ["V", "DV"].forEach((key) => {
      if (typeof options[key] === "string") {
        options[key] = new String(options[key]);
      }
    });
    if (options.MK && options.MK.CA) {
      options.MK.CA = new String(options.MK.CA);
    }
    if (options.label) {
      options.MK = options.MK ? options.MK : {};
      options.MK.CA = new String(options.label);
      delete options.label;
    }
    return options;
  }
};
var AttachmentsMixin = {
  /**
   * Embed contents of `src` in PDF
   * @param {Buffer | ArrayBuffer | string} src input Buffer, ArrayBuffer, base64 encoded string or path to file
   * @param {object} options
   *  * options.name: filename to be shown in PDF, will use `src` if none set
   *  * options.type: filetype to be shown in PDF
   *  * options.description: description to be shown in PDF
   *  * options.hidden: if true, do not add attachment to EmbeddedFiles dictionary. Useful for file attachment annotations
   *  * options.creationDate: override creation date
   *  * options.modifiedDate: override modified date
   *  * options.relationship: Relationship between the PDF document and its attached file. Can be 'Alternative', 'Data', 'Source', 'Supplement' or 'Unspecified'.
   * @returns filespec reference
   */
  file(src, options) {
    if (options === void 0) {
      options = {};
    }
    options.name = options.name || src;
    options.relationship = options.relationship || "Unspecified";
    const refBody = {
      Type: "EmbeddedFile",
      Params: {}
    };
    let data2;
    if (!src) {
      throw new Error("No src specified");
    }
    if (Buffer$2.isBuffer(src)) {
      data2 = src;
    } else if (src instanceof ArrayBuffer) {
      data2 = Buffer$2.from(new Uint8Array(src));
    } else {
      let match;
      if (match = /^data:(.*?);base64,(.*)$/.exec(src)) {
        if (match[1]) {
          refBody.Subtype = match[1].replace("/", "#2F");
        }
        data2 = Buffer$2.from(match[2], "base64");
      } else {
        data2 = fs.readFileSync(src);
        if (!data2) {
          throw new Error(`Could not read contents of file at filepath ${src}`);
        }
        const {
          birthtime,
          ctime
        } = fs.statSync(src);
        refBody.Params.CreationDate = birthtime;
        refBody.Params.ModDate = ctime;
      }
    }
    if (options.creationDate instanceof Date) {
      refBody.Params.CreationDate = options.creationDate;
    }
    if (options.modifiedDate instanceof Date) {
      refBody.Params.ModDate = options.modifiedDate;
    }
    if (options.type) {
      refBody.Subtype = options.type.replace("/", "#2F");
    }
    const checksum = import_crypto_js.default.MD5(import_crypto_js.default.lib.WordArray.create(new Uint8Array(data2)));
    refBody.Params.CheckSum = new String(checksum);
    refBody.Params.Size = data2.byteLength;
    let ref;
    if (!this._fileRegistry) this._fileRegistry = {};
    let file = this._fileRegistry[options.name];
    if (file && isEqual(refBody, file)) {
      ref = file.ref;
    } else {
      ref = this.ref(refBody);
      ref.end(data2);
      this._fileRegistry[options.name] = {
        ...refBody,
        ref
      };
    }
    const fileSpecBody = {
      Type: "Filespec",
      AFRelationship: options.relationship,
      F: new String(options.name),
      EF: {
        F: ref
      },
      UF: new String(options.name)
    };
    if (options.description) {
      fileSpecBody.Desc = new String(options.description);
    }
    const filespec = this.ref(fileSpecBody);
    filespec.end();
    if (!options.hidden) {
      this.addNamedEmbeddedFile(options.name, filespec);
    }
    if (this._root.data.AF) {
      this._root.data.AF.push(filespec);
    } else {
      this._root.data.AF = [filespec];
    }
    return filespec;
  }
};
function isEqual(a3, b2) {
  return a3.Subtype === b2.Subtype && a3.Params.CheckSum.toString() === b2.Params.CheckSum.toString() && a3.Params.Size === b2.Params.Size && a3.Params.CreationDate.getTime() === b2.Params.CreationDate.getTime() && (a3.Params.ModDate === void 0 && b2.Params.ModDate === void 0 || a3.Params.ModDate.getTime() === b2.Params.ModDate.getTime());
}
var __dirname = "/home/runner/work/react-pdf/react-pdf/packages/pdfkit/src/mixins";
var PDFA = {
  initPDFA(pSubset) {
    if (pSubset.charAt(pSubset.length - 3) === "-") {
      this.subset_conformance = pSubset.charAt(pSubset.length - 1).toUpperCase();
      this.subset = parseInt(pSubset.charAt(pSubset.length - 2));
    } else {
      this.subset_conformance = "B";
      this.subset = parseInt(pSubset.charAt(pSubset.length - 1));
    }
  },
  endSubset() {
    this._addPdfaMetadata();
    this._addColorOutputIntent();
  },
  _addColorOutputIntent() {
    const iccProfile = fs.readFileSync(`${__dirname}/data/sRGB_IEC61966_2_1.icc`);
    const colorProfileRef = this.ref({
      Length: iccProfile.length,
      N: 3
    });
    colorProfileRef.write(iccProfile);
    colorProfileRef.end();
    const intentRef = this.ref({
      Type: "OutputIntent",
      S: "GTS_PDFA1",
      Info: new String("sRGB IEC61966-2.1"),
      OutputConditionIdentifier: new String("sRGB IEC61966-2.1"),
      DestOutputProfile: colorProfileRef
    });
    intentRef.end();
    this._root.data.OutputIntents = [intentRef];
  },
  _getPdfaid() {
    return `
        <rdf:Description xmlns:pdfaid="http://www.aiim.org/pdfa/ns/id/" rdf:about="">
            <pdfaid:part>${this.subset}</pdfaid:part>
            <pdfaid:conformance>${this.subset_conformance}</pdfaid:conformance>
        </rdf:Description>
        `;
  },
  _addPdfaMetadata() {
    this.appendXML(this._getPdfaid());
  }
};
var PDFUA = {
  initPDFUA() {
    this.subset = 1;
  },
  endSubset() {
    this._addPdfuaMetadata();
  },
  _addPdfuaMetadata() {
    this.appendXML(this._getPdfuaid());
  },
  _getPdfuaid() {
    return `
        <rdf:Description xmlns:pdfuaid="http://www.aiim.org/pdfua/ns/id/" rdf:about="">
            <pdfuaid:part>${this.subset}</pdfuaid:part>
        </rdf:Description>
        `;
  }
};
var SubsetMixin = {
  _importSubset(subset) {
    Object.assign(this, subset);
  },
  initSubset(options) {
    switch (options.subset) {
      case "PDF/A-1":
      case "PDF/A-1a":
      case "PDF/A-1b":
      case "PDF/A-2":
      case "PDF/A-2a":
      case "PDF/A-2b":
      case "PDF/A-3":
      case "PDF/A-3a":
      case "PDF/A-3b":
        this._importSubset(PDFA);
        this.initPDFA(options.subset);
        break;
      case "PDF/UA":
        this._importSubset(PDFUA);
        this.initPDFUA();
        break;
    }
  }
};
var PDFMetadata = class {
  constructor() {
    this._metadata = `
        <?xpacket begin="\uFEFF" id="W5M0MpCehiHzreSzNTczkc9d"?>
            <x:xmpmeta xmlns:x="adobe:ns:meta/">
                <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
        `;
  }
  _closeTags() {
    this._metadata = this._metadata.concat(`
                </rdf:RDF>
            </x:xmpmeta>
        <?xpacket end="w"?>
        `);
  }
  append(xml, newline) {
    if (newline === void 0) {
      newline = true;
    }
    this._metadata = this._metadata.concat(xml);
    if (newline) this._metadata = this._metadata.concat("\n");
  }
  getXML() {
    return this._metadata;
  }
  getLength() {
    return this._metadata.length;
  }
  end() {
    this._closeTags();
    this._metadata = this._metadata.trim();
  }
};
var MetadataMixin = {
  initMetadata() {
    this.metadata = new PDFMetadata();
  },
  appendXML(xml, newline) {
    if (newline === void 0) {
      newline = true;
    }
    this.metadata.append(xml, newline);
  },
  _addInfo() {
    this.appendXML(`
        <rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/">
            <xmp:CreateDate>${this.info.CreationDate.toISOString().split(".")[0] + "Z"}</xmp:CreateDate>
            <xmp:CreatorTool>${this.info.Creator}</xmp:CreatorTool>
        </rdf:Description>
        `);
    if (this.info.Title || this.info.Author || this.info.Subject) {
      this.appendXML(`
            <rdf:Description rdf:about="" xmlns:dc="http://purl.org/dc/elements/1.1/">
            `);
      if (this.info.Title) {
        this.appendXML(`
                <dc:title>
                    <rdf:Alt>
                        <rdf:li xml:lang="x-default">${this.info.Title}</rdf:li>
                    </rdf:Alt>
                </dc:title>
                `);
      }
      if (this.info.Author) {
        this.appendXML(`
                <dc:creator>
                    <rdf:Seq>
                        <rdf:li>${this.info.Author}</rdf:li>
                    </rdf:Seq>
                </dc:creator>
                `);
      }
      if (this.info.Subject) {
        this.appendXML(`
                <dc:description>
                    <rdf:Alt>
                        <rdf:li xml:lang="x-default">${this.info.Subject}</rdf:li>
                    </rdf:Alt>
                </dc:description>
                `);
      }
      this.appendXML(`
            </rdf:Description>
            `);
    }
    this.appendXML(`
        <rdf:Description rdf:about="" xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
            <pdf:Producer>${this.info.Creator}</pdf:Producer>`, false);
    if (this.info.Keywords) {
      this.appendXML(`
            <pdf:Keywords>${this.info.Keywords}</pdf:Keywords>`, false);
    }
    this.appendXML(`
        </rdf:Description>
        `);
  },
  endMetadata() {
    this._addInfo();
    this.metadata.end();
    if (this.version != 1.3) {
      this.metadataRef = this.ref({
        length: this.metadata.getLength(),
        Type: "Metadata",
        Subtype: "XML"
      });
      this.metadataRef.compress = false;
      this.metadataRef.write(Buffer$2.from(this.metadata.getXML(), "utf-8"));
      this.metadataRef.end();
      this._root.data.Metadata = this.metadataRef;
    }
  }
};
var PDFDocument = class extends stream.Readable {
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    super(options);
    this.options = options;
    switch (options.pdfVersion) {
      case "1.4":
        this.version = 1.4;
        break;
      case "1.5":
        this.version = 1.5;
        break;
      case "1.6":
        this.version = 1.6;
        break;
      case "1.7":
      case "1.7ext3":
        this.version = 1.7;
        break;
      default:
        this.version = 1.3;
        break;
    }
    this.compress = this.options.compress != null ? this.options.compress : true;
    this._pageBuffer = [];
    this._pageBufferStart = 0;
    this._offsets = [];
    this._waiting = 0;
    this._ended = false;
    this._offset = 0;
    const Pages = this.ref({
      Type: "Pages",
      Count: 0,
      Kids: []
    });
    const Names = this.ref({
      Dests: new PDFNameTree()
    });
    this._root = this.ref({
      Type: "Catalog",
      Pages,
      Names
    });
    if (this.options.lang) {
      this._root.data.Lang = new String(this.options.lang);
    }
    this.page = null;
    this.initMetadata();
    this.initColor();
    this.initVector();
    this.initFonts(options.font);
    this.initText();
    this.initImages();
    this.initOutline();
    this.initMarkings(options);
    this.initSubset(options);
    this.info = {
      Producer: "PDFKit",
      Creator: "PDFKit",
      CreationDate: /* @__PURE__ */ new Date()
    };
    if (this.options.info) {
      for (let key in this.options.info) {
        const val = this.options.info[key];
        this.info[key] = val;
      }
    }
    if (this.options.displayTitle) {
      this._root.data.ViewerPreferences = this.ref({
        DisplayDocTitle: true
      });
    }
    this._id = PDFSecurity.generateFileID(this.info);
    this._write(`%PDF-${this.version}`);
    this._write("%");
    if (this.options.autoFirstPage !== false) {
      this.addPage();
    }
  }
  addPage(options) {
    if (options == null) {
      ({
        options
      } = this);
    }
    if (!this.options.bufferPages) {
      this.flushPages();
    }
    this.page = new PDFPage(this, options);
    this._pageBuffer.push(this.page);
    const pages = this._root.data.Pages.data;
    pages.Kids.push(this.page.dictionary);
    pages.Count++;
    this.x = this.page.margins.left;
    this.y = this.page.margins.top;
    this._ctm = [1, 0, 0, 1, 0, 0];
    this.transform(1, 0, 0, -1, 0, this.page.height);
    this.emit("pageAdded");
    return this;
  }
  continueOnNewPage(options) {
    const pageMarkings = this.endPageMarkings(this.page);
    this.addPage(options ?? this.page._options);
    this.initPageMarkings(pageMarkings);
    return this;
  }
  bufferedPageRange() {
    return {
      start: this._pageBufferStart,
      count: this._pageBuffer.length
    };
  }
  switchToPage(n4) {
    let page;
    if (!(page = this._pageBuffer[n4 - this._pageBufferStart])) {
      throw new Error(`switchToPage(${n4}) out of bounds, current buffer covers pages ${this._pageBufferStart} to ${this._pageBufferStart + this._pageBuffer.length - 1}`);
    }
    return this.page = page;
  }
  flushPages() {
    const pages = this._pageBuffer;
    this._pageBuffer = [];
    this._pageBufferStart += pages.length;
    for (let page of pages) {
      this.endPageMarkings(page);
      page.end();
    }
  }
  addNamedDestination(name) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (args.length === 0) {
      args = ["XYZ", null, null, null];
    }
    if (args[0] === "XYZ" && args[2] !== null) {
      args[2] = this.page.height - args[2];
    }
    args.unshift(this.page.dictionary);
    this._root.data.Names.data.Dests.add(name, args);
  }
  addNamedEmbeddedFile(name, ref) {
    if (!this._root.data.Names.data.EmbeddedFiles) {
      this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({
        limits: false
      });
    }
    this._root.data.Names.data.EmbeddedFiles.add(name, ref);
  }
  addNamedJavaScript(name, js) {
    if (!this._root.data.Names.data.JavaScript) {
      this._root.data.Names.data.JavaScript = new PDFNameTree();
    }
    let data2 = {
      JS: new String(js),
      S: "JavaScript"
    };
    this._root.data.Names.data.JavaScript.add(name, data2);
  }
  ref(data2) {
    const ref = new PDFReference(this, this._offsets.length + 1, data2);
    this._offsets.push(null);
    this._waiting++;
    return ref;
  }
  _read() {
  }
  // do nothing, but this method is required by node
  _write(data2) {
    if (!Buffer$2.isBuffer(data2)) {
      data2 = Buffer$2.from(data2 + "\n", "binary");
    }
    this.push(data2);
    return this._offset += data2.length;
  }
  addContent(data2) {
    this.page.write(data2);
    return this;
  }
  _refEnd(ref) {
    this._offsets[ref.id - 1] = ref.offset;
    if (--this._waiting === 0 && this._ended) {
      this._finalize();
      return this._ended = false;
    }
  }
  end() {
    this.flushPages();
    this._info = this.ref();
    for (let key in this.info) {
      let val = this.info[key];
      if (typeof val === "string") {
        val = new String(val);
      }
      let entry = this.ref(val);
      entry.end();
      this._info.data[key] = entry;
    }
    this._info.end();
    for (let name in this._fontFamilies) {
      const font = this._fontFamilies[name];
      font.finalize();
    }
    this.endOutline();
    this.endMarkings();
    if (this.subset) {
      this.endSubset();
    }
    this.endMetadata();
    this._root.end();
    this._root.data.Pages.end();
    this._root.data.Names.end();
    this.endAcroForm();
    if (this._root.data.ViewerPreferences) {
      this._root.data.ViewerPreferences.end();
    }
    if (this._security) {
      this._security.end();
    }
    if (this._waiting === 0) {
      return this._finalize();
    } else {
      return this._ended = true;
    }
  }
  _finalize() {
    const xRefOffset = this._offset;
    this._write("xref");
    this._write(`0 ${this._offsets.length + 1}`);
    this._write("0000000000 65535 f ");
    for (let offset2 of this._offsets) {
      offset2 = `0000000000${offset2}`.slice(-10);
      this._write(offset2 + " 00000 n ");
    }
    const trailer = {
      Size: this._offsets.length + 1,
      Root: this._root,
      Info: this._info,
      ID: [this._id, this._id]
    };
    if (this._security) {
      trailer.Encrypt = this._security.dictionary;
    }
    this._write("trailer");
    this._write(PDFObject.convert(trailer));
    this._write("startxref");
    this._write(`${xRefOffset}`);
    this._write("%%EOF");
    return this.push(null);
  }
  toString() {
    return "[object PDFDocument]";
  }
};
var mixin = (methods) => {
  Object.assign(PDFDocument.prototype, methods);
};
mixin(MetadataMixin);
mixin(ColorMixin);
mixin(VectorMixin);
mixin(FontsMixin);
mixin(TextMixin);
mixin(ImagesMixin);
mixin(AnnotationsMixin);
mixin(OutlineMixin);
mixin(MarkingsMixin);
mixin(AcroFormMixin);
mixin(AttachmentsMixin);
mixin(SubsetMixin);
PDFDocument.LineWrapper = LineWrapper;

// node_modules/@react-pdf/stylesheet/lib/index.js
var import_media_engine = __toESM(require_src());
var import_hsl_to_hex = __toESM(require_hsl_to_hex());
var import_color_string2 = __toESM(require_color_string());
var import_parse = __toESM(require_parse());
var import_unit = __toESM(require_unit());
var compact = (array) => array.filter(Boolean);
var mergeStyles = (styles) => styles.reduce((acc, style) => {
  const s2 = Array.isArray(style) ? flatten(style) : style;
  Object.keys(s2).forEach((key) => {
    if (s2[key] !== null && s2[key] !== void 0) {
      acc[key] = s2[key];
    }
  });
  return acc;
}, {});
var flatten = compose(mergeStyles, compact, castArray);
var resolveMediaQueries = (container, style) => {
  return Object.keys(style).reduce((acc, key) => {
    if (/@media/.test(key)) {
      return {
        ...acc,
        ...(0, import_media_engine.default)({ [key]: style[key] }, container)
      };
    }
    return { ...acc, [key]: style[key] };
  }, {});
};
var isRgb = (value2) => /rgba?/g.test(value2);
var isHsl = (value2) => /hsla?/g.test(value2);
var parseRgb = (value2) => {
  const rgb = import_color_string2.default.get.rgb(value2);
  return import_color_string2.default.to.hex(rgb);
};
var parseHsl = (value2) => {
  const hsl = import_color_string2.default.get.hsl(value2).map(Math.round);
  const hex = (0, import_hsl_to_hex.default)(...hsl);
  return hex.toUpperCase();
};
var transformColor = (value2) => {
  if (isRgb(value2))
    return parseRgb(value2);
  if (isHsl(value2))
    return parseHsl(value2);
  return value2;
};
var parseValue = (value2) => {
  if (typeof value2 === "number")
    return { value: value2, unit: void 0 };
  const match = /^(-?\d*\.?\d+)(in|mm|cm|pt|vh|vw|px|rem)?$/g.exec(value2);
  return match ? { value: parseFloat(match[1]), unit: match[2] || "pt" } : { value: value2, unit: void 0 };
};
var transformUnit = (container, value2) => {
  const scalar = parseValue(value2);
  const outputDpi = 72;
  const inputDpi = container.dpi || 72;
  const mmFactor = 1 / 25.4 * outputDpi;
  const cmFactor = 1 / 2.54 * outputDpi;
  if (typeof scalar.value !== "number")
    return scalar.value;
  switch (scalar.unit) {
    case "rem":
      return scalar.value * (container.remBase || 18);
    case "in":
      return scalar.value * outputDpi;
    case "mm":
      return scalar.value * mmFactor;
    case "cm":
      return scalar.value * cmFactor;
    case "vh":
      return scalar.value * (container.height / 100);
    case "vw":
      return scalar.value * (container.width / 100);
    case "px":
      return Math.round(scalar.value * (outputDpi / inputDpi));
    default:
      return scalar.value;
  }
};
var processNumberValue = (key, value2) => ({
  [key]: parseFloat(value2)
});
var processUnitValue = (key, value2, container) => ({
  [key]: transformUnit(container, value2)
});
var processColorValue = (key, value2) => {
  const result = { [key]: transformColor(value2) };
  return result;
};
var processNoopValue = (key, value2) => ({
  [key]: value2
});
var BORDER_SHORTHAND_REGEX = /(-?\d+(\.\d+)?(in|mm|cm|pt|vw|vh|px|rem)?)\s(\S+)\s(.+)/;
var matchBorderShorthand = (value2) => value2.match(BORDER_SHORTHAND_REGEX) || [];
var resolveBorderShorthand = (key, value2, container) => {
  const match = matchBorderShorthand(`${value2}`);
  if (match) {
    const widthMatch = match[1] || value2;
    const styleMatch = match[4] || value2;
    const colorMatch = match[5] || value2;
    const style = styleMatch;
    const color = colorMatch ? transformColor(colorMatch) : void 0;
    const width = widthMatch ? transformUnit(container, widthMatch) : void 0;
    if (key.match(/(Top|Right|Bottom|Left)$/)) {
      return {
        [`${key}Color`]: color,
        [`${key}Style`]: style,
        [`${key}Width`]: width
      };
    }
    if (key.match(/Color$/)) {
      return {
        borderTopColor: color,
        borderRightColor: color,
        borderBottomColor: color,
        borderLeftColor: color
      };
    }
    if (key.match(/Style$/)) {
      if (typeof style === "number")
        throw new Error(`Invalid border style: ${style}`);
      return {
        borderTopStyle: style,
        borderRightStyle: style,
        borderBottomStyle: style,
        borderLeftStyle: style
      };
    }
    if (key.match(/Width$/)) {
      if (typeof width !== "number")
        throw new Error(`Invalid border width: ${width}`);
      return {
        borderTopWidth: width,
        borderRightWidth: width,
        borderBottomWidth: width,
        borderLeftWidth: width
      };
    }
    if (key.match(/Radius$/)) {
      const radius = value2 ? transformUnit(container, value2) : void 0;
      if (typeof radius !== "number")
        throw new Error(`Invalid border radius: ${radius}`);
      return {
        borderTopLeftRadius: radius,
        borderTopRightRadius: radius,
        borderBottomRightRadius: radius,
        borderBottomLeftRadius: radius
      };
    }
    if (typeof width !== "number")
      throw new Error(`Invalid border width: ${width}`);
    if (typeof style === "number")
      throw new Error(`Invalid border style: ${style}`);
    return {
      borderTopColor: color,
      borderTopStyle: style,
      borderTopWidth: width,
      borderRightColor: color,
      borderRightStyle: style,
      borderRightWidth: width,
      borderBottomColor: color,
      borderBottomStyle: style,
      borderBottomWidth: width,
      borderLeftColor: color,
      borderLeftStyle: style,
      borderLeftWidth: width
    };
  }
  return { [key]: value2 };
};
var handlers$b = {
  border: resolveBorderShorthand,
  borderBottom: resolveBorderShorthand,
  borderBottomColor: processColorValue,
  borderBottomLeftRadius: processUnitValue,
  borderBottomRightRadius: processUnitValue,
  borderBottomStyle: processNoopValue,
  borderBottomWidth: processUnitValue,
  borderColor: resolveBorderShorthand,
  borderLeft: resolveBorderShorthand,
  borderLeftColor: processColorValue,
  borderLeftStyle: processNoopValue,
  borderLeftWidth: processUnitValue,
  borderRadius: resolveBorderShorthand,
  borderRight: resolveBorderShorthand,
  borderRightColor: processColorValue,
  borderRightStyle: processNoopValue,
  borderRightWidth: processUnitValue,
  borderStyle: resolveBorderShorthand,
  borderTop: resolveBorderShorthand,
  borderTopColor: processColorValue,
  borderTopLeftRadius: processUnitValue,
  borderTopRightRadius: processUnitValue,
  borderTopStyle: processNoopValue,
  borderTopWidth: processUnitValue,
  borderWidth: resolveBorderShorthand
};
var handlers$a = {
  backgroundColor: processColorValue,
  color: processColorValue,
  opacity: processNumberValue
};
var handlers$9 = {
  height: processUnitValue,
  maxHeight: processUnitValue,
  maxWidth: processUnitValue,
  minHeight: processUnitValue,
  minWidth: processUnitValue,
  width: processUnitValue
};
var flexDefaults = [1, 1, 0];
var flexAuto = [1, 1, "auto"];
var processFlexShorthand = (key, value2, container) => {
  let defaults = flexDefaults;
  let matches = [];
  if (value2 === "auto") {
    defaults = flexAuto;
  } else {
    matches = `${value2}`.split(" ");
  }
  const flexGrow = transformUnit(container, matches[0] || defaults[0]);
  const flexShrink = transformUnit(container, matches[1] || defaults[1]);
  const flexBasis = transformUnit(container, matches[2] || defaults[2]);
  return { flexGrow, flexShrink, flexBasis };
};
var handlers$8 = {
  alignContent: processNoopValue,
  alignItems: processNoopValue,
  alignSelf: processNoopValue,
  flex: processFlexShorthand,
  flexBasis: processUnitValue,
  flexDirection: processNoopValue,
  flexFlow: processNoopValue,
  flexGrow: processUnitValue,
  flexShrink: processUnitValue,
  flexWrap: processNoopValue,
  justifyContent: processNoopValue,
  justifySelf: processNoopValue
};
var processGapShorthand = (key, value2, container) => {
  const match = `${value2}`.split(" ");
  const rowGap = transformUnit(container, (match == null ? void 0 : match[0]) || value2);
  const columnGap = transformUnit(container, (match == null ? void 0 : match[1]) || value2);
  return { rowGap, columnGap };
};
var handlers$7 = {
  gap: processGapShorthand,
  columnGap: processUnitValue,
  rowGap: processUnitValue
};
var handlers$6 = {
  aspectRatio: processNumberValue,
  bottom: processUnitValue,
  display: processNoopValue,
  left: processUnitValue,
  position: processNoopValue,
  right: processUnitValue,
  top: processUnitValue,
  overflow: processNoopValue,
  zIndex: processNumberValue
};
var BOX_MODEL_UNITS = "px,in,mm,cm,pt,%,vw,vh";
var logError = (style, value2) => {
  const name = style.toString();
  console.error(`
    @react-pdf/stylesheet parsing error:
    ${name}: ${value2},
    ${" ".repeat(name.length + 2)}^
    Unsupported ${name} value format
  `);
};
var expandBoxModel = ({ expandsTo, maxValues = 1, autoSupported = false } = {}) => (model, value2, container) => {
  const nodes = (0, import_parse.default)(`${value2}`);
  const parts = [];
  for (let i3 = 0; i3 < nodes.length; i3++) {
    const node = nodes[i3];
    if (node.type === "function" || node.type === "string" || node.type === "div") {
      logError(model, value2);
      return {};
    }
    if (node.type === "word") {
      if (node.value === "auto" && autoSupported) {
        parts.push(node.value);
      } else {
        const result = (0, import_unit.default)(node.value);
        if (result && BOX_MODEL_UNITS.includes(result.unit)) {
          parts.push(node.value);
        } else {
          logError(model, value2);
          return {};
        }
      }
    }
  }
  if (parts.length > maxValues) {
    logError(model, value2);
    return {};
  }
  const first = transformUnit(container, parts[0]);
  if (expandsTo) {
    const second = transformUnit(container, parts[1] || parts[0]);
    const third = transformUnit(container, parts[2] || parts[0]);
    const fourth = transformUnit(container, parts[3] || parts[1] || parts[0]);
    return expandsTo({ first, second, third, fourth });
  }
  return {
    [model]: first
  };
};
var processMargin = expandBoxModel({
  expandsTo: ({ first, second, third, fourth }) => ({
    marginTop: first,
    marginRight: second,
    marginBottom: third,
    marginLeft: fourth
  }),
  maxValues: 4,
  autoSupported: true
});
var processMarginVertical = expandBoxModel({
  expandsTo: ({ first, second }) => ({
    marginTop: first,
    marginBottom: second
  }),
  maxValues: 2,
  autoSupported: true
});
var processMarginHorizontal = expandBoxModel({
  expandsTo: ({ first, second }) => ({
    marginRight: first,
    marginLeft: second
  }),
  maxValues: 2,
  autoSupported: true
});
var processMarginSingle = expandBoxModel({
  autoSupported: true
});
var handlers$5 = {
  margin: processMargin,
  marginBottom: processMarginSingle,
  marginHorizontal: processMarginHorizontal,
  marginLeft: processMarginSingle,
  marginRight: processMarginSingle,
  marginTop: processMarginSingle,
  marginVertical: processMarginVertical
};
var processPadding = expandBoxModel({
  expandsTo: ({ first, second, third, fourth }) => ({
    paddingTop: first,
    paddingRight: second,
    paddingBottom: third,
    paddingLeft: fourth
  }),
  maxValues: 4
});
var processPaddingVertical = expandBoxModel({
  expandsTo: ({ first, second }) => ({
    paddingTop: first,
    paddingBottom: second
  }),
  maxValues: 2
});
var processPaddingHorizontal = expandBoxModel({
  expandsTo: ({ first, second }) => ({
    paddingRight: first,
    paddingLeft: second
  }),
  maxValues: 2
});
var processPaddingSingle = expandBoxModel();
var handlers$4 = {
  padding: processPadding,
  paddingBottom: processPaddingSingle,
  paddingHorizontal: processPaddingHorizontal,
  paddingLeft: processPaddingSingle,
  paddingRight: processPaddingSingle,
  paddingTop: processPaddingSingle,
  paddingVertical: processPaddingVertical
};
var offsetKeyword = (value2) => {
  switch (value2) {
    case "top":
    case "left":
      return "0%";
    case "right":
    case "bottom":
      return "100%";
    case "center":
      return "50%";
    default:
      return value2;
  }
};
var processObjectPosition = (key, value2, container) => {
  const match = `${value2}`.split(" ");
  const objectPositionX = offsetKeyword(transformUnit(container, (match == null ? void 0 : match[0]) || value2));
  const objectPositionY = offsetKeyword(transformUnit(container, (match == null ? void 0 : match[1]) || value2));
  return { objectPositionX, objectPositionY };
};
var processObjectPositionValue = (key, value2, container) => ({
  [key]: offsetKeyword(transformUnit(container, value2))
});
var handlers$3 = {
  objectPosition: processObjectPosition,
  objectPositionX: processObjectPositionValue,
  objectPositionY: processObjectPositionValue,
  objectFit: processNoopValue
};
var castInt = (value2) => {
  if (typeof value2 === "number")
    return value2;
  return parseInt(value2, 10);
};
var FONT_WEIGHTS2 = {
  thin: 100,
  hairline: 100,
  ultralight: 200,
  extralight: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  demibold: 600,
  bold: 700,
  ultrabold: 800,
  extrabold: 800,
  heavy: 900,
  black: 900
};
var transformFontWeight = (value2) => {
  if (!value2)
    return FONT_WEIGHTS2.normal;
  if (typeof value2 === "number")
    return value2;
  const lv = value2.toLowerCase();
  if (FONT_WEIGHTS2[lv])
    return FONT_WEIGHTS2[lv];
  return castInt(value2);
};
var processFontWeight = (key, value2) => {
  return { [key]: transformFontWeight(value2) };
};
var transformLineHeight = (value2, styles, container) => {
  if (value2 === "")
    return value2;
  const fontSize = transformUnit(container, styles.fontSize || 18);
  const lineHeight = transformUnit(container, value2);
  const { percent } = matchPercent(lineHeight) || {};
  if (percent)
    return percent * fontSize;
  return isNaN(value2) ? lineHeight : lineHeight * fontSize;
};
var processLineHeight = (key, value2, container, styles) => {
  return {
    [key]: transformLineHeight(value2, styles, container)
  };
};
var handlers$2 = {
  fontFamily: processNoopValue,
  fontSize: processUnitValue,
  fontStyle: processNoopValue,
  fontWeight: processFontWeight,
  letterSpacing: processUnitValue,
  lineHeight: processLineHeight,
  maxLines: processNumberValue,
  textAlign: processNoopValue,
  textDecoration: processNoopValue,
  textDecorationColor: processColorValue,
  textDecorationStyle: processNoopValue,
  textIndent: processNoopValue,
  textOverflow: processNoopValue,
  textTransform: processNoopValue,
  verticalAlign: processNoopValue
};
var matchNumber = (value2) => typeof value2 === "string" && /^-?\d*\.?\d*$/.test(value2);
var castFloat = (value2) => {
  if (typeof value2 !== "string")
    return value2;
  if (matchNumber(value2))
    return parseFloat(value2);
  return value2;
};
var parse2 = (transformString) => {
  const transforms = transformString.trim().split(/\)[ ,]|\)/);
  if (transforms.length === 1) {
    return [[transforms[0], true]];
  }
  const parsed = [];
  for (let i3 = 0; i3 < transforms.length; i3 += 1) {
    const transform = transforms[i3];
    if (transform) {
      const [name, rawValue] = transform.split("(");
      const splitChar = rawValue.indexOf(",") >= 0 ? "," : " ";
      const value2 = rawValue.split(splitChar).map((val) => val.trim());
      parsed.push({ operation: name.trim(), value: value2 });
    }
  }
  return parsed;
};
var parseAngle = (value2) => {
  const unitsRegexp = /(-?\d*\.?\d*)(\w*)?/i;
  const [, angle, unit] = unitsRegexp.exec(value2);
  const number3 = Number.parseFloat(angle);
  return unit === "rad" ? number3 * 180 / Math.PI : number3;
};
var normalizeTransformOperation = ({ operation, value: value2 }) => {
  switch (operation) {
    case "scale": {
      const [scaleX, scaleY = scaleX] = value2.map((num) => Number.parseFloat(num));
      return { operation: "scale", value: [scaleX, scaleY] };
    }
    case "scaleX": {
      return { operation: "scale", value: [Number.parseFloat(value2), 1] };
    }
    case "scaleY": {
      return { operation: "scale", value: [1, Number.parseFloat(value2)] };
    }
    case "rotate": {
      return { operation: "rotate", value: [parseAngle(value2)] };
    }
    case "translate": {
      return {
        operation: "translate",
        value: value2.map((num) => Number.parseFloat(num))
      };
    }
    case "translateX": {
      return {
        operation: "translate",
        value: [Number.parseFloat(value2), 0]
      };
    }
    case "translateY": {
      return { operation: "translate", value: [0, Number.parseFloat(value2)] };
    }
    case "skew": {
      return { operation: "skew", value: value2.map(parseAngle) };
    }
    case "skewX": {
      return { operation: "skew", value: [parseAngle(value2), 0] };
    }
    case "skewY": {
      return { operation: "skew", value: [0, parseAngle(value2)] };
    }
    default: {
      return { operation, value: value2.map((num) => Number.parseFloat(num)) };
    }
  }
};
var normalize2 = (operations) => {
  return operations.map((operation) => normalizeTransformOperation(operation));
};
var processTransform = (key, value2) => {
  if (typeof value2 !== "string")
    return { [key]: value2 };
  return { [key]: normalize2(parse2(value2)) };
};
var Y_AXIS_SHORTHANDS = { top: true, bottom: true };
var sortTransformOriginPair = (a3, b2) => {
  if (Y_AXIS_SHORTHANDS[a3])
    return 1;
  if (Y_AXIS_SHORTHANDS[b2])
    return -1;
  return 0;
};
var getTransformOriginPair = (values) => {
  if (!values || values.length === 0)
    return ["center", "center"];
  const pair = values.length === 1 ? [values[0], "center"] : values;
  return pair.sort(sortTransformOriginPair);
};
var processTransformOriginShorthand = (key, value2, container) => {
  const match = `${value2}`.split(" ");
  const pair = getTransformOriginPair(match);
  const transformOriginX = transformUnit(container, pair[0]);
  const transformOriginY = transformUnit(container, pair[1]);
  return {
    transformOriginX: offsetKeyword(transformOriginX) || castFloat(transformOriginX),
    transformOriginY: offsetKeyword(transformOriginY) || castFloat(transformOriginY)
  };
};
var processTransformOriginValue = (key, value2, container) => {
  const v2 = transformUnit(container, value2);
  return { [key]: offsetKeyword(v2) || castFloat(v2) };
};
var handlers$1 = {
  transform: processTransform,
  transformOrigin: processTransformOriginShorthand,
  transformOriginX: processTransformOriginValue,
  transformOriginY: processTransformOriginValue
};
var handlers = {
  fill: processColorValue,
  stroke: processColorValue,
  strokeDasharray: processNoopValue,
  strokeWidth: processUnitValue,
  fillOpacity: processNumberValue,
  strokeOpacity: processNumberValue,
  fillRule: processNoopValue,
  textAnchor: processNoopValue,
  strokeLinecap: processNoopValue,
  strokeLinejoin: processNoopValue,
  visibility: processNoopValue,
  clipPath: processNoopValue,
  dominantBaseline: processNoopValue
};
var shorthands = {
  ...handlers$b,
  ...handlers$a,
  ...handlers$9,
  ...handlers$8,
  ...handlers$7,
  ...handlers$6,
  ...handlers$5,
  ...handlers$4,
  ...handlers$3,
  ...handlers$2,
  ...handlers$1,
  ...handlers
};
var resolve = (container) => (style) => {
  const propsArray = Object.keys(style);
  const resolvedStyle = {};
  for (let i3 = 0; i3 < propsArray.length; i3 += 1) {
    const key = propsArray[i3];
    const value2 = style[key];
    if (!shorthands[key]) {
      resolvedStyle[key] = value2;
      continue;
    }
    const resolved = shorthands[key](key, value2, container, style);
    const keys2 = Object.keys(resolved);
    for (let j = 0; j < keys2.length; j += 1) {
      const propName = keys2[j];
      const propValue = resolved[propName];
      resolvedStyle[propName] = propValue;
    }
  }
  return resolvedStyle;
};
var resolveStyles = (container, style) => {
  const computeMediaQueries = (value2) => resolveMediaQueries(container, value2);
  return compose(resolve(container), computeMediaQueries, flatten)(style);
};

// node_modules/bidi-js/dist/bidi.mjs
function bidiFactory() {
  var bidi2 = function(exports) {
    var DATA = {
      "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      "B": "a,3,f+2,2v,690",
      "S": "9,2,k",
      "WS": "c,k,4f4,1vk+a,u,1j,335",
      "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      "LRO": "6ct",
      "RLO": "6cu",
      "LRE": "6cq",
      "RLE": "6cr",
      "PDF": "6cs",
      "LRI": "6ee",
      "RLI": "6ef",
      "FSI": "6eg",
      "PDI": "6eh"
    };
    var TYPES = {};
    var TYPES_TO_NAMES = {};
    TYPES.L = 1;
    TYPES_TO_NAMES[1] = "L";
    Object.keys(DATA).forEach(function(type, i3) {
      TYPES[type] = 1 << i3 + 1;
      TYPES_TO_NAMES[TYPES[type]] = type;
    });
    Object.freeze(TYPES);
    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;
    var map = null;
    function parseData() {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        var loop = function(type2) {
          if (DATA.hasOwnProperty(type2)) {
            var lastCode = 0;
            DATA[type2].split(",").forEach(function(range2) {
              var ref = range2.split("+");
              var skip = ref[0];
              var step = ref[1];
              skip = parseInt(skip, 36);
              step = step ? parseInt(step, 36) : 0;
              map.set(lastCode += skip, TYPES[type2]);
              for (var i3 = 0; i3 < step; i3++) {
                map.set(++lastCode, TYPES[type2]);
              }
            });
          }
        };
        for (var type in DATA) loop(type);
      }
    }
    function getBidiCharType(char) {
      parseData();
      return map.get(char.codePointAt(0)) || TYPES.L;
    }
    function getBidiCharTypeName(char) {
      return TYPES_TO_NAMES[getBidiCharType(char)];
    }
    var data$1 = {
      "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function parseCharacterMap(encodedString, includeReverse) {
      var radix = 36;
      var lastCode = 0;
      var map2 = /* @__PURE__ */ new Map();
      var reverseMap = includeReverse && /* @__PURE__ */ new Map();
      var prevPair;
      encodedString.split(",").forEach(function visit(entry) {
        if (entry.indexOf("+") !== -1) {
          for (var i3 = +entry; i3--; ) {
            visit(prevPair);
          }
        } else {
          prevPair = entry;
          var ref = entry.split(">");
          var a3 = ref[0];
          var b2 = ref[1];
          a3 = String.fromCodePoint(lastCode += parseInt(a3, radix));
          b2 = String.fromCodePoint(lastCode += parseInt(b2, radix));
          map2.set(a3, b2);
          includeReverse && reverseMap.set(b2, a3);
        }
      });
      return { map: map2, reverseMap };
    }
    var openToClose, closeToOpen, canonical;
    function parse$12() {
      if (!openToClose) {
        var ref = parseCharacterMap(data$1.pairs, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        openToClose = map2;
        closeToOpen = reverseMap;
        canonical = parseCharacterMap(data$1.canonical, false).map;
      }
    }
    function openingToClosingBracket(char) {
      parse$12();
      return openToClose.get(char) || null;
    }
    function closingToOpeningBracket(char) {
      parse$12();
      return closeToOpen.get(char) || null;
    }
    function getCanonicalBracket(char) {
      parse$12();
      return canonical.get(char) || null;
    }
    var TYPE_L = TYPES.L;
    var TYPE_R = TYPES.R;
    var TYPE_EN = TYPES.EN;
    var TYPE_ES = TYPES.ES;
    var TYPE_ET = TYPES.ET;
    var TYPE_AN = TYPES.AN;
    var TYPE_CS = TYPES.CS;
    var TYPE_B = TYPES.B;
    var TYPE_S = TYPES.S;
    var TYPE_ON = TYPES.ON;
    var TYPE_BN = TYPES.BN;
    var TYPE_NSM = TYPES.NSM;
    var TYPE_AL = TYPES.AL;
    var TYPE_LRO = TYPES.LRO;
    var TYPE_RLO = TYPES.RLO;
    var TYPE_LRE = TYPES.LRE;
    var TYPE_RLE = TYPES.RLE;
    var TYPE_PDF = TYPES.PDF;
    var TYPE_LRI = TYPES.LRI;
    var TYPE_RLI = TYPES.RLI;
    var TYPE_FSI = TYPES.FSI;
    var TYPE_PDI = TYPES.PDI;
    function getEmbeddingLevels(string, baseDirection) {
      var MAX_DEPTH = 125;
      var charTypes = new Uint32Array(string.length);
      for (var i3 = 0; i3 < string.length; i3++) {
        charTypes[i3] = getBidiCharType(string[i3]);
      }
      var charTypeCounts = /* @__PURE__ */ new Map();
      function changeCharType(i4, type2) {
        var oldType = charTypes[i4];
        charTypes[i4] = type2;
        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
        if (oldType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
        }
        charTypeCounts.set(type2, (charTypeCounts.get(type2) || 0) + 1);
        if (type2 & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }
      }
      var embedLevels = new Uint8Array(string.length);
      var isolationPairs = /* @__PURE__ */ new Map();
      var paragraphs = [];
      var paragraph = null;
      for (var i$1 = 0; i$1 < string.length; i$1++) {
        if (!paragraph) {
          paragraphs.push(paragraph = {
            start: i$1,
            end: string.length - 1,
            // 3.3.1 P2-P3: Determine the paragraph level
            level: baseDirection === "rtl" ? 1 : baseDirection === "ltr" ? 0 : determineAutoEmbedLevel(i$1, false)
          });
        }
        if (charTypes[i$1] & TYPE_B) {
          paragraph.end = i$1;
          paragraph = null;
        }
      }
      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
      var nextEven = function(n4) {
        return n4 + (n4 & 1 ? 1 : 2);
      };
      var nextOdd = function(n4) {
        return n4 + (n4 & 1 ? 2 : 1);
      };
      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
        paragraph = paragraphs[paraIdx];
        var statusStack = [{
          _level: paragraph.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }];
        var stackTop = void 0;
        var overflowIsolateCount = 0;
        var overflowEmbeddingCount = 0;
        var validIsolateCount = 0;
        charTypeCounts.clear();
        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
          var charType = charTypes[i$2];
          stackTop = statusStack[statusStack.length - 1];
          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
          if (charType & NEUTRAL_ISOLATE_TYPES) {
            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
          }
          if (charType & FORMATTING_TYPES) {
            if (charType & (TYPE_RLE | TYPE_LRE)) {
              embedLevels[i$2] = stackTop._level;
              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level,
                  _override: 0,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & (TYPE_RLO | TYPE_LRO)) {
              embedLevels[i$2] = stackTop._level;
              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level$1,
                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & ISOLATE_INIT_TYPES) {
              if (charType & TYPE_FSI) {
                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
              }
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
                validIsolateCount++;
                statusStack.push({
                  _level: level$2,
                  _override: 0,
                  _isolate: 1,
                  _isolInitIndex: i$2
                });
              } else {
                overflowIsolateCount++;
              }
            } else if (charType & TYPE_PDI) {
              if (overflowIsolateCount > 0) {
                overflowIsolateCount--;
              } else if (validIsolateCount > 0) {
                overflowEmbeddingCount = 0;
                while (!statusStack[statusStack.length - 1]._isolate) {
                  statusStack.pop();
                }
                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
                if (isolInitIndex != null) {
                  isolationPairs.set(isolInitIndex, i$2);
                  isolationPairs.set(i$2, isolInitIndex);
                }
                statusStack.pop();
                validIsolateCount--;
              }
              stackTop = statusStack[statusStack.length - 1];
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
            } else if (charType & TYPE_PDF) {
              if (overflowIsolateCount === 0) {
                if (overflowEmbeddingCount > 0) {
                  overflowEmbeddingCount--;
                } else if (!stackTop._isolate && statusStack.length > 1) {
                  statusStack.pop();
                  stackTop = statusStack[statusStack.length - 1];
                }
              }
              embedLevels[i$2] = stackTop._level;
            } else if (charType & TYPE_B) {
              embedLevels[i$2] = paragraph.level;
            }
          } else {
            embedLevels[i$2] = stackTop._level;
            if (stackTop._override && charType !== TYPE_BN) {
              changeCharType(i$2, stackTop._override);
            }
          }
        }
        var levelRuns = [];
        var currentRun = null;
        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
          var charType$1 = charTypes[i$3];
          if (!(charType$1 & BN_LIKE_TYPES)) {
            var lvl = embedLevels[i$3];
            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
            var isPDI = charType$1 === TYPE_PDI;
            if (currentRun && lvl === currentRun._level) {
              currentRun._end = i$3;
              currentRun._endsWithIsolInit = isIsolInit;
            } else {
              levelRuns.push(currentRun = {
                _start: i$3,
                _end: i$3,
                _level: lvl,
                _startsWithPDI: isPDI,
                _endsWithIsolInit: isIsolInit
              });
            }
          }
        }
        var isolatingRunSeqs = [];
        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
          var run = levelRuns[runIdx];
          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
            var seqRuns = [currentRun = run];
            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null; ) {
              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
                if (levelRuns[i$4]._start === pdiIndex) {
                  seqRuns.push(currentRun = levelRuns[i$4]);
                  break;
                }
              }
            }
            var seqIndices = [];
            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
              var run$1 = seqRuns[i$5];
              for (var j = run$1._start; j <= run$1._end; j++) {
                seqIndices.push(j);
              }
            }
            var firstLevel = embedLevels[seqIndices[0]];
            var prevLevel = paragraph.level;
            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {
                prevLevel = embedLevels[i$6];
                break;
              }
            }
            var lastIndex = seqIndices[seqIndices.length - 1];
            var lastLevel = embedLevels[lastIndex];
            var nextLevel = paragraph.level;
            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {
                  nextLevel = embedLevels[i$7];
                  break;
                }
              }
            }
            isolatingRunSeqs.push({
              _seqIndices: seqIndices,
              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
            });
          }
        }
        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
          var ref = isolatingRunSeqs[seqIdx];
          var seqIndices$1 = ref._seqIndices;
          var sosType = ref._sosType;
          var eosType = ref._eosType;
          var embedDirection = embedLevels[seqIndices$1[0]] & 1 ? TYPE_R : TYPE_L;
          if (charTypeCounts.get(TYPE_NSM)) {
            for (var si = 0; si < seqIndices$1.length; si++) {
              var i$8 = seqIndices$1[si];
              if (charTypes[i$8] & TYPE_NSM) {
                var prevType = sosType;
                for (var sj = si - 1; sj >= 0; sj--) {
                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {
                    prevType = charTypes[seqIndices$1[sj]];
                    break;
                  }
                }
                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
              var i$9 = seqIndices$1[si$1];
              if (charTypes[i$9] & TYPE_EN) {
                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                  if (prevCharType & STRONG_TYPES) {
                    if (prevCharType === TYPE_AL) {
                      changeCharType(i$9, TYPE_AN);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_AL)) {
            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
              var i$10 = seqIndices$1[si$2];
              if (charTypes[i$10] & TYPE_AL) {
                changeCharType(i$10, TYPE_R);
              }
            }
          }
          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
              var i$11 = seqIndices$1[si$3];
              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
                var prevType$1 = 0, nextType = 0;
                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                  prevType$1 = charTypes[seqIndices$1[sj$2]];
                  if (!(prevType$1 & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                  nextType = charTypes[seqIndices$1[sj$3]];
                  if (!(nextType & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {
                  changeCharType(i$11, prevType$1);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
              var i$12 = seqIndices$1[si$4];
              if (charTypes[i$12] & TYPE_EN) {
                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {
                  changeCharType(seqIndices$1[sj$4], TYPE_EN);
                }
                for (si$4++; si$4 < seqIndices$1.length && charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN); si$4++) {
                  if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {
                    changeCharType(seqIndices$1[si$4], TYPE_EN);
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
              var i$13 = seqIndices$1[si$5];
              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
                changeCharType(i$13, TYPE_ON);
                for (var sj$5 = si$5 - 1; sj$5 >= 0 && charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES; sj$5--) {
                  changeCharType(seqIndices$1[sj$5], TYPE_ON);
                }
                for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6++) {
                  changeCharType(seqIndices$1[sj$6], TYPE_ON);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
              var i$14 = seqIndices$1[si$6];
              var type = charTypes[i$14];
              if (type & TYPE_EN) {
                if (prevStrongType === TYPE_L) {
                  changeCharType(i$14, TYPE_L);
                }
              } else if (type & STRONG_TYPES) {
                prevStrongType = type;
              }
            }
          }
          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;
            var bracketPairs = [];
            {
              var openerStack = [];
              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                  var char = string[seqIndices$1[si$7]];
                  var oppositeBracket = void 0;
                  if (openingToClosingBracket(char) !== null) {
                    if (openerStack.length < 63) {
                      openerStack.push({ char, seqIndex: si$7 });
                    } else {
                      break;
                    }
                  } else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                      var stackChar = openerStack[stackIdx].char;
                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {
                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                        openerStack.length = stackIdx;
                        break;
                      }
                    }
                  }
                }
              }
              bracketPairs.sort(function(a3, b2) {
                return a3[0] - b2[0];
              });
            }
            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
              var ref$1 = bracketPairs[pairIdx];
              var openSeqIdx = ref$1[0];
              var closeSeqIdx = ref$1[1];
              var foundStrongType = false;
              var useStrongType = 0;
              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
                var i$15 = seqIndices$1[si$8];
                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                  foundStrongType = true;
                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                  if (lr === embedDirection) {
                    useStrongType = lr;
                    break;
                  }
                }
              }
              if (foundStrongType && !useStrongType) {
                useStrongType = sosType;
                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                  var i$16 = seqIndices$1[si$9];
                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    if (lr$1 !== embedDirection) {
                      useStrongType = lr$1;
                    } else {
                      useStrongType = embedDirection;
                    }
                    break;
                  }
                }
              }
              if (useStrongType) {
                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
                if (useStrongType !== embedDirection) {
                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$10]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
                if (useStrongType !== embedDirection) {
                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$11]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
              }
            }
            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
                var niRunStart = si$12, niRunEnd = si$12;
                var prevType$2 = sosType;
                for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                    niRunStart = si2;
                  } else {
                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                var nextType$1 = eosType;
                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                    niRunEnd = si2$1;
                  } else {
                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {
                  charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;
                }
                si$12 = niRunEnd;
              }
            }
          }
        }
        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
          var level$3 = embedLevels[i$17];
          var type$1 = charTypes[i$17];
          if (level$3 & 1) {
            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
              embedLevels[i$17]++;
            }
          } else {
            if (type$1 & TYPE_R) {
              embedLevels[i$17]++;
            } else if (type$1 & (TYPE_AN | TYPE_EN)) {
              embedLevels[i$17] += 2;
            }
          }
          if (type$1 & BN_LIKE_TYPES) {
            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
          }
          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {
              embedLevels[j$1] = paragraph.level;
            }
          }
        }
      }
      return {
        levels: embedLevels,
        paragraphs
      };
      function determineAutoEmbedLevel(start2, isFSI) {
        for (var i4 = start2; i4 < string.length; i4++) {
          var charType2 = charTypes[i4];
          if (charType2 & (TYPE_R | TYPE_AL)) {
            return 1;
          }
          if (charType2 & (TYPE_B | TYPE_L) || isFSI && charType2 === TYPE_PDI) {
            return 0;
          }
          if (charType2 & ISOLATE_INIT_TYPES) {
            var pdi = indexOfMatchingPDI(i4);
            i4 = pdi === -1 ? string.length : pdi;
          }
        }
        return 0;
      }
      function indexOfMatchingPDI(isolateStart) {
        var isolationLevel = 1;
        for (var i4 = isolateStart + 1; i4 < string.length; i4++) {
          var charType2 = charTypes[i4];
          if (charType2 & TYPE_B) {
            break;
          }
          if (charType2 & TYPE_PDI) {
            if (--isolationLevel === 0) {
              return i4;
            }
          } else if (charType2 & ISOLATE_INIT_TYPES) {
            isolationLevel++;
          }
        }
        return -1;
      }
    }
    var data2 = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";
    var mirrorMap;
    function parse3() {
      if (!mirrorMap) {
        var ref = parseCharacterMap(data2, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        reverseMap.forEach(function(value2, key) {
          map2.set(key, value2);
        });
        mirrorMap = map2;
      }
    }
    function getMirroredCharacter(char) {
      parse3();
      return mirrorMap.get(char) || null;
    }
    function getMirroredCharactersMap(string, embeddingLevels, start2, end2) {
      var strLen = string.length;
      start2 = Math.max(0, start2 == null ? 0 : +start2);
      end2 = Math.min(strLen - 1, end2 == null ? strLen - 1 : +end2);
      var map2 = /* @__PURE__ */ new Map();
      for (var i3 = start2; i3 <= end2; i3++) {
        if (embeddingLevels[i3] & 1) {
          var mirror = getMirroredCharacter(string[i3]);
          if (mirror !== null) {
            map2.set(i3, mirror);
          }
        }
      }
      return map2;
    }
    function getReorderSegments(string, embeddingLevelsResult, start2, end2) {
      var strLen = string.length;
      start2 = Math.max(0, start2 == null ? 0 : +start2);
      end2 = Math.min(strLen - 1, end2 == null ? strLen - 1 : +end2);
      var segments = [];
      embeddingLevelsResult.paragraphs.forEach(function(paragraph) {
        var lineStart = Math.max(start2, paragraph.start);
        var lineEnd = Math.min(end2, paragraph.end);
        if (lineStart < lineEnd) {
          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);
          for (var i3 = lineEnd; i3 >= lineStart && getBidiCharType(string[i3]) & TRAILING_TYPES; i3--) {
            lineLevels[i3] = paragraph.level;
          }
          var maxLevel = paragraph.level;
          var minOddLevel = Infinity;
          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
            var level = lineLevels[i$1];
            if (level > maxLevel) {
              maxLevel = level;
            }
            if (level < minOddLevel) {
              minOddLevel = level | 1;
            }
          }
          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
              if (lineLevels[i$2] >= lvl) {
                var segStart = i$2;
                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                  i$2++;
                }
                if (i$2 > segStart) {
                  segments.push([segStart + lineStart, i$2 + lineStart]);
                }
              }
            }
          }
        }
      });
      return segments;
    }
    function getReorderedString(string, embedLevelsResult, start2, end2) {
      var indices = getReorderedIndices2(string, embedLevelsResult, start2, end2);
      var chars = [].concat(string);
      indices.forEach(function(charIndex, i3) {
        chars[i3] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];
      });
      return chars.join("");
    }
    function getReorderedIndices2(string, embedLevelsResult, start2, end2) {
      var segments = getReorderSegments(string, embedLevelsResult, start2, end2);
      var indices = [];
      for (var i3 = 0; i3 < string.length; i3++) {
        indices[i3] = i3;
      }
      segments.forEach(function(ref) {
        var start3 = ref[0];
        var end3 = ref[1];
        var slice5 = indices.slice(start3, end3 + 1);
        for (var i4 = slice5.length; i4--; ) {
          indices[end3 - i4] = slice5[i4];
        }
      });
      return indices;
    }
    exports.closingToOpeningBracket = closingToOpeningBracket;
    exports.getBidiCharType = getBidiCharType;
    exports.getBidiCharTypeName = getBidiCharTypeName;
    exports.getCanonicalBracket = getCanonicalBracket;
    exports.getEmbeddingLevels = getEmbeddingLevels;
    exports.getMirroredCharacter = getMirroredCharacter;
    exports.getMirroredCharactersMap = getMirroredCharactersMap;
    exports.getReorderSegments = getReorderSegments;
    exports.getReorderedIndices = getReorderedIndices2;
    exports.getReorderedString = getReorderedString;
    exports.openingToClosingBracket = openingToClosingBracket;
    Object.defineProperty(exports, "__esModule", { value: true });
    return exports;
  }({});
  return bidi2;
}
var bidi_default = bidiFactory;

// node_modules/@react-pdf/textkit/lib/textkit.js
var import_hyphen = __toESM(require_hyphen());
var import_en_us = __toESM(require_en_us());
var fromFragments = (fragments) => {
  let offset2 = 0;
  let string = "";
  const runs = [];
  fragments.forEach((fragment) => {
    string += fragment.string;
    runs.push({
      ...fragment,
      start: offset2,
      end: offset2 + fragment.string.length,
      attributes: fragment.attributes || {}
    });
    offset2 += fragment.string.length;
  });
  return { string, runs };
};
var defaultHyphenationEngine = (word) => [word];
var wrapWords = (engines2 = {}, options = {}) => {
  return (attributedString) => {
    var _a;
    const syllables = [];
    const fragments = [];
    const hyphenateWord = options.hyphenationCallback || ((_a = engines2.wordHyphenation) == null ? void 0 : _a.call(engines2)) || defaultHyphenationEngine;
    for (let i3 = 0; i3 < attributedString.runs.length; i3 += 1) {
      let string = "";
      const run = attributedString.runs[i3];
      const words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);
      for (let j = 0; j < words.length; j += 1) {
        const word = words[j];
        const parts = hyphenateWord(word);
        syllables.push(...parts);
        string += parts.join("");
      }
      fragments.push({ ...run, string });
    }
    const result = { ...fromFragments(fragments), syllables };
    return result;
  };
};
var copy3 = (rect) => {
  return Object.assign({}, rect);
};
var partition = (rect, height2) => {
  const a3 = Object.assign({}, rect, { height: height2 });
  const b2 = Object.assign({}, rect, {
    y: rect.y + height2,
    height: rect.height - height2
  });
  return [a3, b2];
};
var crop = (height2, rect) => {
  const [, result] = partition(rect, height2);
  return result;
};
var height$2 = (paragraph) => {
  return paragraph.reduce((acc, block) => acc + block.box.height, 0);
};
var calculateScale = (run) => {
  const attributes2 = run.attributes || {};
  const fontSize = attributes2.fontSize || 12;
  const font = attributes2.font;
  const unitsPerEm = typeof font === "string" ? null : font == null ? void 0 : font.unitsPerEm;
  return unitsPerEm ? fontSize / unitsPerEm : 0;
};
var scale = (run) => {
  var _a;
  return ((_a = run.attributes) == null ? void 0 : _a.scale) || calculateScale(run);
};
var offset = (index3, run) => {
  if (!run)
    return 0;
  const glyphIndices = run.glyphIndices || [];
  const value2 = glyphIndices[index3];
  return glyphIndices.slice(0, index3).filter((i3) => i3 === value2).length;
};
var getFont = (run) => {
  var _a;
  return ((_a = run.attributes) == null ? void 0 : _a.font) || null;
};
var slice$2 = (start2, end2, font, glyph) => {
  if (!glyph)
    return [];
  if (start2 === end2)
    return [];
  if (start2 === 0 && end2 === glyph.codePoints.length)
    return [glyph];
  const codePoints = glyph.codePoints.slice(start2, end2);
  const string = String.fromCodePoint(...codePoints);
  return font ? font.layout(string, void 0, void 0, void 0, "ltr").glyphs : [glyph];
};
var glyphIndexAt = (index3, run) => {
  var _a;
  const result = (_a = run == null ? void 0 : run.glyphIndices) == null ? void 0 : _a[index3];
  return isNil(result) ? index3 : result;
};
var normalize3 = (array) => {
  const head = array[0];
  return array.map((value2) => value2 - head);
};
var slice$1 = (start2, end2, run) => {
  var _a, _b;
  const runScale = scale(run);
  const font = getFont(run);
  const startIndex = glyphIndexAt(start2, run);
  const endIndex = glyphIndexAt(end2, run);
  const startGlyph = (_a = run.glyphs) == null ? void 0 : _a[startIndex];
  const endGlyph = (_b = run.glyphs) == null ? void 0 : _b[endIndex];
  const startOffset = offset(start2, run);
  const startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];
  const endOffset = offset(end2, run);
  const endGlyphs = slice$2(0, endOffset, font, endGlyph);
  const sliceStart = startIndex + Math.min(1, startOffset);
  const glyphs = (run.glyphs || []).slice(sliceStart, endIndex);
  const glyphPosition = (g2) => ({
    xAdvance: g2.advanceWidth * runScale,
    yAdvance: 0,
    xOffset: 0,
    yOffset: 0
  });
  const startPositions = startGlyphs.map(glyphPosition);
  const positions = (run.positions || []).slice(sliceStart, endIndex);
  const endPositions = endGlyphs.map(glyphPosition);
  return Object.assign({}, run, {
    start: run.start + start2,
    end: Math.min(run.end, run.start + end2),
    glyphIndices: normalize3((run.glyphIndices || []).slice(start2, end2)),
    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),
    positions: [startPositions, positions, endPositions].flat()
  });
};
var runIndexAt$1 = (index3, runs) => {
  if (!runs)
    return -1;
  return runs.findIndex((run) => run.start <= index3 && index3 < run.end);
};
var filter = (start2, end2, runs) => {
  const startIndex = runIndexAt$1(start2, runs);
  const endIndex = Math.max(runIndexAt$1(end2 - 1, runs), startIndex);
  return runs.slice(startIndex, endIndex + 1);
};
var subtract = (index3, run) => {
  const start2 = run.start - index3;
  const end2 = run.end - index3;
  return Object.assign({}, run, { start: start2, end: end2 });
};
var sliceRuns = (start2, end2, runs) => {
  const sliceFirstRun = (a3) => slice$1(start2 - a3.start, end2 - a3.start, a3);
  const sliceLastRun = (a3) => slice$1(0, end2 - a3.start, a3);
  return runs.map((run, i3) => {
    let result = run;
    const isFirst = i3 === 0;
    const isLast = !isFirst && i3 === runs.length - 1;
    if (isFirst)
      result = sliceFirstRun(run);
    if (isLast)
      result = sliceLastRun(run);
    return subtract(start2, result);
  });
};
var slice3 = (start2, end2, attributedString) => {
  if (attributedString.string.length === 0)
    return attributedString;
  const string = attributedString.string.slice(start2, end2);
  const filteredRuns = filter(start2, end2, attributedString.runs);
  const slicedRuns = sliceRuns(start2, end2, filteredRuns);
  return Object.assign({}, attributedString, { string, runs: slicedRuns });
};
var findCharIndex = (string) => {
  return string.search(/\S/g);
};
var findLastCharIndex = (string) => {
  const match = string.match(/\S/g);
  return match ? string.lastIndexOf(match[match.length - 1]) : -1;
};
var trim = (attributedString) => {
  const start2 = findCharIndex(attributedString.string);
  const end2 = findLastCharIndex(attributedString.string);
  return slice3(start2, end2 + 1, attributedString);
};
var empty$1 = () => {
  return {
    start: 0,
    end: 0,
    glyphIndices: [],
    glyphs: [],
    positions: [],
    attributes: {}
  };
};
var isNumber3 = (value2) => {
  return typeof value2 === "number";
};
var appendIndices = (length2, indices) => {
  const lastIndex = last(indices);
  const value2 = isNil(lastIndex) ? 0 : lastIndex + 1;
  const newIndices = Array(length2).fill(value2);
  return indices.concat(newIndices);
};
var fromCodePoint = (value2, font) => {
  if (typeof font === "string")
    return null;
  return font && value2 ? font.glyphForCodePoint(value2) : null;
};
var appendGlyph = (glyph, run) => {
  var _a;
  const glyphLength = ((_a = glyph.codePoints) == null ? void 0 : _a.length) || 0;
  const end2 = run.end + glyphLength;
  const glyphs = run.glyphs.concat(glyph);
  const glyphIndices = appendIndices(glyphLength, run.glyphIndices);
  if (!run.positions)
    return Object.assign({}, run, { end: end2, glyphs, glyphIndices });
  const positions = run.positions.concat({
    xAdvance: glyph.advanceWidth * scale(run),
    yAdvance: 0,
    xOffset: 0,
    yOffset: 0
  });
  return Object.assign({}, run, { end: end2, glyphs, glyphIndices, positions });
};
var append$1 = (value2, run) => {
  if (!value2)
    return run;
  const font = getFont(run);
  const glyph = isNumber3(value2) ? fromCodePoint(value2, font) : value2;
  return appendGlyph(glyph, run);
};
var stringFromCodePoints = (codePoints) => {
  return String.fromCodePoint(...codePoints || []);
};
var append = (glyph, attributedString) => {
  const codePoints = typeof glyph === "number" ? [glyph] : glyph == null ? void 0 : glyph.codePoints;
  const codePointsString = stringFromCodePoints(codePoints || []);
  const string = attributedString.string + codePointsString;
  const firstRuns = attributedString.runs.slice(0, -1);
  const lastRun = last(attributedString.runs) || empty$1();
  const runs = firstRuns.concat(append$1(glyph, lastRun));
  return Object.assign({}, attributedString, { string, runs });
};
var ELLIPSIS_UNICODE = 8230;
var ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);
var getEllipsisCodePoint = (font) => {
  if (!font.encode)
    return ELLIPSIS_UNICODE;
  const [codePoints] = font.encode(ELLIPSIS_STRING);
  return parseInt(codePoints[0], 16);
};
var truncate3 = (paragraph) => {
  var _a, _b, _c;
  const runs = ((_a = last(paragraph)) == null ? void 0 : _a.runs) || [];
  const font = (_c = (_b = last(runs)) == null ? void 0 : _b.attributes) == null ? void 0 : _c.font;
  if (font) {
    const index3 = paragraph.length - 1;
    const codePoint = getEllipsisCodePoint(font);
    const glyph = font.glyphForCodePoint(codePoint);
    const lastBlock = append(glyph, trim(paragraph[index3]));
    return Object.assign([], paragraph, { [index3]: lastBlock });
  }
  return paragraph;
};
var omit2 = (value2, run) => {
  const attributes2 = Object.assign({}, run.attributes);
  delete attributes2[value2];
  return Object.assign({}, run, { attributes: attributes2 });
};
var ascent$1 = (run) => {
  const { font, attachment } = run.attributes;
  const attachmentHeight = (attachment == null ? void 0 : attachment.height) || 0;
  const fontAscent = typeof font === "string" ? 0 : (font == null ? void 0 : font.ascent) || 0;
  return Math.max(attachmentHeight, fontAscent * scale(run));
};
var descent = (run) => {
  var _a;
  const font = (_a = run.attributes) == null ? void 0 : _a.font;
  const fontDescent = typeof font === "string" ? 0 : (font == null ? void 0 : font.descent) || 0;
  return scale(run) * fontDescent;
};
var lineGap = (run) => {
  var _a;
  const font = (_a = run.attributes) == null ? void 0 : _a.font;
  const lineGap2 = typeof font === "string" ? 0 : (font == null ? void 0 : font.lineGap) || 0;
  return lineGap2 * scale(run);
};
var height$1 = (run) => {
  var _a;
  const lineHeight = (_a = run.attributes) == null ? void 0 : _a.lineHeight;
  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);
};
var height = (attributedString) => {
  const reducer = (acc, run) => Math.max(acc, height$1(run));
  return attributedString.runs.reduce(reducer, 0);
};
var intersects = (a3, b2) => {
  const x = Math.max(a3.x, b2.x);
  const num1 = Math.min(a3.x + a3.width, b2.x + b2.width);
  const y2 = Math.max(a3.y, b2.y);
  const num2 = Math.min(a3.y + a3.height, b2.y + b2.height);
  return num1 >= x && num2 >= y2;
};
var getLineFragment = (lineRect, excludeRect) => {
  if (!intersects(excludeRect, lineRect))
    return [lineRect];
  const eStart = excludeRect.x;
  const eEnd = excludeRect.x + excludeRect.width;
  const lStart = lineRect.x;
  const lEnd = lineRect.x + lineRect.width;
  const a3 = Object.assign({}, lineRect, { width: eStart - lStart });
  const b2 = Object.assign({}, lineRect, { x: eEnd, width: lEnd - eEnd });
  return [a3, b2].filter((r3) => r3.width > 0);
};
var getLineFragments = (rect, excludeRects) => {
  let fragments = [rect];
  for (let i3 = 0; i3 < excludeRects.length; i3 += 1) {
    const excludeRect = excludeRects[i3];
    fragments = fragments.reduce((acc, fragment) => {
      const pieces = getLineFragment(fragment, excludeRect);
      return acc.concat(pieces);
    }, []);
  }
  return fragments;
};
var generateLineRects = (container, height2) => {
  const { excludeRects, ...rect } = container;
  if (!excludeRects)
    return [rect];
  const lineRects = [];
  const maxY = Math.max(...excludeRects.map((r3) => r3.y + r3.height));
  let currentRect = rect;
  while (currentRect.y < maxY) {
    const [lineRect, rest] = partition(currentRect, height2);
    const lineRectFragments = getLineFragments(lineRect, excludeRects);
    currentRect = rest;
    lineRects.push(...lineRectFragments);
  }
  return [...lineRects, currentRect];
};
var ATTACHMENT_CODE$1 = "";
var purgeAttachments = (line2) => {
  const shouldPurge = !line2.string.includes(ATTACHMENT_CODE$1);
  if (!shouldPurge)
    return line2;
  const runs = line2.runs.map((run) => omit2("attachment", run));
  return Object.assign({}, line2, { runs });
};
var layoutLines = (rects, lines, indent) => {
  let rect = rects.shift();
  let currentY = rect.y;
  return lines.map((line2, i3) => {
    var _a, _b;
    const lineIndent = i3 === 0 ? indent : 0;
    const style = ((_b = (_a = line2.runs) == null ? void 0 : _a[0]) == null ? void 0 : _b.attributes) || {};
    const height$12 = Math.max(height(line2), style.lineHeight);
    if (currentY + height$12 > rect.y + rect.height && rects.length > 0) {
      rect = rects.shift();
      currentY = rect.y;
    }
    const newLine = {
      string: line2.string,
      runs: line2.runs,
      box: {
        x: rect.x + lineIndent,
        y: currentY,
        width: rect.width - lineIndent,
        height: height$12
      }
    };
    currentY += height$12;
    return purgeAttachments(newLine);
  });
};
var layoutParagraph = (engines2, options = {}) => {
  return (container, paragraph) => {
    var _a, _b, _c;
    const height$12 = height(paragraph);
    const indent = ((_c = (_b = (_a = paragraph.runs) == null ? void 0 : _a[0]) == null ? void 0 : _b.attributes) == null ? void 0 : _c.indent) || 0;
    const rects = generateLineRects(container, height$12);
    const availableWidths = rects.map((r3) => r3.width);
    availableWidths.unshift(availableWidths[0] - indent);
    const lines = engines2.linebreaker(options)(paragraph, availableWidths);
    return layoutLines(rects, lines, indent);
  };
};
var sliceAtHeight = (height2, paragraph) => {
  const newBlock = [];
  let counter = 0;
  for (let i3 = 0; i3 < paragraph.length; i3 += 1) {
    const line2 = paragraph[i3];
    counter += line2.box.height;
    if (counter < height2) {
      newBlock.push(line2);
    } else {
      break;
    }
  }
  return newBlock;
};
var typesetter = (engines2, options, container) => {
  return (attributedStrings) => {
    const result = [];
    const paragraphs = [...attributedStrings];
    const layout2 = layoutParagraph(engines2, options);
    const maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;
    const truncateEllipsis = container.truncateMode === "ellipsis";
    let linesCount = maxLines;
    let paragraphRect = copy3(container);
    let nextParagraph = paragraphs.shift();
    while (linesCount > 0 && nextParagraph) {
      const paragraph = layout2(paragraphRect, nextParagraph);
      const slicedBlock = paragraph.slice(0, linesCount);
      const linesHeight2 = height$2(slicedBlock);
      const shouldTruncate = truncateEllipsis && paragraph.length !== slicedBlock.length;
      linesCount -= slicedBlock.length;
      if (paragraphRect.height >= linesHeight2) {
        result.push(shouldTruncate ? truncate3(slicedBlock) : slicedBlock);
        paragraphRect = crop(linesHeight2, paragraphRect);
        nextParagraph = paragraphs.shift();
      } else {
        result.push(truncate3(sliceAtHeight(paragraphRect.height, slicedBlock)));
        break;
      }
    }
    return result;
  };
};
var start = (attributedString) => {
  const { runs } = attributedString;
  return runs.length === 0 ? 0 : runs[0].start;
};
var end = (attributedString) => {
  const { runs } = attributedString;
  return runs.length === 0 ? 0 : last(runs).end;
};
var length$1 = (attributedString) => {
  return end(attributedString) - start(attributedString);
};
var bidi$2 = bidi_default();
var getBidiLevels$1 = (runs) => {
  return runs.reduce((acc, run) => {
    const length2 = run.end - run.start;
    const levels = repeat(run.attributes.bidiLevel, length2);
    return acc.concat(levels);
  }, []);
};
var getReorderedIndices = (string, segments) => {
  const indices = [];
  for (let i3 = 0; i3 < string.length; i3 += 1) {
    indices[i3] = i3;
  }
  segments.forEach(([start2, end2]) => {
    const slice5 = indices.slice(start2, end2 + 1);
    for (let i3 = slice5.length - 1; i3 >= 0; i3 -= 1) {
      indices[end2 - i3] = slice5[i3];
    }
  });
  return indices;
};
var getItemAtIndex = (runs, objectName, index3) => {
  for (let i3 = 0; i3 < runs.length; i3 += 1) {
    const run = runs[i3];
    const updatedIndex = run.glyphIndices[index3 - run.start];
    if (index3 >= run.start && index3 < run.end) {
      return run[objectName][updatedIndex];
    }
  }
  throw new Error(`index ${index3} out of range`);
};
var reorderLine = (line2) => {
  var _a;
  const levels = getBidiLevels$1(line2.runs);
  const direction = (_a = line2.runs[0]) == null ? void 0 : _a.attributes.direction;
  const level = direction === "rtl" ? 1 : 0;
  const end2 = length$1(line2) - 1;
  const paragraphs = [{ start: 0, end: end2, level }];
  const embeddingLevels = { paragraphs, levels };
  const segments = bidi$2.getReorderSegments(line2.string, embeddingLevels);
  if (segments.length === 0)
    return line2;
  const indices = getReorderedIndices(line2.string, segments);
  const updatedString = bidi$2.getReorderedString(line2.string, embeddingLevels);
  const updatedRuns = line2.runs.map((run) => {
    const selectedIndices = indices.slice(run.start, run.end);
    const updatedGlyphs = [];
    const updatedPositions = [];
    const addedGlyphs = /* @__PURE__ */ new Set();
    for (let i3 = 0; i3 < selectedIndices.length; i3 += 1) {
      const index3 = selectedIndices[i3];
      const glyph = getItemAtIndex(line2.runs, "glyphs", index3);
      if (addedGlyphs.has(glyph.id))
        continue;
      updatedGlyphs.push(glyph);
      updatedPositions.push(getItemAtIndex(line2.runs, "positions", index3));
      if (glyph.isLigature) {
        addedGlyphs.add(glyph.id);
      }
    }
    return {
      ...run,
      glyphs: updatedGlyphs,
      positions: updatedPositions
    };
  });
  return {
    box: line2.box,
    runs: updatedRuns,
    string: updatedString
  };
};
var reorderParagraph = (paragraph) => paragraph.map(reorderLine);
var bidiReordering = () => {
  return (paragraphs) => paragraphs.map(reorderParagraph);
};
var DUMMY_CODEPOINT = 123;
var resolve2 = (glyphs = []) => {
  return glyphs.reduce((acc, glyph) => {
    const codePoints = (glyph == null ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];
    if (acc.length === 0)
      return codePoints.map(() => 0);
    const last2 = acc[acc.length - 1];
    const next = codePoints.map(() => last2 + 1);
    return [...acc, ...next];
  }, []);
};
var getCharacterSpacing = (run) => {
  var _a;
  return ((_a = run.attributes) == null ? void 0 : _a.characterSpacing) || 0;
};
var scalePositions = (run, positions) => {
  const runScale = scale(run);
  const characterSpacing = getCharacterSpacing(run);
  return positions.map((position, i3) => {
    const isLast = i3 === positions.length;
    const xSpacing = isLast ? 0 : characterSpacing;
    return Object.assign({}, position, {
      xAdvance: position.xAdvance * runScale + xSpacing,
      yAdvance: position.yAdvance * runScale,
      xOffset: position.xOffset * runScale,
      yOffset: position.yOffset * runScale
    });
  });
};
var layoutRun = (string) => {
  return (run) => {
    const { start: start2, end: end2, attributes: attributes2 = {} } = run;
    const { font } = attributes2;
    if (!font)
      return { ...run, glyphs: [], glyphIndices: [], positions: [] };
    const runString = string.slice(start2, end2);
    if (typeof font === "string")
      throw new Error("Invalid font");
    const glyphRun = font.layout(runString, void 0, void 0, void 0, "ltr");
    const positions = scalePositions(run, glyphRun.positions);
    const glyphIndices = resolve2(glyphRun.glyphs);
    const result = {
      ...run,
      positions,
      glyphIndices,
      glyphs: glyphRun.glyphs
    };
    return result;
  };
};
var generateGlyphs = () => {
  return (attributedString) => {
    const runs = attributedString.runs.map(layoutRun(attributedString.string));
    const res = Object.assign({}, attributedString, { runs });
    return res;
  };
};
var resolveRunYOffset = (run) => {
  var _a, _b, _c;
  if (!run.positions)
    return run;
  const unitsPerEm = ((_b = (_a = run.attributes) == null ? void 0 : _a.font) == null ? void 0 : _b.unitsPerEm) || 0;
  const yOffset = (((_c = run.attributes) == null ? void 0 : _c.yOffset) || 0) * unitsPerEm;
  const positions = run.positions.map((p2) => Object.assign({}, p2, { yOffset }));
  return Object.assign({}, run, { positions });
};
var resolveYOffset = () => {
  return (attributedString) => {
    const runs = attributedString.runs.map(resolveRunYOffset);
    const res = Object.assign({}, attributedString, { runs });
    return res;
  };
};
var sort = (runs) => {
  return runs.sort((a3, b2) => a3.start - b2.start || a3.end - b2.end);
};
var isEmpty = (run) => {
  return run.start === run.end;
};
var sortPoints = (a3, b2) => {
  return a3[1] - b2[1] || a3[3] - b2[3];
};
var generatePoints = (runs) => {
  const result = runs.reduce((acc, run, i3) => {
    return acc.concat([
      ["start", run.start, run.attributes, i3],
      ["end", run.end, run.attributes, i3]
    ]);
  }, []);
  return result.sort(sortPoints);
};
var mergeRuns = (runs) => {
  return runs.reduce((acc, run) => {
    const attributes2 = Object.assign({}, acc.attributes, run.attributes);
    return Object.assign({}, run, { attributes: attributes2 });
  }, {});
};
var groupEmptyRuns = (runs) => {
  const groups = runs.reduce((acc, run) => {
    if (!acc[run.start])
      acc[run.start] = [];
    acc[run.start].push(run);
    return acc;
  }, []);
  return Object.values(groups);
};
var flattenEmptyRuns = (runs) => {
  return groupEmptyRuns(runs).map(mergeRuns);
};
var flattenRegularRuns = (runs) => {
  const res = [];
  const points = generatePoints(runs);
  let start2 = -1;
  let attrs = {};
  const stack = [];
  for (let i3 = 0; i3 < points.length; i3 += 1) {
    const [type, offset2, attributes2] = points[i3];
    if (start2 !== -1 && start2 < offset2) {
      res.push({
        start: start2,
        end: offset2,
        attributes: attrs,
        glyphIndices: [],
        glyphs: [],
        positions: []
      });
    }
    if (type === "start") {
      stack.push(attributes2);
      attrs = Object.assign({}, attrs, attributes2);
    } else {
      attrs = {};
      for (let j = 0; j < stack.length; j += 1) {
        if (stack[j] === attributes2) {
          stack.splice(j--, 1);
        } else {
          attrs = Object.assign({}, attrs, stack[j]);
        }
      }
    }
    start2 = offset2;
  }
  return res;
};
var flatten2 = (runs = []) => {
  const emptyRuns = flattenEmptyRuns(runs.filter((run) => isEmpty(run)));
  const regularRuns = flattenRegularRuns(runs.filter((run) => !isEmpty(run)));
  return sort(emptyRuns.concat(regularRuns));
};
var empty = () => ({ string: "", runs: [] });
var omitFont = (attributedString) => {
  const runs = attributedString.runs.map((run) => omit2("font", run));
  return Object.assign({}, attributedString, { runs });
};
var preprocessRuns = (engines2) => {
  return (attributedString) => {
    if (isNil(attributedString))
      return empty();
    const { string } = attributedString;
    const { fontSubstitution: fontSubstitution2, scriptItemizer: scriptItemizer2, bidi: bidi2 } = engines2;
    const { runs: omittedFontRuns } = omitFont(attributedString);
    const { runs: itemizationRuns } = scriptItemizer2()(attributedString);
    const { runs: substitutedRuns } = fontSubstitution2()(attributedString);
    const { runs: bidiRuns } = bidi2()(attributedString);
    const runs = bidiRuns.concat(substitutedRuns).concat(itemizationRuns).concat(omittedFontRuns);
    return { string, runs: flatten2(runs) };
  };
};
var splitParagraphs = () => {
  return (attributedString) => {
    const paragraphs = [];
    let start2 = 0;
    let breakPoint = attributedString.string.indexOf("\n") + 1;
    while (breakPoint > 0) {
      paragraphs.push(slice3(start2, breakPoint, attributedString));
      start2 = breakPoint;
      breakPoint = attributedString.string.indexOf("\n", breakPoint) + 1;
    }
    if (start2 === 0) {
      paragraphs.push(attributedString);
    } else if (start2 < attributedString.string.length) {
      paragraphs.push(slice3(start2, length$1(attributedString), attributedString));
    }
    return paragraphs;
  };
};
var advanceWidth$2 = (positions) => {
  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);
};
var advanceWidth$1 = (run) => {
  return advanceWidth$2(run.positions || []);
};
var advanceWidth = (attributedString) => {
  const reducer = (acc, run) => acc + advanceWidth$1(run);
  return attributedString.runs.reduce(reducer, 0);
};
var WHITE_SPACES_CODE = 32;
var isWhiteSpace = (glyph) => {
  const codePoints = (glyph == null ? void 0 : glyph.codePoints) || [];
  return codePoints.includes(WHITE_SPACES_CODE);
};
var leadingPositions = (run) => {
  const glyphs = run.glyphs || [];
  const positions = run.positions || [];
  const leadingWhitespaces = glyphs.findIndex((g2) => !isWhiteSpace(g2));
  return positions.slice(0, leadingWhitespaces);
};
var leadingOffset$1 = (run) => {
  const positions = leadingPositions(run);
  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);
};
var leadingOffset = (attributedString) => {
  const runs = attributedString.runs || [];
  return leadingOffset$1(runs[0]);
};
var trailingPositions = (run) => {
  const glyphs = reverse(run.glyphs || []);
  const positions = reverse(run.positions || []);
  const leadingWhitespaces = glyphs.findIndex((g2) => !isWhiteSpace(g2));
  return positions.slice(0, leadingWhitespaces);
};
var trailingOffset$1 = (run) => {
  const positions = trailingPositions(run);
  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);
};
var trailingOffset = (attributedString) => {
  const runs = attributedString.runs || [];
  return trailingOffset$1(last(runs));
};
var dropLast$1 = (run) => {
  return slice$1(0, run.end - run.start - 1, run);
};
var dropLast2 = (attributedString) => {
  const string = dropLast(attributedString.string);
  const runs = adjust(-1, dropLast$1, attributedString.runs);
  return Object.assign({}, attributedString, { string, runs });
};
var ALIGNMENT_FACTORS = { center: 0.5, right: 1 };
var removeNewLine = (line2) => {
  return last(line2.string) === "\n" ? dropLast2(line2) : line2;
};
var getOverflowLeft = (line2) => {
  return leadingOffset(line2) + (line2.overflowLeft || 0);
};
var getOverflowRight = (line2) => {
  return trailingOffset(line2) + (line2.overflowRight || 0);
};
var adjustOverflow = (line2) => {
  const overflowLeft = getOverflowLeft(line2);
  const overflowRight = getOverflowRight(line2);
  const x = line2.box.x - overflowLeft;
  const width = line2.box.width + overflowLeft + overflowRight;
  const box = Object.assign({}, line2.box, { x, width });
  return Object.assign({}, line2, { box, overflowLeft, overflowRight });
};
var justifyLine$1 = (engines2, options, align) => {
  return (line2) => {
    const lineWidth = advanceWidth(line2);
    const alignFactor = ALIGNMENT_FACTORS[align] || 0;
    const remainingWidth = Math.max(0, line2.box.width - lineWidth);
    const shouldJustify = align === "justify" || lineWidth > line2.box.width;
    const x = line2.box.x + remainingWidth * alignFactor;
    const box = Object.assign({}, line2.box, { x });
    const newLine = Object.assign({}, line2, { box });
    return shouldJustify ? engines2.justification(options)(newLine) : newLine;
  };
};
var finalizeLine = (line2) => {
  let lineAscent = 0;
  let lineDescent = 0;
  let lineHeight = 0;
  let lineXAdvance = 0;
  const runs = line2.runs.map((run) => {
    const height2 = height$1(run);
    const ascent2 = ascent$1(run);
    const descent$1 = descent(run);
    const xAdvance = advanceWidth$1(run);
    lineHeight = Math.max(lineHeight, height2);
    lineAscent = Math.max(lineAscent, ascent2);
    lineDescent = Math.max(lineDescent, descent$1);
    lineXAdvance += xAdvance;
    return Object.assign({}, run, { height: height2, ascent: ascent2, descent: descent$1, xAdvance });
  });
  return Object.assign({}, line2, {
    runs,
    height: lineHeight,
    ascent: lineAscent,
    descent: lineDescent,
    xAdvance: lineXAdvance
  });
};
var finalizeBlock = (engines2, options) => {
  return (line2, index3, lines) => {
    var _a, _b;
    const isLastFragment = index3 === lines.length - 1;
    const style = ((_b = (_a = line2.runs) == null ? void 0 : _a[0]) == null ? void 0 : _b.attributes) || {};
    const align = isLastFragment ? style.alignLastLine : style.align;
    return compose(finalizeLine, engines2.textDecoration(), justifyLine$1(engines2, options, align), adjustOverflow, removeNewLine)(line2);
  };
};
var finalizeFragments = (engines2, options) => {
  return (paragraphs) => {
    const blockFinalizer = finalizeBlock(engines2, options);
    return paragraphs.map((paragraph) => paragraph.map(blockFinalizer));
  };
};
var ATTACHMENT_CODE = 65532;
var isReplaceGlyph = (glyph) => glyph.codePoints.includes(ATTACHMENT_CODE);
var resolveRunAttachments = (run) => {
  var _a;
  if (!run.positions)
    return run;
  const glyphs = run.glyphs || [];
  const attachment = ((_a = run.attributes) == null ? void 0 : _a.attachment) || {};
  const positions = run.positions.map((position, i3) => {
    const glyph = glyphs[i3];
    if (attachment && attachment.width && isReplaceGlyph(glyph)) {
      return Object.assign({}, position, { xAdvance: attachment.width });
    }
    return Object.assign({}, position);
  });
  return Object.assign({}, run, { positions });
};
var resolveAttachments = () => {
  return (attributedString) => {
    const runs = attributedString.runs.map(resolveRunAttachments);
    const res = Object.assign({}, attributedString, { runs });
    return res;
  };
};
var applyAttributes = (a3) => {
  return {
    align: a3.align || (a3.direction === "rtl" ? "right" : "left"),
    alignLastLine: a3.alignLastLine || (a3.align === "justify" ? "left" : a3.align || "left"),
    attachment: a3.attachment || null,
    backgroundColor: a3.backgroundColor || null,
    bullet: a3.bullet || null,
    characterSpacing: a3.characterSpacing || 0,
    color: a3.color || "black",
    direction: a3.direction || "ltr",
    features: a3.features || [],
    fill: a3.fill !== false,
    font: a3.font || null,
    fontSize: a3.fontSize || 12,
    hangingPunctuation: a3.hangingPunctuation || false,
    hyphenationFactor: a3.hyphenationFactor || 0,
    indent: a3.indent || 0,
    justificationFactor: a3.justificationFactor || 1,
    lineHeight: a3.lineHeight || null,
    lineSpacing: a3.lineSpacing || 0,
    link: a3.link || null,
    marginLeft: a3.marginLeft || a3.margin || 0,
    marginRight: a3.marginRight || a3.margin || 0,
    opacity: a3.opacity,
    paddingTop: a3.paddingTop || a3.padding || 0,
    paragraphSpacing: a3.paragraphSpacing || 0,
    script: a3.script || null,
    shrinkFactor: a3.shrinkFactor || 0,
    strike: a3.strike || false,
    strikeColor: a3.strikeColor || a3.color || "black",
    strikeStyle: a3.strikeStyle || "solid",
    stroke: a3.stroke || false,
    underline: a3.underline || false,
    underlineColor: a3.underlineColor || a3.color || "black",
    underlineStyle: a3.underlineStyle || "solid",
    verticalAlign: a3.verticalAlign || null,
    wordSpacing: a3.wordSpacing || 0,
    yOffset: a3.yOffset || 0
  };
};
var applyRunStyles = (run) => {
  const attributes2 = applyAttributes(run.attributes);
  return Object.assign({}, run, { attributes: attributes2 });
};
var applyDefaultStyles = () => {
  return (attributedString) => {
    const string = attributedString.string || "";
    const runs = (attributedString.runs || []).map(applyRunStyles);
    return { string, runs };
  };
};
var verticalAlignment = () => {
  return (attributedString) => {
    attributedString.runs.forEach((run) => {
      const { attributes: attributes2 } = run;
      const { verticalAlign } = attributes2;
      if (verticalAlign === "sub") {
        attributes2.yOffset = -0.2;
      } else if (verticalAlign === "super") {
        attributes2.yOffset = 0.4;
      }
    });
    return attributedString;
  };
};
var bidi$1 = bidi_default();
var getBidiLevels = (runs) => {
  return runs.reduce((acc, run) => {
    const length2 = run.end - run.start;
    const levels = repeat(run.attributes.bidiLevel, length2);
    return acc.concat(levels);
  }, []);
};
var mirrorString = () => {
  return (attributedString) => {
    const levels = getBidiLevels(attributedString.runs);
    let updatedString = "";
    attributedString.string.split("").forEach((char, index3) => {
      const isRTL = levels[index3] % 2 === 1;
      const mirroredChar = isRTL ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index3)) : null;
      updatedString += mirroredChar || char;
    });
    const result = {
      ...attributedString,
      string: updatedString
    };
    return result;
  };
};
var layoutEngine = (engines2) => {
  return (attributedString, container, options = {}) => {
    const processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines2, options), generateGlyphs(), mirrorString(), preprocessRuns(engines2));
    const processParagraphs = (paragraphs) => paragraphs.map(processParagraph);
    return compose(finalizeFragments(engines2, options), bidiReordering(), typesetter(engines2, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);
  };
};
var bidi = bidi_default();
var bidiEngine = () => {
  return (attributedString) => {
    var _a;
    const { string } = attributedString;
    const direction = (_a = attributedString.runs[0]) == null ? void 0 : _a.attributes.direction;
    const { levels } = bidi.getEmbeddingLevels(string, direction);
    let lastLevel = null;
    let lastIndex = 0;
    let index3 = 0;
    const runs = [];
    for (let i3 = 0; i3 < levels.length; i3 += 1) {
      const level = levels[i3];
      if (level !== lastLevel) {
        if (lastLevel !== null) {
          runs.push({
            start: lastIndex,
            end: index3,
            attributes: { bidiLevel: lastLevel }
          });
        }
        lastIndex = index3;
        lastLevel = level;
      }
      index3 += 1;
    }
    if (lastIndex < string.length) {
      runs.push({
        start: lastIndex,
        end: string.length,
        attributes: { bidiLevel: lastLevel }
      });
    }
    const result = { string, runs };
    return result;
  };
};
var INFINITY = 1e4;
var getNextBreakpoint = (subnodes, widths, lineNumber) => {
  let position = null;
  let minimumBadness = Infinity;
  const sum = { width: 0, stretch: 0, shrink: 0 };
  const lineLength = widths[Math.min(lineNumber, widths.length - 1)];
  const calculateRatio = (node) => {
    const stretch = "stretch" in node ? node.stretch : null;
    if (sum.width < lineLength) {
      if (!stretch)
        return INFINITY;
      return sum.stretch - stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;
    }
    const shrink = "shrink" in node ? node.shrink : null;
    if (sum.width > lineLength) {
      if (!shrink)
        return INFINITY;
      return sum.shrink - shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;
    }
    return 0;
  };
  for (let i3 = 0; i3 < subnodes.length; i3 += 1) {
    const node = subnodes[i3];
    if (node.type === "box") {
      sum.width += node.width;
    }
    if (node.type === "glue") {
      sum.width += node.width;
      sum.stretch += node.stretch;
      sum.shrink += node.shrink;
    }
    if (sum.width - sum.shrink > lineLength) {
      if (position === null) {
        let j = i3 === 0 ? i3 + 1 : i3;
        while (j < subnodes.length && (subnodes[j].type === "glue" || subnodes[j].type === "penalty")) {
          j++;
        }
        position = j - 1;
      }
      break;
    }
    if (node.type === "penalty" || node.type === "glue") {
      const ratio = calculateRatio(node);
      const penalty = node.type === "penalty" ? node.penalty : 0;
      const badness = 100 * Math.abs(ratio) ** 3 + penalty;
      if (minimumBadness >= badness) {
        position = i3;
        minimumBadness = badness;
      }
    }
  }
  return sum.width - sum.shrink > lineLength ? position : null;
};
var applyBestFit = (nodes, widths) => {
  let count = 0;
  let lineNumber = 0;
  let subnodes = nodes;
  const breakpoints = [0];
  while (subnodes.length > 0) {
    const breakpoint2 = getNextBreakpoint(subnodes, widths, lineNumber);
    if (breakpoint2 !== null) {
      count += breakpoint2;
      breakpoints.push(count);
      subnodes = subnodes.slice(breakpoint2 + 1, subnodes.length);
      count++;
      lineNumber++;
    } else {
      subnodes = [];
    }
  }
  return breakpoints;
};
var LinkedListNode = class {
  constructor(data2) {
    __publicField(this, "data");
    __publicField(this, "prev");
    __publicField(this, "next");
    this.data = data2;
    this.prev = null;
    this.next = null;
  }
};
var LinkedList = class {
  constructor() {
    __publicField(this, "head");
    __publicField(this, "tail");
    __publicField(this, "listSize");
    __publicField(this, "listLength");
    this.head = null;
    this.tail = null;
    this.listSize = 0;
    this.listLength = 0;
  }
  isLinked(node) {
    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());
  }
  size() {
    return this.listSize;
  }
  isEmpty() {
    return this.listSize === 0;
  }
  first() {
    return this.head;
  }
  last() {
    return this.last;
  }
  forEach(callback) {
    let node = this.head;
    while (node !== null) {
      callback(node);
      node = node.next;
    }
  }
  at(i3) {
    let node = this.head;
    let index3 = 0;
    if (i3 >= this.listLength || i3 < 0) {
      return null;
    }
    while (node !== null) {
      if (i3 === index3) {
        return node;
      }
      node = node.next;
      index3 += 1;
    }
    return null;
  }
  insertAfter(node, newNode) {
    if (!this.isLinked(node))
      return this;
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next === null) {
      this.tail = newNode;
    } else {
      node.next.prev = newNode;
    }
    node.next = newNode;
    this.listSize += 1;
    return this;
  }
  insertBefore(node, newNode) {
    if (!this.isLinked(node))
      return this;
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev === null) {
      this.head = newNode;
    } else {
      node.prev.next = newNode;
    }
    node.prev = newNode;
    this.listSize += 1;
    return this;
  }
  push(node) {
    if (this.head === null) {
      this.unshift(node);
    } else {
      this.insertAfter(this.tail, node);
    }
    return this;
  }
  unshift(node) {
    if (this.head === null) {
      this.head = node;
      this.tail = node;
      node.prev = null;
      node.next = null;
      this.listSize += 1;
    } else {
      this.insertBefore(this.head, node);
    }
    return this;
  }
  remove(node) {
    if (!this.isLinked(node))
      return this;
    if (node.prev === null) {
      this.head = node.next;
    } else {
      node.prev.next = node.next;
    }
    if (node.next === null) {
      this.tail = node.prev;
    } else {
      node.next.prev = node.prev;
    }
    this.listSize -= 1;
    return this;
  }
};
__publicField(LinkedList, "Node", LinkedListNode);
function breakpoint(position, demerits, line2, fitnessClass, totals, previous) {
  return {
    position,
    demerits,
    line: line2,
    fitnessClass,
    totals: totals || {
      width: 0,
      stretch: 0,
      shrink: 0
    },
    previous
  };
}
function computeCost(nodes, lineLengths, sum, end2, active, currentLine) {
  let width = sum.width - active.totals.width;
  let stretch = 0;
  let shrink = 0;
  const lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];
  if (nodes[end2].type === "penalty") {
    width += nodes[end2].width;
  }
  if (width < lineLength) {
    stretch = sum.stretch - active.totals.stretch;
    if (stretch > 0) {
      return (lineLength - width) / stretch;
    }
    return linebreak.infinity;
  }
  if (width > lineLength) {
    shrink = sum.shrink - active.totals.shrink;
    if (shrink > 0) {
      return (lineLength - width) / shrink;
    }
    return linebreak.infinity;
  }
  return 0;
}
function computeSum(nodes, sum, breakPointIndex) {
  const result = {
    width: sum.width,
    stretch: sum.stretch,
    shrink: sum.shrink
  };
  for (let i3 = breakPointIndex; i3 < nodes.length; i3 += 1) {
    const node = nodes[i3];
    if (node.type === "glue") {
      result.width += node.width;
      result.stretch += node.stretch;
      result.shrink += node.shrink;
    } else if (node.type === "box" || node.type === "penalty" && node.penalty === -linebreak.infinity && i3 > breakPointIndex) {
      break;
    }
  }
  return result;
}
function findBestBreakpoints(activeNodes) {
  const breakpoints = [];
  if (activeNodes.size() === 0)
    return [];
  let tmp = { data: { demerits: Infinity } };
  activeNodes.forEach((node) => {
    if (node.data.demerits < tmp.data.demerits) {
      tmp = node;
    }
  });
  while (tmp !== null) {
    breakpoints.push(tmp.data.position);
    tmp = tmp.data.previous;
  }
  return breakpoints.reverse();
}
var linebreak = (nodes, availableWidths, tolerance) => {
  const options = {
    demerits: { line: 10, flagged: 100, fitness: 3e3 },
    tolerance: tolerance || 3
  };
  const activeNodes = new LinkedList();
  const sum = { width: 0, stretch: 0, shrink: 0 };
  const lineLengths = availableWidths;
  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, void 0, null)));
  function mainLoop(node, index3, nodes2) {
    let active = activeNodes.first();
    while (active !== null) {
      let currentLine = 0;
      const candidates = [
        { active: void 0, demerits: Infinity },
        { active: void 0, demerits: Infinity },
        { active: void 0, demerits: Infinity },
        { active: void 0, demerits: Infinity }
      ];
      while (active !== null) {
        currentLine = active.data.line + 1;
        const ratio = computeCost(nodes2, lineLengths, sum, index3, active.data, currentLine);
        if (ratio < -1 || node.type === "penalty" && node.penalty === -linebreak.infinity) {
          activeNodes.remove(active);
        }
        if (ratio >= -1 && ratio <= options.tolerance) {
          const badness = 100 * Math.pow(Math.abs(ratio), 3);
          let demerits = 0;
          if (node.type === "penalty" && node.penalty >= 0) {
            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2);
          } else if (node.type === "penalty" && node.penalty !== -linebreak.infinity) {
            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2);
          } else {
            demerits = Math.pow(options.demerits.line + badness, 2);
          }
          if (node.type === "penalty" && nodes2[active.data.position].type === "penalty") {
            demerits += options.demerits.flagged * node.flagged * // @ts-expect-error node is penalty here
            nodes2[active.data.position].flagged;
          }
          let currentClass;
          if (ratio < -0.5) {
            currentClass = 0;
          } else if (ratio <= 0.5) {
            currentClass = 1;
          } else if (ratio <= 1) {
            currentClass = 2;
          } else {
            currentClass = 3;
          }
          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {
            demerits += options.demerits.fitness;
          }
          demerits += active.data.demerits;
          if (demerits < candidates[currentClass].demerits) {
            candidates[currentClass] = { active, demerits };
          }
        }
        active = active.next;
        if (active !== null && active.data.line >= currentLine) {
          break;
        }
      }
      const tmpSum = computeSum(nodes2, sum, index3);
      for (let fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {
        const candidate = candidates[fitnessClass];
        if (candidate.demerits === Infinity)
          continue;
        const newNode = new LinkedList.Node(breakpoint(index3, candidate.demerits, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));
        if (active !== null) {
          activeNodes.insertBefore(active, newNode);
        } else {
          activeNodes.push(newNode);
        }
      }
    }
  }
  nodes.forEach((node, index3, nodes2) => {
    if (node.type === "box") {
      sum.width += node.width;
      return;
    }
    if (node.type === "glue") {
      const precedesBox = index3 > 0 && nodes2[index3 - 1].type === "box";
      if (precedesBox)
        mainLoop(node, index3, nodes2);
      sum.width += node.width;
      sum.stretch += node.stretch;
      sum.shrink += node.shrink;
      return;
    }
    if (node.type === "penalty" && node.penalty !== linebreak.infinity) {
      mainLoop(node, index3, nodes2);
    }
  });
  return findBestBreakpoints(activeNodes);
};
linebreak.infinity = 1e4;
linebreak.glue = (width, start2, end2, stretch, shrink) => ({
  type: "glue",
  start: start2,
  end: end2,
  width,
  stretch,
  shrink
});
linebreak.box = (width, start2, end2, hyphenated = false) => ({
  type: "box",
  width,
  start: start2,
  end: end2,
  hyphenated
});
linebreak.penalty = (width, penalty, flagged) => ({
  type: "penalty",
  width,
  penalty,
  flagged
});
var add = (index3, run) => {
  const start2 = run.start + index3;
  const end2 = run.end + index3;
  return Object.assign({}, run, { start: start2, end: end2 });
};
var length = (run) => {
  return run.end - run.start;
};
var concat3 = (runA, runB) => {
  const end2 = runA.end + length(runB);
  const glyphs = (runA.glyphs || []).concat(runB.glyphs || []);
  const positions = (runA.positions || []).concat(runB.positions || []);
  const attributes2 = Object.assign({}, runA.attributes, runB.attributes);
  const runAIndices = runA.glyphIndices || [];
  const runALastIndex = last(runAIndices) || 0;
  const runBIndices = (runB.glyphIndices || []).map((i3) => i3 + runALastIndex + 1);
  const glyphIndices = normalize3(runAIndices.concat(runBIndices));
  return Object.assign({}, runA, {
    end: end2,
    glyphs,
    positions,
    attributes: attributes2,
    glyphIndices
  });
};
var insertGlyph$1 = (index3, glyph, run) => {
  if (!glyph)
    return run;
  const leadingRun = slice$1(0, index3, run);
  const trailingRun = slice$1(index3, Infinity, run);
  return concat3(append$1(glyph, leadingRun), trailingRun);
};
var insert = (index3, value2, run) => {
  const font = getFont(run);
  const glyph = isNumber3(value2) ? fromCodePoint(value2, font) : value2;
  return insertGlyph$1(index3, glyph, run);
};
var runIndexAt = (index3, attributedString) => {
  return runIndexAt$1(index3, attributedString.runs);
};
var insertGlyph = (index3, glyph, attributedString) => {
  const runIndex = runIndexAt(index3, attributedString);
  if (runIndex === -1)
    return append(glyph, attributedString);
  const codePoints = [glyph];
  const string = attributedString.string.slice(0, index3) + stringFromCodePoints(codePoints) + attributedString.string.slice(index3);
  const runs = attributedString.runs.map((run, i3) => {
    if (i3 === runIndex)
      return insert(index3 - run.start, glyph, run);
    if (i3 > runIndex)
      return add(codePoints.length, run);
    return run;
  });
  return Object.assign({}, attributedString, { string, runs });
};
var advanceWidthBetween$1 = (start2, end2, run) => {
  const runStart = run.start || 0;
  const glyphStartIndex = Math.max(0, glyphIndexAt(start2 - runStart, run));
  const glyphEndIndex = Math.max(0, glyphIndexAt(end2 - runStart, run));
  const positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);
  return advanceWidth$2(positions);
};
var advanceWidthBetween = (start2, end2, attributedString) => {
  const runs = filter(start2, end2, attributedString.runs);
  return runs.reduce((acc, run) => acc + advanceWidthBetween$1(start2, end2, run), 0);
};
var HYPHEN2 = 45;
var TOLERANCE_STEPS = 5;
var TOLERANCE_LIMIT = 50;
var opts = {
  width: 3,
  stretch: 6,
  shrink: 9
};
var breakLines = (attributedString, nodes, breaks) => {
  let start2 = 0;
  let end2 = null;
  const lines = breaks.reduce((acc, breakPoint) => {
    const node = nodes[breakPoint];
    const prevNode = nodes[breakPoint - 1];
    if (breakPoint === nodes.length - 1)
      return acc;
    let line2;
    if (node.type === "penalty") {
      end2 = prevNode.end;
      line2 = slice3(start2, end2, attributedString);
      line2 = insertGlyph(line2.string.length, HYPHEN2, line2);
    } else {
      end2 = node.end;
      line2 = slice3(start2, end2, attributedString);
    }
    start2 = end2;
    return [...acc, line2];
  }, []);
  lines.push(slice3(start2, attributedString.string.length, attributedString));
  return lines;
};
var getNodes = (attributedString, { align }, options) => {
  let start2 = 0;
  const hyphenWidth = 5;
  const { syllables } = attributedString;
  const hyphenPenalty = options.hyphenationPenalty || (align === "justify" ? 100 : 600);
  const result = syllables.reduce((acc, s2, index3) => {
    const width = advanceWidthBetween(start2, start2 + s2.length, attributedString);
    if (s2.trim() === "") {
      const stretch = width * opts.width / opts.stretch;
      const shrink = width * opts.width / opts.shrink;
      const end2 = start2 + s2.length;
      acc.push(linebreak.glue(width, start2, end2, stretch, shrink));
    } else {
      const hyphenated = syllables[index3 + 1] !== " ";
      const end2 = start2 + s2.length;
      acc.push(linebreak.box(width, start2, end2, hyphenated));
      if (syllables[index3 + 1] && hyphenated) {
        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));
      }
    }
    start2 += s2.length;
    return acc;
  }, []);
  result.push(linebreak.glue(0, start2, start2, linebreak.infinity, 0));
  result.push(linebreak.penalty(0, -linebreak.infinity, 1));
  return result;
};
var getAttributes = (attributedString) => {
  var _a, _b;
  return ((_b = (_a = attributedString.runs) == null ? void 0 : _a[0]) == null ? void 0 : _b.attributes) || {};
};
var linebreaker = (options) => {
  return (attributedString, availableWidths) => {
    let tolerance = options.tolerance || 4;
    const attributes2 = getAttributes(attributedString);
    const nodes = getNodes(attributedString, attributes2, options);
    let breaks = linebreak(nodes, availableWidths, tolerance);
    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {
      tolerance += TOLERANCE_STEPS;
      breaks = linebreak(nodes, availableWidths, tolerance);
    }
    if (breaks.length === 0 || breaks.length === 1 && breaks[0] === 0) {
      breaks = applyBestFit(nodes, availableWidths);
    }
    return breakLines(attributedString, nodes, breaks.slice(1));
  };
};
var Direction;
(function(Direction3) {
  Direction3[Direction3["GROW"] = 0] = "GROW";
  Direction3[Direction3["SHRINK"] = 1] = "SHRINK";
})(Direction || (Direction = {}));
var WHITESPACE_PRIORITY = 1;
var LETTER_PRIORITY = 2;
var EXPAND_WHITESPACE_FACTOR = {
  before: 0.5,
  after: 0.5,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};
var EXPAND_CHAR_FACTOR = {
  before: 0.14453125,
  // 37/256
  after: 0.14453125,
  priority: LETTER_PRIORITY,
  unconstrained: false
};
var SHRINK_WHITESPACE_FACTOR = {
  before: -0.04296875,
  // -11/256
  after: -0.04296875,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};
var SHRINK_CHAR_FACTOR = {
  before: -0.04296875,
  after: -0.04296875,
  priority: LETTER_PRIORITY,
  unconstrained: false
};
var getCharFactor = (direction, options) => {
  const expandCharFactor = options.expandCharFactor || {};
  const shrinkCharFactor = options.shrinkCharFactor || {};
  return direction === Direction.GROW ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);
};
var getWhitespaceFactor = (direction, options) => {
  const expandWhitespaceFactor = options.expandWhitespaceFactor || {};
  const shrinkWhitespaceFactor2 = options.shrinkWhitespaceFactor || {};
  return direction === Direction.GROW ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor2);
};
var factor = (direction, options) => (glyphs) => {
  const charFactor = getCharFactor(direction, options);
  const whitespaceFactor = getWhitespaceFactor(direction, options);
  const factors = [];
  for (let index3 = 0; index3 < glyphs.length; index3 += 1) {
    let f2;
    const glyph = glyphs[index3];
    if (isWhiteSpace(glyph)) {
      f2 = Object.assign({}, whitespaceFactor);
      if (index3 === glyphs.length - 1) {
        f2.before = 0;
        if (index3 > 0) {
          factors[index3 - 1].after = 0;
        }
      }
    } else if (glyph.isMark && index3 > 0) {
      f2 = Object.assign({}, factors[index3 - 1]);
      f2.before = 0;
      factors[index3 - 1].after = 0;
    } else {
      f2 = Object.assign({}, charFactor);
    }
    factors.push(f2);
  }
  return factors;
};
var getFactors = (gap, line2, options) => {
  const direction = gap > 0 ? Direction.GROW : Direction.SHRINK;
  const getFactor = factor(direction, options);
  const factors = line2.runs.reduce((acc, run) => {
    return acc.concat(getFactor(run.glyphs));
  }, []);
  factors[0].before = 0;
  factors[factors.length - 1].after = 0;
  return factors;
};
var KASHIDA_PRIORITY = 0;
var NULL_PRIORITY = 3;
var getDistances = (gap, factors) => {
  let total = 0;
  const priorities = [];
  const unconstrained = [];
  for (let priority2 = KASHIDA_PRIORITY; priority2 <= NULL_PRIORITY; priority2 += 1) {
    priorities[priority2] = unconstrained[priority2] = 0;
  }
  for (let j = 0; j < factors.length; j += 1) {
    const f2 = factors[j];
    const sum = f2.before + f2.after;
    total += sum;
    priorities[f2.priority] += sum;
    if (f2.unconstrained) {
      unconstrained[f2.priority] += sum;
    }
  }
  let highestPriority = -1;
  let highestPrioritySum = 0;
  let remainingGap = gap;
  let priority;
  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {
    const prioritySum = priorities[priority];
    if (prioritySum !== 0) {
      if (highestPriority === -1) {
        highestPriority = priority;
        highestPrioritySum = prioritySum;
      }
      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {
        priorities[priority] = remainingGap / prioritySum;
        unconstrained[priority] = 0;
        remainingGap = 0;
        break;
      }
      priorities[priority] = 1;
      remainingGap -= prioritySum;
      if (unconstrained[priority] !== 0) {
        unconstrained[priority] = remainingGap / unconstrained[priority];
        remainingGap = 0;
        break;
      }
    }
  }
  for (let p2 = priority + 1; p2 <= NULL_PRIORITY; p2 += 1) {
    priorities[p2] = 0;
    unconstrained[p2] = 0;
  }
  if (remainingGap > 0 && highestPriority > -1) {
    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;
  }
  const distances = [];
  for (let index3 = 0; index3 < factors.length; index3 += 1) {
    const f2 = factors[index3];
    const next = factors[index3 + 1];
    let dist = f2.after * priorities[f2.priority];
    if (next) {
      dist += next.before * priorities[next.priority];
    }
    if (f2.unconstrained) {
      dist += f2.after * unconstrained[f2.priority];
      if (next) {
        dist += next.before * unconstrained[next.priority];
      }
    }
    distances.push(dist);
  }
  return distances;
};
var justifyLine = (distances, line2) => {
  let index3 = 0;
  for (const run of line2.runs) {
    for (const position of run.positions) {
      position.xAdvance += distances[index3++];
    }
  }
  return line2;
};
var justification = (options) => {
  return (line2) => {
    const gap = line2.box.width - advanceWidth(line2);
    if (gap === 0)
      return line2;
    const factors = getFactors(gap, line2, options);
    const distances = getDistances(gap, factors);
    return justifyLine(distances, line2);
  };
};
var ascent = (attributedString) => {
  const reducer = (acc, run) => Math.max(acc, ascent$1(run));
  return attributedString.runs.reduce(reducer, 0);
};
var BASE_FONT_SIZE = 12;
var textDecoration = () => (line2) => {
  let x = line2.overflowLeft || 0;
  const overflowRight = line2.overflowRight || 0;
  const maxX = advanceWidth(line2) - overflowRight;
  line2.decorationLines = [];
  for (let i3 = 0; i3 < line2.runs.length; i3 += 1) {
    const run = line2.runs[i3];
    const width = Math.min(maxX - x, advanceWidth$1(run));
    const thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));
    if (run.attributes.underline) {
      const rect = {
        x,
        y: ascent(line2) + thickness * 2,
        width,
        height: thickness
      };
      const decorationLine = {
        rect,
        opacity: run.attributes.opacity,
        color: run.attributes.underlineColor || "black",
        style: run.attributes.underlineStyle || "solid"
      };
      line2.decorationLines.push(decorationLine);
    }
    if (run.attributes.strike) {
      const y2 = ascent(line2) - ascent$1(run) / 3;
      const rect = { x, y: y2, width, height: thickness };
      const decorationLine = {
        rect,
        opacity: run.attributes.opacity,
        color: run.attributes.strikeColor || "black",
        style: run.attributes.strikeStyle || "solid"
      };
      line2.decorationLines.push(decorationLine);
    }
    x += width;
  }
  return line2;
};
var ignoredScripts = ["Common", "Inherited", "Unknown"];
var scriptItemizer = () => {
  return (attributedString) => {
    const { string } = attributedString;
    let lastScript = "Unknown";
    let lastIndex = 0;
    let index3 = 0;
    const runs = [];
    if (!string)
      return empty();
    for (let i3 = 0; i3 < string.length; i3 += 1) {
      const char = string[i3];
      const codePoint = char.codePointAt(0);
      const script = $747425b437e121da$export$2e2bcd8739ae039.getScript(codePoint);
      if (script !== lastScript && !ignoredScripts.includes(script)) {
        if (lastScript !== "Unknown") {
          runs.push({
            start: lastIndex,
            end: index3,
            attributes: { script: lastScript }
          });
        }
        lastIndex = index3;
        lastScript = script;
      }
      index3 += char.length;
    }
    if (lastIndex < string.length) {
      runs.push({
        start: lastIndex,
        end: string.length,
        attributes: { script: lastScript }
      });
    }
    const result = { string, runs };
    return result;
  };
};
var SOFT_HYPHEN2 = "";
var hyphenator = (0, import_hyphen.default)(import_en_us.default);
var splitHyphen = (word) => {
  return word.split(SOFT_HYPHEN2);
};
var cache = {};
var getParts = (word) => {
  const base = word.includes(SOFT_HYPHEN2) ? word : hyphenator(word);
  return splitHyphen(base);
};
var wordHyphenation = () => {
  return (word) => {
    const cacheKey = `_${word}`;
    if (isNil(word))
      return [];
    if (cache[cacheKey])
      return cache[cacheKey];
    cache[cacheKey] = getParts(word);
    return cache[cacheKey];
  };
};

// node_modules/yoga-layout/dist/binaries/yoga-wasm-base64-esm.js
var loadYoga = (() => {
  var _scriptDir = import.meta.url;
  return function(loadYoga4) {
    loadYoga4 = loadYoga4 || {};
    var h2;
    h2 || (h2 = typeof loadYoga4 !== "undefined" ? loadYoga4 : {});
    var aa, ca;
    h2.ready = new Promise(function(a3, b2) {
      aa = a3;
      ca = b2;
    });
    var da = Object.assign({}, h2), q = "";
    "undefined" != typeof document && document.currentScript && (q = document.currentScript.src);
    _scriptDir && (q = _scriptDir);
    0 !== q.indexOf("blob:") ? q = q.substr(0, q.replace(/[?#].*/, "").lastIndexOf("/") + 1) : q = "";
    var ea = h2.print || console.log.bind(console), v2 = h2.printErr || console.warn.bind(console);
    Object.assign(h2, da);
    da = null;
    var w;
    h2.wasmBinary && (w = h2.wasmBinary);
    var noExitRuntime = h2.noExitRuntime || true;
    "object" != typeof WebAssembly && x("no native wasm support detected");
    var fa, ha = false;
    function z(a3, b2, c3) {
      c3 = b2 + c3;
      for (var d2 = ""; !(b2 >= c3); ) {
        var e3 = a3[b2++];
        if (!e3) break;
        if (e3 & 128) {
          var f2 = a3[b2++] & 63;
          if (192 == (e3 & 224)) d2 += String.fromCharCode((e3 & 31) << 6 | f2);
          else {
            var g2 = a3[b2++] & 63;
            e3 = 224 == (e3 & 240) ? (e3 & 15) << 12 | f2 << 6 | g2 : (e3 & 7) << 18 | f2 << 12 | g2 << 6 | a3[b2++] & 63;
            65536 > e3 ? d2 += String.fromCharCode(e3) : (e3 -= 65536, d2 += String.fromCharCode(55296 | e3 >> 10, 56320 | e3 & 1023));
          }
        } else d2 += String.fromCharCode(e3);
      }
      return d2;
    }
    var ia, ja, A, C, ka, D, E, la, ma;
    function na() {
      var a3 = fa.buffer;
      ia = a3;
      h2.HEAP8 = ja = new Int8Array(a3);
      h2.HEAP16 = C = new Int16Array(a3);
      h2.HEAP32 = D = new Int32Array(a3);
      h2.HEAPU8 = A = new Uint8Array(a3);
      h2.HEAPU16 = ka = new Uint16Array(a3);
      h2.HEAPU32 = E = new Uint32Array(a3);
      h2.HEAPF32 = la = new Float32Array(a3);
      h2.HEAPF64 = ma = new Float64Array(a3);
    }
    var oa, pa = [], qa = [], ra = [];
    function sa() {
      var a3 = h2.preRun.shift();
      pa.unshift(a3);
    }
    var F = 0, ta = null, G2 = null;
    function x(a3) {
      if (h2.onAbort) h2.onAbort(a3);
      a3 = "Aborted(" + a3 + ")";
      v2(a3);
      ha = true;
      a3 = new WebAssembly.RuntimeError(a3 + ". Build with -sASSERTIONS for more info.");
      ca(a3);
      throw a3;
    }
    function ua(a3) {
      return a3.startsWith("data:application/octet-stream;base64,");
    }
    var H;
    H = "data:application/octet-stream;base64,AGFzbQEAAAABugM3YAF/AGACf38AYAF/AX9gA39/fwBgAn98AGACf38Bf2ADf39/AX9gBH9/f30BfWADf398AGAAAGAEf39/fwBgAX8BfGACf38BfGAFf39/f38Bf2AAAX9gA39/fwF9YAZ/f31/fX8AYAV/f39/fwBgAn9/AX1gBX9/f319AX1gAX8BfWADf35/AX5gB39/f39/f38AYAZ/f39/f38AYAR/f39/AX9gBn9/f319fQF9YAR/f31/AGADf399AX1gBn98f39/fwF/YAR/fHx/AGACf30AYAh/f39/f39/fwBgDX9/f39/f39/f39/f38AYAp/f39/f39/f39/AGAFf39/f38BfGAEfHx/fwF9YA1/fX1/f399fX9/f39/AX9gB39/f319f38AYAJ+fwF/YAN/fX0BfWABfAF8YAN/fHwAYAR/f319AGAHf39/fX19fQF9YA1/fX99f31/fX19fX1/AX9gC39/f39/f399fX19AX9gCH9/f39/f319AGAEf39+fgBgB39/f39/f38Bf2ACfH8BfGAFf398fH8AYAN/f38BfGAEf39/fABgA39/fQBgBn9/fX99fwF/ArUBHgFhAWEAHwFhAWIAAwFhAWMACQFhAWQAFgFhAWUAEQFhAWYAIAFhAWcAAAFhAWgAIQFhAWkAAwFhAWoAAAFhAWsAFwFhAWwACgFhAW0ABQFhAW4AAwFhAW8AAQFhAXAAFwFhAXEABgFhAXIAAAFhAXMAIgFhAXQACgFhAXUADQFhAXYAFgFhAXcAAgFhAXgAAwFhAXkAGAFhAXoAAgFhAUEAAQFhAUIAEQFhAUMAAQFhAUQAAAOiAqACAgMSBwcACRkDAAoRBgYKEwAPDxMBBiMTCgcHGgMUASQFJRQHAwMKCgMmAQYYDxobFAAKBw8KBwMDAgkCAAAFGwACBwIHBgIDAQMIDAABKAkHBQURACkZASoAAAIrLAIALQcHBy4HLwkFCgMCMA0xAgMJAgACAQYKAQIBBQEACQIFAQEABQAODQ0GFQIBHBUGAgkCEAAAAAUyDzMMBQYINAUCAwUODg41AgMCAgIDBgICNgIBDAwMAQsLCwsLCx0CAAIAAAABABABBQICAQMCEgMMCwEBAQEBAQsLAQICAwICAgICAgIDAgIICAEICAgEBAQEBAQEBAQABAQABAQEBAAE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GiABQQA2AvADIAFCADcC6AMgAigC7AMiAyACKALoAyIERwRAIAMgBGsiBEEASA0FIAEgBBAeIgM2AuwDIAEgAzYC6AMgASADIARqNgLwAyACKALoAyIEIAIoAuwDIghHBEADQCADIAQoAgA2AgAgA0EEaiEDIARBBGoiBCAIRw0ACwsgASADNgLsAwsgASACKQL0AzcC9AMgASACKAKEBDYChAQgASACKQL8AzcC/AMgAUEANgLkAwsgBSABNgIAIAEgADYC5AMLIAZBAWohBiAFQQRqIgUgB0cNAAsLDwsQAgALUAACQAJAAkACQAJAIAIOBAQAAQIDCyAAIAEgAUEwahBDDwsgACABIAFBMGogAxBEDwsgACABIAFBMGoQQg8LECQACyAAIAEgAUEwaiADEEULcAIBfwF9IwBBEGsiBCQAIARBCGogACABQQJ0QdwlaigCACACEDZDAADAfyEFAkACQAJAIAQtAAxBAWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwt5AgF/AX0jAEEQayIDJAAgA0EIaiAAIAFBAnRB7CVqKAIAIAIQU0MAAMB/IQQCQAJAAkAgAy0ADEEBaw4CAAECCyADKgIIIQQMAQsgAyoCCEMAAAAAlEMK1yM8lCEECyADQRBqJAAgBEMAAAAAl0MAAAAAIAQgBFsbC1QAAkACQAJAAkACQCACDgQEAAECAwsgACABIAFBwgBqEEMPCyAAIAEgAUHCAGogAxBEDwsgACABIAFBwgBqEEIPCxAkAAsgACABIAFBwgBqIAMQRQsvACAAIAJFQQF0IgIgASADEGAgACACIAEQS5IgACACIAEgAxB/IAAgAiABEFKSkgvOAQIDfwJ9IwBBEGsiAyQAQQEhBCADQQhqIABB/ABqIgUgACABQQF0akH2AGoiAS8BABAfAkACQCADKgIIIgcgAioCACIGXARAIAcgB1sEQCACLQAEIQIMAgsgBiAGXCEECyACLQAEIQIgBEUNACADLQAMIAJB/wFxRg0BCyAFIAEgBiACEDkDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCyADQRBqJAALzgECA38CfSMAQRBrIgMk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AWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwscACAAIAFBCCACpyACQiCIpyADpyADQiCIpxAVCwUAEFgACzkAIABFBEBBAA8LAn8gAUGAf3FBgL8DRiABQf8ATXJFBEBB/DtBGTYCAEF/DAELIAAgAToAAEEBCwvEAgACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQQlrDhIACgsMCgsCAwQFDAsMDAoLBwgJCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCwALIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LAAsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAQALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC84BAgN/An0jAEEQayIDJABBASEEIANBCGogAEH8AGoiBSAAIAFBAXRqQegAaiIBLwEAEB8CQAJAIAMqAggiByACKgIAIgZcBEAgByAHWwRAIAItAAQhAgwCCyAGIAZcIQQLIAItAAQhAiAERQ0AIAMtAAwgAkH/AXFGDQELIAUgASAGIAIQOQNAIAAtAAAiAUEEcQ0BIAAgAUEEcjoAACAAKAIQIgEEQCAAIAERAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLIANBEGokAAtdAQR/IAAoAgAhAgNAIAIsAAAiAxBXBEBBfyEEIAAgAkEBaiICNgIAIAFBzJmz5gBNBH9BfyADQTBrIgMgAUEKbCIEaiADIARB/////wdzShsFIAQLIQEMAQsLIAELrhQCEn8BfiMAQdAAayIIJAAgCCABNgJMIAhBN2ohFyAIQThqIRQCQAJAAkACQANAIAEhDSAHIA5B/////wdzSg0BIAcgDmohDgJAAkACQCANIgctAAAiCQRAA0ACQAJAIAlB/wFxIgFFBEAgByEBDAELIAFBJUcNASAH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IQEgAEIANwIEIAAgATYCACABIAA2AgQgAkEQaiQAIAALGwEBfyAABEAgACgCACIBBEAgARAjCyAAECMLC0kBAn9BBBAeIQFBIBAeIgBBADYCHCAAQoCAgICAgIDAPzcCFCAAQgA3AgwgAEEAOgAIIABBAzYCBCAAQQA2AgAgASAANgIAIAELIAAgAkEFR0EAIAIbRQRAQbgwIAMgBBBJDwsgAyAEEHALIgEBfiABIAKtIAOtQiCGhCAEIAARFQAiBUIgiKckASAFpwuoAQEFfyAAKAJUIgMoAgAhBSADKAIEIgQgACgCFCAAKAIcIgdrIgYgBCAGSRsiBgRAIAUgByAGECsaIAMgAygCACAGaiIFNgIAIAMgAygCBCAGayIENgIECyAEIAIgAiAESxsiBARAIAUgASAEECsaIAMgAygCACAEaiIFNgIAIAMgAygCBCAEazYCBAsgBUEAOgAAIAAgACgCLCIBNgIcIAAgATYCFCACCwQAQgALBABBAAuKBQIGfgJ/IAEgASgCAEEHakF4cSIBQRBqNgIAIAAhCSABKQMAIQMgASkDCCEGIwBBIGsiCCQAAkAgBkL///////////8AgyIEQoCAgICAgMCAPH0gBEKAgICAgIDA/8MAfVQEQCAGQgSGIANCPIiEIQQgA0L//////////w+DIgNCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhAgwCCyAEQoCAgICAgICAQH0hAiADQoCAgICAgICACFINASACIARCAYN8IQIMAQsgA1AgBEKAgICAgIDA//8AVCAEQoCAgICAgMD//wBRG0UEQCAGQgSGIANCPIiEQv////////8Dg0KAgICAgICA/P8AhCECDAELQoCAgICAgID4/wAhAiAEQv///////7//wwBWDQBCACECIARCMIinIgBBkfcASQ0AIAMhAiAGQv///////z+DQoCAgICAgMAAhCIFIQcCQCAAQYH3AGsiAUHAAHEEQCACIAFBQGqthiEHQgAhAgwBCyABRQ0AIAcgAa0iBIYgAkHAACABa62IhCEHIAIgBIYhAgsgCCACNwMQIAggBzcDGAJAQYH4ACAAayIAQcAAcQRAIAUgAEFAaq2IIQNCACEFDAELIABFDQAgBUHAACAAa62GIAMgAK0iAoiEIQMgBSACiCEFCyAIIAM3AwAgCCAF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ASAAKAIAIQAgASACQQFxBH8gASgCACAAaigCAAUgAAsRCwALYQECfyMAQRBrIgIkACABIAAoAgQiA0EBdWohASAAKAIAIQAgAiABIANBAXEEfyABKAIAIABqKAIABSAACxEBAEEQEB4iACACKQMINwMIIAAgAikDADcDACACQRBqJAAgAAtjAQJ/IwBBEGsiAyQAIAEgACgCBCIEQQF1aiEBIAAoAgAhACADIAEgAiAEQQFxBH8gASgCACAAaigCAAUgAAsRAwBBEBAeIgAgAykDCDcDCCAAIAMpAwA3AwAgA0EQaiQAIAALNwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEEAAs5AQF/IAEgACgCBCIEQQF1aiEBIAAoAgAhACABIAIgAyAEQQFxBH8gASgCACAAaigCAAUgAAsRCAALCQAgASAAEQIACwUAQcM7Cw8AIAEgACgCAGogAjYCAAsNACABIAAoAgBqKAIACxgBAX9BEBAeIgBCADcDCCAAQQA2AgAgAAsYAQF/QRAQHiIAQgA3AwAgAEIANwMIIAALDABBMBAeQQBBMBAqCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRHgALBQBBvjsLIQAgACABKAIAIAEgASwAC0EASBtBuzsgAigCABAQNgIACyoBAX9BDBAeIgFBADoABCABIAAoAgA2AgggAEEANgIAIAFB2Cc2AgAgAQsFAEG7OwsFAEG4OwshACAAIAEoAgAgASABLAALQQBIG0GkOyACKAIAEBA2AgAL2AEBBH8jAEEgayIDJAAgASgCACIEQfD///8HSQRAAkACQCAEQQtPBEAgBEEPckEBaiIFEB4hBiADIAVBgICAgHhyNgIQIAMgBjYCCCADIAQ2AgwgBCAGaiEFDAELIAMgBDoAEyADQQhqIgYgBGohBSAERQ0BCyAGIAFBBGogBBArGgsgBUEAOgAAIAMgAjYCACADQRhqIANBCGogAyAAEQMAIAMoAhgQHSADKAIYIgAQBiADKAIAEAYgAywAE0EASARAIAMoAggQIwsgA0EgaiQAIAAPCxACAAsqAQF/QQwQHiIBQQA6AAQgASAAKAIANgIIIABBADYCACABQeAmNgIA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AkEIaiAIIAYQHyACIAcgAC8AABAfQQEhAyACKgIIIgogAioCACILXAR/IAogClsNAyALIAtcBSADC0UNAiACLQAMIAItAARHDQILIABBAmohAEEBIQMgBCEGQQEhBCAGRQ0ACyABLwB6IgBBB3FFBEAgBS0AekEHcUUNAgsgCCAAECAiCiAHIAUvAHoQICILWw0BIAogClsNACALIAtcDQELIAFBFGogBUEUakHoABArGiABQfwAaiAFQfwAahCgAQNAIAEtAAAiAEEEcQ0BIAEgAEEEcjoAACABKAIQIgAEQCABIAARAAALIAFBgICA/gc2ApwBIAEoAuQDIgENAAsLIAJBEGokAAvGAwEEfyMAQaAEayICJAAgACgCBCEBIABBADYCBCABBEAgASABKAIAKAIEEQAACyAAKAIIIQEgAEEANgIIIAEEQCABIAEoAgAoAgQRAAALAkAgACgCACIAKALoAyAAKALsA0YEQCAAKALkAw0BIAAgAkEYaiAAKAL0AxBcIgEpAgA3AgAgACABKAIQNgIQIAAgASkCCDcCCCAAQRRqIAFBFGpB6AAQKxogACABKQKMATcCjAEgACABKQKEATcChAEgACABKQJ8NwJ8IAEoApQBIQQgAUEANgKUASAAKAKUASEDIAAgBDYClAEgAwRAIAMQWwsgAEGYAWogAUGYAWpB0AIQKxogACgC6AMiAwRAIAAgAzYC7AMgAxAjCyAAIAEoAugDNgLoAyAAIAEoAuwDNgLsAyAAIAEoAvADNgLwAyABQQA2AvADIAFCADcC6AMgACABKQL8AzcC/AMgACABKQL0AzcC9AMgACABKAKEBDYChAQgASgClAEhACABQQA2ApQBIAAEQCAAEFsLIAJBoARqJAAPCyACQfAcNgIQIABBBUHYJSACQRBqECwQJAALIAJB5hE2AgAgAEEFQdglIAIQLBAkAAsLAEEMEB4gABCiAQsLAEEMEB5BABCiAQsNACAAKAIALQAIQQFxCwoAIAAoAgAoAhQLGQAgAUH/AXEEQBACAAsgACgCACgCEEEBcQsYACAAKAIAIgAgAC0ACEH+AXEgAXI6AAgLJgAgASAAKAIAIgAoAhRHBEAgACABNgIUIAAgACgCDEEBajYCDAsLkgEBAn8jAEEQayICJAAgACgCACEAIAFDAAAAAGAEQCABIAAqAhhcBEAgACABOAIYIAAgACgCDEEBajYCDAsgAkEQaiQADwsgAkGIFDYCACMAQRBrIgMkACADIAI2AgwCQCAARQRAQbgwQdglIAIQSRoMAQsgAEEAQQVB2CUgAiAAKAIEEQ0AGgsgA0EQaiQAECQACz8AIAFB/wFxRQRAIAIgACgCACIAKAIQIgFBAXFHBEAgACABQX5xIAJyNgIQIAAgACgCDEEBajYCDAsPCxACAAsL4CYjAEGACAuBHk9ubHkgbGVhZiBub2RlcyB3aXRoIGN1c3RvbSBtZWFzdXJlIGZ1bmN0aW9ucyBzaG91bGQgbWFudWFsbHkgbWFyayB0aGVtc2VsdmVzIGFzIGRpcnR5AGlzRGlydHkAbWFya0RpcnR5AGRlc3Ryb3kAc2V0RGlzcGxheQBnZXREaXNwbGF5AHNldEZsZXgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABzZXRGbGV4R3JvdwBnZXRGbGV4R3JvdwBzZXRPdmVyZmxvdwBnZXRPdmVyZmxvdwBoYXNOZXdMYXlvdXQAY2FsY3VsYXRlTGF5b3V0AGdldENvbXB1dGVkTGF5b3V0AHVuc2lnbmVkIHNob3J0AGdldENoaWxkQ291bnQAdW5zaWduZWQgaW50AHNldEp1c3RpZnlDb250ZW50AGdldEp1c3RpZnlDb250ZW50AGF2YWlsYWJsZUhlaWdodCBpcyBpbmRlZmluaXRlIHNvIGhlaWdodFNpemluZ01vZGUgbXVzdCBiZSBTaXppbmdNb2RlOjpNYXhDb250ZW50AGF2YWlsYWJsZVdpZHRoIGlzIGluZGVmaW5pdGUgc28gd2lkdGhTaXppbmdNb2RlIG11c3QgYmUgU2l6aW5nTW9kZTo6TWF4Q29udGVudABzZXRBbGlnbkNvbnRlbnQAZ2V0QWxpZ25Db250ZW50AGdldFBhcmVudABpbXBsZW1lbnQAc2V0TWF4SGVpZ2h0UGVyY2VudABzZXRIZWlnaHRQZXJjZW50AHNldE1pbkhlaWdodFBlcmNlbnQAc2V0RmxleEJhc2lzUGVyY2VudABzZXRHYXBQZXJjZW50AHNldFBvc2l0aW9uUGVyY2VudABzZXRNYXJnaW5QZXJjZW50AHNldE1heFdpZHRoUGVyY2VudABzZXRXaWR0aFBlcmNlbnQAc2V0TWluV2lkdGhQZXJjZW50AHNldFBhZGRpbmdQZXJjZW50AGhhbmRsZS50eXBlKCkgPT0gU3R5bGVWYWx1ZUhhbmRsZTo6VHlwZTo6UG9pbnQgfHwgaGFuZGxlLnR5cGUoKSA9PSBTdHlsZVZhbHVlSGFuZGxlOjpUeXBlOjpQZXJjZW50AGNyZWF0ZURlZmF1bHQAdW5pdAByaWdodABoZWlnaHQAc2V0TWF4SGVpZ2h0AGdldE1heEhlaWdodABzZXRIZWlnaHQAZ2V0SGVpZ2h0AHNldE1pbkhlaWdodABnZXRNaW5IZWlnaHQAZ2V0Q29tcHV0ZWRIZWlnaHQAZ2V0Q29tcHV0ZWRSaWdodABsZWZ0AGdldENvbXB1dGVkTGVmdAByZXNldABfX2Rlc3RydWN0AGZsb2F0AHVpbnQ2NF90AHVzZVdlYkRlZmF1bHRzAHNldFVzZVdlYkRlZmF1bHRzAHNldEFsaWduSXRlbXMAZ2V0QWxpZ25JdGVtcwBzZXRGbGV4QmFzaXMAZ2V0RmxleEJhc2lzAENhbm5vdCBnZXQgbGF5b3V0IHByb3BlcnRpZXMgb2YgbXVsdGktZWRnZSBzaG9ydGhhbmRzAHNldFBvaW50U2NhbGVGYWN0b3IATWVhc3VyZUNhbGxiYWNrV3JhcHBlcgBEaXJ0aWVkQ2FsbGJhY2tXcmFwcGVyAENhbm5vdCByZXNldCBhIG5vZGUgc3RpbGwgYXR0YWNoZWQgdG8gYSBvd25lcgBzZXRCb3JkZXIAZ2V0Qm9yZGVyAGdldENvbXB1dGVkQm9yZGVyAGdldE51bWJlcgBoYW5kbGUudHlwZSgpID09IFN0eWxlVmFsdWVIYW5kbGU6OlR5cGU6Ok51bWJlcgB1bnNpZ25lZCBjaGFyAHRvcABnZXRDb21wdXRlZFRvcABzZXRGbGV4V3JhcABnZXRGbGV4V3JhcABzZXRHYXAAZ2V0R2FwACVwAHNldEhlaWdodEF1dG8Ac2V0RmxleEJhc2lzQXV0bwBzZXRQb3NpdGlvbkF1dG8Ac2V0TWFyZ2luQXV0bwBzZXRXaWR0aEF1dG8AU2NhbGUgZmFjdG9yIHNob3VsZCBub3QgYmUgbGVzcyB0aGFuIHplcm8Ac2V0QXNwZWN0UmF0aW8AZ2V0QXNwZWN0UmF0aW8Ac2V0UG9zaXRpb24AZ2V0UG9zaXRpb24Abm90aWZ5T25EZXN0cnVjdGlvbgBzZXRGbGV4RGlyZWN0aW9uAGdldEZsZXhEaXJlY3Rpb24Ac2V0RGlyZWN0aW9uAGdldERpcmVjdGlvbgBzZXRNYXJnaW4AZ2V0TWFyZ2luAGdldENvbXB1dGVkTWFyZ2luAG1hcmtMYXlvdXRTZWVuAG5hbgBib3R0b20AZ2V0Q29tcHV0ZWRCb3R0b20AYm9vbABlbXNjcmlwdGVuOjp2YWwAc2V0RmxleFNocmluawBnZXRGbGV4U2hyaW5rAHNldEFsd2F5c0Zvcm1zQ29udGFpbmluZ0Jsb2NrAE1lYXN1cmVDYWxsYmFjawBEaXJ0aWVkQ2FsbGJhY2sAZ2V0TGVuZ3RoAHdpZHRoAHNldE1heFdpZHRoAGdldE1heFdpZHRoAHNldFdpZHRoAGdldFdpZHRoAHNldE1pbldpZHRoAGdldE1pbldpZHRoAGdldENvbXB1dGVkV2lkdGgAcHVzaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1NtYWxsVmFsdWVCdWZmZXIuaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1N0eWxlVmFsdWVQb29sLmgAdW5zaWduZWQgbG9uZwBzZXRCb3hTaXppbmcAZ2V0Qm94U2l6aW5nAHN0ZDo6d3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBzZXRQYWRkaW5nAGdldFBhZGRpbmcAZ2V0Q29tcHV0ZWRQYWRkaW5nAFRyaWVkIHRvIGNvbnN0cnVjdCBZR05vZGUgd2l0aCBudWxsIGNvbmZpZwBBdHRlbXB0aW5nIHRvIGNvbnN0cnVjdCBOb2RlIHdpdGggbnVsbCBjb25maWcAY3JlYXRlV2l0aENvbmZpZwBpbmYAc2V0QWxpZ25TZWxmAGdldEFsaWduU2VsZgBTaXplAHZhbHVlAFZhbHVlAGNyZWF0ZQBtZWFzdXJlAHNldFBvc2l0aW9uVHlwZQBnZXRQb3NpdGlvblR5cGUAaXNSZWZlcmVuY2VCYXNlbGluZQBzZXRJc1JlZmVyZW5jZUJhc2VsaW5lAGNvcHlTdHlsZQBkb3VibGUATm9kZQBleHRlbmQAaW5zZXJ0Q2hpbGQAZ2V0Q2hpbGQAcmVtb3ZlQ2hpbGQAdm9pZABzZXRFeHBlcmltZW50YWxGZWF0dXJlRW5hYmxlZABpc0V4cGVyaW1lbnRhbEZlYXR1cmVFbmFibGVkAGRpcnRpZWQAQ2Fubm90IHJlc2V0IGEgbm9kZSB3aGljaCBzdGlsbCBoYXMgY2hpbGRyZW4gYXR0YWNoZWQAdW5zZXRNZWFzdXJlRnVuYwB1bnNldERpcnRpZWRGdW5jAHNldEVycmF0YQBnZXRFcnJhdGEATWVhc3VyZSBmdW5jdGlvbiByZXR1cm5lZCBhbiBpbnZhbGlkIGRpbWVuc2lvbiB0byBZb2dhOiBbd2lkdGg9JWYsIGhlaWdodD0lZl0ARXhwZWN0IGN1c3RvbSBiYXNlbGluZSBmdW5jdGlvbiB0byBub3QgcmV0dXJuIE5hTgBOQU4ASU5GAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVk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";
    if (!ua(H)) {
      var va = H;
      H = h2.locateFile ? h2.locateFile(va, q) : q + va;
    }
    function wa() {
      var a3 = H;
      try {
        if (a3 == H && w) return new Uint8Array(w);
        if (ua(a3)) try {
          var b2 = xa(a3.slice(37)), c3 = new Uint8Array(b2.length);
          for (a3 = 0; a3 < b2.length; ++a3) c3[a3] = b2.charCodeAt(a3);
          var d2 = c3;
        } catch (f2) {
          throw Error("Converting base64 string to bytes failed.");
        }
        else d2 = void 0;
        var e3 = d2;
        if (e3) return e3;
        throw "both async and sync fetching of the wasm failed";
      } catch (f2) {
        x(f2);
      }
    }
    function ya() {
      return w || "function" != typeof fetch ? Promise.resolve().then(function() {
        return wa();
      }) : fetch(H, { credentials: "same-origin" }).then(function(a3) {
        if (!a3.ok) throw "failed to load wasm binary file at '" + H + "'";
        return a3.arrayBuffer();
      }).catch(function() {
        return wa();
      });
    }
    function za(a3) {
      for (; 0 < a3.length; ) a3.shift()(h2);
    }
    function Aa(a3) {
      if (void 0 === a3) return "_unknown";
      a3 = a3.replace(/[^a-zA-Z0-9_]/g, "$");
      var b2 = a3.charCodeAt(0);
      return 48 <= b2 && 57 >= b2 ? "_" + a3 : a3;
    }
    function Ba(a3, b2) {
      a3 = Aa(a3);
      return function() {
        return b2.apply(this, arguments);
      };
    }
    var J = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }], Ca = [];
    function Da(a3) {
      var b2 = Error, c3 = Ba(a3, function(d2) {
        this.name = a3;
        this.message = d2;
        d2 = Error(d2).stack;
        void 0 !== d2 && (this.stack = this.toString() + "\n" + d2.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      c3.prototype = Object.create(b2.prototype);
      c3.prototype.constructor = c3;
      c3.prototype.toString = function() {
        return void 0 === this.message ? this.name : this.name + ": " + this.message;
      };
      return c3;
    }
    var K = void 0;
    function L(a3) {
      throw new K(a3);
    }
    var M = (a3) => {
      a3 || L("Cannot use deleted val. handle = " + a3);
      return J[a3].value;
    }, Ea = (a3) => {
      switch (a3) {
        case void 0:
          return 1;
        case null:
          return 2;
        case true:
          return 3;
        case false:
          return 4;
        default:
          var b2 = Ca.length ? Ca.pop() : J.length;
          J[b2] = { ga: 1, value: a3 };
          return b2;
      }
    }, Fa = void 0, Ga = void 0;
    function N(a3) {
      for (var b2 = ""; A[a3]; ) b2 += Ga[A[a3++]];
      return b2;
    }
    var O = [];
    function Ha() {
      for (; O.length; ) {
        var a3 = O.pop();
        a3.M.$ = false;
        a3["delete"]();
      }
    }
    var P = void 0, Q = {};
    function Ia(a3, b2) {
      for (void 0 === b2 && L("ptr should not be undefined"); a3.R; ) b2 = a3.ba(b2), a3 = a3.R;
      return b2;
    }
    var R = {};
    function Ja(a3) {
      a3 = Ka(a3);
      var b2 = N(a3);
      S2(a3);
      return b2;
    }
    function La(a3, b2) {
      var c3 = R[a3];
      void 0 === c3 && L(b2 + " has unknown type " + Ja(a3));
      return c3;
    }
    function Ma() {
    }
    var Na = false;
    function Oa(a3) {
      --a3.count.value;
      0 === a3.count.value && (a3.T ? a3.U.W(a3.T) : a3.P.N.W(a3.O));
    }
    function Pa(a3, b2, c3) {
      if (b2 === c3) return a3;
      if (void 0 === c3.R) return null;
      a3 = Pa(a3, b2, c3.R);
      return null === a3 ? null : c3.na(a3);
    }
    var Qa = {};
    function Ra(a3, b2) {
      b2 = Ia(a3, b2);
      return Q[b2];
    }
    var Sa = void 0;
    function Ta(a3) {
      throw new Sa(a3);
    }
    function Ua(a3, b2) {
      b2.P && b2.O || Ta("makeClassHandle requires ptr and ptrType");
      !!b2.U !== !!b2.T && Ta("Both smartPtrType and smartPtr must be specified");
      b2.count = { value: 1 };
      return T(Object.create(a3, { M: { value: b2 } }));
    }
    function T(a3) {
      if ("undefined" === typeof FinalizationRegistry) return T = (b2) => b2, a3;
      Na = new FinalizationRegistry((b2) => {
        Oa(b2.M);
      });
      T = (b2) => {
        var c3 = b2.M;
        c3.T && Na.register(b2, { M: c3 }, b2);
        return b2;
      };
      Ma = (b2) => {
        Na.unregister(b2);
      };
      return T(a3);
    }
    var Va = {};
    function Wa(a3) {
      for (; a3.length; ) {
        var b2 = a3.pop();
        a3.pop()(b2);
      }
    }
    function Xa(a3) {
      return this.fromWireType(D[a3 >> 2]);
    }
    var U = {}, Ya = {};
    function V(a3, b2, c3) {
      function d2(k2) {
        k2 = c3(k2);
        k2.length !== a3.length && Ta("Mismatched type converter count");
        for (var m = 0; m < a3.length; ++m) W(a3[m], k2[m]);
      }
      a3.forEach(function(k2) {
        Ya[k2] = b2;
      });
      var e3 = Array(b2.length), f2 = [], g2 = 0;
      b2.forEach((k2, m) => {
        R.hasOwnProperty(k2) ? e3[m] = R[k2] : (f2.push(k2), U.hasOwnProperty(k2) || (U[k2] = []), U[k2].push(() => {
          e3[m] = R[k2];
          ++g2;
          g2 === f2.length && d2(e3);
        }));
      });
      0 === f2.length && d2(e3);
    }
    function Za(a3) {
      switch (a3) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError("Unknown type size: " + a3);
      }
    }
    function W(a3, b2, c3 = {}) {
      if (!("argPackAdvance" in b2)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
      var d2 = b2.name;
      a3 || L('type "' + d2 + '" must have a positive integer typeid pointer');
      if (R.hasOwnProperty(a3)) {
        if (c3.ua) return;
        L("Cannot register type '" + d2 + "' twice");
      }
      R[a3] = b2;
      delete Ya[a3];
      U.hasOwnProperty(a3) && (b2 = U[a3], delete U[a3], b2.forEach((e3) => e3()));
    }
    function $a(a3) {
      L(a3.M.P.N.name + " instance already deleted");
    }
    function X() {
    }
    function ab(a3, b2, c3) {
      if (void 0 === a3[b2].S) {
        var d2 = a3[b2];
        a3[b2] = function() {
          a3[b2].S.hasOwnProperty(arguments.length) || L("Function '" + c3 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a3[b2].S + ")!");
          return a3[b2].S[arguments.length].apply(this, arguments);
        };
        a3[b2].S = [];
        a3[b2].S[d2.Z] = d2;
      }
    }
    function bb(a3, b2) {
      h2.hasOwnProperty(a3) ? (L("Cannot register public name '" + a3 + "' twice"), ab(h2, a3, a3), h2.hasOwnProperty(void 0) && L("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), h2[a3].S[void 0] = b2) : h2[a3] = b2;
    }
    function cb(a3, b2, c3, d2, e3, f2, g2, k2) {
      this.name = a3;
      this.constructor = b2;
      this.X = c3;
      this.W = d2;
      this.R = e3;
      this.pa = f2;
      this.ba = g2;
      this.na = k2;
      this.ja = [];
    }
    function db(a3, b2, c3) {
      for (; b2 !== c3; ) b2.ba || L("Expected null or instance of " + c3.name + ", got an instance of " + b2.name), a3 = b2.ba(a3), b2 = b2.R;
      return a3;
    }
    function eb(a3, b2) {
      if (null === b2) return this.ea && L("null is not a valid " + this.name), 0;
      b2.M || L('Cannot pass "' + fb(b2) + '" as a ' + this.name);
      b2.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      return db(b2.M.O, b2.M.P.N, this.N);
    }
    function gb(a3, b2) {
      if (null === b2) {
        this.ea && L("null is not a valid " + this.name);
        if (this.da) {
          var c3 = this.fa();
          null !== a3 && a3.push(this.W, c3);
          return c3;
        }
        return 0;
      }
      b2.M || L('Cannot pass "' + fb(b2) + '" as a ' + this.name);
      b2.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      !this.ca && b2.M.P.ca && L("Cannot convert argument of type " + (b2.M.U ? b2.M.U.name : b2.M.P.name) + " to parameter type " + this.name);
      c3 = db(b2.M.O, b2.M.P.N, this.N);
      if (this.da) switch (void 0 === b2.M.T && L("Passing raw pointer to smart pointer is illegal"), this.Ba) {
        case 0:
          b2.M.U === this ? c3 = b2.M.T : L("Cannot convert argument of type " + (b2.M.U ? b2.M.U.name : b2.M.P.name) + " to parameter type " + this.name);
          break;
        case 1:
          c3 = b2.M.T;
          break;
        case 2:
          if (b2.M.U === this) c3 = b2.M.T;
          else {
            var d2 = b2.clone();
            c3 = this.xa(c3, Ea(function() {
              d2["delete"]();
            }));
            null !== a3 && a3.push(this.W, c3);
          }
          break;
        default:
          L("Unsupporting sharing policy");
      }
      return c3;
    }
    function hb(a3, b2) {
      if (null === b2) return this.ea && L("null is not a valid " + this.name), 0;
      b2.M || L('Cannot pass "' + fb(b2) + '" as a ' + this.name);
      b2.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      b2.M.P.ca && L("Cannot convert argument of type " + b2.M.P.name + " to parameter type " + this.name);
      return db(b2.M.O, b2.M.P.N, this.N);
    }
    function Y(a3, b2, c3, d2) {
      this.name = a3;
      this.N = b2;
      this.ea = c3;
      this.ca = d2;
      this.da = false;
      this.W = this.xa = this.fa = this.ka = this.Ba = this.wa = void 0;
      void 0 !== b2.R ? this.toWireType = gb : (this.toWireType = d2 ? eb : hb, this.V = null);
    }
    function ib(a3, b2) {
      h2.hasOwnProperty(a3) || Ta("Replacing nonexistant public symbol");
      h2[a3] = b2;
      h2[a3].Z = void 0;
    }
    function jb(a3, b2) {
      var c3 = [];
      return function() {
        c3.length = 0;
        Object.assign(c3, arguments);
        if (a3.includes("j")) {
          var d2 = h2["dynCall_" + a3];
          d2 = c3 && c3.length ? d2.apply(null, [b2].concat(c3)) : d2.call(null, b2);
        } else d2 = oa.get(b2).apply(null, c3);
        return d2;
      };
    }
    function Z(a3, b2) {
      a3 = N(a3);
      var c3 = a3.includes("j") ? jb(a3, b2) : oa.get(b2);
      "function" != typeof c3 && L("unknown function pointer with signature " + a3 + ": " + b2);
      return c3;
    }
    var mb = void 0;
    function nb(a3, b2) {
      function c3(f2) {
        e3[f2] || R[f2] || (Ya[f2] ? Ya[f2].forEach(c3) : (d2.push(f2), e3[f2] = true));
      }
      var d2 = [], e3 = {};
      b2.forEach(c3);
      throw new mb(a3 + ": " + d2.map(Ja).join([", "]));
    }
    function ob(a3, b2, c3, d2, e3) {
      var f2 = b2.length;
      2 > f2 && L("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var g2 = null !== b2[1] && null !== c3, k2 = false;
      for (c3 = 1; c3 < b2.length; ++c3) if (null !== b2[c3] && void 0 === b2[c3].V) {
        k2 = true;
        break;
      }
      var m = "void" !== b2[0].name, l2 = f2 - 2, n4 = Array(l2), p2 = [], r3 = [];
      return function() {
        arguments.length !== l2 && L("function " + a3 + " called with " + arguments.length + " arguments, expected " + l2 + " args!");
        r3.length = 0;
        p2.length = g2 ? 2 : 1;
        p2[0] = e3;
        if (g2) {
          var u3 = b2[1].toWireType(r3, this);
          p2[1] = u3;
        }
        for (var t3 = 0; t3 < l2; ++t3) n4[t3] = b2[t3 + 2].toWireType(r3, arguments[t3]), p2.push(n4[t3]);
        t3 = d2.apply(null, p2);
        if (k2) Wa(r3);
        else for (var y2 = g2 ? 1 : 2; y2 < b2.length; y2++) {
          var B = 1 === y2 ? u3 : n4[y2 - 2];
          null !== b2[y2].V && b2[y2].V(B);
        }
        u3 = m ? b2[0].fromWireType(t3) : void 0;
        return u3;
      };
    }
    function pb(a3, b2) {
      for (var c3 = [], d2 = 0; d2 < a3; d2++) c3.push(E[b2 + 4 * d2 >> 2]);
      return c3;
    }
    function qb(a3) {
      4 < a3 && 0 === --J[a3].ga && (J[a3] = void 0, Ca.push(a3));
    }
    function fb(a3) {
      if (null === a3) return "null";
      var b2 = typeof a3;
      return "object" === b2 || "array" === b2 || "function" === b2 ? a3.toString() : "" + a3;
    }
    function rb(a3, b2) {
      switch (b2) {
        case 2:
          return function(c3) {
            return this.fromWireType(la[c3 >> 2]);
          };
        case 3:
          return function(c3) {
            return this.fromWireType(ma[c3 >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + a3);
      }
    }
    function sb(a3, b2, c3) {
      switch (b2) {
        case 0:
          return c3 ? function(d2) {
            return ja[d2];
          } : function(d2) {
            return A[d2];
          };
        case 1:
          return c3 ? function(d2) {
            return C[d2 >> 1];
          } : function(d2) {
            return ka[d2 >> 1];
          };
        case 2:
          return c3 ? function(d2) {
            return D[d2 >> 2];
          } : function(d2) {
            return E[d2 >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + a3);
      }
    }
    function tb(a3, b2) {
      for (var c3 = "", d2 = 0; !(d2 >= b2 / 2); ++d2) {
        var e3 = C[a3 + 2 * d2 >> 1];
        if (0 == e3) break;
        c3 += String.fromCharCode(e3);
      }
      return c3;
    }
    function ub(a3, b2, c3) {
      void 0 === c3 && (c3 = 2147483647);
      if (2 > c3) return 0;
      c3 -= 2;
      var d2 = b2;
      c3 = c3 < 2 * a3.length ? c3 / 2 : a3.length;
      for (var e3 = 0; e3 < c3; ++e3) C[b2 >> 1] = a3.charCodeAt(e3), b2 += 2;
      C[b2 >> 1] = 0;
      return b2 - d2;
    }
    function vb(a3) {
      return 2 * a3.length;
    }
    function wb(a3, b2) {
      for (var c3 = 0, d2 = ""; !(c3 >= b2 / 4); ) {
        var e3 = D[a3 + 4 * c3 >> 2];
        if (0 == e3) break;
        ++c3;
        65536 <= e3 ? (e3 -= 65536, d2 += String.fromCharCode(55296 | e3 >> 10, 56320 | e3 & 1023)) : d2 += String.fromCharCode(e3);
      }
      return d2;
    }
    function xb(a3, b2, c3) {
      void 0 === c3 && (c3 = 2147483647);
      if (4 > c3) return 0;
      var d2 = b2;
      c3 = d2 + c3 - 4;
      for (var e3 = 0; e3 < a3.length; ++e3) {
        var f2 = a3.charCodeAt(e3);
        if (55296 <= f2 && 57343 >= f2) {
          var g2 = a3.charCodeAt(++e3);
          f2 = 65536 + ((f2 & 1023) << 10) | g2 & 1023;
        }
        D[b2 >> 2] = f2;
        b2 += 4;
        if (b2 + 4 > c3) break;
      }
      D[b2 >> 2] = 0;
      return b2 - d2;
    }
    function yb(a3) {
      for (var b2 = 0, c3 = 0; c3 < a3.length; ++c3) {
        var d2 = a3.charCodeAt(c3);
        55296 <= d2 && 57343 >= d2 && ++c3;
        b2 += 4;
      }
      return b2;
    }
    var zb = {};
    function Ab(a3) {
      var b2 = zb[a3];
      return void 0 === b2 ? N(a3) : b2;
    }
    var Bb = [];
    function Cb(a3) {
      var b2 = Bb.length;
      Bb.push(a3);
      return b2;
    }
    function Db(a3, b2) {
      for (var c3 = Array(a3), d2 = 0; d2 < a3; ++d2) c3[d2] = La(E[b2 + 4 * d2 >> 2], "parameter " + d2);
      return c3;
    }
    var Eb = [], Fb = [null, [], []];
    K = h2.BindingError = Da("BindingError");
    h2.count_emval_handles = function() {
      for (var a3 = 0, b2 = 5; b2 < J.length; ++b2) void 0 !== J[b2] && ++a3;
      return a3;
    };
    h2.get_first_emval = function() {
      for (var a3 = 5; a3 < J.length; ++a3) if (void 0 !== J[a3]) return J[a3];
      return null;
    };
    Fa = h2.PureVirtualError = Da("PureVirtualError");
    for (var Gb = Array(256), Hb = 0; 256 > Hb; ++Hb) Gb[Hb] = String.fromCharCode(Hb);
    Ga = Gb;
    h2.getInheritedInstanceCount = function() {
      return Object.keys(Q).length;
    };
    h2.getLiveInheritedInstances = function() {
      var a3 = [], b2;
      for (b2 in Q) Q.hasOwnProperty(b2) && a3.push(Q[b2]);
      return a3;
    };
    h2.flushPendingDeletes = Ha;
    h2.setDelayFunction = function(a3) {
      P = a3;
      O.length && P && P(Ha);
    };
    Sa = h2.InternalError = Da("InternalError");
    X.prototype.isAliasOf = function(a3) {
      if (!(this instanceof X && a3 instanceof X)) return false;
      var b2 = this.M.P.N, c3 = this.M.O, d2 = a3.M.P.N;
      for (a3 = a3.M.O; b2.R; ) c3 = b2.ba(c3), b2 = b2.R;
      for (; d2.R; ) a3 = d2.ba(a3), d2 = d2.R;
      return b2 === d2 && c3 === a3;
    };
    X.prototype.clone = function() {
      this.M.O || $a(this);
      if (this.M.aa) return this.M.count.value += 1, this;
      var a3 = T, b2 = Object, c3 = b2.create, d2 = Object.getPrototypeOf(this), e3 = this.M;
      a3 = a3(c3.call(b2, d2, { M: { value: { count: e3.count, $: e3.$, aa: e3.aa, O: e3.O, P: e3.P, T: e3.T, U: e3.U } } }));
      a3.M.count.value += 1;
      a3.M.$ = false;
      return a3;
    };
    X.prototype["delete"] = function() {
      this.M.O || $a(this);
      this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
      Ma(this);
      Oa(this.M);
      this.M.aa || (this.M.T = void 0, this.M.O = void 0);
    };
    X.prototype.isDeleted = function() {
      return !this.M.O;
    };
    X.prototype.deleteLater = function() {
      this.M.O || $a(this);
      this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
      O.push(this);
      1 === O.length && P && P(Ha);
      this.M.$ = true;
      return this;
    };
    Y.prototype.qa = function(a3) {
      this.ka && (a3 = this.ka(a3));
      return a3;
    };
    Y.prototype.ha = function(a3) {
      this.W && this.W(a3);
    };
    Y.prototype.argPackAdvance = 8;
    Y.prototype.readValueFromPointer = Xa;
    Y.prototype.deleteObject = function(a3) {
      if (null !== a3) a3["delete"]();
    };
    Y.prototype.fromWireType = function(a3) {
      function b2() {
        return this.da ? Ua(this.N.X, { P: this.wa, O: c3, U: this, T: a3 }) : Ua(this.N.X, { P: this, O: a3 });
      }
      var c3 = this.qa(a3);
      if (!c3) return this.ha(a3), null;
      var d2 = Ra(this.N, c3);
      if (void 0 !== d2) {
        if (0 === d2.M.count.value) return d2.M.O = c3, d2.M.T = a3, d2.clone();
        d2 = d2.clone();
        this.ha(a3);
        return d2;
      }
      d2 = this.N.pa(c3);
      d2 = Qa[d2];
      if (!d2) return b2.call(this);
      d2 = this.ca ? d2.la : d2.pointerType;
      var e3 = Pa(c3, this.N, d2.N);
      return null === e3 ? b2.call(this) : this.da ? Ua(d2.N.X, { P: d2, O: e3, U: this, T: a3 }) : Ua(d2.N.X, { P: d2, O: e3 });
    };
    mb = h2.UnboundTypeError = Da("UnboundTypeError");
    var xa = "function" == typeof atob ? atob : function(a3) {
      var b2 = "", c3 = 0;
      a3 = a3.replace(/[^A-Za-z0-9\+\/=]/g, "");
      do {
        var d2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a3.charAt(c3++));
        var e3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a3.charAt(c3++));
        var f2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a3.charAt(c3++));
        var g2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a3.charAt(c3++));
        d2 = d2 << 2 | e3 >> 4;
        e3 = (e3 & 15) << 4 | f2 >> 2;
        var k2 = (f2 & 3) << 6 | g2;
        b2 += String.fromCharCode(d2);
        64 !== f2 && (b2 += String.fromCharCode(e3));
        64 !== g2 && (b2 += String.fromCharCode(k2));
      } while (c3 < a3.length);
      return b2;
    }, Jb = {
      l: function(a3, b2, c3, d2) {
        x("Assertion failed: " + (a3 ? z(A, a3) : "") + ", at: " + [b2 ? b2 ? z(A, b2) : "" : "unknown filename", c3, d2 ? d2 ? z(A, d2) : "" : "unknown function"]);
      },
      q: function(a3, b2, c3) {
        a3 = N(a3);
        b2 = La(b2, "wrapper");
        c3 = M(c3);
        var d2 = [].slice, e3 = b2.N, f2 = e3.X, g2 = e3.R.X, k2 = e3.R.constructor;
        a3 = Ba(a3, function() {
          e3.R.ja.forEach((function(l2) {
            if (this[l2] === g2[l2]) throw new Fa("Pure virtual function " + l2 + " must be implemented in JavaScript");
          }).bind(this));
          Object.defineProperty(this, "__parent", { value: f2 });
          this.__construct.apply(this, d2.call(arguments));
        });
        f2.__construct = function() {
          this === f2 && L("Pass correct 'this' to __construct");
          var l2 = k2.implement.apply(void 0, [this].concat(d2.call(arguments)));
          Ma(l2);
          var n4 = l2.M;
          l2.notifyOnDestruction();
          n4.aa = true;
          Object.defineProperties(this, { M: { value: n4 } });
          T(this);
          l2 = n4.O;
          l2 = Ia(e3, l2);
          Q.hasOwnProperty(l2) ? L("Tried to register registered instance: " + l2) : Q[l2] = this;
        };
        f2.__destruct = function() {
          this === f2 && L("Pass correct 'this' to __destruct");
          Ma(this);
          var l2 = this.M.O;
          l2 = Ia(e3, l2);
          Q.hasOwnProperty(l2) ? delete Q[l2] : L("Tried to unregister unregistered instance: " + l2);
        };
        a3.prototype = Object.create(f2);
        for (var m in c3) a3.prototype[m] = c3[m];
        return Ea(a3);
      },
      j: function(a3) {
        var b2 = Va[a3];
        delete Va[a3];
        var c3 = b2.fa, d2 = b2.W, e3 = b2.ia, f2 = e3.map((g2) => g2.ta).concat(e3.map((g2) => g2.za));
        V([a3], f2, (g2) => {
          var k2 = {};
          e3.forEach((m, l2) => {
            var n4 = g2[l2], p2 = m.ra, r3 = m.sa, u3 = g2[l2 + e3.length], t3 = m.ya, y2 = m.Aa;
            k2[m.oa] = { read: (B) => n4.fromWireType(p2(r3, B)), write: (B, ba) => {
              var I = [];
              t3(
                y2,
                B,
                u3.toWireType(I, ba)
              );
              Wa(I);
            } };
          });
          return [{ name: b2.name, fromWireType: function(m) {
            var l2 = {}, n4;
            for (n4 in k2) l2[n4] = k2[n4].read(m);
            d2(m);
            return l2;
          }, toWireType: function(m, l2) {
            for (var n4 in k2) if (!(n4 in l2)) throw new TypeError('Missing field:  "' + n4 + '"');
            var p2 = c3();
            for (n4 in k2) k2[n4].write(p2, l2[n4]);
            null !== m && m.push(d2, p2);
            return p2;
          }, argPackAdvance: 8, readValueFromPointer: Xa, V: d2 }];
        });
      },
      v: function() {
      },
      B: function(a3, b2, c3, d2, e3) {
        var f2 = Za(c3);
        b2 = N(b2);
        W(a3, {
          name: b2,
          fromWireType: function(g2) {
            return !!g2;
          },
          toWireType: function(g2, k2) {
            return k2 ? d2 : e3;
          },
          argPackAdvance: 8,
          readValueFromPointer: function(g2) {
            if (1 === c3) var k2 = ja;
            else if (2 === c3) k2 = C;
            else if (4 === c3) k2 = D;
            else throw new TypeError("Unknown boolean type size: " + b2);
            return this.fromWireType(k2[g2 >> f2]);
          },
          V: null
        });
      },
      f: function(a3, b2, c3, d2, e3, f2, g2, k2, m, l2, n4, p2, r3) {
        n4 = N(n4);
        f2 = Z(e3, f2);
        k2 && (k2 = Z(g2, k2));
        l2 && (l2 = Z(m, l2));
        r3 = Z(p2, r3);
        var u3 = Aa(n4);
        bb(u3, function() {
          nb("Cannot construct " + n4 + " due to unbound types", [d2]);
        });
        V([a3, b2, c3], d2 ? [d2] : [], function(t3) {
          t3 = t3[0];
          if (d2) {
            var y2 = t3.N;
            var B = y2.X;
          } else B = X.prototype;
          t3 = Ba(u3, function() {
            if (Object.getPrototypeOf(this) !== ba) throw new K("Use 'new' to construct " + n4);
            if (void 0 === I.Y) throw new K(n4 + " has no accessible constructor");
            var kb = I.Y[arguments.length];
            if (void 0 === kb) throw new K("Tried to invoke ctor of " + n4 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(I.Y).toString() + ") parameters instead!");
            return kb.apply(this, arguments);
          });
          var ba = Object.create(B, { constructor: { value: t3 } });
          t3.prototype = ba;
          var I = new cb(n4, t3, ba, r3, y2, f2, k2, l2);
          y2 = new Y(n4, I, true, false);
          B = new Y(n4 + "*", I, false, false);
          var lb = new Y(n4 + " const*", I, false, true);
          Qa[a3] = {
            pointerType: B,
            la: lb
          };
          ib(u3, t3);
          return [y2, B, lb];
        });
      },
      d: function(a3, b2, c3, d2, e3, f2, g2) {
        var k2 = pb(c3, d2);
        b2 = N(b2);
        f2 = Z(e3, f2);
        V([], [a3], function(m) {
          function l2() {
            nb("Cannot call " + n4 + " due to unbound types", k2);
          }
          m = m[0];
          var n4 = m.name + "." + b2;
          b2.startsWith("@@") && (b2 = Symbol[b2.substring(2)]);
          var p2 = m.N.constructor;
          void 0 === p2[b2] ? (l2.Z = c3 - 1, p2[b2] = l2) : (ab(p2, b2, n4), p2[b2].S[c3 - 1] = l2);
          V([], k2, function(r3) {
            r3 = ob(n4, [r3[0], null].concat(r3.slice(1)), null, f2, g2);
            void 0 === p2[b2].S ? (r3.Z = c3 - 1, p2[b2] = r3) : p2[b2].S[c3 - 1] = r3;
            return [];
          });
          return [];
        });
      },
      p: function(a3, b2, c3, d2, e3, f2) {
        0 < b2 || x();
        var g2 = pb(
          b2,
          c3
        );
        e3 = Z(d2, e3);
        V([], [a3], function(k2) {
          k2 = k2[0];
          var m = "constructor " + k2.name;
          void 0 === k2.N.Y && (k2.N.Y = []);
          if (void 0 !== k2.N.Y[b2 - 1]) throw new K("Cannot register multiple constructors with identical number of parameters (" + (b2 - 1) + ") for class '" + k2.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          k2.N.Y[b2 - 1] = () => {
            nb("Cannot construct " + k2.name + " due to unbound types", g2);
          };
          V([], g2, function(l2) {
            l2.splice(1, 0, null);
            k2.N.Y[b2 - 1] = ob(m, l2, null, e3, f2);
            return [];
          });
          return [];
        });
      },
      a: function(a3, b2, c3, d2, e3, f2, g2, k2) {
        var m = pb(c3, d2);
        b2 = N(b2);
        f2 = Z(e3, f2);
        V([], [a3], function(l2) {
          function n4() {
            nb("Cannot call " + p2 + " due to unbound types", m);
          }
          l2 = l2[0];
          var p2 = l2.name + "." + b2;
          b2.startsWith("@@") && (b2 = Symbol[b2.substring(2)]);
          k2 && l2.N.ja.push(b2);
          var r3 = l2.N.X, u3 = r3[b2];
          void 0 === u3 || void 0 === u3.S && u3.className !== l2.name && u3.Z === c3 - 2 ? (n4.Z = c3 - 2, n4.className = l2.name, r3[b2] = n4) : (ab(r3, b2, p2), r3[b2].S[c3 - 2] = n4);
          V([], m, function(t3) {
            t3 = ob(p2, t3, l2, f2, g2);
            void 0 === r3[b2].S ? (t3.Z = c3 - 2, r3[b2] = t3) : r3[b2].S[c3 - 2] = t3;
            return [];
          });
          return [];
        });
      },
      A: function(a3, b2) {
        b2 = N(b2);
        W(
          a3,
          { name: b2, fromWireType: function(c3) {
            var d2 = M(c3);
            qb(c3);
            return d2;
          }, toWireType: function(c3, d2) {
            return Ea(d2);
          }, argPackAdvance: 8, readValueFromPointer: Xa, V: null }
        );
      },
      n: function(a3, b2, c3) {
        c3 = Za(c3);
        b2 = N(b2);
        W(a3, { name: b2, fromWireType: function(d2) {
          return d2;
        }, toWireType: function(d2, e3) {
          return e3;
        }, argPackAdvance: 8, readValueFromPointer: rb(b2, c3), V: null });
      },
      e: function(a3, b2, c3, d2, e3) {
        b2 = N(b2);
        -1 === e3 && (e3 = 4294967295);
        e3 = Za(c3);
        var f2 = (k2) => k2;
        if (0 === d2) {
          var g2 = 32 - 8 * c3;
          f2 = (k2) => k2 << g2 >>> g2;
        }
        c3 = b2.includes("unsigned") ? function(k2, m) {
          return m >>> 0;
        } : function(k2, m) {
          return m;
        };
        W(a3, { name: b2, fromWireType: f2, toWireType: c3, argPackAdvance: 8, readValueFromPointer: sb(b2, e3, 0 !== d2), V: null });
      },
      b: function(a3, b2, c3) {
        function d2(f2) {
          f2 >>= 2;
          var g2 = E;
          return new e3(ia, g2[f2 + 1], g2[f2]);
        }
        var e3 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b2];
        c3 = N(c3);
        W(a3, { name: c3, fromWireType: d2, argPackAdvance: 8, readValueFromPointer: d2 }, { ua: true });
      },
      o: function(a3, b2) {
        b2 = N(b2);
        var c3 = "std::string" === b2;
        W(a3, { name: b2, fromWireType: function(d2) {
          var e3 = E[d2 >> 2], f2 = d2 + 4;
          if (c3) for (var g2 = f2, k2 = 0; k2 <= e3; ++k2) {
            var m = f2 + k2;
            if (k2 == e3 || 0 == A[m]) {
              g2 = g2 ? z(A, g2, m - g2) : "";
              if (void 0 === l2) var l2 = g2;
              else l2 += String.fromCharCode(0), l2 += g2;
              g2 = m + 1;
            }
          }
          else {
            l2 = Array(e3);
            for (k2 = 0; k2 < e3; ++k2) l2[k2] = String.fromCharCode(A[f2 + k2]);
            l2 = l2.join("");
          }
          S2(d2);
          return l2;
        }, toWireType: function(d2, e3) {
          e3 instanceof ArrayBuffer && (e3 = new Uint8Array(e3));
          var f2, g2 = "string" == typeof e3;
          g2 || e3 instanceof Uint8Array || e3 instanceof Uint8ClampedArray || e3 instanceof Int8Array || L("Cannot pass non-string to std::string");
          if (c3 && g2) {
            var k2 = 0;
            for (f2 = 0; f2 < e3.length; ++f2) {
              var m = e3.charCodeAt(f2);
              127 >= m ? k2++ : 2047 >= m ? k2 += 2 : 55296 <= m && 57343 >= m ? (k2 += 4, ++f2) : k2 += 3;
            }
            f2 = k2;
          } else f2 = e3.length;
          k2 = Ib(4 + f2 + 1);
          m = k2 + 4;
          E[k2 >> 2] = f2;
          if (c3 && g2) {
            if (g2 = m, m = f2 + 1, f2 = A, 0 < m) {
              m = g2 + m - 1;
              for (var l2 = 0; l2 < e3.length; ++l2) {
                var n4 = e3.charCodeAt(l2);
                if (55296 <= n4 && 57343 >= n4) {
                  var p2 = e3.charCodeAt(++l2);
                  n4 = 65536 + ((n4 & 1023) << 10) | p2 & 1023;
                }
                if (127 >= n4) {
                  if (g2 >= m) break;
                  f2[g2++] = n4;
                } else {
                  if (2047 >= n4) {
                    if (g2 + 1 >= m) break;
                    f2[g2++] = 192 | n4 >> 6;
                  } else {
                    if (65535 >= n4) {
                      if (g2 + 2 >= m) break;
                      f2[g2++] = 224 | n4 >> 12;
                    } else {
                      if (g2 + 3 >= m) break;
                      f2[g2++] = 240 | n4 >> 18;
                      f2[g2++] = 128 | n4 >> 12 & 63;
                    }
                    f2[g2++] = 128 | n4 >> 6 & 63;
                  }
                  f2[g2++] = 128 | n4 & 63;
                }
              }
              f2[g2] = 0;
            }
          } else if (g2) for (g2 = 0; g2 < f2; ++g2) l2 = e3.charCodeAt(g2), 255 < l2 && (S2(m), L("String has UTF-16 code units that do not fit in 8 bits")), A[m + g2] = l2;
          else for (g2 = 0; g2 < f2; ++g2) A[m + g2] = e3[g2];
          null !== d2 && d2.push(S2, k2);
          return k2;
        }, argPackAdvance: 8, readValueFromPointer: Xa, V: function(d2) {
          S2(d2);
        } });
      },
      i: function(a3, b2, c3) {
        c3 = N(c3);
        if (2 === b2) {
          var d2 = tb;
          var e3 = ub;
          var f2 = vb;
          var g2 = () => ka;
          var k2 = 1;
        } else 4 === b2 && (d2 = wb, e3 = xb, f2 = yb, g2 = () => E, k2 = 2);
        W(a3, { name: c3, fromWireType: function(m) {
          for (var l2 = E[m >> 2], n4 = g2(), p2, r3 = m + 4, u3 = 0; u3 <= l2; ++u3) {
            var t3 = m + 4 + u3 * b2;
            if (u3 == l2 || 0 == n4[t3 >> k2]) r3 = d2(r3, t3 - r3), void 0 === p2 ? p2 = r3 : (p2 += String.fromCharCode(0), p2 += r3), r3 = t3 + b2;
          }
          S2(m);
          return p2;
        }, toWireType: function(m, l2) {
          "string" != typeof l2 && L("Cannot pass non-string to C++ string type " + c3);
          var n4 = f2(l2), p2 = Ib(4 + n4 + b2);
          E[p2 >> 2] = n4 >> k2;
          e3(l2, p2 + 4, n4 + b2);
          null !== m && m.push(S2, p2);
          return p2;
        }, argPackAdvance: 8, readValueFromPointer: Xa, V: function(m) {
          S2(m);
        } });
      },
      k: function(a3, b2, c3, d2, e3, f2) {
        Va[a3] = { name: N(b2), fa: Z(c3, d2), W: Z(e3, f2), ia: [] };
      },
      h: function(a3, b2, c3, d2, e3, f2, g2, k2, m, l2) {
        Va[a3].ia.push({ oa: N(b2), ta: c3, ra: Z(d2, e3), sa: f2, za: g2, ya: Z(k2, m), Aa: l2 });
      },
      C: function(a3, b2) {
        b2 = N(b2);
        W(a3, {
          va: true,
          name: b2,
          argPackAdvance: 0,
          fromWireType: function() {
          },
          toWireType: function() {
          }
        });
      },
      s: function(a3, b2, c3, d2, e3) {
        a3 = Bb[a3];
        b2 = M(b2);
        c3 = Ab(c3);
        var f2 = [];
        E[d2 >> 2] = Ea(f2);
        return a3(b2, c3, f2, e3);
      },
      t: function(a3, b2, c3, d2) {
        a3 = Bb[a3];
        b2 = M(b2);
        c3 = Ab(c3);
        a3(b2, c3, null, d2);
      },
      g: qb,
      m: function(a3, b2) {
        var c3 = Db(a3, b2), d2 = c3[0];
        b2 = d2.name + "_$" + c3.slice(1).map(function(g2) {
          return g2.name;
        }).join("_") + "$";
        var e3 = Eb[b2];
        if (void 0 !== e3) return e3;
        var f2 = Array(a3 - 1);
        e3 = Cb((g2, k2, m, l2) => {
          for (var n4 = 0, p2 = 0; p2 < a3 - 1; ++p2) f2[p2] = c3[p2 + 1].readValueFromPointer(l2 + n4), n4 += c3[p2 + 1].argPackAdvance;
          g2 = g2[k2].apply(
            g2,
            f2
          );
          for (p2 = 0; p2 < a3 - 1; ++p2) c3[p2 + 1].ma && c3[p2 + 1].ma(f2[p2]);
          if (!d2.va) return d2.toWireType(m, g2);
        });
        return Eb[b2] = e3;
      },
      D: function(a3) {
        4 < a3 && (J[a3].ga += 1);
      },
      r: function(a3) {
        var b2 = M(a3);
        Wa(b2);
        qb(a3);
      },
      c: function() {
        x("");
      },
      x: function(a3, b2, c3) {
        A.copyWithin(a3, b2, b2 + c3);
      },
      w: function(a3) {
        var b2 = A.length;
        a3 >>>= 0;
        if (2147483648 < a3) return false;
        for (var c3 = 1; 4 >= c3; c3 *= 2) {
          var d2 = b2 * (1 + 0.2 / c3);
          d2 = Math.min(d2, a3 + 100663296);
          var e3 = Math;
          d2 = Math.max(a3, d2);
          e3 = e3.min.call(e3, 2147483648, d2 + (65536 - d2 % 65536) % 65536);
          a: {
            try {
              fa.grow(e3 - ia.byteLength + 65535 >>> 16);
              na();
              var f2 = 1;
              break a;
            } catch (g2) {
            }
            f2 = void 0;
          }
          if (f2) return true;
        }
        return false;
      },
      z: function() {
        return 52;
      },
      u: function() {
        return 70;
      },
      y: function(a3, b2, c3, d2) {
        for (var e3 = 0, f2 = 0; f2 < c3; f2++) {
          var g2 = E[b2 >> 2], k2 = E[b2 + 4 >> 2];
          b2 += 8;
          for (var m = 0; m < k2; m++) {
            var l2 = A[g2 + m], n4 = Fb[a3];
            0 === l2 || 10 === l2 ? ((1 === a3 ? ea : v2)(z(n4, 0)), n4.length = 0) : n4.push(l2);
          }
          e3 += k2;
        }
        E[d2 >> 2] = e3;
        return 0;
      }
    };
    (function() {
      function a3(e3) {
        h2.asm = e3.exports;
        fa = h2.asm.E;
        na();
        oa = h2.asm.J;
        qa.unshift(h2.asm.F);
        F--;
        h2.monitorRunDependencies && h2.monitorRunDependencies(F);
        0 == F && (null !== ta && (clearInterval(ta), ta = null), G2 && (e3 = G2, G2 = null, e3()));
      }
      function b2(e3) {
        a3(e3.instance);
      }
      function c3(e3) {
        return ya().then(function(f2) {
          return WebAssembly.instantiate(f2, d2);
        }).then(function(f2) {
          return f2;
        }).then(e3, function(f2) {
          v2("failed to asynchronously prepare wasm: " + f2);
          x(f2);
        });
      }
      var d2 = { a: Jb };
      F++;
      h2.monitorRunDependencies && h2.monitorRunDependencies(F);
      if (h2.instantiateWasm) try {
        return h2.instantiateWasm(
          d2,
          a3
        );
      } catch (e3) {
        v2("Module.instantiateWasm callback failed with error: " + e3), ca(e3);
      }
      (function() {
        return w || "function" != typeof WebAssembly.instantiateStreaming || ua(H) || "function" != typeof fetch ? c3(b2) : fetch(H, { credentials: "same-origin" }).then(function(e3) {
          return WebAssembly.instantiateStreaming(e3, d2).then(b2, function(f2) {
            v2("wasm streaming compile failed: " + f2);
            v2("falling back to ArrayBuffer instantiation");
            return c3(b2);
          });
        });
      })().catch(ca);
      return {};
    })();
    h2.___wasm_call_ctors = function() {
      return (h2.___wasm_call_ctors = h2.asm.F).apply(null, arguments);
    };
    var Ka = h2.___getTypeName = function() {
      return (Ka = h2.___getTypeName = h2.asm.G).apply(null, arguments);
    };
    h2.__embind_initialize_bindings = function() {
      return (h2.__embind_initialize_bindings = h2.asm.H).apply(null, arguments);
    };
    var Ib = h2._malloc = function() {
      return (Ib = h2._malloc = h2.asm.I).apply(null, arguments);
    }, S2 = h2._free = function() {
      return (S2 = h2._free = h2.asm.K).apply(null, arguments);
    };
    h2.dynCall_jiji = function() {
      return (h2.dynCall_jiji = h2.asm.L).apply(null, arguments);
    };
    var Kb;
    G2 = function Lb() {
      Kb || Mb();
      Kb || (G2 = Lb);
    };
    function Mb() {
      function a3() {
        if (!Kb && (Kb = true, h2.calledRun = true, !ha)) {
          za(qa);
          aa(h2);
          if (h2.onRuntimeInitialized) h2.onRuntimeInitialized();
          if (h2.postRun) for ("function" == typeof h2.postRun && (h2.postRun = [h2.postRun]); h2.postRun.length; ) {
            var b2 = h2.postRun.shift();
            ra.unshift(b2);
          }
          za(ra);
        }
      }
      if (!(0 < F)) {
        if (h2.preRun) for ("function" == typeof h2.preRun && (h2.preRun = [h2.preRun]); h2.preRun.length; ) sa();
        za(pa);
        0 < F || (h2.setStatus ? (h2.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            h2.setStatus("");
          }, 1);
          a3();
        }, 1)) : a3());
      }
    }
    if (h2.preInit) for ("function" == typeof h2.preInit && (h2.preInit = [h2.preInit]); 0 < h2.preInit.length; ) h2.preInit.pop()();
    Mb();
    return loadYoga4.ready;
  };
})();
var yoga_wasm_base64_esm_default = loadYoga;

// node_modules/yoga-layout/dist/src/generated/YGEnums.js
var Align = function(Align2) {
  Align2[Align2["Auto"] = 0] = "Auto";
  Align2[Align2["FlexStart"] = 1] = "FlexStart";
  Align2[Align2["Center"] = 2] = "Center";
  Align2[Align2["FlexEnd"] = 3] = "FlexEnd";
  Align2[Align2["Stretch"] = 4] = "Stretch";
  Align2[Align2["Baseline"] = 5] = "Baseline";
  Align2[Align2["SpaceBetween"] = 6] = "SpaceBetween";
  Align2[Align2["SpaceAround"] = 7] = "SpaceAround";
  Align2[Align2["SpaceEvenly"] = 8] = "SpaceEvenly";
  return Align2;
}({});
var BoxSizing = function(BoxSizing2) {
  BoxSizing2[BoxSizing2["BorderBox"] = 0] = "BorderBox";
  BoxSizing2[BoxSizing2["ContentBox"] = 1] = "ContentBox";
  return BoxSizing2;
}({});
var Dimension = function(Dimension2) {
  Dimension2[Dimension2["Width"] = 0] = "Width";
  Dimension2[Dimension2["Height"] = 1] = "Height";
  return Dimension2;
}({});
var Direction2 = function(Direction3) {
  Direction3[Direction3["Inherit"] = 0] = "Inherit";
  Direction3[Direction3["LTR"] = 1] = "LTR";
  Direction3[Direction3["RTL"] = 2] = "RTL";
  return Direction3;
}({});
var Display = function(Display2) {
  Display2[Display2["Flex"] = 0] = "Flex";
  Display2[Display2["None"] = 1] = "None";
  Display2[Display2["Contents"] = 2] = "Contents";
  return Display2;
}({});
var Edge = function(Edge2) {
  Edge2[Edge2["Left"] = 0] = "Left";
  Edge2[Edge2["Top"] = 1] = "Top";
  Edge2[Edge2["Right"] = 2] = "Right";
  Edge2[Edge2["Bottom"] = 3] = "Bottom";
  Edge2[Edge2["Start"] = 4] = "Start";
  Edge2[Edge2["End"] = 5] = "End";
  Edge2[Edge2["Horizontal"] = 6] = "Horizontal";
  Edge2[Edge2["Vertical"] = 7] = "Vertical";
  Edge2[Edge2["All"] = 8] = "All";
  return Edge2;
}({});
var Errata = function(Errata2) {
  Errata2[Errata2["None"] = 0] = "None";
  Errata2[Errata2["StretchFlexBasis"] = 1] = "StretchFlexBasis";
  Errata2[Errata2["AbsolutePositionWithoutInsetsExcludesPadding"] = 2] = "AbsolutePositionWithoutInsetsExcludesPadding";
  Errata2[Errata2["AbsolutePercentAgainstInnerSize"] = 4] = "AbsolutePercentAgainstInnerSize";
  Errata2[Errata2["All"] = 2147483647] = "All";
  Errata2[Errata2["Classic"] = 2147483646] = "Classic";
  return Errata2;
}({});
var ExperimentalFeature = function(ExperimentalFeature2) {
  ExperimentalFeature2[ExperimentalFeature2["WebFlexBasis"] = 0] = "WebFlexBasis";
  return ExperimentalFeature2;
}({});
var FlexDirection = function(FlexDirection2) {
  FlexDirection2[FlexDirection2["Column"] = 0] = "Column";
  FlexDirection2[FlexDirection2["ColumnReverse"] = 1] = "ColumnReverse";
  FlexDirection2[FlexDirection2["Row"] = 2] = "Row";
  FlexDirection2[FlexDirection2["RowReverse"] = 3] = "RowReverse";
  return FlexDirection2;
}({});
var Gutter = function(Gutter2) {
  Gutter2[Gutter2["Column"] = 0] = "Column";
  Gutter2[Gutter2["Row"] = 1] = "Row";
  Gutter2[Gutter2["All"] = 2] = "All";
  return Gutter2;
}({});
var Justify = function(Justify2) {
  Justify2[Justify2["FlexStart"] = 0] = "FlexStart";
  Justify2[Justify2["Center"] = 1] = "Center";
  Justify2[Justify2["FlexEnd"] = 2] = "FlexEnd";
  Justify2[Justify2["SpaceBetween"] = 3] = "SpaceBetween";
  Justify2[Justify2["SpaceAround"] = 4] = "SpaceAround";
  Justify2[Justify2["SpaceEvenly"] = 5] = "SpaceEvenly";
  return Justify2;
}({});
var LogLevel = function(LogLevel2) {
  LogLevel2[LogLevel2["Error"] = 0] = "Error";
  LogLevel2[LogLevel2["Warn"] = 1] = "Warn";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Debug"] = 3] = "Debug";
  LogLevel2[LogLevel2["Verbose"] = 4] = "Verbose";
  LogLevel2[LogLevel2["Fatal"] = 5] = "Fatal";
  return LogLevel2;
}({});
var MeasureMode = function(MeasureMode2) {
  MeasureMode2[MeasureMode2["Undefined"] = 0] = "Undefined";
  MeasureMode2[MeasureMode2["Exactly"] = 1] = "Exactly";
  MeasureMode2[MeasureMode2["AtMost"] = 2] = "AtMost";
  return MeasureMode2;
}({});
var NodeType = function(NodeType2) {
  NodeType2[NodeType2["Default"] = 0] = "Default";
  NodeType2[NodeType2["Text"] = 1] = "Text";
  return NodeType2;
}({});
var Overflow = function(Overflow2) {
  Overflow2[Overflow2["Visible"] = 0] = "Visible";
  Overflow2[Overflow2["Hidden"] = 1] = "Hidden";
  Overflow2[Overflow2["Scroll"] = 2] = "Scroll";
  return Overflow2;
}({});
var PositionType = function(PositionType2) {
  PositionType2[PositionType2["Static"] = 0] = "Static";
  PositionType2[PositionType2["Relative"] = 1] = "Relative";
  PositionType2[PositionType2["Absolute"] = 2] = "Absolute";
  return PositionType2;
}({});
var Unit = function(Unit2) {
  Unit2[Unit2["Undefined"] = 0] = "Undefined";
  Unit2[Unit2["Point"] = 1] = "Point";
  Unit2[Unit2["Percent"] = 2] = "Percent";
  Unit2[Unit2["Auto"] = 3] = "Auto";
  return Unit2;
}({});
var Wrap = function(Wrap2) {
  Wrap2[Wrap2["NoWrap"] = 0] = "NoWrap";
  Wrap2[Wrap2["Wrap"] = 1] = "Wrap";
  Wrap2[Wrap2["WrapReverse"] = 2] = "WrapReverse";
  return Wrap2;
}({});
var constants2 = {
  ALIGN_AUTO: Align.Auto,
  ALIGN_FLEX_START: Align.FlexStart,
  ALIGN_CENTER: Align.Center,
  ALIGN_FLEX_END: Align.FlexEnd,
  ALIGN_STRETCH: Align.Stretch,
  ALIGN_BASELINE: Align.Baseline,
  ALIGN_SPACE_BETWEEN: Align.SpaceBetween,
  ALIGN_SPACE_AROUND: Align.SpaceAround,
  ALIGN_SPACE_EVENLY: Align.SpaceEvenly,
  BOX_SIZING_BORDER_BOX: BoxSizing.BorderBox,
  BOX_SIZING_CONTENT_BOX: BoxSizing.ContentBox,
  DIMENSION_WIDTH: Dimension.Width,
  DIMENSION_HEIGHT: Dimension.Height,
  DIRECTION_INHERIT: Direction2.Inherit,
  DIRECTION_LTR: Direction2.LTR,
  DIRECTION_RTL: Direction2.RTL,
  DISPLAY_FLEX: Display.Flex,
  DISPLAY_NONE: Display.None,
  DISPLAY_CONTENTS: Display.Contents,
  EDGE_LEFT: Edge.Left,
  EDGE_TOP: Edge.Top,
  EDGE_RIGHT: Edge.Right,
  EDGE_BOTTOM: Edge.Bottom,
  EDGE_START: Edge.Start,
  EDGE_END: Edge.End,
  EDGE_HORIZONTAL: Edge.Horizontal,
  EDGE_VERTICAL: Edge.Vertical,
  EDGE_ALL: Edge.All,
  ERRATA_NONE: Errata.None,
  ERRATA_STRETCH_FLEX_BASIS: Errata.StretchFlexBasis,
  ERRATA_ABSOLUTE_POSITION_WITHOUT_INSETS_EXCLUDES_PADDING: Errata.AbsolutePositionWithoutInsetsExcludesPadding,
  ERRATA_ABSOLUTE_PERCENT_AGAINST_INNER_SIZE: Errata.AbsolutePercentAgainstInnerSize,
  ERRATA_ALL: Errata.All,
  ERRATA_CLASSIC: Errata.Classic,
  EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS: ExperimentalFeature.WebFlexBasis,
  FLEX_DIRECTION_COLUMN: FlexDirection.Column,
  FLEX_DIRECTION_COLUMN_REVERSE: FlexDirection.ColumnReverse,
  FLEX_DIRECTION_ROW: FlexDirection.Row,
  FLEX_DIRECTION_ROW_REVERSE: FlexDirection.RowReverse,
  GUTTER_COLUMN: Gutter.Column,
  GUTTER_ROW: Gutter.Row,
  GUTTER_ALL: Gutter.All,
  JUSTIFY_FLEX_START: Justify.FlexStart,
  JUSTIFY_CENTER: Justify.Center,
  JUSTIFY_FLEX_END: Justify.FlexEnd,
  JUSTIFY_SPACE_BETWEEN: Justify.SpaceBetween,
  JUSTIFY_SPACE_AROUND: Justify.SpaceAround,
  JUSTIFY_SPACE_EVENLY: Justify.SpaceEvenly,
  LOG_LEVEL_ERROR: LogLevel.Error,
  LOG_LEVEL_WARN: LogLevel.Warn,
  LOG_LEVEL_INFO: LogLevel.Info,
  LOG_LEVEL_DEBUG: LogLevel.Debug,
  LOG_LEVEL_VERBOSE: LogLevel.Verbose,
  LOG_LEVEL_FATAL: LogLevel.Fatal,
  MEASURE_MODE_UNDEFINED: MeasureMode.Undefined,
  MEASURE_MODE_EXACTLY: MeasureMode.Exactly,
  MEASURE_MODE_AT_MOST: MeasureMode.AtMost,
  NODE_TYPE_DEFAULT: NodeType.Default,
  NODE_TYPE_TEXT: NodeType.Text,
  OVERFLOW_VISIBLE: Overflow.Visible,
  OVERFLOW_HIDDEN: Overflow.Hidden,
  OVERFLOW_SCROLL: Overflow.Scroll,
  POSITION_TYPE_STATIC: PositionType.Static,
  POSITION_TYPE_RELATIVE: PositionType.Relative,
  POSITION_TYPE_ABSOLUTE: PositionType.Absolute,
  UNIT_UNDEFINED: Unit.Undefined,
  UNIT_POINT: Unit.Point,
  UNIT_PERCENT: Unit.Percent,
  UNIT_AUTO: Unit.Auto,
  WRAP_NO_WRAP: Wrap.NoWrap,
  WRAP_WRAP: Wrap.Wrap,
  WRAP_WRAP_REVERSE: Wrap.WrapReverse
};
var YGEnums_default = constants2;

// node_modules/yoga-layout/dist/src/wrapAssembly.js
function wrapAssembly(lib3) {
  function patch(prototype, name, fn) {
    const original = prototype[name];
    prototype[name] = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return fn.call(this, original, ...args);
    };
  }
  for (const fnName of ["setPosition", "setMargin", "setFlexBasis", "setWidth", "setHeight", "setMinWidth", "setMinHeight", "setMaxWidth", "setMaxHeight", "setPadding", "setGap"]) {
    const methods = {
      [Unit.Point]: lib3.Node.prototype[fnName],
      [Unit.Percent]: lib3.Node.prototype[`${fnName}Percent`],
      [Unit.Auto]: lib3.Node.prototype[`${fnName}Auto`]
    };
    patch(lib3.Node.prototype, fnName, function(original) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      const value2 = args.pop();
      let unit, asNumber;
      if (value2 === "auto") {
        unit = Unit.Auto;
        asNumber = void 0;
      } else if (typeof value2 === "object") {
        unit = value2.unit;
        asNumber = value2.valueOf();
      } else {
        unit = typeof value2 === "string" && value2.endsWith("%") ? Unit.Percent : Unit.Point;
        asNumber = parseFloat(value2);
        if (value2 !== void 0 && !Number.isNaN(value2) && Number.isNaN(asNumber)) {
          throw new Error(`Invalid value ${value2} for ${fnName}`);
        }
      }
      if (!methods[unit]) throw new Error(`Failed to execute "${fnName}": Unsupported unit '${value2}'`);
      if (asNumber !== void 0) {
        return methods[unit].call(this, ...args, asNumber);
      } else {
        return methods[unit].call(this, ...args);
      }
    });
  }
  function wrapMeasureFunction(measureFunction) {
    return lib3.MeasureCallback.implement({
      measure: function() {
        const {
          width,
          height: height2
        } = measureFunction(...arguments);
        return {
          width: width ?? NaN,
          height: height2 ?? NaN
        };
      }
    });
  }
  patch(lib3.Node.prototype, "setMeasureFunc", function(original, measureFunc) {
    if (measureFunc) {
      return original.call(this, wrapMeasureFunction(measureFunc));
    } else {
      return this.unsetMeasureFunc();
    }
  });
  function wrapDirtiedFunc(dirtiedFunction) {
    return lib3.DirtiedCallback.implement({
      dirtied: dirtiedFunction
    });
  }
  patch(lib3.Node.prototype, "setDirtiedFunc", function(original, dirtiedFunc) {
    original.call(this, wrapDirtiedFunc(dirtiedFunc));
  });
  patch(lib3.Config.prototype, "free", function() {
    lib3.Config.destroy(this);
  });
  patch(lib3.Node, "create", (_, config3) => {
    return config3 ? lib3.Node.createWithConfig(config3) : lib3.Node.createDefault();
  });
  patch(lib3.Node.prototype, "free", function() {
    lib3.Node.destroy(this);
  });
  patch(lib3.Node.prototype, "freeRecursive", function() {
    for (let t3 = 0, T = this.getChildCount(); t3 < T; ++t3) {
      this.getChild(0).freeRecursive();
    }
    this.free();
  });
  patch(lib3.Node.prototype, "calculateLayout", function(original) {
    let width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
    let height2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
    let direction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Direction2.LTR;
    return original.call(this, width, height2, direction);
  });
  return {
    Config: lib3.Config,
    Node: lib3.Node,
    ...YGEnums_default
  };
}

// node_modules/yoga-layout/dist/src/load.js
async function loadYoga2() {
  return wrapAssembly(await yoga_wasm_base64_esm_default());
}

// node_modules/emoji-regex/index.mjs
var emoji_regex_default = () => {
  return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};

// node_modules/@react-pdf/image/lib/index.browser.js
var global$13 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup3 = [];
var revLookup3 = [];
var Arr3 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited3 = false;
function init3() {
  inited3 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i3 = 0, len = code.length; i3 < len; ++i3) {
    lookup3[i3] = code[i3];
    revLookup3[code.charCodeAt(i3)] = i3;
  }
  revLookup3["-".charCodeAt(0)] = 62;
  revLookup3["_".charCodeAt(0)] = 63;
}
function toByteArray3(b64) {
  if (!inited3) {
    init3();
  }
  var i3, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr3(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i3 = 0, j = 0; i3 < l2; i3 += 4, j += 3) {
    tmp = revLookup3[b64.charCodeAt(i3)] << 18 | revLookup3[b64.charCodeAt(i3 + 1)] << 12 | revLookup3[b64.charCodeAt(i3 + 2)] << 6 | revLookup3[b64.charCodeAt(i3 + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup3[b64.charCodeAt(i3)] << 2 | revLookup3[b64.charCodeAt(i3 + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup3[b64.charCodeAt(i3)] << 10 | revLookup3[b64.charCodeAt(i3 + 1)] << 4 | revLookup3[b64.charCodeAt(i3 + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase643(num) {
  return lookup3[num >> 18 & 63] + lookup3[num >> 12 & 63] + lookup3[num >> 6 & 63] + lookup3[num & 63];
}
function encodeChunk3(uint82, start2, end2) {
  var tmp;
  var output = [];
  for (var i3 = start2; i3 < end2; i3 += 3) {
    tmp = (uint82[i3] << 16) + (uint82[i3 + 1] << 8) + uint82[i3 + 2];
    output.push(tripletToBase643(tmp));
  }
  return output.join("");
}
function fromByteArray3(uint82) {
  if (!inited3) {
    init3();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i3 = 0, len2 = len - extraBytes; i3 < len2; i3 += maxChunkLength) {
    parts.push(encodeChunk3(uint82, i3, i3 + maxChunkLength > len2 ? len2 : i3 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup3[tmp >> 2];
    output += lookup3[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup3[tmp >> 10];
    output += lookup3[tmp >> 4 & 63];
    output += lookup3[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read3(buffer, offset2, isLE, mLen, nBytes) {
  var e3, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i3 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer[offset2 + i3];
  i3 += d2;
  e3 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e3 = e3 * 256 + buffer[offset2 + i3], i3 += d2, nBits -= 8) {
  }
  m = e3 & (1 << -nBits) - 1;
  e3 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset2 + i3], i3 += d2, nBits -= 8) {
  }
  if (e3 === 0) {
    e3 = 1 - eBias;
  } else if (e3 === eMax) {
    return m ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e3 = e3 - eBias;
  }
  return (s2 ? -1 : 1) * m * Math.pow(2, e3 - mLen);
}
function write5(buffer, value2, offset2, isLE, mLen, nBytes) {
  var e3, m, c3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i3 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m = isNaN(value2) ? 1 : 0;
    e3 = eMax;
  } else {
    e3 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c3 = Math.pow(2, -e3)) < 1) {
      e3--;
      c3 *= 2;
    }
    if (e3 + eBias >= 1) {
      value2 += rt / c3;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c3 >= 2) {
      e3++;
      c3 /= 2;
    }
    if (e3 + eBias >= eMax) {
      m = 0;
      e3 = eMax;
    } else if (e3 + eBias >= 1) {
      m = (value2 * c3 - 1) * Math.pow(2, mLen);
      e3 = e3 + eBias;
    } else {
      m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e3 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset2 + i3] = m & 255, i3 += d2, m /= 256, mLen -= 8) {
  }
  e3 = e3 << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset2 + i3] = e3 & 255, i3 += d2, e3 /= 256, eLen -= 8) {
  }
  buffer[offset2 + i3 - d2] |= s2 * 128;
}
var toString5 = {}.toString;
var isArray3 = Array.isArray || function(arr) {
  return toString5.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES3 = 50;
Buffer4.TYPED_ARRAY_SUPPORT = global$13.TYPED_ARRAY_SUPPORT !== void 0 ? global$13.TYPED_ARRAY_SUPPORT : true;
kMaxLength3();
function kMaxLength3() {
  return Buffer4.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer3(that, length2) {
  if (kMaxLength3() < length2) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length2);
    that.__proto__ = Buffer4.prototype;
  } else {
    if (that === null) {
      that = new Buffer4(length2);
    }
    that.length = length2;
  }
  return that;
}
function Buffer4(arg, encodingOrOffset, length2) {
  if (!Buffer4.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer4)) {
    return new Buffer4(arg, encodingOrOffset, length2);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe3(this, arg);
  }
  return from3(this, arg, encodingOrOffset, length2);
}
Buffer4.poolSize = 8192;
Buffer4._augment = function(arr) {
  arr.__proto__ = Buffer4.prototype;
  return arr;
};
function from3(that, value2, encodingOrOffset, length2) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer3(that, value2, encodingOrOffset, length2);
  }
  if (typeof value2 === "string") {
    return fromString3(that, value2, encodingOrOffset);
  }
  return fromObject3(that, value2);
}
Buffer4.from = function(value2, encodingOrOffset, length2) {
  return from3(null, value2, encodingOrOffset, length2);
};
if (Buffer4.TYPED_ARRAY_SUPPORT) {
  Buffer4.prototype.__proto__ = Uint8Array.prototype;
  Buffer4.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer4[Symbol.species] === Buffer4) ;
}
function assertSize3(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc3(that, size, fill4, encoding) {
  assertSize3(size);
  if (size <= 0) {
    return createBuffer3(that, size);
  }
  if (fill4 !== void 0) {
    return typeof encoding === "string" ? createBuffer3(that, size).fill(fill4, encoding) : createBuffer3(that, size).fill(fill4);
  }
  return createBuffer3(that, size);
}
Buffer4.alloc = function(size, fill4, encoding) {
  return alloc3(null, size, fill4, encoding);
};
function allocUnsafe3(that, size) {
  assertSize3(size);
  that = createBuffer3(that, size < 0 ? 0 : checked3(size) | 0);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) {
    for (var i3 = 0; i3 < size; ++i3) {
      that[i3] = 0;
    }
  }
  return that;
}
Buffer4.allocUnsafe = function(size) {
  return allocUnsafe3(null, size);
};
Buffer4.allocUnsafeSlow = function(size) {
  return allocUnsafe3(null, size);
};
function fromString3(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer4.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length2 = byteLength4(string, encoding) | 0;
  that = createBuffer3(that, length2);
  var actual = that.write(string, encoding);
  if (actual !== length2) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike3(that, array) {
  var length2 = array.length < 0 ? 0 : checked3(array.length) | 0;
  that = createBuffer3(that, length2);
  for (var i3 = 0; i3 < length2; i3 += 1) {
    that[i3] = array[i3] & 255;
  }
  return that;
}
function fromArrayBuffer3(that, array, byteOffset, length2) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length2 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length2 === void 0) {
    array = new Uint8Array(array);
  } else if (length2 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length2);
  }
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer4.prototype;
  } else {
    that = fromArrayLike3(that, array);
  }
  return that;
}
function fromObject3(that, obj) {
  if (internalIsBuffer3(obj)) {
    var len = checked3(obj.length) | 0;
    that = createBuffer3(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan3(obj.length)) {
        return createBuffer3(that, 0);
      }
      return fromArrayLike3(that, obj);
    }
    if (obj.type === "Buffer" && isArray3(obj.data)) {
      return fromArrayLike3(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked3(length2) {
  if (length2 >= kMaxLength3()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength3().toString(16) + " bytes");
  }
  return length2 | 0;
}
Buffer4.isBuffer = isBuffer$13;
function internalIsBuffer3(b2) {
  return !!(b2 != null && b2._isBuffer);
}
Buffer4.compare = function compare7(a3, b2) {
  if (!internalIsBuffer3(a3) || !internalIsBuffer3(b2)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a3 === b2) return 0;
  var x = a3.length;
  var y2 = b2.length;
  for (var i3 = 0, len = Math.min(x, y2); i3 < len; ++i3) {
    if (a3[i3] !== b2[i3]) {
      x = a3[i3];
      y2 = b2[i3];
      break;
    }
  }
  if (x < y2) return -1;
  if (y2 < x) return 1;
  return 0;
};
Buffer4.isEncoding = function isEncoding3(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer4.concat = function concat4(list, length2) {
  if (!isArray3(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer4.alloc(0);
  }
  var i3;
  if (length2 === void 0) {
    length2 = 0;
    for (i3 = 0; i3 < list.length; ++i3) {
      length2 += list[i3].length;
    }
  }
  var buffer = Buffer4.allocUnsafe(length2);
  var pos = 0;
  for (i3 = 0; i3 < list.length; ++i3) {
    var buf = list[i3];
    if (!internalIsBuffer3(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength4(string, encoding) {
  if (internalIsBuffer3(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes3(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes3(string).length;
      default:
        if (loweredCase) return utf8ToBytes3(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer4.byteLength = byteLength4;
function slowToString3(encoding, start2, end2) {
  var loweredCase = false;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (start2 > this.length) {
    return "";
  }
  if (end2 === void 0 || end2 > this.length) {
    end2 = this.length;
  }
  if (end2 <= 0) {
    return "";
  }
  end2 >>>= 0;
  start2 >>>= 0;
  if (end2 <= start2) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice3(this, start2, end2);
      case "utf8":
      case "utf-8":
        return utf8Slice3(this, start2, end2);
      case "ascii":
        return asciiSlice3(this, start2, end2);
      case "latin1":
      case "binary":
        return latin1Slice3(this, start2, end2);
      case "base64":
        return base64Slice3(this, start2, end2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice3(this, start2, end2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer4.prototype._isBuffer = true;
function swap3(b2, n4, m) {
  var i3 = b2[n4];
  b2[n4] = b2[m];
  b2[m] = i3;
}
Buffer4.prototype.swap16 = function swap163() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i3 = 0; i3 < len; i3 += 2) {
    swap3(this, i3, i3 + 1);
  }
  return this;
};
Buffer4.prototype.swap32 = function swap323() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i3 = 0; i3 < len; i3 += 4) {
    swap3(this, i3, i3 + 3);
    swap3(this, i3 + 1, i3 + 2);
  }
  return this;
};
Buffer4.prototype.swap64 = function swap643() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i3 = 0; i3 < len; i3 += 8) {
    swap3(this, i3, i3 + 7);
    swap3(this, i3 + 1, i3 + 6);
    swap3(this, i3 + 2, i3 + 5);
    swap3(this, i3 + 3, i3 + 4);
  }
  return this;
};
Buffer4.prototype.toString = function toString6() {
  var length2 = this.length | 0;
  if (length2 === 0) return "";
  if (arguments.length === 0) return utf8Slice3(this, 0, length2);
  return slowToString3.apply(this, arguments);
};
Buffer4.prototype.equals = function equals3(b2) {
  if (!internalIsBuffer3(b2)) throw new TypeError("Argument must be a Buffer");
  if (this === b2) return true;
  return Buffer4.compare(this, b2) === 0;
};
Buffer4.prototype.inspect = function inspect5() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES3;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2) str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer4.prototype.compare = function compare8(target, start2, end2, thisStart, thisEnd) {
  if (!internalIsBuffer3(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start2 === void 0) {
    start2 = 0;
  }
  if (end2 === void 0) {
    end2 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start2 >= end2) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start2 >= end2) {
    return 1;
  }
  start2 >>>= 0;
  end2 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y2 = end2 - start2;
  var len = Math.min(x, y2);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start2, end2);
  for (var i3 = 0; i3 < len; ++i3) {
    if (thisCopy[i3] !== targetCopy[i3]) {
      x = thisCopy[i3];
      y2 = targetCopy[i3];
      break;
    }
  }
  if (x < y2) return -1;
  if (y2 < x) return 1;
  return 0;
};
function bidirectionalIndexOf3(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer4.from(val, encoding);
  }
  if (internalIsBuffer3(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf3(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer4.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf3(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf3(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read4(buf, i4) {
    if (indexSize === 1) {
      return buf[i4];
    } else {
      return buf.readUInt16BE(i4 * indexSize);
    }
  }
  var i3;
  if (dir) {
    var foundIndex = -1;
    for (i3 = byteOffset; i3 < arrLength; i3++) {
      if (read4(arr, i3) === read4(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i3;
        if (i3 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i3 -= i3 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i3 = byteOffset; i3 >= 0; i3--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read4(arr, i3 + j) !== read4(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i3;
    }
  }
  return -1;
}
Buffer4.prototype.includes = function includes4(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer4.prototype.indexOf = function indexOf5(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, true);
};
Buffer4.prototype.lastIndexOf = function lastIndexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, false);
};
function hexWrite3(buf, string, offset2, length2) {
  offset2 = Number(offset2) || 0;
  var remaining = buf.length - offset2;
  if (!length2) {
    length2 = remaining;
  } else {
    length2 = Number(length2);
    if (length2 > remaining) {
      length2 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length2 > strLen / 2) {
    length2 = strLen / 2;
  }
  for (var i3 = 0; i3 < length2; ++i3) {
    var parsed = parseInt(string.substr(i3 * 2, 2), 16);
    if (isNaN(parsed)) return i3;
    buf[offset2 + i3] = parsed;
  }
  return i3;
}
function utf8Write3(buf, string, offset2, length2) {
  return blitBuffer3(utf8ToBytes3(string, buf.length - offset2), buf, offset2, length2);
}
function asciiWrite3(buf, string, offset2, length2) {
  return blitBuffer3(asciiToBytes3(string), buf, offset2, length2);
}
function latin1Write3(buf, string, offset2, length2) {
  return asciiWrite3(buf, string, offset2, length2);
}
function base64Write3(buf, string, offset2, length2) {
  return blitBuffer3(base64ToBytes3(string), buf, offset2, length2);
}
function ucs2Write3(buf, string, offset2, length2) {
  return blitBuffer3(utf16leToBytes3(string, buf.length - offset2), buf, offset2, length2);
}
Buffer4.prototype.write = function write6(string, offset2, length2, encoding) {
  if (offset2 === void 0) {
    encoding = "utf8";
    length2 = this.length;
    offset2 = 0;
  } else if (length2 === void 0 && typeof offset2 === "string") {
    encoding = offset2;
    length2 = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length2)) {
      length2 = length2 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length2;
      length2 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset2;
  if (length2 === void 0 || length2 > remaining) length2 = remaining;
  if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite3(this, string, offset2, length2);
      case "utf8":
      case "utf-8":
        return utf8Write3(this, string, offset2, length2);
      case "ascii":
        return asciiWrite3(this, string, offset2, length2);
      case "latin1":
      case "binary":
        return latin1Write3(this, string, offset2, length2);
      case "base64":
        return base64Write3(this, string, offset2, length2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write3(this, string, offset2, length2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer4.prototype.toJSON = function toJSON3() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice3(buf, start2, end2) {
  if (start2 === 0 && end2 === buf.length) {
    return fromByteArray3(buf);
  } else {
    return fromByteArray3(buf.slice(start2, end2));
  }
}
function utf8Slice3(buf, start2, end2) {
  end2 = Math.min(buf.length, end2);
  var res = [];
  var i3 = start2;
  while (i3 < end2) {
    var firstByte = buf[i3];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i3 + bytesPerSequence <= end2) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i3 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i3 + 1];
          thirdByte = buf[i3 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i3 + 1];
          thirdByte = buf[i3 + 2];
          fourthByte = buf[i3 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i3 += bytesPerSequence;
  }
  return decodeCodePointsArray3(res);
}
var MAX_ARGUMENTS_LENGTH3 = 4096;
function decodeCodePointsArray3(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH3) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i3 = 0;
  while (i3 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH3)
    );
  }
  return res;
}
function asciiSlice3(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i3 = start2; i3 < end2; ++i3) {
    ret += String.fromCharCode(buf[i3] & 127);
  }
  return ret;
}
function latin1Slice3(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i3 = start2; i3 < end2; ++i3) {
    ret += String.fromCharCode(buf[i3]);
  }
  return ret;
}
function hexSlice3(buf, start2, end2) {
  var len = buf.length;
  if (!start2 || start2 < 0) start2 = 0;
  if (!end2 || end2 < 0 || end2 > len) end2 = len;
  var out = "";
  for (var i3 = start2; i3 < end2; ++i3) {
    out += toHex3(buf[i3]);
  }
  return out;
}
function utf16leSlice3(buf, start2, end2) {
  var bytes = buf.slice(start2, end2);
  var res = "";
  for (var i3 = 0; i3 < bytes.length; i3 += 2) {
    res += String.fromCharCode(bytes[i3] + bytes[i3 + 1] * 256);
  }
  return res;
}
Buffer4.prototype.slice = function slice4(start2, end2) {
  var len = this.length;
  start2 = ~~start2;
  end2 = end2 === void 0 ? len : ~~end2;
  if (start2 < 0) {
    start2 += len;
    if (start2 < 0) start2 = 0;
  } else if (start2 > len) {
    start2 = len;
  }
  if (end2 < 0) {
    end2 += len;
    if (end2 < 0) end2 = 0;
  } else if (end2 > len) {
    end2 = len;
  }
  if (end2 < start2) end2 = start2;
  var newBuf;
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start2, end2);
    newBuf.__proto__ = Buffer4.prototype;
  } else {
    var sliceLen = end2 - start2;
    newBuf = new Buffer4(sliceLen, void 0);
    for (var i3 = 0; i3 < sliceLen; ++i3) {
      newBuf[i3] = this[i3 + start2];
    }
  }
  return newBuf;
};
function checkOffset3(offset2, ext, length2) {
  if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
  if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
}
Buffer4.prototype.readUIntLE = function readUIntLE3(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset3(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i3 = 0;
  while (++i3 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i3] * mul;
  }
  return val;
};
Buffer4.prototype.readUIntBE = function readUIntBE3(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset3(offset2, byteLength5, this.length);
  }
  var val = this[offset2 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset2 + --byteLength5] * mul;
  }
  return val;
};
Buffer4.prototype.readUInt8 = function readUInt84(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 1, this.length);
  return this[offset2];
};
Buffer4.prototype.readUInt16LE = function readUInt16LE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 2, this.length);
  return this[offset2] | this[offset2 + 1] << 8;
};
Buffer4.prototype.readUInt16BE = function readUInt16BE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 2, this.length);
  return this[offset2] << 8 | this[offset2 + 1];
};
Buffer4.prototype.readUInt32LE = function readUInt32LE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
};
Buffer4.prototype.readUInt32BE = function readUInt32BE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
};
Buffer4.prototype.readIntLE = function readIntLE3(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset3(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i3 = 0;
  while (++i3 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i3] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer4.prototype.readIntBE = function readIntBE3(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset3(offset2, byteLength5, this.length);
  var i3 = byteLength5;
  var mul = 1;
  var val = this[offset2 + --i3];
  while (i3 > 0 && (mul *= 256)) {
    val += this[offset2 + --i3] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer4.prototype.readInt8 = function readInt83(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 1, this.length);
  if (!(this[offset2] & 128)) return this[offset2];
  return (255 - this[offset2] + 1) * -1;
};
Buffer4.prototype.readInt16LE = function readInt16LE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 2, this.length);
  var val = this[offset2] | this[offset2 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer4.prototype.readInt16BE = function readInt16BE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 2, this.length);
  var val = this[offset2 + 1] | this[offset2] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer4.prototype.readInt32LE = function readInt32LE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
};
Buffer4.prototype.readInt32BE = function readInt32BE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
};
Buffer4.prototype.readFloatLE = function readFloatLE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return read3(this, offset2, true, 23, 4);
};
Buffer4.prototype.readFloatBE = function readFloatBE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return read3(this, offset2, false, 23, 4);
};
Buffer4.prototype.readDoubleLE = function readDoubleLE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 8, this.length);
  return read3(this, offset2, true, 52, 8);
};
Buffer4.prototype.readDoubleBE = function readDoubleBE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 8, this.length);
  return read3(this, offset2, false, 52, 8);
};
function checkInt3(buf, value2, offset2, ext, max2, min2) {
  if (!internalIsBuffer3(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max2 || value2 < min2) throw new RangeError('"value" argument is out of bounds');
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer4.prototype.writeUIntLE = function writeUIntLE3(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt3(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i3 = 0;
  this[offset2] = value2 & 255;
  while (++i3 < byteLength5 && (mul *= 256)) {
    this[offset2 + i3] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
};
Buffer4.prototype.writeUIntBE = function writeUIntBE3(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt3(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var i3 = byteLength5 - 1;
  var mul = 1;
  this[offset2 + i3] = value2 & 255;
  while (--i3 >= 0 && (mul *= 256)) {
    this[offset2 + i3] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
};
Buffer4.prototype.writeUInt8 = function writeUInt83(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 1, 255, 0);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
function objectWriteUInt163(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i3 = 0, j = Math.min(buf.length - offset2, 2); i3 < j; ++i3) {
    buf[offset2 + i3] = (value2 & 255 << 8 * (littleEndian ? i3 : 1 - i3)) >>> (littleEndian ? i3 : 1 - i3) * 8;
  }
}
Buffer4.prototype.writeUInt16LE = function writeUInt16LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 2, 65535, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt163(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer4.prototype.writeUInt16BE = function writeUInt16BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 2, 65535, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt163(this, value2, offset2, false);
  }
  return offset2 + 2;
};
function objectWriteUInt323(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i3 = 0, j = Math.min(buf.length - offset2, 4); i3 < j; ++i3) {
    buf[offset2 + i3] = value2 >>> (littleEndian ? i3 : 3 - i3) * 8 & 255;
  }
}
Buffer4.prototype.writeUInt32LE = function writeUInt32LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer4.prototype.writeUInt32BE = function writeUInt32BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset2, false);
  }
  return offset2 + 4;
};
Buffer4.prototype.writeIntLE = function writeIntLE3(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt3(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i3 = 0;
  var mul = 1;
  var sub = 0;
  this[offset2] = value2 & 255;
  while (++i3 < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i3 - 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i3] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
};
Buffer4.prototype.writeIntBE = function writeIntBE3(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt3(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i3 = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset2 + i3] = value2 & 255;
  while (--i3 >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i3 + 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i3] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
};
Buffer4.prototype.writeInt8 = function writeInt83(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 1, 127, -128);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
Buffer4.prototype.writeInt16LE = function writeInt16LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 2, 32767, -32768);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt163(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer4.prototype.writeInt16BE = function writeInt16BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 2, 32767, -32768);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt163(this, value2, offset2, false);
  }
  return offset2 + 2;
};
Buffer4.prototype.writeInt32LE = function writeInt32LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 4, 2147483647, -2147483648);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt323(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer4.prototype.writeInt32BE = function writeInt32BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset2, false);
  }
  return offset2 + 4;
};
function checkIEEE7543(buf, value2, offset2, ext, max2, min2) {
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset2 < 0) throw new RangeError("Index out of range");
}
function writeFloat3(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7543(buf, value2, offset2, 4);
  }
  write5(buf, value2, offset2, littleEndian, 23, 4);
  return offset2 + 4;
}
Buffer4.prototype.writeFloatLE = function writeFloatLE3(value2, offset2, noAssert) {
  return writeFloat3(this, value2, offset2, true, noAssert);
};
Buffer4.prototype.writeFloatBE = function writeFloatBE3(value2, offset2, noAssert) {
  return writeFloat3(this, value2, offset2, false, noAssert);
};
function writeDouble3(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7543(buf, value2, offset2, 8);
  }
  write5(buf, value2, offset2, littleEndian, 52, 8);
  return offset2 + 8;
}
Buffer4.prototype.writeDoubleLE = function writeDoubleLE3(value2, offset2, noAssert) {
  return writeDouble3(this, value2, offset2, true, noAssert);
};
Buffer4.prototype.writeDoubleBE = function writeDoubleBE3(value2, offset2, noAssert) {
  return writeDouble3(this, value2, offset2, false, noAssert);
};
Buffer4.prototype.copy = function copy4(target, targetStart, start2, end2) {
  if (!start2) start2 = 0;
  if (!end2 && end2 !== 0) end2 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end2 > 0 && end2 < start2) end2 = start2;
  if (end2 === start2) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start2 < 0 || start2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end2 > this.length) end2 = this.length;
  if (target.length - targetStart < end2 - start2) {
    end2 = target.length - targetStart + start2;
  }
  var len = end2 - start2;
  var i3;
  if (this === target && start2 < targetStart && targetStart < end2) {
    for (i3 = len - 1; i3 >= 0; --i3) {
      target[i3 + targetStart] = this[i3 + start2];
    }
  } else if (len < 1e3 || !Buffer4.TYPED_ARRAY_SUPPORT) {
    for (i3 = 0; i3 < len; ++i3) {
      target[i3 + targetStart] = this[i3 + start2];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start2, start2 + len),
      targetStart
    );
  }
  return len;
};
Buffer4.prototype.fill = function fill3(val, start2, end2, encoding) {
  if (typeof val === "string") {
    if (typeof start2 === "string") {
      encoding = start2;
      start2 = 0;
      end2 = this.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start2 < 0 || this.length < start2 || this.length < end2) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start2) {
    return this;
  }
  start2 = start2 >>> 0;
  end2 = end2 === void 0 ? this.length : end2 >>> 0;
  if (!val) val = 0;
  var i3;
  if (typeof val === "number") {
    for (i3 = start2; i3 < end2; ++i3) {
      this[i3] = val;
    }
  } else {
    var bytes = internalIsBuffer3(val) ? val : utf8ToBytes3(new Buffer4(val, encoding).toString());
    var len = bytes.length;
    for (i3 = 0; i3 < end2 - start2; ++i3) {
      this[i3 + start2] = bytes[i3 % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE3 = /[^+\/0-9A-Za-z-_]/g;
function base64clean3(str) {
  str = stringtrim3(str).replace(INVALID_BASE64_RE3, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim3(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex3(n4) {
  if (n4 < 16) return "0" + n4.toString(16);
  return n4.toString(16);
}
function utf8ToBytes3(string, units) {
  units = units || Infinity;
  var codePoint;
  var length2 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i3 = 0; i3 < length2; ++i3) {
    codePoint = string.charCodeAt(i3);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i3 + 1 === length2) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes3(str) {
  var byteArray = [];
  for (var i3 = 0; i3 < str.length; ++i3) {
    byteArray.push(str.charCodeAt(i3) & 255);
  }
  return byteArray;
}
function utf16leToBytes3(str, units) {
  var c3, hi, lo;
  var byteArray = [];
  for (var i3 = 0; i3 < str.length; ++i3) {
    if ((units -= 2) < 0) break;
    c3 = str.charCodeAt(i3);
    hi = c3 >> 8;
    lo = c3 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes3(str) {
  return toByteArray3(base64clean3(str));
}
function blitBuffer3(src, dst, offset2, length2) {
  for (var i3 = 0; i3 < length2; ++i3) {
    if (i3 + offset2 >= dst.length || i3 >= src.length) break;
    dst[i3 + offset2] = src[i3];
  }
  return i3;
}
function isnan3(val) {
  return val !== val;
}
function isBuffer$13(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer3(obj) || isSlowBuffer3(obj));
}
function isFastBuffer3(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer3(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer3(obj.slice(0, 0));
}
var PNG2 = class _PNG {
  constructor(data2) {
    __publicField(this, "data");
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "format");
    const png = new PNG(data2);
    this.data = data2;
    this.width = png.width;
    this.height = png.height;
    this.format = "png";
  }
  static isValid(data2) {
    try {
      return !!new _PNG(data2);
    } catch {
      return false;
    }
  }
};
var JPEG3 = class {
  constructor(data2) {
    __publicField(this, "data");
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "format");
    this.data = data2;
    this.format = "jpeg";
    if (data2.readUInt16BE(0) !== 65496) {
      throw new Error("SOI not found in JPEG");
    }
    const markers = src_default.decode(this.data);
    let orientation;
    for (let i3 = 0; i3 < markers.length; i3 += 1) {
      const marker = markers[i3];
      if (marker.name === "EXIF" && marker.entries.orientation) {
        orientation = marker.entries.orientation;
      }
      if (marker.name === "SOF") {
        this.width || (this.width = marker.width);
        this.height || (this.height = marker.height);
      }
    }
    if (orientation > 4) {
      [this.width, this.height] = [this.height, this.width];
    }
  }
  static isValid(data2) {
    return data2 && Buffer4.isBuffer(data2) && data2.readUInt16BE(0) === 65496;
  }
};
var createCache = ({ limit = 100 } = {}) => {
  let cache2 = {};
  let keys2 = [];
  return {
    get: (key) => cache2[key],
    set: (key, value2) => {
      keys2.push(key);
      if (keys2.length > limit) {
        delete cache2[keys2.shift()];
      }
      cache2[key] = value2;
    },
    reset: () => {
      cache2 = {};
      keys2 = [];
    },
    length: () => keys2.length
  };
};
var IMAGE_CACHE = createCache({ limit: 30 });
var isBuffer3 = Buffer4.isBuffer;
var isBlob = (src) => {
  return typeof Blob !== "undefined" && src instanceof Blob;
};
var isDataImageSrc = (src) => {
  return "data" in src;
};
var isBase64Src = (imageSrc) => "uri" in imageSrc && /^data:image\/[a-zA-Z]*;base64,[^"]*/g.test(imageSrc.uri);
var fetchRemoteFile = async (src) => {
  const { method = "GET", headers, body, credentials } = src;
  const response = await fetch(src.uri, {
    method,
    headers,
    body,
    credentials
  });
  const buffer = await response.arrayBuffer();
  return Buffer4.from(buffer);
};
var isValidFormat = (format3) => {
  const lower = format3.toLowerCase();
  return lower === "jpg" || lower === "jpeg" || lower === "png";
};
var guessFormat = (buffer) => {
  let format3;
  if (JPEG3.isValid(buffer)) {
    format3 = "jpg";
  } else if (PNG2.isValid(buffer)) {
    format3 = "png";
  }
  return format3;
};
function getImage(body, format3) {
  switch (format3.toLowerCase()) {
    case "jpg":
    case "jpeg":
      return new JPEG3(body);
    case "png":
      return new PNG2(body);
    default:
      return null;
  }
}
var resolveBase64Image = async ({ uri }) => {
  const match = /^data:image\/([a-zA-Z]*);base64,([^"]*)/g.exec(uri);
  const format3 = match[1];
  const data2 = match[2];
  if (!isValidFormat(format3)) {
    throw new Error(`Base64 image invalid format: ${format3}`);
  }
  return getImage(Buffer4.from(data2, "base64"), format3);
};
var resolveImageFromData = async (src) => {
  if (src.data && src.format) {
    return getImage(src.data, src.format);
  }
  throw new Error(`Invalid data given for local file: ${JSON.stringify(src)}`);
};
var resolveBufferImage = async (buffer) => {
  const format3 = guessFormat(buffer);
  if (format3) {
    return getImage(buffer, format3);
  }
  return null;
};
var resolveBlobImage = async (blob) => {
  const { type } = blob;
  if (!type || type === "application/octet-stream") {
    const arrayBuffer = await blob.arrayBuffer();
    const buffer2 = Buffer4.from(arrayBuffer);
    return resolveBufferImage(buffer2);
  }
  if (!type.startsWith("image/")) {
    throw new Error(`Invalid blob type: ${type}`);
  }
  const format3 = type.replace("image/", "");
  if (!isValidFormat(format3)) {
    throw new Error(`Invalid blob type: ${type}`);
  }
  const buffer = await blob.arrayBuffer();
  return getImage(Buffer4.from(buffer), format3);
};
var getImageFormat = (body) => {
  const isPng = body[0] === 137 && body[1] === 80 && body[2] === 78 && body[3] === 71 && body[4] === 13 && body[5] === 10 && body[6] === 26 && body[7] === 10;
  const isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;
  let extension = "";
  if (isPng) {
    extension = "png";
  } else if (isJpg) {
    extension = "jpg";
  } else {
    throw new Error("Not valid image extension");
  }
  return extension;
};
var resolveImageFromUrl = async (src) => {
  const data2 = await fetchRemoteFile(src);
  const format3 = getImageFormat(data2);
  return getImage(data2, format3);
};
var getCacheKey = (src) => {
  if (isBlob(src) || isBuffer3(src))
    return null;
  if (isDataImageSrc(src))
    return src.data.toString();
  return src.uri;
};
var resolveImage = (src, { cache: cache2 = true } = {}) => {
  let image;
  const cacheKey = getCacheKey(src);
  if (isBlob(src)) {
    image = resolveBlobImage(src);
  } else if (isBuffer3(src)) {
    image = resolveBufferImage(src);
  } else if (cache2 && IMAGE_CACHE.get(cacheKey)) {
    return IMAGE_CACHE.get(cacheKey);
  } else if (isBase64Src(src)) {
    image = resolveBase64Image(src);
  } else if (isDataImageSrc(src)) {
    image = resolveImageFromData(src);
  } else {
    image = resolveImageFromUrl(src);
  }
  if (!image) {
    throw new Error("Cannot resolve image");
  }
  if (cache2 && cacheKey) {
    IMAGE_CACHE.set(cacheKey, image);
  }
  return image;
};

// node_modules/@react-pdf/layout/lib/index.js
var fromFragments2 = (fragments) => {
  let offset2 = 0;
  let string = "";
  const runs = [];
  fragments.forEach((fragment) => {
    string += fragment.string;
    runs.push({
      start: offset2,
      end: offset2 + fragment.string.length,
      attributes: fragment.attributes || {}
    });
    offset2 += fragment.string.length;
  });
  return {
    string,
    runs
  };
};
var transformText = (text, transformation) => {
  switch (transformation) {
    case "uppercase":
      return text.toUpperCase();
    case "lowercase":
      return text.toLowerCase();
    case "capitalize":
      return capitalize(text);
    case "upperfirst":
      return upperFirst(text);
    default:
      return text;
  }
};
var StandardFont2 = class {
  constructor(src) {
    this.name = src;
    this.src = PDFFont.open(null, src);
  }
  encode(str) {
    return this.src.encode(str);
  }
  layout(str) {
    const [encoded, positions] = this.encode(str);
    return {
      positions,
      stringIndices: positions.map((_, i3) => i3),
      glyphs: encoded.map((g2, i3) => {
        const glyph = this.getGlyph(parseInt(g2, 16));
        glyph.advanceWidth = positions[i3].advanceWidth;
        return glyph;
      })
    };
  }
  glyphForCodePoint(codePoint) {
    const glyph = this.getGlyph(codePoint);
    glyph.advanceWidth = 400;
    return glyph;
  }
  getGlyph(id) {
    return {
      id,
      _font: this.src,
      codePoints: [id],
      isLigature: false,
      name: this.src.font.characterToGlyph(id)
    };
  }
  hasGlyphForCodePoint(codePoint) {
    return this.src.font.characterToGlyph(codePoint) !== ".notdef";
  }
  // Based on empirical observation
  get ascent() {
    return 900;
  }
  // Based on empirical observation
  get capHeight() {
    switch (this.name) {
      case "Times-Roman":
      case "Times-Bold":
      case "Times-Italic":
      case "Times-BoldItalic":
        return 650;
      case "Courier":
      case "Courier-Bold":
      case "Courier-Oblique":
      case "Courier-BoldOblique":
        return 550;
      default:
        return 690;
    }
  }
  // Based on empirical observation
  get xHeight() {
    switch (this.name) {
      case "Times-Roman":
      case "Times-Bold":
      case "Times-Italic":
      case "Times-BoldItalic":
        return 440;
      case "Courier":
      case "Courier-Bold":
      case "Courier-Oblique":
      case "Courier-BoldOblique":
        return 390;
      default:
        return 490;
    }
  }
  // Based on empirical observation
  get descent() {
    switch (this.name) {
      case "Times-Roman":
      case "Times-Bold":
      case "Times-Italic":
      case "Times-BoldItalic":
        return -220;
      case "Courier":
      case "Courier-Bold":
      case "Courier-Oblique":
      case "Courier-BoldOblique":
        return -230;
      default:
        return -200;
    }
  }
  get lineGap() {
    return 0;
  }
  get unitsPerEm() {
    return 1e3;
  }
};
var fontCache = {};
var IGNORED_CODE_POINTS = [173];
var getFontSize = (node) => node.attributes.fontSize || 12;
var getOrCreateFont = (name) => {
  if (fontCache[name]) return fontCache[name];
  const font = new StandardFont2(name);
  fontCache[name] = font;
  return font;
};
var getFallbackFont = () => getOrCreateFont("Helvetica");
var pickFontFromFontStack = (codePoint, fontStack, lastFont) => {
  const fontStackWithFallback = [...fontStack, lastFont, getFallbackFont()];
  for (let i3 = 0; i3 < fontStackWithFallback.length; i3 += 1) {
    const font = fontStackWithFallback[i3];
    if (!IGNORED_CODE_POINTS.includes(codePoint) && font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {
      return font;
    }
  }
  return getFallbackFont();
};
var fontSubstitution = () => (_ref) => {
  let {
    string,
    runs
  } = _ref;
  let lastFont = null;
  let lastFontSize = null;
  let lastIndex = 0;
  let index3 = 0;
  const res = [];
  for (let i3 = 0; i3 < runs.length; i3 += 1) {
    const run = runs[i3];
    const defaultFont = run.attributes.font.map((font) => typeof font === "string" ? getOrCreateFont(font) : font);
    if (string.length === 0) {
      res.push({
        start: 0,
        end: 0,
        attributes: {
          font: defaultFont
        }
      });
      break;
    }
    const chars = string.slice(run.start, run.end);
    for (let j = 0; j < chars.length; j += 1) {
      const char = chars[j];
      const codePoint = char.codePointAt();
      const font = pickFontFromFontStack(codePoint, defaultFont, lastFont);
      const fontSize = getFontSize(run);
      if (font !== lastFont || fontSize !== lastFontSize || font.unitsPerEm !== lastFont.unitsPerEm) {
        if (lastFont) {
          res.push({
            start: lastIndex,
            end: index3,
            attributes: {
              font: lastFont,
              scale: lastFontSize / lastFont.unitsPerEm
            }
          });
        }
        lastFont = font;
        lastFontSize = fontSize;
        lastIndex = index3;
      }
      index3 += char.length;
    }
  }
  if (lastIndex < string.length) {
    const fontSize = getFontSize(last(runs));
    res.push({
      start: lastIndex,
      end: string.length,
      attributes: {
        font: lastFont,
        scale: fontSize / lastFont.unitsPerEm
      }
    });
  }
  return {
    string,
    runs: res
  };
};
var isTextInstance$4 = (node) => node.type === TextInstance;
var engines$1 = {
  bidi: bidiEngine,
  linebreaker,
  justification,
  textDecoration,
  scriptItemizer,
  wordHyphenation,
  fontSubstitution
};
var engine$1 = layoutEngine(engines$1);
var getFragments$1 = (fontStore2, instance) => {
  if (!instance) return [{
    string: ""
  }];
  const fragments = [];
  const {
    fill: fill4 = "black",
    fontFamily = "Helvetica",
    fontWeight,
    fontStyle,
    fontSize = 18,
    textDecorationColor,
    textDecorationStyle,
    textTransform,
    opacity
  } = instance.props;
  const _textDecoration = instance.props.textDecoration;
  const fontFamilies = typeof fontFamily === "string" ? [fontFamily] : [...fontFamily || []];
  const font = fontFamilies.map((fontFamilyName) => {
    if (typeof fontFamilyName !== "string") return fontFamilyName;
    const opts2 = {
      fontFamily: fontFamilyName,
      fontWeight,
      fontStyle
    };
    const obj = fontStore2 ? fontStore2.getFont(opts2) : null;
    return obj ? obj.data : fontFamilyName;
  });
  const attributes2 = {
    font,
    opacity,
    fontSize,
    color: fill4,
    underlineStyle: textDecorationStyle,
    underline: _textDecoration === "underline" || _textDecoration === "underline line-through" || _textDecoration === "line-through underline",
    underlineColor: textDecorationColor || fill4,
    strike: _textDecoration === "line-through" || _textDecoration === "underline line-through" || _textDecoration === "line-through underline",
    strikeStyle: textDecorationStyle,
    strikeColor: textDecorationColor || fill4
  };
  for (let i3 = 0; i3 < instance.children.length; i3 += 1) {
    const child = instance.children[i3];
    if (isTextInstance$4(child)) {
      fragments.push({
        string: transformText(child.value, textTransform),
        attributes: attributes2
      });
    } else if (child) {
      fragments.push(...getFragments$1(child));
    }
  }
  return fragments;
};
var getAttributedString$1 = (fontStore2, instance) => fromFragments2(getFragments$1(fontStore2, instance));
var AlmostInfinity = 999999999999;
var shrinkWhitespaceFactor = {
  before: -0.5,
  after: -0.5
};
var layoutTspan = (fontStore2) => (node, xOffset) => {
  var _node$props;
  const attributedString = getAttributedString$1(fontStore2, node);
  const x = node.props.x === void 0 ? xOffset : node.props.x;
  const y2 = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.y) || 0;
  const container = {
    x,
    y: y2,
    width: AlmostInfinity,
    height: AlmostInfinity
  };
  const hyphenationCallback = node.props.hyphenationCallback || (fontStore2 === null || fontStore2 === void 0 ? void 0 : fontStore2.getHyphenationCallback()) || null;
  const layoutOptions = {
    hyphenationCallback,
    shrinkWhitespaceFactor
  };
  const lines = engine$1(attributedString, container, layoutOptions).flat();
  return Object.assign({}, node, {
    lines
  });
};
var joinTSpanLines = (node) => {
  const children = node.children.map((child, index3) => {
    const textInstance = child.children[0];
    if (child.props.x === void 0 && index3 < node.children.length - 1 && textInstance !== null && textInstance !== void 0 && textInstance.value) {
      return Object.assign({}, child, {
        children: [{
          ...textInstance,
          value: `${textInstance.value} `
        }]
      });
    }
    return child;
  }, []);
  return Object.assign({}, node, {
    children
  });
};
var layoutText$1 = (fontStore2, node) => {
  var _node$props2;
  if (!node.children) return node;
  let currentXOffset = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.x) || 0;
  const layoutFn = layoutTspan(fontStore2);
  const joinedNode = joinTSpanLines(node);
  const children = joinedNode.children.map((child) => {
    const childWithLayout = layoutFn(child, currentXOffset);
    currentXOffset += childWithLayout.lines[0].xAdvance;
    return childWithLayout;
  });
  return Object.assign({}, node, {
    children
  });
};
var isDefs = (node) => node.type === Defs;
var getDefs = (node) => {
  const children = node.children || [];
  const defs = children.find(isDefs) || {};
  const values = defs.children || [];
  return values.reduce((acc, value2) => {
    var _value$props;
    const id = (_value$props = value2.props) === null || _value$props === void 0 ? void 0 : _value$props.id;
    if (id) acc[id] = value2;
    return acc;
  }, {});
};
var isNotDefs = (node) => node.type !== Defs;
var detachDefs = (node) => {
  if (!node.children) return node;
  const children = node.children.filter(isNotDefs);
  return Object.assign({}, node, {
    children
  });
};
var URL_REGEX = /url\(['"]?#([^'"]+)['"]?\)/;
var replaceDef = (defs, value2) => {
  if (!value2) return void 0;
  if (!URL_REGEX.test(value2)) return value2;
  const match = value2.match(URL_REGEX);
  return defs[match[1]];
};
var parseNodeDefs = (defs) => (node) => {
  var _node$props, _node$props2;
  const fill4 = replaceDef(defs, (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fill);
  const clipPath2 = replaceDef(defs, (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.clipPath);
  const props = Object.assign({}, node.props, {
    fill: fill4,
    clipPath: clipPath2
  });
  const children = node.children ? node.children.map(parseNodeDefs(defs)) : void 0;
  return Object.assign({}, node, {
    props,
    children
  });
};
var parseDefs = (root) => {
  if (!root.children) return root;
  const defs = getDefs(root);
  const children = root.children.map(parseNodeDefs(defs));
  return Object.assign({}, root, {
    children
  });
};
var replaceDefs = (node) => {
  return detachDefs(parseDefs(node));
};
var parseViewbox = (value2) => {
  if (!value2) return null;
  const values = value2.split(/[,\s]+/).map(parseFloat);
  if (values.length !== 4) return null;
  return {
    minX: values[0],
    minY: values[1],
    maxX: values[2],
    maxY: values[3]
  };
};
var getContainer$1 = (node) => {
  const viewbox = parseViewbox(node.props.viewBox);
  if (viewbox) {
    return {
      width: viewbox.maxX,
      height: viewbox.maxY
    };
  }
  if (node.props.width && node.props.height) {
    return {
      width: parseFloat(node.props.width),
      height: parseFloat(node.props.height)
    };
  }
  return {
    width: 0,
    height: 0
  };
};
var BASE_SVG_INHERITED_PROPS = ["x", "y", "clipPath", "clipRule", "opacity", "fill", "fillOpacity", "fillRule", "stroke", "strokeLinecap", "strokeLinejoin", "strokeOpacity", "strokeWidth", "textAnchor", "dominantBaseline", "color", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "opacity", "textDecoration", "lineHeight", "textAlign", "visibility", "wordSpacing"];
var TEXT_SVG_INHERITED_PROPS = without(["x"], BASE_SVG_INHERITED_PROPS);
var SVG_INHERITED_PROPS = {
  [Text]: TEXT_SVG_INHERITED_PROPS
};
var getInheritProps = (node) => {
  const props = node.props || {};
  const svgInheritedProps = SVG_INHERITED_PROPS[node.type] ?? BASE_SVG_INHERITED_PROPS;
  return pick(svgInheritedProps, props);
};
var inheritProps = (node) => {
  if (!node.children) return node;
  const inheritedProps = getInheritProps(node);
  const children = node.children.map((child) => {
    const props = Object.assign({}, inheritedProps, child.props || {});
    const newChild = Object.assign({}, child, {
      props
    });
    return inheritProps(newChild);
  });
  return Object.assign({}, node, {
    children
  });
};
var parseAspectRatio = (value2) => {
  const match = value2.replace(/[\s\r\t\n]+/gm, " ").replace(/^defer\s/, "").split(" ");
  const align = match[0] || "xMidYMid";
  const meetOrSlice = match[1] || "meet";
  return {
    align,
    meetOrSlice
  };
};
var STYLE_PROPS = ["width", "height", "color", "stroke", "strokeWidth", "opacity", "fillOpacity", "strokeOpacity", "fill", "fillRule", "clipPath", "offset", "transform", "strokeLinejoin", "strokeLinecap", "strokeDasharray"];
var VERTICAL_PROPS = ["y", "y1", "y2", "height", "cy", "ry"];
var HORIZONTAL_PROPS = ["x", "x1", "x2", "width", "cx", "rx"];
var isType$3 = (type) => (node) => node.type === type;
var isSvg$3 = isType$3(Svg);
var isText$5 = isType$3(Text);
var isTextInstance$3 = isType$3(TextInstance);
var transformPercent = (container) => (props) => mapValues(props, (value2, key) => {
  const match = matchPercent(value2);
  if (match && VERTICAL_PROPS.includes(key)) {
    return match.percent * container.height;
  }
  if (match && HORIZONTAL_PROPS.includes(key)) {
    return match.percent * container.width;
  }
  return value2;
});
var parsePercent = (value2) => {
  const match = matchPercent(value2);
  return match ? match.percent : parseFloat(value2);
};
var parseTransform = (container) => (value2) => {
  return resolveStyles(container, {
    transform: value2
  }).transform;
};
var parseProps = (container) => (node) => {
  let props = transformPercent(container)(node.props);
  props = evolve({
    x: parseFloat,
    x1: parseFloat,
    x2: parseFloat,
    y: parseFloat,
    y1: parseFloat,
    y2: parseFloat,
    r: parseFloat,
    rx: parseFloat,
    ry: parseFloat,
    cx: parseFloat,
    cy: parseFloat,
    width: parseFloat,
    height: parseFloat,
    offset: parsePercent,
    fill: transformColor,
    opacity: parsePercent,
    stroke: transformColor,
    stopOpacity: parsePercent,
    stopColor: transformColor,
    transform: parseTransform(container)
  }, props);
  return Object.assign({}, node, {
    props
  });
};
var mergeStyles$1 = (node) => {
  const style = node.style || {};
  const props = Object.assign({}, style, node.props);
  return Object.assign({}, node, {
    props
  });
};
var removeNoneValues = (node) => {
  const removeNone = (value2) => value2 === "none" ? null : value2;
  const props = mapValues(node.props, removeNone);
  return Object.assign({}, node, {
    props
  });
};
var pickStyleProps = (node) => {
  const props = node.props || {};
  const styleProps = pick(STYLE_PROPS, props);
  const style = Object.assign({}, styleProps, node.style || {});
  return Object.assign({}, node, {
    style
  });
};
var parseSvgProps = (node) => {
  const props = evolve({
    width: parseFloat,
    height: parseFloat,
    viewBox: parseViewbox,
    preserveAspectRatio: parseAspectRatio
  }, node.props);
  return Object.assign({}, node, {
    props
  });
};
var wrapBetweenTspan = (node) => ({
  type: Tspan,
  props: {},
  children: [node]
});
var addMissingTspan = (node) => {
  if (!isText$5(node)) return node;
  if (!node.children) return node;
  const resolveChild = (child) => isTextInstance$3(child) ? wrapBetweenTspan(child) : child;
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children
  });
};
var parseText = (fontStore2) => (node) => {
  if (isText$5(node)) return layoutText$1(fontStore2, node);
  if (!node.children) return node;
  const children = node.children.map(parseText(fontStore2));
  return Object.assign({}, node, {
    children
  });
};
var resolveSvgNode = (container) => compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);
var resolveChildren = (container) => (node) => {
  if (!node.children) return node;
  const resolveChild = compose(resolveChildren(container), resolveSvgNode(container));
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children
  });
};
var resolveSvgRoot = (node, fontStore2) => {
  const container = getContainer$1(node);
  return compose(replaceDefs, parseText(fontStore2), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container))(node);
};
var resolveSvg = (node, fontStore2) => {
  if (!node.children) return node;
  const resolveChild = (child) => resolveSvg(child, fontStore2);
  const root = isSvg$3(node) ? resolveSvgRoot(node, fontStore2) : node;
  const children = root.children.map(resolveChild);
  return Object.assign({}, root, {
    children
  });
};
var instancePromise;
var loadYoga3 = async () => {
  const instance = await (instancePromise ?? (instancePromise = loadYoga2()));
  const config3 = instance.Config.create();
  config3.setPointScaleFactor(0);
  const node = {
    create: () => instance.Node.createWithConfig(config3)
  };
  return {
    node
  };
};
var resolveYoga = async (root) => {
  const yoga = await loadYoga3();
  return Object.assign({}, root, {
    yoga
  });
};
var getZIndex = (node) => node.style.zIndex;
var shouldSort = (node) => node.type !== Document && node.type !== Svg;
var sortZIndex = (a3, b2) => {
  const za = getZIndex(a3);
  const zb = getZIndex(b2);
  if (!za && !zb) return 0;
  if (!za) return 1;
  if (!zb) return -1;
  return zb - za;
};
var resolveZIndex = (node) => {
  if (!node.children) return node;
  const sortedChildren = shouldSort(node) ? node.children.sort(sortZIndex) : node.children;
  const children = sortedChildren.map(resolveZIndex);
  return Object.assign({}, node, {
    children
  });
};
var emojis = {};
var regex3 = emoji_regex_default();
var reflect = (promise) => function() {
  return promise(...arguments).then((v2) => v2, (e3) => e3);
};
var makeFetchEmojiImage = () => reflect(resolveImage);
var _removeVariationSelectors = (x) => x !== "";
var getCodePoints = (string, withVariationSelectors) => Array.from(string).filter(withVariationSelectors ? () => true : _removeVariationSelectors).map((char) => char.codePointAt(0).toString(16)).join("-");
var buildEmojiUrl = (emoji, source) => {
  const {
    url,
    format: format3,
    builder,
    withVariationSelectors
  } = source;
  if (typeof builder === "function") {
    return builder(getCodePoints(emoji, withVariationSelectors));
  }
  return `${url}${getCodePoints(emoji, withVariationSelectors)}.${format3}`;
};
var fetchEmojis = (string, source) => {
  if (!source || !source.url && !source.builder) return [];
  const promises = [];
  Array.from(string.matchAll(regex3)).forEach((match) => {
    const emoji = match[0];
    if (!emojis[emoji] || emojis[emoji].loading) {
      const emojiUrl = buildEmojiUrl(emoji, source);
      emojis[emoji] = {
        loading: true
      };
      const fetchEmojiImage = makeFetchEmojiImage();
      promises.push(fetchEmojiImage({
        uri: emojiUrl
      }).then((image) => {
        emojis[emoji].loading = false;
        emojis[emoji].data = image.data;
      }));
    }
  });
  return promises;
};
var embedEmojis = (fragments) => {
  const result = [];
  for (let i3 = 0; i3 < fragments.length; i3 += 1) {
    const fragment = fragments[i3];
    let lastIndex = 0;
    Array.from(fragment.string.matchAll(regex3)).forEach((match) => {
      const {
        index: index3
      } = match;
      const emoji = match[0];
      const emojiSize = fragment.attributes.fontSize;
      const chunk = fragment.string.slice(lastIndex, index3 + match[0].length);
      if (emojis[emoji] && emojis[emoji].data) {
        result.push({
          string: chunk.replace(match, String.fromCharCode(65532)),
          attributes: {
            ...fragment.attributes,
            attachment: {
              width: emojiSize,
              height: emojiSize,
              yOffset: Math.floor(emojiSize * 0.1),
              image: emojis[emoji].data
            }
          }
        });
      } else {
        result.push({
          string: chunk,
          attributes: fragment.attributes
        });
      }
      lastIndex = index3 + emoji.length;
    });
    if (lastIndex < fragment.string.length) {
      result.push({
        string: fragment.string.slice(lastIndex),
        attributes: fragment.attributes
      });
    }
  }
  return result;
};
var getSource = (node) => {
  var _node$props, _node$props2, _node$props3;
  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.src) || ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.source) || ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.href);
};
var resolveSource = async (src) => {
  const source = typeof src === "function" ? await src() : await src;
  return typeof source === "string" ? {
    uri: source
  } : source;
};
var fetchImage = async (node) => {
  const src = getSource(node);
  const {
    cache: cache2
  } = node.props;
  if (!src) {
    console.warn(false, 'Image should receive either a "src" or "source" prop');
    return;
  }
  try {
    const source = await resolveSource(src);
    if (!source) {
      throw new Error(`Image's "src" or "source" prop returned ${source}`);
    }
    node.image = await resolveImage(source, {
      cache: cache2
    });
    node.image.key = source.data ? source.data.toString() : source.uri;
  } catch (e3) {
    node.image = {
      width: 0,
      height: 0,
      key: null
    };
    console.warn(e3.message);
  }
};
var isImage$2 = (node) => node.type === Image;
var fetchAssets = (fontStore2, node) => {
  var _node$children;
  const promises = [];
  const listToExplore = ((_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children.slice(0)) || [];
  const emojiSource = fontStore2 ? fontStore2.getEmojiSource() : null;
  while (listToExplore.length > 0) {
    var _n$style;
    const n4 = listToExplore.shift();
    if (isImage$2(n4)) {
      promises.push(fetchImage(n4));
    }
    if (fontStore2 && (_n$style = n4.style) !== null && _n$style !== void 0 && _n$style.fontFamily) {
      promises.push(fontStore2.load(n4.style));
    }
    if (typeof n4 === "string") {
      promises.push(...fetchEmojis(n4, emojiSource));
    }
    if (typeof n4.value === "string") {
      promises.push(...fetchEmojis(n4.value, emojiSource));
    }
    if (n4.children) {
      n4.children.forEach((childNode) => {
        listToExplore.push(childNode);
      });
    }
  }
  return promises;
};
var resolveAssets = async (node, fontStore2) => {
  const promises = fetchAssets(fontStore2, node);
  await Promise.all(promises);
  return node;
};
var isLink$1 = (node) => node.type === Link;
var DEFAULT_LINK_STYLES = {
  color: "blue",
  textDecoration: "underline"
};
var computeStyle = (container, node) => {
  let baseStyle = node.style;
  if (isLink$1(node)) {
    baseStyle = Array.isArray(node.style) ? [DEFAULT_LINK_STYLES, ...node.style] : [DEFAULT_LINK_STYLES, node.style];
  }
  return resolveStyles(container, baseStyle);
};
var resolveNodeStyles = (container) => (node) => {
  const style = computeStyle(container, node);
  if (!node.children) return Object.assign({}, node, {
    style
  });
  const children = node.children.map(resolveNodeStyles(container));
  return Object.assign({}, node, {
    style,
    children
  });
};
var resolvePageStyles = (page) => {
  var _page$props, _page$box, _page$box2, _page$props2, _page$style;
  const dpi = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.dpi) || 72;
  const width = ((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.width) || page.style.width;
  const height2 = ((_page$box2 = page.box) === null || _page$box2 === void 0 ? void 0 : _page$box2.height) || page.style.height;
  const orientation = ((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.orientation) || "portrait";
  const remBase = ((_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.fontSize) || 18;
  const container = {
    width,
    height: height2,
    orientation,
    dpi,
    remBase
  };
  return resolveNodeStyles(container)(page);
};
var resolveStyles2 = (root) => {
  if (!root.children) return root;
  const children = root.children.map(resolvePageStyles);
  return Object.assign({}, root, {
    children
  });
};
var getTransformStyle = (s2) => (node) => {
  var _node$style, _node$style2;
  return isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style[s2]) ? "50%" : (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2[s2];
};
var getOrigin = (node) => {
  if (!node.box) return {};
  const {
    left,
    top,
    width,
    height: height2
  } = node.box;
  const transformOriginX = getTransformStyle("transformOriginX")(node);
  const transformOriginY = getTransformStyle("transformOriginY")(node);
  const percentX = matchPercent(transformOriginX);
  const percentY = matchPercent(transformOriginY);
  const offsetX = percentX ? width * percentX.percent : transformOriginX;
  const offsetY = percentY ? height2 * percentY.percent : transformOriginY;
  return {
    left: left + offsetX,
    top: top + offsetY
  };
};
var resolveNodeOrigin = (node) => {
  const origin = getOrigin(node);
  const newNode = Object.assign({}, node, {
    origin
  });
  if (!node.children) return newNode;
  const children = node.children.map(resolveNodeOrigin);
  return Object.assign({}, newNode, {
    children
  });
};
var resolveOrigin = (root) => {
  if (!root.children) return root;
  const children = root.children.map(resolveNodeOrigin);
  return Object.assign({}, root, {
    children
  });
};
var getBookmarkValue = (title3) => {
  return typeof title3 === "string" ? {
    title: title3,
    fit: false,
    expanded: false
  } : title3;
};
var resolveBookmarks = (node) => {
  let refs = 0;
  const children = (node.children || []).slice(0);
  const listToExplore = children.map((value2) => ({
    value: value2,
    parent: null
  }));
  while (listToExplore.length > 0) {
    var _child$props;
    const element = listToExplore.shift();
    const child = element.value;
    let parent = element.parent;
    if ((_child$props = child.props) !== null && _child$props !== void 0 && _child$props.bookmark) {
      var _parent;
      const bookmark = getBookmarkValue(child.props.bookmark);
      const ref = refs++;
      const newHierarchy = {
        ref,
        parent: (_parent = parent) === null || _parent === void 0 ? void 0 : _parent.ref,
        ...bookmark
      };
      child.props.bookmark = newHierarchy;
      parent = newHierarchy;
    }
    if (child.children) {
      child.children.forEach((childNode) => {
        listToExplore.push({
          value: childNode,
          parent
        });
      });
    }
  }
  return node;
};
var VALID_ORIENTATIONS = ["portrait", "landscape"];
var getOrientation = (page) => {
  var _page$props;
  const value2 = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.orientation) || "portrait";
  return VALID_ORIENTATIONS.includes(value2) ? value2 : "portrait";
};
var isLandscape = (page) => getOrientation(page) === "landscape";
var PAGE_SIZES = {
  "4A0": [4767.87, 6740.79],
  "2A0": [3370.39, 4767.87],
  A0: [2383.94, 3370.39],
  A1: [1683.78, 2383.94],
  A2: [1190.55, 1683.78],
  A3: [841.89, 1190.55],
  A4: [595.28, 841.89],
  A5: [419.53, 595.28],
  A6: [297.64, 419.53],
  A7: [209.76, 297.64],
  A8: [147.4, 209.76],
  A9: [104.88, 147.4],
  A10: [73.7, 104.88],
  B0: [2834.65, 4008.19],
  B1: [2004.09, 2834.65],
  B2: [1417.32, 2004.09],
  B3: [1000.63, 1417.32],
  B4: [708.66, 1000.63],
  B5: [498.9, 708.66],
  B6: [354.33, 498.9],
  B7: [249.45, 354.33],
  B8: [175.75, 249.45],
  B9: [124.72, 175.75],
  B10: [87.87, 124.72],
  C0: [2599.37, 3676.54],
  C1: [1836.85, 2599.37],
  C2: [1298.27, 1836.85],
  C3: [918.43, 1298.27],
  C4: [649.13, 918.43],
  C5: [459.21, 649.13],
  C6: [323.15, 459.21],
  C7: [229.61, 323.15],
  C8: [161.57, 229.61],
  C9: [113.39, 161.57],
  C10: [79.37, 113.39],
  RA0: [2437.8, 3458.27],
  RA1: [1729.13, 2437.8],
  RA2: [1218.9, 1729.13],
  RA3: [864.57, 1218.9],
  RA4: [609.45, 864.57],
  SRA0: [2551.18, 3628.35],
  SRA1: [1814.17, 2551.18],
  SRA2: [1275.59, 1814.17],
  SRA3: [907.09, 1275.59],
  SRA4: [637.8, 907.09],
  EXECUTIVE: [521.86, 756],
  FOLIO: [612, 936],
  LEGAL: [612, 1008],
  LETTER: [612, 792],
  TABLOID: [792, 1224],
  ID1: [153, 243]
};
var parseValue2 = (value2) => {
  const match = /^(-?\d*\.?\d+)(in|mm|cm|pt|px)?$/g.exec(value2);
  return match ? {
    value: parseFloat(match[1]),
    unit: match[2] || "pt"
  } : {
    value: value2,
    unit: void 0
  };
};
var transformUnit2 = (value2, inputDpi) => {
  const scalar = parseValue2(value2);
  const outputDpi = 72;
  const mmFactor = 1 / 25.4 * outputDpi;
  const cmFactor = 1 / 2.54 * outputDpi;
  switch (scalar.unit) {
    case "in":
      return scalar.value * outputDpi;
    case "mm":
      return scalar.value * mmFactor;
    case "cm":
      return scalar.value * cmFactor;
    case "px":
      return Math.round(scalar.value * (outputDpi / inputDpi));
    default:
      return scalar.value;
  }
};
var transformUnits = (_ref, dpi) => {
  let {
    width,
    height: height2
  } = _ref;
  return {
    width: transformUnit2(width, dpi),
    height: transformUnit2(height2, dpi)
  };
};
var toSizeObject = (v2) => ({
  width: v2[0],
  height: v2[1]
});
var flipSizeObject = (v2) => ({
  width: v2.height,
  height: v2.width
});
var getStringSize = (v2) => {
  return toSizeObject(PAGE_SIZES[v2.toUpperCase()]);
};
var getNumberSize = (n4) => toSizeObject([n4, n4]);
var getSize = (page) => {
  var _page$props, _page$props2;
  const value2 = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.size) || "A4";
  const dpi = parseFloat(((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.dpi) || 72);
  const type = typeof value2;
  let size;
  if (type === "string") {
    size = getStringSize(value2);
  } else if (Array.isArray(value2)) {
    size = transformUnits(toSizeObject(value2), dpi);
  } else if (type === "number") {
    size = transformUnits(getNumberSize(value2), dpi);
  } else {
    size = transformUnits(value2, dpi);
  }
  return isLandscape(page) ? flipSizeObject(size) : size;
};
var resolvePageSize = (page) => {
  const size = getSize(page);
  const style = flatten(page.style || {});
  const box = page.box || {};
  return {
    ...page,
    box,
    style: {
      ...style,
      ...size
    }
  };
};
var resolvePageSizes = (root) => {
  if (!root.children) return root;
  const children = root.children.map(resolvePageSize);
  return Object.assign({}, root, {
    children
  });
};
var isFixed = (node) => {
  var _node$props;
  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fixed) === true;
};
var lineIndexAtHeight = (node, height2) => {
  let y2 = 0;
  if (!node.lines) return 0;
  for (let i3 = 0; i3 < node.lines.length; i3 += 1) {
    const line2 = node.lines[i3];
    if (y2 + line2.box.height > height2) return i3;
    y2 += line2.box.height;
  }
  return node.lines.length;
};
var heightAtLineIndex = (node, index3) => {
  let counter = 0;
  if (!node.lines) return counter;
  for (let i3 = 0; i3 < index3; i3 += 1) {
    const line2 = node.lines[i3];
    if (!line2) break;
    counter += line2.box.height;
  }
  return counter;
};
var getLineBreak = (node, height2) => {
  const top = get(node, ["box", "top"], 0);
  const widows = get(node, ["props", "widows"], 2);
  const orphans = get(node, ["props", "orphans"], 2);
  const linesQuantity = node.lines.length;
  const slicedLine = lineIndexAtHeight(node, height2 - top);
  if (slicedLine === 0) {
    return 0;
  }
  if (linesQuantity < orphans) {
    return linesQuantity;
  }
  if (slicedLine < orphans || linesQuantity < orphans + widows) {
    return 0;
  }
  if (linesQuantity === orphans + widows) {
    return orphans;
  }
  if (linesQuantity - slicedLine < widows) {
    return linesQuantity - widows;
  }
  return slicedLine;
};
var splitText = (node, height2) => {
  const slicedLineIndex = getLineBreak(node, height2);
  const currentHeight = heightAtLineIndex(node, slicedLineIndex);
  const nextHeight = node.box.height - currentHeight;
  const current = Object.assign({}, node, {
    box: {
      ...node.box,
      height: currentHeight,
      borderBottomWidth: 0
    },
    style: {
      ...node.style,
      marginBottom: 0,
      paddingBottom: 0,
      borderBottomWidth: 0,
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    },
    lines: node.lines.slice(0, slicedLineIndex)
  });
  const next = Object.assign({}, node, {
    box: {
      ...node.box,
      top: 0,
      height: nextHeight,
      borderTopWidth: 0
    },
    style: {
      ...node.style,
      marginTop: 0,
      paddingTop: 0,
      borderTopWidth: 0,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    },
    lines: node.lines.slice(slicedLineIndex)
  });
  return [current, next];
};
var getTop$1 = (node) => {
  var _node$box;
  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;
};
var hasFixedHeight = (node) => {
  var _node$style;
  return !isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height);
};
var splitNode = (node, height2) => {
  if (!node) return [null, null];
  const nodeTop = getTop$1(node);
  const current = Object.assign({}, node, {
    box: {
      ...node.box,
      borderBottomWidth: 0
    },
    style: {
      ...node.style,
      marginBottom: 0,
      paddingBottom: 0,
      borderBottomWidth: 0,
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    }
  });
  current.style.height = height2 - nodeTop;
  const nextHeight = hasFixedHeight(node) ? node.box.height - (height2 - nodeTop) : null;
  const next = Object.assign({}, node, {
    box: {
      ...node.box,
      top: 0,
      borderTopWidth: 0
    },
    style: {
      ...node.style,
      marginTop: 0,
      paddingTop: 0,
      borderTopWidth: 0,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    }
  });
  if (nextHeight) {
    next.style.height = nextHeight;
  }
  return [current, next];
};
var NON_WRAP_TYPES = [Svg, Note, Image, Canvas];
var getWrap = (node) => {
  var _node$props;
  if (NON_WRAP_TYPES.includes(node.type)) return false;
  return isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.wrap) ? true : node.props.wrap;
};
var getComputedPadding = (node, edge) => {
  const {
    yogaNode
  } = node;
  return yogaNode ? yogaNode.getComputedPadding(edge) : null;
};
var getPadding = (node) => {
  const {
    style,
    box
  } = node;
  const paddingTop = getComputedPadding(node, Edge.Top) || (box === null || box === void 0 ? void 0 : box.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;
  const paddingRight = getComputedPadding(node, Edge.Right) || (box === null || box === void 0 ? void 0 : box.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;
  const paddingBottom = getComputedPadding(node, Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;
  const paddingLeft = getComputedPadding(node, Edge.Left) || (box === null || box === void 0 ? void 0 : box.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;
  return {
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft
  };
};
var getWrapArea = (page) => {
  var _page$style;
  const {
    paddingBottom
  } = getPadding(page);
  const height2 = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;
  return height2 - paddingBottom;
};
var getContentArea = (page) => {
  var _page$style;
  const height2 = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;
  const {
    paddingTop,
    paddingBottom
  } = getPadding(page);
  return height2 - paddingBottom - paddingTop;
};
var isString3 = (value2) => typeof value2 === "string";
var isNumber4 = (value2) => typeof value2 === "number";
var isFragment = (value2) => value2 && value2.type === Symbol.for("react.fragment");
var createInstances = (element) => {
  if (!element) return [];
  if (isString3(element) || isNumber4(element)) {
    return [{
      type: TextInstance,
      value: `${element}`
    }];
  }
  if (isFragment(element)) {
    return createInstances(element.props.children);
  }
  if (Array.isArray(element)) {
    return element.reduce((acc, el) => acc.concat(createInstances(el)), []);
  }
  if (!isString3(element.type)) {
    return createInstances(element.type(element.props));
  }
  const {
    type,
    props: {
      style = {},
      children = [],
      ...props
    }
  } = element;
  const nextChildren = castArray(children).reduce((acc, child) => acc.concat(createInstances(child)), []);
  return [{
    type,
    style,
    props,
    box: {},
    children: nextChildren
  }];
};
var getBreak = (node) => {
  var _node$props;
  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.break) || false;
};
var getMinPresenceAhead = (node) => {
  var _node$props2;
  return ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.minPresenceAhead) || 0;
};
var getFurthestEnd = (elements) => Math.max(...elements.map((node) => node.box.top + node.box.height));
var getEndOfMinPresenceAhead = (child) => {
  return child.box.top + child.box.height + child.box.marginBottom + getMinPresenceAhead(child);
};
var getEndOfPresence = (child, futureElements) => {
  const afterMinPresenceAhead = getEndOfMinPresenceAhead(child);
  const endOfFurthestFutureElement = getFurthestEnd(futureElements.filter((node) => {
    var _node$props3;
    return !((_node$props3 = node.props) !== null && _node$props3 !== void 0 && _node$props3.fixed);
  }));
  return Math.min(afterMinPresenceAhead, endOfFurthestFutureElement);
};
var shouldBreak = (child, futureElements, height2) => {
  var _child$props;
  if ((_child$props = child.props) !== null && _child$props !== void 0 && _child$props.fixed) return false;
  const shouldSplit = height2 < child.box.top + child.box.height;
  const canWrap = getWrap(child);
  const endOfPresence = getEndOfPresence(child, futureElements);
  const breakingImprovesPresence = child.box.top > child.box.marginTop;
  return getBreak(child) || shouldSplit && !canWrap || !shouldSplit && endOfPresence > height2 && breakingImprovesPresence;
};
var IGNORABLE_CODEPOINTS = [
  8232,
  // LINE_SEPARATOR
  8233
  // PARAGRAPH_SEPARATOR
];
var buildSubsetForFont = (font) => IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {
  if (font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {
    return acc;
  }
  return [...acc, String.fromCharCode(codePoint)];
}, []);
var ignoreChars = (fragments) => fragments.map((fragment) => {
  const charSubset = buildSubsetForFont(fragment.attributes.font);
  const subsetRegex = new RegExp(charSubset.join("|"));
  return {
    string: fragment.string.replace(subsetRegex, ""),
    attributes: fragment.attributes
  };
});
var PREPROCESSORS = [ignoreChars, embedEmojis];
var isImage$1 = (node) => node.type === Image;
var isTextInstance$2 = (node) => node.type === TextInstance;
var getFragments = function(fontStore2, instance, parentLink, level) {
  var _instance$props, _instance$props2;
  if (level === void 0) {
    level = 0;
  }
  if (!instance) return [{
    string: ""
  }];
  let fragments = [];
  const {
    color = "black",
    direction = "ltr",
    fontFamily = "Helvetica",
    fontWeight,
    fontStyle,
    fontSize = 18,
    textAlign,
    lineHeight,
    textDecoration: textDecoration2,
    textDecorationColor,
    textDecorationStyle,
    textTransform,
    letterSpacing,
    textIndent,
    opacity,
    verticalAlign
  } = instance.style;
  const fontFamilies = typeof fontFamily === "string" ? [fontFamily] : [...fontFamily || []];
  const font = fontFamilies.map((fontFamilyName) => {
    if (typeof fontFamilyName !== "string") return fontFamilyName;
    const opts2 = {
      fontFamily: fontFamilyName,
      fontWeight,
      fontStyle
    };
    const obj = fontStore2 ? fontStore2.getFont(opts2) : null;
    return obj ? obj.data : fontFamilyName;
  });
  const backgroundColor = level === 0 ? null : instance.style.backgroundColor;
  const attributes2 = {
    font,
    color,
    opacity,
    fontSize,
    lineHeight,
    direction,
    verticalAlign,
    backgroundColor,
    indent: textIndent,
    characterSpacing: letterSpacing,
    strikeStyle: textDecorationStyle,
    underlineStyle: textDecorationStyle,
    underline: textDecoration2 === "underline" || textDecoration2 === "underline line-through" || textDecoration2 === "line-through underline",
    strike: textDecoration2 === "line-through" || textDecoration2 === "underline line-through" || textDecoration2 === "line-through underline",
    strikeColor: textDecorationColor || color,
    underlineColor: textDecorationColor || color,
    link: parentLink || ((_instance$props = instance.props) === null || _instance$props === void 0 ? void 0 : _instance$props.src) || ((_instance$props2 = instance.props) === null || _instance$props2 === void 0 ? void 0 : _instance$props2.href),
    align: textAlign || (direction === "rtl" ? "right" : "left")
  };
  for (let i3 = 0; i3 < instance.children.length; i3 += 1) {
    const child = instance.children[i3];
    if (isImage$1(child)) {
      fragments.push({
        string: String.fromCharCode(65532),
        attributes: {
          ...attributes2,
          attachment: {
            width: child.style.width || fontSize,
            height: child.style.height || fontSize,
            image: child.image.data
          }
        }
      });
    } else if (isTextInstance$2(child)) {
      fragments.push({
        string: transformText(child.value, textTransform),
        attributes: attributes2
      });
    } else if (child) {
      fragments.push(...getFragments(fontStore2, child, attributes2.link, level + 1));
    }
  }
  for (let i3 = 0; i3 < PREPROCESSORS.length; i3 += 1) {
    const preprocessor = PREPROCESSORS[i3];
    fragments = preprocessor(fragments);
  }
  return fragments;
};
var getAttributedString = (fontStore2, instance) => {
  const fragments = getFragments(fontStore2, instance);
  return fromFragments2(fragments);
};
var engines = {
  bidi: bidiEngine,
  linebreaker,
  justification,
  textDecoration,
  scriptItemizer,
  wordHyphenation,
  fontSubstitution
};
var engine = layoutEngine(engines);
var getMaxLines = (node) => {
  var _node$style;
  return (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.maxLines;
};
var getTextOverflow = (node) => {
  var _node$style2;
  return (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.textOverflow;
};
var getContainer = (width, height2, node) => {
  const maxLines = getMaxLines(node);
  const textOverflow = getTextOverflow(node);
  return {
    x: 0,
    y: 0,
    width,
    maxLines,
    height: height2 || Infinity,
    truncateMode: textOverflow
  };
};
var getLayoutOptions = (fontStore2, node) => ({
  hyphenationPenalty: node.props.hyphenationPenalty,
  shrinkWhitespaceFactor: {
    before: -0.5,
    after: -0.5
  },
  hyphenationCallback: node.props.hyphenationCallback || (fontStore2 === null || fontStore2 === void 0 ? void 0 : fontStore2.getHyphenationCallback()) || null
});
var layoutText = (node, width, height2, fontStore2) => {
  const attributedString = getAttributedString(fontStore2, node);
  const container = getContainer(width, height2, node);
  const options = getLayoutOptions(fontStore2, node);
  const lines = engine(attributedString, container, options);
  return lines.reduce((acc, line2) => [...acc, ...line2], []);
};
var isType$2 = (type) => (node) => node.type === type;
var isSvg$2 = isType$2(Svg);
var isText$4 = isType$2(Text);
var shouldIterate = (node) => !isSvg$2(node) && !isText$4(node);
var shouldLayoutText = (node) => isText$4(node) && !node.lines;
var resolveTextLayout = (node, fontStore2) => {
  if (shouldLayoutText(node)) {
    const width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);
    const height2 = node.box.height - (node.box.paddingTop + node.box.paddingBottom);
    node.lines = layoutText(node, width, height2, fontStore2);
  }
  if (shouldIterate(node)) {
    if (!node.children) return node;
    const mapChild = (child) => resolveTextLayout(child, fontStore2);
    const children = node.children.map(mapChild);
    return Object.assign({}, node, {
      children
    });
  }
  return node;
};
var BASE_INHERITABLE_PROPERTIES = ["color", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "opacity", "textDecoration", "textTransform", "lineHeight", "textAlign", "visibility", "wordSpacing"];
var TEXT_INHERITABLE_PROPERTIES = [...BASE_INHERITABLE_PROPERTIES, "backgroundColor"];
var isSvg$1 = (node) => node.type === Svg;
var isText$3 = (node) => node.type === Text;
var mergeValues = (styleName, value2, inheritedValue) => {
  switch (styleName) {
    case "textDecoration": {
      return [inheritedValue, value2].filter((v2) => v2 && v2 !== "none").join(" ");
    }
    default:
      return value2;
  }
};
var merge = (inheritedStyles, style) => {
  const mergedStyles = {
    ...inheritedStyles
  };
  Object.entries(style).forEach((_ref) => {
    let [styleName, value2] = _ref;
    mergedStyles[styleName] = mergeValues(styleName, value2, inheritedStyles[styleName]);
  });
  return mergedStyles;
};
var mergeStyles2 = (inheritedStyles) => (node) => {
  const style = merge(inheritedStyles, node.style || {});
  return Object.assign({}, node, {
    style
  });
};
var resolveInheritance = (node) => {
  if (isSvg$1(node)) return node;
  if (!node.children) return node;
  const inheritableProperties = isText$3(node) ? TEXT_INHERITABLE_PROPERTIES : BASE_INHERITABLE_PROPERTIES;
  const inheritStyles = pick(inheritableProperties, node.style || {});
  const resolveChild = compose(resolveInheritance, mergeStyles2(inheritStyles));
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children
  });
};
var getComputedMargin = (node, edge) => {
  const {
    yogaNode
  } = node;
  return yogaNode ? yogaNode.getComputedMargin(edge) : null;
};
var getMargin2 = (node) => {
  const {
    style,
    box
  } = node;
  const marginTop = getComputedMargin(node, Edge.Top) || (box === null || box === void 0 ? void 0 : box.marginTop) || (style === null || style === void 0 ? void 0 : style.marginTop) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;
  const marginRight = getComputedMargin(node, Edge.Right) || (box === null || box === void 0 ? void 0 : box.marginRight) || (style === null || style === void 0 ? void 0 : style.marginRight) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;
  const marginBottom = getComputedMargin(node, Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;
  const marginLeft = getComputedMargin(node, Edge.Left) || (box === null || box === void 0 ? void 0 : box.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;
  return {
    marginTop,
    marginRight,
    marginBottom,
    marginLeft
  };
};
var getPosition = (node) => {
  const {
    yogaNode
  } = node;
  return {
    top: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedTop()) || 0,
    right: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedRight()) || 0,
    bottom: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedBottom()) || 0,
    left: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedLeft()) || 0
  };
};
var DEFAULT_DIMENSION = {
  width: 0,
  height: 0
};
var getDimension = (node) => {
  const {
    yogaNode
  } = node;
  if (!yogaNode) return DEFAULT_DIMENSION;
  return {
    width: yogaNode.getComputedWidth(),
    height: yogaNode.getComputedHeight()
  };
};
var getComputedBorder = (yogaNode, edge) => yogaNode ? yogaNode.getComputedBorder(edge) : 0;
var getBorderWidth = (node) => {
  const {
    yogaNode
  } = node;
  return {
    borderTopWidth: getComputedBorder(yogaNode, Edge.Top),
    borderRightWidth: getComputedBorder(yogaNode, Edge.Right),
    borderBottomWidth: getComputedBorder(yogaNode, Edge.Bottom),
    borderLeftWidth: getComputedBorder(yogaNode, Edge.Left)
  };
};
var setDisplay = (value2) => (node) => {
  const {
    yogaNode
  } = node;
  if (yogaNode) {
    yogaNode.setDisplay(value2 === "none" ? Display.None : Display.Flex);
  }
  return node;
};
var OVERFLOW = {
  hidden: Overflow.Hidden,
  scroll: Overflow.Scroll
};
var setOverflow = (value2) => (node) => {
  const {
    yogaNode
  } = node;
  if (!isNil(value2) && yogaNode) {
    const overflow = OVERFLOW[value2] || Overflow.Visible;
    yogaNode.setOverflow(overflow);
  }
  return node;
};
var FLEX_WRAP = {
  wrap: Wrap.Wrap,
  "wrap-reverse": Wrap.WrapReverse
};
var setFlexWrap = (value2) => (node) => {
  const {
    yogaNode
  } = node;
  if (yogaNode) {
    const flexWrap = FLEX_WRAP[value2] || Wrap.NoWrap;
    yogaNode.setFlexWrap(flexWrap);
  }
  return node;
};
var setYogaValue = (attr, edge) => (value2) => (node) => {
  const {
    yogaNode
  } = node;
  if (!isNil(value2) && yogaNode) {
    const hasEdge = !isNil(edge);
    const fixedMethod = `set${upperFirst(attr)}`;
    const autoMethod = `${fixedMethod}Auto`;
    const percentMethod = `${fixedMethod}Percent`;
    const percent = matchPercent(value2);
    if (percent && !yogaNode[percentMethod]) {
      throw new Error(`You can't pass percentage values to ${attr} property`);
    }
    if (percent) {
      if (hasEdge) {
        var _yogaNode$percentMeth;
        (_yogaNode$percentMeth = yogaNode[percentMethod]) === null || _yogaNode$percentMeth === void 0 ? void 0 : _yogaNode$percentMeth.call(yogaNode, edge, percent.value);
      } else {
        var _yogaNode$percentMeth2;
        (_yogaNode$percentMeth2 = yogaNode[percentMethod]) === null || _yogaNode$percentMeth2 === void 0 ? void 0 : _yogaNode$percentMeth2.call(yogaNode, percent.value);
      }
    } else if (value2 === "auto") {
      if (hasEdge) {
        var _yogaNode$autoMethod;
        (_yogaNode$autoMethod = yogaNode[autoMethod]) === null || _yogaNode$autoMethod === void 0 ? void 0 : _yogaNode$autoMethod.call(yogaNode, edge);
      } else {
        var _yogaNode$autoMethod2;
        (_yogaNode$autoMethod2 = yogaNode[autoMethod]) === null || _yogaNode$autoMethod2 === void 0 ? void 0 : _yogaNode$autoMethod2.call(yogaNode);
      }
    } else if (hasEdge) {
      var _yogaNode$fixedMethod;
      (_yogaNode$fixedMethod = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod === void 0 ? void 0 : _yogaNode$fixedMethod.call(yogaNode, edge, value2);
    } else {
      var _yogaNode$fixedMethod2;
      (_yogaNode$fixedMethod2 = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod2 === void 0 ? void 0 : _yogaNode$fixedMethod2.call(yogaNode, value2);
    }
  }
  return node;
};
var setFlexGrow = (value2) => (node) => {
  return setYogaValue("flexGrow")(value2 || 0)(node);
};
var setFlexBasis = setYogaValue("flexBasis");
var ALIGN = {
  "flex-start": Align.FlexStart,
  center: Align.Center,
  "flex-end": Align.FlexEnd,
  stretch: Align.Stretch,
  baseline: Align.Baseline,
  "space-between": Align.SpaceBetween,
  "space-around": Align.SpaceAround,
  "space-evenly": Align.SpaceEvenly
};
var setAlign = (attr) => (value2) => (node) => {
  const {
    yogaNode
  } = node;
  const defaultValue = attr === "items" ? Align.Stretch : Align.Auto;
  if (yogaNode) {
    const align = ALIGN[value2] || defaultValue;
    yogaNode[`setAlign${upperFirst(attr)}`](align);
  }
  return node;
};
var setAlignSelf = setAlign("self");
var setAlignItems = setAlign("items");
var setFlexShrink = (value2) => (node) => {
  return setYogaValue("flexShrink")(value2 || 1)(node);
};
var setAspectRatio = (value2) => (node) => {
  const {
    yogaNode
  } = node;
  if (!isNil(value2) && yogaNode) {
    yogaNode.setAspectRatio(value2);
  }
  return node;
};
var setAlignContent = setAlign("content");
var POSITION = {
  absolute: PositionType.Absolute,
  relative: PositionType.Relative,
  static: PositionType.Static
};
var setPositionType = (value2) => (node) => {
  const {
    yogaNode
  } = node;
  if (!isNil(value2) && yogaNode) {
    yogaNode.setPositionType(POSITION[value2]);
  }
  return node;
};
var FLEX_DIRECTIONS = {
  row: FlexDirection.Row,
  "row-reverse": FlexDirection.RowReverse,
  "column-reverse": FlexDirection.ColumnReverse
};
var setFlexDirection = (value2) => (node) => {
  const {
    yogaNode
  } = node;
  if (yogaNode) {
    const flexDirection = FLEX_DIRECTIONS[value2] || FlexDirection.Column;
    yogaNode.setFlexDirection(flexDirection);
  }
  return node;
};
var JUSTIFY_CONTENT = {
  center: Justify.Center,
  "flex-end": Justify.FlexEnd,
  "space-between": Justify.SpaceBetween,
  "space-around": Justify.SpaceAround,
  "space-evenly": Justify.SpaceEvenly
};
var setJustifyContent = (value2) => (node) => {
  const {
    yogaNode
  } = node;
  if (!isNil(value2) && yogaNode) {
    const justifyContent = JUSTIFY_CONTENT[value2] || Justify.FlexStart;
    yogaNode.setJustifyContent(justifyContent);
  }
  return node;
};
var setMarginTop = setYogaValue("margin", Edge.Top);
var setMarginRight = setYogaValue("margin", Edge.Right);
var setMarginBottom = setYogaValue("margin", Edge.Bottom);
var setMarginLeft = setYogaValue("margin", Edge.Left);
var setPaddingTop = setYogaValue("padding", Edge.Top);
var setPaddingRight = setYogaValue("padding", Edge.Right);
var setPaddingBottom = setYogaValue("padding", Edge.Bottom);
var setPaddingLeft = setYogaValue("padding", Edge.Left);
var setBorderTop = setYogaValue("border", Edge.Top);
var setBorderRight = setYogaValue("border", Edge.Right);
var setBorderBottom = setYogaValue("border", Edge.Bottom);
var setBorderLeft = setYogaValue("border", Edge.Left);
var setPositionTop = setYogaValue("position", Edge.Top);
var setPositionRight = setYogaValue("position", Edge.Right);
var setPositionBottom = setYogaValue("position", Edge.Bottom);
var setPositionLeft = setYogaValue("position", Edge.Left);
var setWidth = setYogaValue("width");
var setMinWidth = setYogaValue("minWidth");
var setMaxWidth = setYogaValue("maxWidth");
var setHeight = setYogaValue("height");
var setMinHeight = setYogaValue("minHeight");
var setMaxHeight = setYogaValue("maxHeight");
var setRowGap = (value2) => (node) => {
  const {
    yogaNode
  } = node;
  if (!isNil(value2) && yogaNode) {
    yogaNode.setGap(Gutter.Row, value2);
  }
  return node;
};
var setColumnGap = (value2) => (node) => {
  const {
    yogaNode
  } = node;
  if (!isNil(value2) && yogaNode) {
    yogaNode.setGap(Gutter.Column, value2);
  }
  return node;
};
var getAspectRatio = (viewbox) => {
  if (!viewbox) return null;
  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);
};
var measureCanvas$1 = (page, node) => (width, widthMode, height2, heightMode) => {
  const aspectRatio = getAspectRatio(node.props.viewBox) || 1;
  if (widthMode === MeasureMode.Exactly || widthMode === MeasureMode.AtMost) {
    return {
      width,
      height: width / aspectRatio
    };
  }
  if (heightMode === MeasureMode.Exactly) {
    return {
      width: height2 * aspectRatio
    };
  }
  return {};
};
var linesWidth = (node) => {
  if (!node.lines) return 0;
  return Math.max(0, ...node.lines.map((line2) => line2.xAdvance));
};
var linesHeight = (node) => {
  if (!node.lines) return -1;
  return node.lines.reduce((acc, line2) => acc + line2.box.height, 0);
};
var ALIGNMENT_FACTORS2 = {
  center: 0.5,
  right: 1
};
var measureText = (page, node, fontStore2) => (width, widthMode, height2) => {
  if (widthMode === MeasureMode.Exactly) {
    if (!node.lines) node.lines = layoutText(node, width, height2, fontStore2);
    return {
      height: linesHeight(node)
    };
  }
  if (widthMode === MeasureMode.AtMost) {
    var _node$style;
    const alignFactor = ALIGNMENT_FACTORS2[(_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.textAlign] || 0;
    if (!node.lines) {
      node.lines = layoutText(node, width, height2, fontStore2);
      node.alignOffset = (width - linesWidth(node)) * alignFactor;
    }
    return {
      height: linesHeight(node),
      width: Math.min(width, linesWidth(node))
    };
  }
  return {};
};
var getRatio = (node) => {
  var _node$image;
  return (_node$image = node.image) !== null && _node$image !== void 0 && _node$image.data ? node.image.width / node.image.height : 1;
};
var isHeightAuto = (page) => {
  var _page$box;
  return isNil((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.height);
};
var SAFETY_HEIGHT$1 = 10;
var measureImage = (page, node) => (width, widthMode, height2, heightMode) => {
  const imageRatio = getRatio(node);
  const imageMargin = getMargin2(node);
  const pagePadding = getPadding(page);
  const pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1;
  if (!node.image) return {
    width: 0,
    height: 0
  };
  if (widthMode === MeasureMode.Exactly && heightMode === MeasureMode.Undefined) {
    const scaledHeight = width / imageRatio;
    return {
      height: Math.min(pageArea, scaledHeight)
    };
  }
  if (heightMode === MeasureMode.Exactly && (widthMode === MeasureMode.AtMost || widthMode === MeasureMode.Undefined)) {
    return {
      width: Math.min(height2 * imageRatio, width)
    };
  }
  if (widthMode === MeasureMode.Exactly && heightMode === MeasureMode.AtMost) {
    const scaledHeight = width / imageRatio;
    return {
      height: Math.min(height2, pageArea, scaledHeight)
    };
  }
  if (widthMode === MeasureMode.AtMost && heightMode === MeasureMode.AtMost) {
    if (imageRatio > 1) {
      return {
        width,
        height: Math.min(width / imageRatio, height2)
      };
    }
    return {
      height: height2,
      width: Math.min(height2 * imageRatio, width)
    };
  }
  return {
    height: height2,
    width
  };
};
var SAFETY_HEIGHT = 10;
var getMax = (values) => Math.max(-Infinity, ...values);
var measureCtx = () => {
  const ctx = {};
  const points = [];
  const nil = () => ctx;
  const addPoint = (x, y2) => points.push([x, y2]);
  const moveTo = function() {
    addPoint(...arguments);
    return ctx;
  };
  const rect = (x, y2, w, h2) => {
    addPoint(x, y2);
    addPoint(x + w, y2);
    addPoint(x, y2 + h2);
    addPoint(x + w, y2 + h2);
    return ctx;
  };
  const ellipse = (x, y2, rx, ry) => {
    ry = ry || rx;
    addPoint(x - rx, y2 - ry);
    addPoint(x + rx, y2 - ry);
    addPoint(x + rx, y2 + ry);
    addPoint(x - rx, y2 + ry);
    return ctx;
  };
  const polygon = function() {
    points.push(...arguments);
    return ctx;
  };
  ctx.rect = rect;
  ctx.moveTo = moveTo;
  ctx.lineTo = moveTo;
  ctx.circle = ellipse;
  ctx.polygon = polygon;
  ctx.ellipse = ellipse;
  ctx.roundedRect = rect;
  ctx.text = nil;
  ctx.path = nil;
  ctx.lineWidth = nil;
  ctx.bezierCurveTo = nil;
  ctx.quadraticCurveTo = nil;
  ctx.scale = nil;
  ctx.rotate = nil;
  ctx.translate = nil;
  ctx.dash = nil;
  ctx.clip = nil;
  ctx.save = nil;
  ctx.fill = nil;
  ctx.font = nil;
  ctx.stroke = nil;
  ctx.lineCap = nil;
  ctx.opacity = nil;
  ctx.restore = nil;
  ctx.lineJoin = nil;
  ctx.fontSize = nil;
  ctx.fillColor = nil;
  ctx.miterLimit = nil;
  ctx.strokeColor = nil;
  ctx.fillOpacity = nil;
  ctx.strokeOpacity = nil;
  ctx.linearGradient = nil;
  ctx.radialGradient = nil;
  ctx.getWidth = () => getMax(points.map((p2) => p2[0]));
  ctx.getHeight = () => getMax(points.map((p2) => p2[1]));
  return ctx;
};
var measureCanvas = (page, node) => () => {
  const imageMargin = getMargin2(node);
  const pagePadding = getPadding(page);
  const pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT;
  const ctx = measureCtx();
  node.props.paint(ctx);
  const width = ctx.getWidth();
  const height2 = Math.min(pageArea, ctx.getHeight());
  return {
    width,
    height: height2
  };
};
var isType$1 = (type) => (node) => node.type === type;
var isSvg = isType$1(Svg);
var isText$2 = isType$1(Text);
var isNote = isType$1(Note);
var isPage = isType$1(Page);
var isImage = isType$1(Image);
var isCanvas = isType$1(Canvas);
var isTextInstance$1 = isType$1(TextInstance);
var setNodeHeight = (node) => {
  const value2 = isPage(node) ? node.box.height : node.style.height;
  return setHeight(value2);
};
var setYogaValues = (node) => {
  compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);
};
var insertYogaNodes = (parent) => (child) => {
  parent.insertChild(child.yogaNode, parent.getChildCount());
  return child;
};
var setMeasureFunc = (node, page, fontStore2) => {
  const {
    yogaNode
  } = node;
  if (isText$2(node)) {
    yogaNode.setMeasureFunc(measureText(page, node, fontStore2));
  }
  if (isImage(node)) {
    yogaNode.setMeasureFunc(measureImage(page, node));
  }
  if (isCanvas(node)) {
    yogaNode.setMeasureFunc(measureCanvas(page, node));
  }
  if (isSvg(node)) {
    yogaNode.setMeasureFunc(measureCanvas$1(page, node));
  }
  return node;
};
var isLayoutElement = (node) => !isText$2(node) && !isNote(node) && !isSvg(node);
var createYogaNodes = (page, fontStore2, yoga) => (node) => {
  const yogaNode = yoga.node.create();
  const result = Object.assign({}, node, {
    yogaNode
  });
  setYogaValues(result);
  if (isLayoutElement(node) && node.children) {
    const resolveChild = compose(insertYogaNodes(yogaNode), createYogaNodes(page, fontStore2, yoga));
    result.children = node.children.map(resolveChild);
  }
  setMeasureFunc(result, page, fontStore2);
  return result;
};
var calculateLayout = (page) => {
  page.yogaNode.calculateLayout();
  return page;
};
var persistDimensions = (node) => {
  if (isTextInstance$1(node)) return node;
  const box = Object.assign(getPadding(node), getMargin2(node), getBorderWidth(node), getPosition(node), getDimension(node));
  const newNode = Object.assign({}, node, {
    box
  });
  if (!node.children) return newNode;
  const children = node.children.map(persistDimensions);
  return Object.assign({}, newNode, {
    children
  });
};
var destroyYogaNodes = (node) => {
  const newNode = Object.assign({}, node);
  delete newNode.yogaNode;
  if (!node.children) return newNode;
  const children = node.children.map(destroyYogaNodes);
  return Object.assign({}, newNode, {
    children
  });
};
var freeYogaNodes = (node) => {
  if (node.yogaNode) node.yogaNode.freeRecursive();
  return node;
};
var resolvePageDimensions = (page, fontStore2, yoga) => {
  if (isNil(page)) return null;
  return compose(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore2, yoga))(page);
};
var resolveDimensions = (node, fontStore2) => {
  if (!node.children) return node;
  const resolveChild = (child) => resolvePageDimensions(child, fontStore2, node.yoga);
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children
  });
};
var isText$1 = (node) => node.type === Text;
var SAFETY_THRESHOLD = 1e-3;
var assingChildren = (children, node) => Object.assign({}, node, {
  children
});
var getTop = (node) => {
  var _node$box;
  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;
};
var allFixed = (nodes) => nodes.every(isFixed);
var isDynamic = (node) => {
  var _node$props;
  return !isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.render);
};
var relayoutPage = compose(resolveTextLayout, resolvePageDimensions, resolveInheritance, resolvePageStyles);
var warnUnavailableSpace = (node) => {
  console.warn(`Node of type ${node.type} can't wrap between pages and it's bigger than available page height`);
};
var splitNodes = (height2, contentArea, nodes) => {
  const currentChildren = [];
  const nextChildren = [];
  for (let i3 = 0; i3 < nodes.length; i3 += 1) {
    const child = nodes[i3];
    const futureNodes = nodes.slice(i3 + 1);
    const futureFixedNodes = futureNodes.filter(isFixed);
    const nodeTop = getTop(child);
    const nodeHeight = child.box.height;
    const isOutside = height2 <= nodeTop;
    const shouldBreak$1 = shouldBreak(child, futureNodes, height2);
    const shouldSplit = height2 + SAFETY_THRESHOLD < nodeTop + nodeHeight;
    const canWrap = getWrap(child);
    const fitsInsidePage = nodeHeight <= contentArea;
    if (isFixed(child)) {
      nextChildren.push(child);
      currentChildren.push(child);
      continue;
    }
    if (isOutside) {
      const box = Object.assign({}, child.box, {
        top: child.box.top - height2
      });
      const next = Object.assign({}, child, {
        box
      });
      nextChildren.push(next);
      continue;
    }
    if (!fitsInsidePage && !canWrap) {
      currentChildren.push(child);
      nextChildren.push(...futureNodes);
      warnUnavailableSpace(child);
      break;
    }
    if (shouldBreak$1) {
      const box = Object.assign({}, child.box, {
        top: child.box.top - height2
      });
      const props = Object.assign({}, child.props, {
        wrap: true,
        break: false
      });
      const next = Object.assign({}, child, {
        box,
        props
      });
      currentChildren.push(...futureFixedNodes);
      nextChildren.push(next, ...futureNodes);
      break;
    }
    if (shouldSplit) {
      const [currentChild, nextChild] = split(child, height2, contentArea);
      if (child.children.length > 0 && currentChild.children.length === 0) {
        if (currentChildren.length === 0) {
          currentChildren.push(child, ...futureFixedNodes);
          nextChildren.push(...futureNodes);
        } else {
          const box = Object.assign({}, child.box, {
            top: child.box.top - height2
          });
          const next = Object.assign({}, child, {
            box
          });
          currentChildren.push(...futureFixedNodes);
          nextChildren.push(next, ...futureNodes);
        }
        break;
      }
      if (currentChild) currentChildren.push(currentChild);
      if (nextChild) nextChildren.push(nextChild);
      continue;
    }
    currentChildren.push(child);
  }
  return [currentChildren, nextChildren];
};
var splitChildren = (height2, contentArea, node) => {
  const children = node.children || [];
  const availableHeight = height2 - getTop(node);
  return splitNodes(availableHeight, contentArea, children);
};
var splitView = (node, height2, contentArea) => {
  const [currentNode, nextNode] = splitNode(node, height2);
  const [currentChilds, nextChildren] = splitChildren(height2, contentArea, node);
  return [assingChildren(currentChilds, currentNode), assingChildren(nextChildren, nextNode)];
};
var split = (node, height2, contentArea) => isText$1(node) ? splitText(node, height2) : splitView(node, height2, contentArea);
var shouldResolveDynamicNodes = (node) => {
  const children = node.children || [];
  return isDynamic(node) || children.some(shouldResolveDynamicNodes);
};
var resolveDynamicNodes = (props, node) => {
  const isNodeDynamic = isDynamic(node);
  const resolveChildren2 = function(children2) {
    if (children2 === void 0) {
      children2 = [];
    }
    if (isNodeDynamic) {
      const res = node.props.render(props);
      return createInstances(res).filter(Boolean).map((n4) => resolveDynamicNodes(props, n4));
    }
    return children2.map((c3) => resolveDynamicNodes(props, c3));
  };
  const resetHeight = isNodeDynamic && isText$1(node);
  const box = resetHeight ? {
    ...node.box,
    height: 0
  } : node.box;
  const children = resolveChildren2(node.children);
  const lines = isNodeDynamic ? null : node.lines;
  return Object.assign({}, node, {
    box,
    lines,
    children
  });
};
var resolveDynamicPage = (props, page, fontStore2, yoga) => {
  if (shouldResolveDynamicNodes(page)) {
    const resolvedPage = resolveDynamicNodes(props, page);
    return relayoutPage(resolvedPage, fontStore2, yoga);
  }
  return page;
};
var splitPage = (page, pageNumber, fontStore2, yoga) => {
  const wrapArea = getWrapArea(page);
  const contentArea = getContentArea(page);
  const dynamicPage = resolveDynamicPage({
    pageNumber
  }, page, fontStore2, yoga);
  const height2 = page.style.height;
  const [currentChilds, nextChilds] = splitNodes(wrapArea, contentArea, dynamicPage.children);
  const relayout = (node) => relayoutPage(node, fontStore2, yoga);
  const currentBox = {
    ...page.box,
    height: height2
  };
  const currentPage = relayout(Object.assign({}, page, {
    box: currentBox,
    children: currentChilds
  }));
  if (nextChilds.length === 0 || allFixed(nextChilds)) return [currentPage, null];
  const nextBox = omit("height", page.box);
  const nextProps = omit("bookmark", page.props);
  const nextPage = relayout(Object.assign({}, page, {
    props: nextProps,
    box: nextBox,
    children: nextChilds
  }));
  return [currentPage, nextPage];
};
var resolvePageIndices = (fontStore2, yoga, page, pageNumber, pages) => {
  const totalPages = pages.length;
  const props = {
    totalPages,
    pageNumber: pageNumber + 1,
    subPageNumber: page.subPageNumber + 1,
    subPageTotalPages: page.subPageTotalPages
  };
  return resolveDynamicPage(props, page, fontStore2, yoga);
};
var assocSubPageData = (subpages) => {
  return subpages.map((page, i3) => ({
    ...page,
    subPageNumber: i3,
    subPageTotalPages: subpages.length
  }));
};
var dissocSubPageData = (page) => {
  return omit(["subPageNumber", "subPageTotalPages"], page);
};
var paginate = (page, pageNumber, fontStore2, yoga) => {
  var _page$props;
  if (!page) return [];
  if (((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.wrap) === false) return [page];
  let splittedPage = splitPage(page, pageNumber, fontStore2, yoga);
  const pages = [splittedPage[0]];
  let nextPage = splittedPage[1];
  while (nextPage !== null) {
    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore2, yoga);
    pages.push(splittedPage[0]);
    nextPage = splittedPage[1];
  }
  return pages;
};
var resolvePagination = (doc, fontStore2) => {
  let pages = [];
  let pageNumber = 1;
  for (let i3 = 0; i3 < doc.children.length; i3 += 1) {
    const page = doc.children[i3];
    let subpages = paginate(page, pageNumber, fontStore2, doc.yoga);
    subpages = assocSubPageData(subpages);
    pageNumber += subpages.length;
    pages = pages.concat(subpages);
  }
  pages = pages.map(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return dissocSubPageData(resolvePageIndices(fontStore2, doc.yoga, ...args));
  });
  return assingChildren(pages, doc);
};
var resolvePageHorizontalPadding = (container) => (value2) => {
  const match = matchPercent(value2);
  return match ? match.percent * container.width : value2;
};
var resolvePageVerticalPadding = (container) => (value2) => {
  const match = matchPercent(value2);
  return match ? match.percent * container.height : value2;
};
var resolvePagePaddings = (page) => {
  const container = page.style;
  const style = evolve({
    paddingTop: resolvePageVerticalPadding(container),
    paddingLeft: resolvePageHorizontalPadding(container),
    paddingRight: resolvePageHorizontalPadding(container),
    paddingBottom: resolvePageVerticalPadding(container)
  }, page.style);
  return Object.assign({}, page, {
    style
  });
};
var resolvePagesPaddings = (root) => {
  if (!root.children) return root;
  const children = root.children.map(resolvePagePaddings);
  return Object.assign({}, root, {
    children
  });
};
var resolveRadius = (container) => (value2) => {
  if (!value2) return void 0;
  const match = matchPercent(value2);
  return match ? match.percent * Math.min(container.width, container.height) : value2;
};
var resolvePercentRadius = (node) => {
  const style = evolve({
    borderTopLeftRadius: resolveRadius(node.box),
    borderTopRightRadius: resolveRadius(node.box),
    borderBottomRightRadius: resolveRadius(node.box),
    borderBottomLeftRadius: resolveRadius(node.box)
  }, node.style || {});
  const newNode = Object.assign({}, node, {
    style
  });
  if (!node.children) return newNode;
  const children = node.children.map(resolvePercentRadius);
  return Object.assign({}, newNode, {
    children
  });
};
var transformHeight = (pageArea, height2) => {
  const match = matchPercent(height2);
  return match ? match.percent * pageArea : height2;
};
var getPageArea = (page) => {
  var _page$style, _page$style2;
  const pageHeight = page.style.height;
  const pagePaddingTop = ((_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.paddingTop) || 0;
  const pagePaddingBottom = ((_page$style2 = page.style) === null || _page$style2 === void 0 ? void 0 : _page$style2.paddingBottom) || 0;
  return pageHeight - pagePaddingTop - pagePaddingBottom;
};
var resolveNodePercentHeight = (page, node) => {
  var _page$style3, _node$style;
  if (isNil((_page$style3 = page.style) === null || _page$style3 === void 0 ? void 0 : _page$style3.height)) return node;
  if (isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height)) return node;
  const pageArea = getPageArea(page);
  const height2 = transformHeight(pageArea, node.style.height);
  const style = Object.assign({}, node.style, {
    height: height2
  });
  return Object.assign({}, node, {
    style
  });
};
var resolvePagePercentHeight = (page) => {
  if (!page.children) return page;
  const resolveChild = (child) => resolveNodePercentHeight(page, child);
  const children = page.children.map(resolveChild);
  return Object.assign({}, page, {
    children
  });
};
var resolvePercentHeight = (root) => {
  if (!root.children) return root;
  const children = root.children.map(resolvePagePercentHeight);
  return Object.assign({}, root, {
    children
  });
};
var isType = (type) => (node) => node.type === type;
var isLink = isType(Link);
var isText = isType(Text);
var isTextInstance = isType(TextInstance);
var hasRenderProp = (node) => {
  var _node$props;
  return !!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.render);
};
var isTextType = (node) => isText(node) || isTextInstance(node);
var isTextLink = (node) => {
  const children = node.children || [];
  if (children.every(isTextInstance)) return true;
  if (children.every(isText)) return false;
  return children.every(isTextType);
};
var wrapText = (node) => {
  const textElement = {
    type: Text,
    props: {},
    style: {},
    box: {},
    children: node.children
  };
  return Object.assign({}, node, {
    children: [textElement]
  });
};
var transformLink = (node) => {
  if (!isLink(node)) return node;
  if (hasRenderProp(node)) return Object.assign({}, node, {
    type: Text
  });
  if (isTextLink(node)) return wrapText(node);
  return node;
};
var resolveLinkSubstitution = (node) => {
  if (!node.children) return node;
  const resolveChild = compose(transformLink, resolveLinkSubstitution);
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children
  });
};
var layout = asyncCompose(resolveZIndex, resolveOrigin, resolveAssets, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles2, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes, resolveYoga);

// node_modules/@react-pdf/reconciler/lib/index.js
var import_react3 = __toESM(require_react());

// node_modules/@react-pdf/reconciler/lib/reconciler-31.js
var import_react = __toESM(require_react(), 1);
var n = __toESM(require_scheduler(), 1);
function t(e3) {
  return e3 && e3.__esModule && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
}
function r(e3) {
  if (e3.__esModule) return e3;
  var n4 = e3.default;
  if ("function" == typeof n4) {
    var t3 = function e4() {
      return this instanceof e4 ? Reflect.construct(n4, arguments, this.constructor) : n4.apply(this, arguments);
    };
    t3.prototype = n4.prototype;
  } else t3 = {};
  return Object.defineProperty(t3, "__esModule", { value: true }), Object.keys(e3).forEach(function(n5) {
    var r3 = Object.getOwnPropertyDescriptor(e3, n5);
    Object.defineProperty(t3, n5, r3.get ? r3 : { enumerable: true, get: function() {
      return e3[n5];
    } });
  }), t3;
}
var a = { exports: {} };
var u = r(n);
var i;
var c = { exports: {} };
false ? a.exports = (l || (l = 1, (s = o).exports = function(n4) {
  function t3(e3, n5, t4, r4) {
    return new Yr(e3, n5, t4, r4);
  }
  function r3(e3) {
    var n5 = "https://react.dev/errors/" + e3;
    if (1 < arguments.length) {
      n5 += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var t4 = 2; t4 < arguments.length; t4++) n5 += "&args[]=" + encodeURIComponent(arguments[t4]);
    }
    return "Minified React error #" + e3 + "; visit " + n5 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function l2(e3) {
    return null === e3 || "object" != typeof e3 ? null : "function" == typeof (e3 = El && e3[El] || e3["@@iterator"]) ? e3 : null;
  }
  function a3(e3) {
    if (null == e3) return null;
    if ("function" == typeof e3) return e3.$$typeof === _l ? null : e3.displayName || e3.name || null;
    if ("string" == typeof e3) return e3;
    switch (e3) {
      case ml:
        return "Fragment";
      case pl:
        return "Portal";
      case gl:
        return "Profiler";
      case hl:
        return "StrictMode";
      case kl:
        return "Suspense";
      case wl:
        return "SuspenseList";
    }
    if ("object" == typeof e3) switch (e3.$$typeof) {
      case vl:
        return (e3.displayName || "Context") + ".Provider";
      case bl:
        return (e3._context.displayName || "Context") + ".Consumer";
      case Sl:
        var n5 = e3.render;
        return (e3 = e3.displayName) || (e3 = "" !== (e3 = n5.displayName || n5.name || "") ? "ForwardRef(" + e3 + ")" : "ForwardRef"), e3;
      case xl:
        return null !== (n5 = e3.displayName || null) ? n5 : a3(e3.type) || "Memo";
      case zl:
        n5 = e3._payload, e3 = e3._init;
        try {
          return a3(e3(n5));
        } catch (e4) {
        }
    }
    return null;
  }
  function o2(e3) {
    if (void 0 === al) try {
      throw Error();
    } catch (e4) {
      var n5 = e4.stack.trim().match(/\n( *(at )?)/);
      al = n5 && n5[1] || "", ol = -1 < e4.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < e4.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
    return "\n" + al + e3 + ol;
  }
  function i3(e3, n5) {
    if (!e3 || Tl) return "";
    Tl = true;
    var t4 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var r4 = { DetermineComponentFrameRoot: function() {
        try {
          if (n5) {
            var t5 = function() {
              throw Error();
            };
            if (Object.defineProperty(t5.prototype, "props", { set: function() {
              throw Error();
            } }), "object" == typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(t5, []);
              } catch (e4) {
                var r5 = e4;
              }
              Reflect.construct(e3, [], t5);
            } else {
              try {
                t5.call();
              } catch (e4) {
                r5 = e4;
              }
              e3.call(t5.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (e4) {
              r5 = e4;
            }
            (t5 = e3()) && "function" == typeof t5.catch && t5.catch(function() {
            });
          }
        } catch (e4) {
          if (e4 && r5 && "string" == typeof e4.stack) return [e4.stack, r5.stack];
        }
        return [null, null];
      } };
      r4.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var l3 = Object.getOwnPropertyDescriptor(r4.DetermineComponentFrameRoot, "name");
      l3 && l3.configurable && Object.defineProperty(r4.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
      var a4 = r4.DetermineComponentFrameRoot(), u3 = a4[0], i4 = a4[1];
      if (u3 && i4) {
        var s3 = u3.split("\n"), c4 = i4.split("\n");
        for (l3 = r4 = 0; r4 < s3.length && !s3[r4].includes("DetermineComponentFrameRoot"); ) r4++;
        for (; l3 < c4.length && !c4[l3].includes("DetermineComponentFrameRoot"); ) l3++;
        if (r4 === s3.length || l3 === c4.length) for (r4 = s3.length - 1, l3 = c4.length - 1; 1 <= r4 && 0 <= l3 && s3[r4] !== c4[l3]; ) l3--;
        for (; 1 <= r4 && 0 <= l3; r4--, l3--) if (s3[r4] !== c4[l3]) {
          if (1 !== r4 || 1 !== l3) do {
            if (r4--, 0 > --l3 || s3[r4] !== c4[l3]) {
              var f3 = "\n" + s3[r4].replace(" at new ", " at ");
              return e3.displayName && f3.includes("<anonymous>") && (f3 = f3.replace("<anonymous>", e3.displayName)), f3;
            }
          } while (1 <= r4 && 0 <= l3);
          break;
        }
      }
    } finally {
      Tl = false, Error.prepareStackTrace = t4;
    }
    return (t4 = e3 ? e3.displayName || e3.name : "") ? o2(t4) : "";
  }
  function s2(e3) {
    switch (e3.tag) {
      case 26:
      case 27:
      case 5:
        return o2(e3.type);
      case 16:
        return o2("Lazy");
      case 13:
        return o2("Suspense");
      case 19:
        return o2("SuspenseList");
      case 0:
      case 15:
        return i3(e3.type, false);
      case 11:
        return i3(e3.type.render, false);
      case 1:
        return i3(e3.type, true);
      default:
        return "";
    }
  }
  function c3(e3) {
    try {
      var n5 = "";
      do {
        n5 += s2(e3), e3 = e3.return;
      } while (e3);
      return n5;
    } catch (e4) {
      return "\nError generating stack: " + e4.message + "\n" + e4.stack;
    }
  }
  function f2(e3) {
    return { current: e3 };
  }
  function d2(e3) {
    0 > Wa || (e3.current = ja[Wa], ja[Wa] = null, Wa--);
  }
  function p2(e3, n5) {
    Wa++, ja[Wa] = e3.current, e3.current = n5;
  }
  function m(e3) {
    var n5 = 42 & e3;
    if (0 !== n5) return n5;
    switch (e3 & -e3) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return 4194176 & e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return 62914560 & e3;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return e3;
    }
  }
  function h2(e3, n5) {
    var t4 = e3.pendingLanes;
    if (0 === t4) return 0;
    var r4 = 0, l3 = e3.suspendedLanes;
    e3 = e3.pingedLanes;
    var a4 = 134217727 & t4;
    return 0 !== a4 ? 0 != (t4 = a4 & ~l3) ? r4 = m(t4) : 0 != (e3 &= a4) && (r4 = m(e3)) : 0 != (t4 &= ~l3) ? r4 = m(t4) : 0 !== e3 && (r4 = m(e3)), 0 === r4 ? 0 : 0 !== n5 && n5 !== r4 && 0 == (n5 & l3) && ((l3 = r4 & -r4) >= (e3 = n5 & -n5) || 32 === l3 && 0 != (4194176 & e3)) ? n5 : r4;
  }
  function g2(e3, n5) {
    switch (e3) {
      case 1:
      case 2:
      case 4:
      case 8:
        return n5 + 250;
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n5 + 5e3;
      default:
        return -1;
    }
  }
  function y2() {
    var e3 = Va;
    return 0 == (4194176 & (Va <<= 1)) && (Va = 128), e3;
  }
  function b2() {
    var e3 = $a;
    return 0 == (62914560 & ($a <<= 1)) && ($a = 4194304), e3;
  }
  function v2(e3) {
    for (var n5 = [], t4 = 0; 31 > t4; t4++) n5.push(e3);
    return n5;
  }
  function S2(e3, n5) {
    e3.pendingLanes |= n5, 268435456 !== n5 && (e3.suspendedLanes = 0, e3.pingedLanes = 0, e3.warmLanes = 0);
  }
  function k2(e3, n5, t4) {
    e3.pendingLanes |= n5, e3.suspendedLanes &= ~n5;
    var r4 = 31 - Aa(n5);
    e3.entangledLanes |= n5, e3.entanglements[r4] = 1073741824 | e3.entanglements[r4] | 4194218 & t4;
  }
  function w(e3, n5) {
    var t4 = e3.entangledLanes |= n5;
    for (e3 = e3.entanglements; t4; ) {
      var r4 = 31 - Aa(t4), l3 = 1 << r4;
      l3 & n5 | e3[r4] & n5 && (e3[r4] |= n5), t4 &= ~l3;
    }
  }
  function x(e3) {
    return 2 < (e3 &= -e3) ? 8 < e3 ? 0 != (134217727 & e3) ? 32 : 268435456 : 8 : 2;
  }
  function z(e3) {
    "function" == typeof to && ro(e3);
  }
  function C(e3, n5) {
    if ("object" == typeof e3 && null !== e3) {
      var t4 = oo.get(e3);
      return void 0 !== t4 ? t4 : (n5 = { value: e3, source: n5, stack: c3(n5) }, oo.set(e3, n5), n5);
    }
    return { value: e3, source: n5, stack: c3(n5) };
  }
  function P(e3) {
    for (; e3 === so; ) so = uo[--io], uo[io] = null, uo[--io], uo[io] = null;
    for (; e3 === po; ) po = co[--fo], co[fo] = null, co[--fo], co[fo] = null, co[--fo], co[fo] = null;
  }
  function E(e3, n5) {
    p2(go, n5), p2(ho, e3), p2(mo, null), e3 = Ul(n5), d2(mo), p2(mo, e3);
  }
  function _() {
    d2(mo), d2(ho), d2(go);
  }
  function R(e3) {
    null !== e3.memoizedState && p2(yo, e3);
    var n5 = mo.current, t4 = Il(n5, e3.type);
    n5 !== t4 && (p2(ho, e3), p2(mo, t4));
  }
  function T(e3) {
    ho.current === e3 && (d2(mo), d2(ho)), yo.current === e3 && (d2(yo), oa._currentValue2 = aa);
  }
  function N(e3) {
    throw L(C(Error(r3(418, "")), e3)), wo;
  }
  function L(e3) {
    null === So ? So = [e3] : So.push(e3);
  }
  function U() {
    for (var e3 = zo, n5 = Co = zo = 0; n5 < e3; ) {
      var t4 = xo[n5];
      xo[n5++] = null;
      var r4 = xo[n5];
      xo[n5++] = null;
      var l3 = xo[n5];
      xo[n5++] = null;
      var a4 = xo[n5];
      if (xo[n5++] = null, null !== r4 && null !== l3) {
        var o3 = r4.pending;
        null === o3 ? l3.next = l3 : (l3.next = o3.next, o3.next = l3), r4.pending = l3;
      }
      0 !== a4 && M(t4, l3, a4);
    }
  }
  function I(e3, n5, t4, r4) {
    xo[zo++] = e3, xo[zo++] = n5, xo[zo++] = t4, xo[zo++] = r4, Co |= r4, e3.lanes |= r4, null !== (e3 = e3.alternate) && (e3.lanes |= r4);
  }
  function D(e3, n5, t4, r4) {
    return I(e3, n5, t4, r4), H(e3);
  }
  function F(e3, n5) {
    return I(e3, null, null, n5), H(e3);
  }
  function M(e3, n5, t4) {
    e3.lanes |= t4;
    var r4 = e3.alternate;
    null !== r4 && (r4.lanes |= t4);
    for (var l3 = false, a4 = e3.return; null !== a4; ) a4.childLanes |= t4, null !== (r4 = a4.alternate) && (r4.childLanes |= t4), 22 === a4.tag && (null === (e3 = a4.stateNode) || 1 & e3._visibility || (l3 = true)), e3 = a4, a4 = a4.return;
    l3 && null !== n5 && 3 === e3.tag && (a4 = e3.stateNode, l3 = 31 - Aa(t4), null === (e3 = (a4 = a4.hiddenUpdates)[l3]) ? a4[l3] = [n5] : e3.push(n5), n5.lane = 536870912 | t4);
  }
  function H(e3) {
    if (50 < mi) throw mi = 0, hi = null, Error(r3(185));
    for (var n5 = e3.return; null !== n5; ) n5 = (e3 = n5).return;
    return 3 === e3.tag ? e3.stateNode : null;
  }
  function j(e3) {
    e3 !== Eo && null === e3.next && (null === Eo ? Po = Eo = e3 : Eo = Eo.next = e3), Ro = true, _o || (_o = true, qa(Xa, O));
  }
  function W(e3, n5) {
    if (!To && Ro) {
      To = true;
      do {
        for (var t4 = false, r4 = Po; null !== r4; ) {
          if (0 !== e3) {
            var l3 = r4.pendingLanes;
            if (0 === l3) var a4 = 0;
            else {
              var o3 = r4.suspendedLanes, u3 = r4.pingedLanes;
              a4 = (1 << 31 - Aa(42 | e3) + 1) - 1, a4 = 201326677 & (a4 &= l3 & ~(o3 & ~u3)) ? 201326677 & a4 | 1 : a4 ? 2 | a4 : 0;
            }
            0 !== a4 && (t4 = true, B(r4, a4));
          } else a4 = Bu, 0 != (3 & (a4 = h2(r4, r4 === Au ? a4 : 0))) && (t4 = true, B(r4, a4));
          r4 = r4.next;
        }
      } while (t4);
      To = false;
    }
  }
  function O() {
    Ro = _o = false;
    var e3 = 0;
    0 !== No && (Xl() && (e3 = No), No = 0);
    for (var n5 = Ka(), t4 = null, r4 = Po; null !== r4; ) {
      var l3 = r4.next, a4 = A(r4, n5);
      0 === a4 ? (r4.next = null, null === t4 ? Po = l3 : t4.next = l3, null === l3 && (Eo = t4)) : (t4 = r4, (0 !== e3 || 0 != (3 & a4)) && (Ro = true)), r4 = l3;
    }
    W(e3);
  }
  function A(e3, n5) {
    for (var t4 = e3.suspendedLanes, r4 = e3.pingedLanes, l3 = e3.expirationTimes, a4 = -62914561 & e3.pendingLanes; 0 < a4; ) {
      var o3 = 31 - Aa(a4), u3 = 1 << o3, i4 = l3[o3];
      -1 === i4 ? 0 != (u3 & t4) && 0 == (u3 & r4) || (l3[o3] = g2(u3, n5)) : i4 <= n5 && (e3.expiredLanes |= u3), a4 &= ~u3;
    }
    if (t4 = Bu, t4 = h2(e3, e3 === (n5 = Au) ? t4 : 0), r4 = e3.callbackNode, 0 === t4 || e3 === n5 && 2 === Vu || null !== e3.cancelPendingCommit) return null !== r4 && null !== r4 && Ya(r4), e3.callbackNode = null, e3.callbackPriority = 0;
    if (0 != (3 & t4)) return null !== r4 && null !== r4 && Ya(r4), e3.callbackPriority = 2, e3.callbackNode = null, 2;
    if ((n5 = t4 & -t4) === e3.callbackPriority) return n5;
    switch (null !== r4 && Ya(r4), x(t4)) {
      case 2:
        t4 = Xa;
        break;
      case 8:
        t4 = Za;
        break;
      case 32:
      default:
        t4 = eo;
        break;
      case 268435456:
        t4 = no;
    }
    return r4 = Q.bind(null, e3), t4 = qa(t4, r4), e3.callbackPriority = n5, e3.callbackNode = t4, n5;
  }
  function Q(e3, n5) {
    var t4 = e3.callbackNode;
    if (Wr() && e3.callbackNode !== t4) return null;
    var r4 = Bu;
    return 0 === (r4 = h2(e3, e3 === Au ? r4 : 0)) ? null : (br(e3, r4, n5), A(e3, Ka()), e3.callbackNode === t4 ? Q.bind(null, e3) : null);
  }
  function B(e3, n5) {
    if (Wr()) return null;
    br(e3, n5, true);
  }
  function V() {
    return 0 === No && (No = y2()), No;
  }
  function $() {
    if (0 == --Uo && null !== Lo) {
      null !== Do && (Do.status = "fulfilled");
      var e3 = Lo;
      Lo = null, Io = 0, Do = null;
      for (var n5 = 0; n5 < e3.length; n5++) (0, e3[n5])();
    }
  }
  function q(e3) {
    e3.updateQueue = { baseState: e3.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null };
  }
  function Y(e3, n5) {
    e3 = e3.updateQueue, n5.updateQueue === e3 && (n5.updateQueue = { baseState: e3.baseState, firstBaseUpdate: e3.firstBaseUpdate, lastBaseUpdate: e3.lastBaseUpdate, shared: e3.shared, callbacks: null });
  }
  function J(e3) {
    return { lane: e3, tag: 0, payload: null, callback: null, next: null };
  }
  function G2(e3, n5, t4) {
    var r4 = e3.updateQueue;
    if (null === r4) return null;
    if (r4 = r4.shared, 0 != (2 & Ou)) {
      var l3 = r4.pending;
      return null === l3 ? n5.next = n5 : (n5.next = l3.next, l3.next = n5), r4.pending = n5, n5 = H(e3), M(e3, null, t4), n5;
    }
    return I(e3, r4, n5, t4), H(e3);
  }
  function K(e3, n5, t4) {
    if (null !== (n5 = n5.updateQueue) && (n5 = n5.shared, 0 != (4194176 & t4))) {
      var r4 = n5.lanes;
      t4 |= r4 &= e3.pendingLanes, n5.lanes = t4, w(e3, t4);
    }
  }
  function X(e3, n5) {
    var t4 = e3.updateQueue, r4 = e3.alternate;
    if (null !== r4 && t4 === (r4 = r4.updateQueue)) {
      var l3 = null, a4 = null;
      if (null !== (t4 = t4.firstBaseUpdate)) {
        do {
          var o3 = { lane: t4.lane, tag: t4.tag, payload: t4.payload, callback: null, next: null };
          null === a4 ? l3 = a4 = o3 : a4 = a4.next = o3, t4 = t4.next;
        } while (null !== t4);
        null === a4 ? l3 = a4 = n5 : a4 = a4.next = n5;
      } else l3 = a4 = n5;
      return t4 = { baseState: r4.baseState, firstBaseUpdate: l3, lastBaseUpdate: a4, shared: r4.shared, callbacks: r4.callbacks }, void (e3.updateQueue = t4);
    }
    null === (e3 = t4.lastBaseUpdate) ? t4.firstBaseUpdate = n5 : e3.next = n5, t4.lastBaseUpdate = n5;
  }
  function Z() {
    if (Mo && null !== Do) throw Do;
  }
  function ee(e3, n5, t4, r4) {
    Mo = false;
    var l3 = e3.updateQueue;
    Fo = false;
    var a4 = l3.firstBaseUpdate, o3 = l3.lastBaseUpdate, u3 = l3.shared.pending;
    if (null !== u3) {
      l3.shared.pending = null;
      var i4 = u3, s3 = i4.next;
      i4.next = null, null === o3 ? a4 = s3 : o3.next = s3, o3 = i4;
      var c4 = e3.alternate;
      null !== c4 && (u3 = (c4 = c4.updateQueue).lastBaseUpdate) !== o3 && (null === u3 ? c4.firstBaseUpdate = s3 : u3.next = s3, c4.lastBaseUpdate = i4);
    }
    if (null !== a4) {
      var f3 = l3.baseState;
      for (o3 = 0, c4 = s3 = i4 = null, u3 = a4; ; ) {
        var d3 = -536870913 & u3.lane, p3 = d3 !== u3.lane;
        if (p3 ? (Bu & d3) === d3 : (r4 & d3) === d3) {
          0 !== d3 && d3 === Io && (Mo = true), null !== c4 && (c4 = c4.next = { lane: 0, tag: u3.tag, payload: u3.payload, callback: null, next: null });
          e: {
            var m2 = e3, h3 = u3;
            d3 = n5;
            var g3 = t4;
            switch (h3.tag) {
              case 1:
                if ("function" == typeof (m2 = h3.payload)) {
                  f3 = m2.call(g3, f3, d3);
                  break e;
                }
                f3 = m2;
                break e;
              case 3:
                m2.flags = -65537 & m2.flags | 128;
              case 0:
                if (null == (d3 = "function" == typeof (m2 = h3.payload) ? m2.call(g3, f3, d3) : m2)) break e;
                f3 = cl({}, f3, d3);
                break e;
              case 2:
                Fo = true;
            }
          }
          null !== (d3 = u3.callback) && (e3.flags |= 64, p3 && (e3.flags |= 8192), null === (p3 = l3.callbacks) ? l3.callbacks = [d3] : p3.push(d3));
        } else p3 = { lane: d3, tag: u3.tag, payload: u3.payload, callback: u3.callback, next: null }, null === c4 ? (s3 = c4 = p3, i4 = f3) : c4 = c4.next = p3, o3 |= d3;
        if (null === (u3 = u3.next)) {
          if (null === (u3 = l3.shared.pending)) break;
          u3 = (p3 = u3).next, p3.next = null, l3.lastBaseUpdate = p3, l3.shared.pending = null;
        }
      }
      null === c4 && (i4 = f3), l3.baseState = i4, l3.firstBaseUpdate = s3, l3.lastBaseUpdate = c4, null === a4 && (l3.shared.lanes = 0), Ku |= o3, e3.lanes = o3, e3.memoizedState = f3;
    }
  }
  function ne(e3, n5) {
    if ("function" != typeof e3) throw Error(r3(191, e3));
    e3.call(n5);
  }
  function te(e3, n5) {
    var t4 = e3.callbacks;
    if (null !== t4) for (e3.callbacks = null, e3 = 0; e3 < t4.length; e3++) ne(t4[e3], n5);
  }
  function re(e3, n5) {
    if (ao(e3, n5)) return true;
    if ("object" != typeof e3 || null === e3 || "object" != typeof n5 || null === n5) return false;
    var t4 = Object.keys(e3), r4 = Object.keys(n5);
    if (t4.length !== r4.length) return false;
    for (r4 = 0; r4 < t4.length; r4++) {
      var l3 = t4[r4];
      if (!Ho.call(n5, l3) || !ao(e3[l3], n5[l3])) return false;
    }
    return true;
  }
  function le(e3) {
    return "fulfilled" === (e3 = e3.status) || "rejected" === e3;
  }
  function ae() {
  }
  function oe(e3, n5, t4) {
    switch (void 0 === (t4 = e3[t4]) ? e3.push(n5) : t4 !== n5 && (n5.then(ae, ae), n5 = t4), n5.status) {
      case "fulfilled":
        return n5.value;
      case "rejected":
        if ((e3 = n5.reason) === jo) throw Error(r3(483));
        throw e3;
      default:
        if ("string" == typeof n5.status) n5.then(ae, ae);
        else {
          if (null !== (e3 = Au) && 100 < e3.shellSuspendCounter) throw Error(r3(482));
          (e3 = n5).status = "pending", e3.then(function(e4) {
            if ("pending" === n5.status) {
              var t5 = n5;
              t5.status = "fulfilled", t5.value = e4;
            }
          }, function(e4) {
            if ("pending" === n5.status) {
              var t5 = n5;
              t5.status = "rejected", t5.reason = e4;
            }
          });
        }
        switch (n5.status) {
          case "fulfilled":
            return n5.value;
          case "rejected":
            if ((e3 = n5.reason) === jo) throw Error(r3(483));
            throw e3;
        }
        throw Ao = n5, jo;
    }
  }
  function ue() {
    if (null === Ao) throw Error(r3(459));
    var e3 = Ao;
    return Ao = null, e3;
  }
  function ie(e3) {
    var n5 = Bo;
    return Bo += 1, null === Qo && (Qo = []), oe(Qo, e3, n5);
  }
  function se(e3, n5, t4, r4) {
    e3 = r4.props.ref, t4.ref = void 0 !== e3 ? e3 : null;
  }
  function ce(e3, n5) {
    if (n5.$$typeof === fl) throw Error(r3(525));
    throw e3 = Object.prototype.toString.call(n5), Error(r3(31, "[object Object]" === e3 ? "object with keys {" + Object.keys(n5).join(", ") + "}" : e3));
  }
  function fe(e3) {
    return (0, e3._init)(e3._payload);
  }
  function de(e3) {
    function n5(n6, t4) {
      if (e3) {
        var r4 = n6.deletions;
        null === r4 ? (n6.deletions = [t4], n6.flags |= 16) : r4.push(t4);
      }
    }
    function a4(t4, r4) {
      if (!e3) return null;
      for (; null !== r4; ) n5(t4, r4), r4 = r4.sibling;
      return null;
    }
    function o3(e4) {
      for (var n6 = /* @__PURE__ */ new Map(); null !== e4; ) null !== e4.key ? n6.set(e4.key, e4) : n6.set(e4.index, e4), e4 = e4.sibling;
      return n6;
    }
    function u3(e4, n6) {
      return (e4 = Gr(e4, n6)).index = 0, e4.sibling = null, e4;
    }
    function i4(n6, t4, r4) {
      return n6.index = r4, e3 ? null !== (r4 = n6.alternate) ? (r4 = r4.index) < t4 ? (n6.flags |= 33554434, t4) : r4 : (n6.flags |= 33554434, t4) : (n6.flags |= 1048576, t4);
    }
    function s3(n6) {
      return e3 && null === n6.alternate && (n6.flags |= 33554434), n6;
    }
    function c4(e4, n6, t4, r4) {
      return null === n6 || 6 !== n6.tag ? ((n6 = nl(t4, e4.mode, r4)).return = e4, n6) : ((n6 = u3(n6, t4)).return = e4, n6);
    }
    function f3(e4, n6, t4, r4) {
      var l3 = t4.type;
      return l3 === ml ? p3(e4, n6, t4.props.children, r4, t4.key) : null !== n6 && (n6.elementType === l3 || "object" == typeof l3 && null !== l3 && l3.$$typeof === zl && fe(l3) === n6.type) ? (se(e4, 0, r4 = u3(n6, t4.props), t4), r4.return = e4, r4) : (se(e4, 0, r4 = Xr(t4.type, t4.key, t4.props, null, e4.mode, r4), t4), r4.return = e4, r4);
    }
    function d3(e4, n6, t4, r4) {
      return null === n6 || 4 !== n6.tag || n6.stateNode.containerInfo !== t4.containerInfo || n6.stateNode.implementation !== t4.implementation ? ((n6 = tl(t4, e4.mode, r4)).return = e4, n6) : ((n6 = u3(n6, t4.children || [])).return = e4, n6);
    }
    function p3(e4, n6, t4, r4, l3) {
      return null === n6 || 7 !== n6.tag ? ((n6 = Zr(t4, e4.mode, r4, l3)).return = e4, n6) : ((n6 = u3(n6, t4)).return = e4, n6);
    }
    function m2(e4, n6, t4) {
      if ("string" == typeof n6 && "" !== n6 || "number" == typeof n6 || "bigint" == typeof n6) return (n6 = nl("" + n6, e4.mode, t4)).return = e4, n6;
      if ("object" == typeof n6 && null !== n6) {
        switch (n6.$$typeof) {
          case dl:
            return se(e4, 0, t4 = Xr(n6.type, n6.key, n6.props, null, e4.mode, t4), n6), t4.return = e4, t4;
          case pl:
            return (n6 = tl(n6, e4.mode, t4)).return = e4, n6;
          case zl:
            return m2(e4, n6 = (0, n6._init)(n6._payload), t4);
        }
        if (Nl(n6) || l2(n6)) return (n6 = Zr(n6, e4.mode, t4, null)).return = e4, n6;
        if ("function" == typeof n6.then) return m2(e4, ie(n6), t4);
        if (n6.$$typeof === vl) return m2(e4, vt(e4, n6), t4);
        ce(e4, n6);
      }
      return null;
    }
    function h3(e4, n6, t4, r4) {
      var a5 = null !== n6 ? n6.key : null;
      if ("string" == typeof t4 && "" !== t4 || "number" == typeof t4 || "bigint" == typeof t4) return null !== a5 ? null : c4(e4, n6, "" + t4, r4);
      if ("object" == typeof t4 && null !== t4) {
        switch (t4.$$typeof) {
          case dl:
            return t4.key === a5 ? f3(e4, n6, t4, r4) : null;
          case pl:
            return t4.key === a5 ? d3(e4, n6, t4, r4) : null;
          case zl:
            return h3(e4, n6, t4 = (a5 = t4._init)(t4._payload), r4);
        }
        if (Nl(t4) || l2(t4)) return null !== a5 ? null : p3(e4, n6, t4, r4, null);
        if ("function" == typeof t4.then) return h3(e4, n6, ie(t4), r4);
        if (t4.$$typeof === vl) return h3(e4, n6, vt(e4, t4), r4);
        ce(e4, t4);
      }
      return null;
    }
    function g3(e4, n6, t4, r4, a5) {
      if ("string" == typeof r4 && "" !== r4 || "number" == typeof r4 || "bigint" == typeof r4) return c4(n6, e4 = e4.get(t4) || null, "" + r4, a5);
      if ("object" == typeof r4 && null !== r4) {
        switch (r4.$$typeof) {
          case dl:
            return f3(n6, e4 = e4.get(null === r4.key ? t4 : r4.key) || null, r4, a5);
          case pl:
            return d3(n6, e4 = e4.get(null === r4.key ? t4 : r4.key) || null, r4, a5);
          case zl:
            return g3(e4, n6, t4, r4 = (0, r4._init)(r4._payload), a5);
        }
        if (Nl(r4) || l2(r4)) return p3(n6, e4 = e4.get(t4) || null, r4, a5, null);
        if ("function" == typeof r4.then) return g3(e4, n6, t4, ie(r4), a5);
        if (r4.$$typeof === vl) return g3(e4, n6, t4, vt(n6, r4), a5);
        ce(n6, r4);
      }
      return null;
    }
    function y3(t4, c5, f4, d4) {
      if ("object" == typeof f4 && null !== f4 && f4.type === ml && null === f4.key && (f4 = f4.props.children), "object" == typeof f4 && null !== f4) {
        switch (f4.$$typeof) {
          case dl:
            e: {
              for (var p4 = f4.key, b3 = c5; null !== b3; ) {
                if (b3.key === p4) {
                  if ((p4 = f4.type) === ml) {
                    if (7 === b3.tag) {
                      a4(t4, b3.sibling), (c5 = u3(b3, f4.props.children)).return = t4, t4 = c5;
                      break e;
                    }
                  } else if (b3.elementType === p4 || "object" == typeof p4 && null !== p4 && p4.$$typeof === zl && fe(p4) === b3.type) {
                    a4(t4, b3.sibling), se(t4, 0, c5 = u3(b3, f4.props), f4), c5.return = t4, t4 = c5;
                    break e;
                  }
                  a4(t4, b3);
                  break;
                }
                n5(t4, b3), b3 = b3.sibling;
              }
              f4.type === ml ? ((c5 = Zr(f4.props.children, t4.mode, d4, f4.key)).return = t4, t4 = c5) : (se(t4, 0, d4 = Xr(f4.type, f4.key, f4.props, null, t4.mode, d4), f4), d4.return = t4, t4 = d4);
            }
            return s3(t4);
          case pl:
            e: {
              for (b3 = f4.key; null !== c5; ) {
                if (c5.key === b3) {
                  if (4 === c5.tag && c5.stateNode.containerInfo === f4.containerInfo && c5.stateNode.implementation === f4.implementation) {
                    a4(t4, c5.sibling), (c5 = u3(c5, f4.children || [])).return = t4, t4 = c5;
                    break e;
                  }
                  a4(t4, c5);
                  break;
                }
                n5(t4, c5), c5 = c5.sibling;
              }
              (c5 = tl(f4, t4.mode, d4)).return = t4, t4 = c5;
            }
            return s3(t4);
          case zl:
            return y3(t4, c5, f4 = (b3 = f4._init)(f4._payload), d4);
        }
        if (Nl(f4)) return function(t5, r4, l3, u4) {
          for (var s4 = null, c6 = null, f5 = r4, d5 = r4 = 0, p5 = null; null !== f5 && d5 < l3.length; d5++) {
            f5.index > d5 ? (p5 = f5, f5 = null) : p5 = f5.sibling;
            var y4 = h3(t5, f5, l3[d5], u4);
            if (null === y4) {
              null === f5 && (f5 = p5);
              break;
            }
            e3 && f5 && null === y4.alternate && n5(t5, f5), r4 = i4(y4, r4, d5), null === c6 ? s4 = y4 : c6.sibling = y4, c6 = y4, f5 = p5;
          }
          if (d5 === l3.length) return a4(t5, f5), s4;
          if (null === f5) {
            for (; d5 < l3.length; d5++) null !== (f5 = m2(t5, l3[d5], u4)) && (r4 = i4(f5, r4, d5), null === c6 ? s4 = f5 : c6.sibling = f5, c6 = f5);
            return s4;
          }
          for (f5 = o3(f5); d5 < l3.length; d5++) null !== (p5 = g3(f5, t5, d5, l3[d5], u4)) && (e3 && null !== p5.alternate && f5.delete(null === p5.key ? d5 : p5.key), r4 = i4(p5, r4, d5), null === c6 ? s4 = p5 : c6.sibling = p5, c6 = p5);
          return e3 && f5.forEach(function(e4) {
            return n5(t5, e4);
          }), s4;
        }(t4, c5, f4, d4);
        if (l2(f4)) {
          if ("function" != typeof (b3 = l2(f4))) throw Error(r3(150));
          return function(t5, l3, u4, s4) {
            if (null == u4) throw Error(r3(151));
            for (var c6 = null, f5 = null, d5 = l3, p5 = l3 = 0, y4 = null, b4 = u4.next(); null !== d5 && !b4.done; p5++, b4 = u4.next()) {
              d5.index > p5 ? (y4 = d5, d5 = null) : y4 = d5.sibling;
              var v3 = h3(t5, d5, b4.value, s4);
              if (null === v3) {
                null === d5 && (d5 = y4);
                break;
              }
              e3 && d5 && null === v3.alternate && n5(t5, d5), l3 = i4(v3, l3, p5), null === f5 ? c6 = v3 : f5.sibling = v3, f5 = v3, d5 = y4;
            }
            if (b4.done) return a4(t5, d5), c6;
            if (null === d5) {
              for (; !b4.done; p5++, b4 = u4.next()) null !== (b4 = m2(t5, b4.value, s4)) && (l3 = i4(b4, l3, p5), null === f5 ? c6 = b4 : f5.sibling = b4, f5 = b4);
              return c6;
            }
            for (d5 = o3(d5); !b4.done; p5++, b4 = u4.next()) null !== (b4 = g3(d5, t5, p5, b4.value, s4)) && (e3 && null !== b4.alternate && d5.delete(null === b4.key ? p5 : b4.key), l3 = i4(b4, l3, p5), null === f5 ? c6 = b4 : f5.sibling = b4, f5 = b4);
            return e3 && d5.forEach(function(e4) {
              return n5(t5, e4);
            }), c6;
          }(t4, c5, f4 = b3.call(f4), d4);
        }
        if ("function" == typeof f4.then) return y3(t4, c5, ie(f4), d4);
        if (f4.$$typeof === vl) return y3(t4, c5, vt(t4, f4), d4);
        ce(t4, f4);
      }
      return "string" == typeof f4 && "" !== f4 || "number" == typeof f4 || "bigint" == typeof f4 ? (f4 = "" + f4, null !== c5 && 6 === c5.tag ? (a4(t4, c5.sibling), (c5 = u3(c5, f4)).return = t4, t4 = c5) : (a4(t4, c5), (c5 = nl(f4, t4.mode, d4)).return = t4, t4 = c5), s3(t4)) : a4(t4, c5);
    }
    return function(e4, n6, r4, l3) {
      try {
        Bo = 0;
        var a5 = y3(e4, n6, r4, l3);
        return Qo = null, a5;
      } catch (n7) {
        if (n7 === jo) throw n7;
        var o4 = t3(29, n7, null, e4.mode);
        return o4.lanes = l3, o4.return = e4, o4;
      }
    };
  }
  function pe(e3, n5) {
    p2(Yo, e3 = Ju), p2(qo, n5), Ju = e3 | n5.baseLanes;
  }
  function me() {
    p2(Yo, Ju), p2(qo, qo.current);
  }
  function he() {
    Ju = Yo.current, d2(qo), d2(Yo);
  }
  function ge(e3) {
    var n5 = e3.alternate;
    p2(Ko, 1 & Ko.current), p2(Jo, e3), null === Go && (null === n5 || null !== qo.current || null !== n5.memoizedState) && (Go = e3);
  }
  function ye(e3) {
    if (22 === e3.tag) {
      if (p2(Ko, Ko.current), p2(Jo, e3), null === Go) {
        var n5 = e3.alternate;
        null !== n5 && null !== n5.memoizedState && (Go = e3);
      }
    } else be();
  }
  function be() {
    p2(Ko, Ko.current), p2(Jo, Jo.current);
  }
  function ve(e3) {
    d2(Jo), Go === e3 && (Go = null), d2(Ko);
  }
  function Se(e3) {
    for (var n5 = e3; null !== n5; ) {
      if (13 === n5.tag) {
        var t4 = n5.memoizedState;
        if (null !== t4 && (null === (t4 = t4.dehydrated) || za(t4) || Ca(t4))) return n5;
      } else if (19 === n5.tag && void 0 !== n5.memoizedProps.revealOrder) {
        if (0 != (128 & n5.flags)) return n5;
      } else if (null !== n5.child) {
        n5.child.return = n5, n5 = n5.child;
        continue;
      }
      if (n5 === e3) break;
      for (; null === n5.sibling; ) {
        if (null === n5.return || n5.return === e3) return null;
        n5 = n5.return;
      }
      n5.sibling.return = n5.return, n5 = n5.sibling;
    }
    return null;
  }
  function ke() {
    throw Error(r3(321));
  }
  function we(e3, n5) {
    if (null === n5) return false;
    for (var t4 = 0; t4 < n5.length && t4 < e3.length; t4++) if (!ao(e3[t4], n5[t4])) return false;
    return true;
  }
  function xe(e3, n5, t4, r4, l3, a4) {
    return Xo = a4, Zo = n5, n5.memoizedState = null, n5.updateQueue = null, n5.lanes = 0, Rl.H = null === e3 || null === e3.memoizedState ? fu : du, lu = false, a4 = t4(r4, l3), lu = false, ru && (a4 = Ce(n5, t4, r4, l3)), ze(e3), a4;
  }
  function ze(e3) {
    Rl.H = cu;
    var n5 = null !== eu && null !== eu.next;
    if (Xo = 0, nu = eu = Zo = null, tu = false, ou = 0, uu = null, n5) throw Error(r3(300));
    null === e3 || gu || null !== (e3 = e3.dependencies) && gt(e3) && (gu = true);
  }
  function Ce(e3, n5, t4, l3) {
    Zo = e3;
    var a4 = 0;
    do {
      if (ru && (uu = null), ou = 0, ru = false, 25 <= a4) throw Error(r3(301));
      if (a4 += 1, nu = eu = null, null != e3.updateQueue) {
        var o3 = e3.updateQueue;
        o3.lastEffect = null, o3.events = null, o3.stores = null, null != o3.memoCache && (o3.memoCache.index = 0);
      }
      Rl.H = pu, o3 = n5(t4, l3);
    } while (ru);
    return o3;
  }
  function Pe() {
    var e3 = Rl.H, n5 = e3.useState()[0];
    return n5 = "function" == typeof n5.then ? Le(n5) : n5, e3 = e3.useState()[0], (null !== eu ? eu.memoizedState : null) !== e3 && (Zo.flags |= 1024), n5;
  }
  function Ee() {
    var e3 = 0 !== au;
    return au = 0, e3;
  }
  function _e(e3, n5, t4) {
    n5.updateQueue = e3.updateQueue, n5.flags &= -2053, e3.lanes &= ~t4;
  }
  function Re(e3) {
    if (tu) {
      for (e3 = e3.memoizedState; null !== e3; ) {
        var n5 = e3.queue;
        null !== n5 && (n5.pending = null), e3 = e3.next;
      }
      tu = false;
    }
    Xo = 0, nu = eu = Zo = null, ru = false, ou = au = 0, uu = null;
  }
  function Te() {
    var e3 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return null === nu ? Zo.memoizedState = nu = e3 : nu = nu.next = e3, nu;
  }
  function Ne() {
    if (null === eu) {
      var e3 = Zo.alternate;
      e3 = null !== e3 ? e3.memoizedState : null;
    } else e3 = eu.next;
    var n5 = null === nu ? Zo.memoizedState : nu.next;
    if (null !== n5) nu = n5, eu = e3;
    else {
      if (null === e3) {
        if (null === Zo.alternate) throw Error(r3(467));
        throw Error(r3(310));
      }
      e3 = { memoizedState: (eu = e3).memoizedState, baseState: eu.baseState, baseQueue: eu.baseQueue, queue: eu.queue, next: null }, null === nu ? Zo.memoizedState = nu = e3 : nu = nu.next = e3;
    }
    return nu;
  }
  function Le(e3) {
    var n5 = ou;
    return ou += 1, null === uu && (uu = []), e3 = oe(uu, e3, n5), n5 = Zo, null === (null === nu ? n5.memoizedState : nu.next) && (n5 = n5.alternate, Rl.H = null === n5 || null === n5.memoizedState ? fu : du), e3;
  }
  function Ue(e3) {
    if (null !== e3 && "object" == typeof e3) {
      if ("function" == typeof e3.then) return Le(e3);
      if (e3.$$typeof === vl) return bt(e3);
    }
    throw Error(r3(438, String(e3)));
  }
  function Ie(e3) {
    var n5 = null, t4 = Zo.updateQueue;
    if (null !== t4 && (n5 = t4.memoCache), null == n5) {
      var r4 = Zo.alternate;
      null !== r4 && null !== (r4 = r4.updateQueue) && null != (r4 = r4.memoCache) && (n5 = { data: r4.data.map(function(e4) {
        return e4.slice();
      }), index: 0 });
    }
    if (null == n5 && (n5 = { data: [], index: 0 }), null === t4 && (t4 = su(), Zo.updateQueue = t4), t4.memoCache = n5, void 0 === (t4 = n5.data[n5.index])) for (t4 = n5.data[n5.index] = Array(e3), r4 = 0; r4 < e3; r4++) t4[r4] = Pl;
    return n5.index++, t4;
  }
  function De(e3, n5) {
    return "function" == typeof n5 ? n5(e3) : n5;
  }
  function Fe(e3) {
    return Me(Ne(), eu, e3);
  }
  function Me(e3, n5, t4) {
    var l3 = e3.queue;
    if (null === l3) throw Error(r3(311));
    l3.lastRenderedReducer = t4;
    var a4 = e3.baseQueue, o3 = l3.pending;
    if (null !== o3) {
      if (null !== a4) {
        var u3 = a4.next;
        a4.next = o3.next, o3.next = u3;
      }
      n5.baseQueue = a4 = o3, l3.pending = null;
    }
    if (o3 = e3.baseState, null === a4) e3.memoizedState = o3;
    else {
      var i4 = u3 = null, s3 = null, c4 = n5 = a4.next, f3 = false;
      do {
        var d3 = -536870913 & c4.lane;
        if (d3 !== c4.lane ? (Bu & d3) === d3 : (Xo & d3) === d3) {
          var p3 = c4.revertLane;
          if (0 === p3) null !== s3 && (s3 = s3.next = { lane: 0, revertLane: 0, action: c4.action, hasEagerState: c4.hasEagerState, eagerState: c4.eagerState, next: null }), d3 === Io && (f3 = true);
          else {
            if ((Xo & p3) === p3) {
              c4 = c4.next, p3 === Io && (f3 = true);
              continue;
            }
            d3 = { lane: 0, revertLane: c4.revertLane, action: c4.action, hasEagerState: c4.hasEagerState, eagerState: c4.eagerState, next: null }, null === s3 ? (i4 = s3 = d3, u3 = o3) : s3 = s3.next = d3, Zo.lanes |= p3, Ku |= p3;
          }
          d3 = c4.action, lu && t4(o3, d3), o3 = c4.hasEagerState ? c4.eagerState : t4(o3, d3);
        } else p3 = { lane: d3, revertLane: c4.revertLane, action: c4.action, hasEagerState: c4.hasEagerState, eagerState: c4.eagerState, next: null }, null === s3 ? (i4 = s3 = p3, u3 = o3) : s3 = s3.next = p3, Zo.lanes |= d3, Ku |= d3;
        c4 = c4.next;
      } while (null !== c4 && c4 !== n5);
      if (null === s3 ? u3 = o3 : s3.next = i4, !ao(o3, e3.memoizedState) && (gu = true, f3 && null !== (t4 = Do))) throw t4;
      e3.memoizedState = o3, e3.baseState = u3, e3.baseQueue = s3, l3.lastRenderedState = o3;
    }
    return null === a4 && (l3.lanes = 0), [e3.memoizedState, l3.dispatch];
  }
  function He(e3) {
    var n5 = Ne(), t4 = n5.queue;
    if (null === t4) throw Error(r3(311));
    t4.lastRenderedReducer = e3;
    var l3 = t4.dispatch, a4 = t4.pending, o3 = n5.memoizedState;
    if (null !== a4) {
      t4.pending = null;
      var u3 = a4 = a4.next;
      do {
        o3 = e3(o3, u3.action), u3 = u3.next;
      } while (u3 !== a4);
      ao(o3, n5.memoizedState) || (gu = true), n5.memoizedState = o3, null === n5.baseQueue && (n5.baseState = o3), t4.lastRenderedState = o3;
    }
    return [o3, l3];
  }
  function je(e3, n5, t4) {
    var l3 = Zo, a4 = Ne();
    t4 = n5();
    var o3 = !ao((eu || a4).memoizedState, t4);
    if (o3 && (a4.memoizedState = t4, gu = true), a4 = a4.queue, fn(Ae.bind(null, l3, a4, e3), [e3]), a4.getSnapshot !== n5 || o3 || null !== nu && 1 & nu.memoizedState.tag) {
      if (l3.flags |= 2048, an(9, Oe.bind(null, l3, a4, t4, n5), { destroy: void 0 }, null), null === Au) throw Error(r3(349));
      0 != (60 & Xo) || We(l3, n5, t4);
    }
    return t4;
  }
  function We(e3, n5, t4) {
    e3.flags |= 16384, e3 = { getSnapshot: n5, value: t4 }, null === (n5 = Zo.updateQueue) ? (n5 = su(), Zo.updateQueue = n5, n5.stores = [e3]) : null === (t4 = n5.stores) ? n5.stores = [e3] : t4.push(e3);
  }
  function Oe(e3, n5, t4, r4) {
    n5.value = t4, n5.getSnapshot = r4, Qe(n5) && Be(e3);
  }
  function Ae(e3, n5, t4) {
    return t4(function() {
      Qe(n5) && Be(e3);
    });
  }
  function Qe(e3) {
    var n5 = e3.getSnapshot;
    e3 = e3.value;
    try {
      var t4 = n5();
      return !ao(e3, t4);
    } catch (e4) {
      return true;
    }
  }
  function Be(e3) {
    var n5 = F(e3, 2);
    null !== n5 && yr(n5, 0, 2);
  }
  function Ve(e3) {
    var n5 = Te();
    if ("function" == typeof e3) {
      var t4 = e3;
      if (e3 = t4(), lu) {
        z(true);
        try {
          t4();
        } finally {
          z(false);
        }
      }
    }
    return n5.memoizedState = n5.baseState = e3, n5.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: De, lastRenderedState: e3 }, n5;
  }
  function $e(e3, n5, t4, r4) {
    return e3.baseState = t4, Me(e3, eu, "function" == typeof r4 ? r4 : De);
  }
  function qe(e3, n5, t4, l3, a4) {
    if (Tn(e3)) throw Error(r3(485));
    if (null !== (e3 = n5.action)) {
      var o3 = { payload: a4, action: e3, next: null, isTransition: true, status: "pending", value: null, reason: null, listeners: [], then: function(e4) {
        o3.listeners.push(e4);
      } };
      null !== Rl.T ? t4(true) : o3.isTransition = false, l3(o3), null === (t4 = n5.pending) ? (o3.next = n5.pending = o3, Ye(n5, o3)) : (o3.next = t4.next, n5.pending = t4.next = o3);
    }
  }
  function Ye(e3, n5) {
    var t4 = n5.action, r4 = n5.payload, l3 = e3.state;
    if (n5.isTransition) {
      var a4 = Rl.T, o3 = {};
      Rl.T = o3;
      try {
        var u3 = t4(l3, r4), i4 = Rl.S;
        null !== i4 && i4(o3, u3), Je(e3, n5, u3);
      } catch (t5) {
        Ke(e3, n5, t5);
      } finally {
        Rl.T = a4;
      }
    } else try {
      Je(e3, n5, a4 = t4(l3, r4));
    } catch (t5) {
      Ke(e3, n5, t5);
    }
  }
  function Je(e3, n5, t4) {
    null !== t4 && "object" == typeof t4 && "function" == typeof t4.then ? t4.then(function(t5) {
      Ge(e3, n5, t5);
    }, function(t5) {
      return Ke(e3, n5, t5);
    }) : Ge(e3, n5, t4);
  }
  function Ge(e3, n5, t4) {
    n5.status = "fulfilled", n5.value = t4, Xe(n5), e3.state = t4, null !== (n5 = e3.pending) && ((t4 = n5.next) === n5 ? e3.pending = null : (t4 = t4.next, n5.next = t4, Ye(e3, t4)));
  }
  function Ke(e3, n5, t4) {
    var r4 = e3.pending;
    if (e3.pending = null, null !== r4) {
      r4 = r4.next;
      do {
        n5.status = "rejected", n5.reason = t4, Xe(n5), n5 = n5.next;
      } while (n5 !== r4);
    }
    e3.action = null;
  }
  function Xe(e3) {
    e3 = e3.listeners;
    for (var n5 = 0; n5 < e3.length; n5++) (0, e3[n5])();
  }
  function Ze(e3, n5) {
    return n5;
  }
  function en(e3, n5) {
    var t4, r4, l3;
    (t4 = Te()).memoizedState = t4.baseState = n5, r4 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Ze, lastRenderedState: n5 }, t4.queue = r4, t4 = En.bind(null, Zo, r4), r4.dispatch = t4, r4 = Ve(false);
    var a4 = Rn.bind(null, Zo, false, r4.queue);
    return l3 = { state: n5, dispatch: null, action: e3, pending: null }, (r4 = Te()).queue = l3, t4 = qe.bind(null, Zo, l3, a4, t4), l3.dispatch = t4, r4.memoizedState = e3, [n5, t4, false];
  }
  function nn(e3) {
    return tn(Ne(), eu, e3);
  }
  function tn(e3, n5, t4) {
    n5 = Me(e3, n5, Ze)[0], e3 = Fe(De)[0], n5 = "object" == typeof n5 && null !== n5 && "function" == typeof n5.then ? Le(n5) : n5;
    var r4 = Ne(), l3 = r4.queue, a4 = l3.dispatch;
    return t4 !== r4.memoizedState && (Zo.flags |= 2048, an(9, rn.bind(null, l3, t4), { destroy: void 0 }, null)), [n5, a4, e3];
  }
  function rn(e3, n5) {
    e3.action = n5;
  }
  function ln(e3) {
    var n5 = Ne(), t4 = eu;
    if (null !== t4) return tn(n5, t4, e3);
    Ne(), n5 = n5.memoizedState;
    var r4 = (t4 = Ne()).queue.dispatch;
    return t4.memoizedState = e3, [n5, r4, false];
  }
  function an(e3, n5, t4, r4) {
    return e3 = { tag: e3, create: n5, inst: t4, deps: r4, next: null }, null === (n5 = Zo.updateQueue) && (n5 = su(), Zo.updateQueue = n5), null === (t4 = n5.lastEffect) ? n5.lastEffect = e3.next = e3 : (r4 = t4.next, t4.next = e3, e3.next = r4, n5.lastEffect = e3), e3;
  }
  function on3() {
    return Ne().memoizedState;
  }
  function un(e3, n5, t4, r4) {
    var l3 = Te();
    Zo.flags |= e3, l3.memoizedState = an(1 | n5, t4, { destroy: void 0 }, void 0 === r4 ? null : r4);
  }
  function sn(e3, n5, t4, r4) {
    var l3 = Ne();
    r4 = void 0 === r4 ? null : r4;
    var a4 = l3.memoizedState.inst;
    null !== eu && null !== r4 && we(r4, eu.memoizedState.deps) ? l3.memoizedState = an(n5, t4, a4, r4) : (Zo.flags |= e3, l3.memoizedState = an(1 | n5, t4, a4, r4));
  }
  function cn(e3, n5) {
    un(8390656, 8, e3, n5);
  }
  function fn(e3, n5) {
    sn(2048, 8, e3, n5);
  }
  function dn(e3, n5) {
    return sn(4, 2, e3, n5);
  }
  function pn(e3, n5) {
    return sn(4, 4, e3, n5);
  }
  function mn(e3, n5) {
    if ("function" == typeof n5) {
      e3 = e3();
      var t4 = n5(e3);
      return function() {
        "function" == typeof t4 ? t4() : n5(null);
      };
    }
    if (null != n5) return e3 = e3(), n5.current = e3, function() {
      n5.current = null;
    };
  }
  function hn(e3, n5, t4) {
    t4 = null != t4 ? t4.concat([e3]) : null, sn(4, 4, mn.bind(null, n5, e3), t4);
  }
  function gn() {
  }
  function yn(e3, n5) {
    var t4 = Ne();
    n5 = void 0 === n5 ? null : n5;
    var r4 = t4.memoizedState;
    return null !== n5 && we(n5, r4[1]) ? r4[0] : (t4.memoizedState = [e3, n5], e3);
  }
  function bn(e3, n5) {
    var t4 = Ne();
    n5 = void 0 === n5 ? null : n5;
    var r4 = t4.memoizedState;
    if (null !== n5 && we(n5, r4[1])) return r4[0];
    if (r4 = e3(), lu) {
      z(true);
      try {
        e3();
      } finally {
        z(false);
      }
    }
    return t4.memoizedState = [r4, n5], r4;
  }
  function vn(e3, n5, t4) {
    return void 0 === t4 || 0 != (1073741824 & Xo) ? e3.memoizedState = n5 : (e3.memoizedState = t4, e3 = gr(), Zo.lanes |= e3, Ku |= e3, t4);
  }
  function Sn(e3, n5, t4, r4) {
    return ao(t4, n5) ? t4 : null !== qo.current ? (e3 = vn(e3, t4, r4), ao(e3, n5) || (gu = true), e3) : 0 == (42 & Xo) ? (gu = true, e3.memoizedState = t4) : (e3 = gr(), Zo.lanes |= e3, Ku |= e3, n5);
  }
  function kn(e3, n5, t4, r4, l3) {
    var a4 = Gl();
    Jl(0 !== a4 && 8 > a4 ? a4 : 8);
    var o3, u3, i4, s3 = Rl.T, c4 = {};
    Rl.T = c4, Rn(e3, false, n5, t4);
    try {
      var f3 = l3(), d3 = Rl.S;
      null !== d3 && d3(c4, f3), null !== f3 && "object" == typeof f3 && "function" == typeof f3.then ? _n(e3, n5, (o3 = r4, u3 = [], i4 = { status: "pending", value: null, reason: null, then: function(e4) {
        u3.push(e4);
      } }, f3.then(function() {
        i4.status = "fulfilled", i4.value = o3;
        for (var e4 = 0; e4 < u3.length; e4++) (0, u3[e4])(o3);
      }, function(e4) {
        for (i4.status = "rejected", i4.reason = e4, e4 = 0; e4 < u3.length; e4++) (0, u3[e4])(void 0);
      }), i4), hr()) : _n(e3, n5, r4, hr());
    } catch (t5) {
      _n(e3, n5, { then: function() {
      }, status: "rejected", reason: t5 }, hr());
    } finally {
      Jl(a4), Rl.T = s3;
    }
  }
  function wn() {
    return bt(oa);
  }
  function xn() {
    return Ne().memoizedState;
  }
  function zn() {
    return Ne().memoizedState;
  }
  function Cn(e3) {
    for (var n5 = e3.return; null !== n5; ) {
      switch (n5.tag) {
        case 24:
        case 3:
          var t4 = hr(), r4 = G2(n5, e3 = J(t4), t4);
          return null !== r4 && (yr(r4, 0, t4), K(r4, n5, t4)), n5 = { cache: kt() }, void (e3.payload = n5);
      }
      n5 = n5.return;
    }
  }
  function Pn(e3, n5, t4) {
    var r4 = hr();
    t4 = { lane: r4, revertLane: 0, action: t4, hasEagerState: false, eagerState: null, next: null }, Tn(e3) ? Nn(n5, t4) : null !== (t4 = D(e3, n5, t4, r4)) && (yr(t4, 0, r4), Ln(t4, n5, r4));
  }
  function En(e3, n5, t4) {
    _n(e3, n5, t4, hr());
  }
  function _n(e3, n5, t4, r4) {
    var l3 = { lane: r4, revertLane: 0, action: t4, hasEagerState: false, eagerState: null, next: null };
    if (Tn(e3)) Nn(n5, l3);
    else {
      var a4 = e3.alternate;
      if (0 === e3.lanes && (null === a4 || 0 === a4.lanes) && null !== (a4 = n5.lastRenderedReducer)) try {
        var o3 = n5.lastRenderedState, u3 = a4(o3, t4);
        if (l3.hasEagerState = true, l3.eagerState = u3, ao(u3, o3)) return I(e3, n5, l3, 0), null === Au && U(), false;
      } catch (e4) {
      }
      if (null !== (t4 = D(e3, n5, l3, r4))) return yr(t4, 0, r4), Ln(t4, n5, r4), true;
    }
    return false;
  }
  function Rn(e3, n5, t4, l3) {
    if (l3 = { lane: 2, revertLane: V(), action: l3, hasEagerState: false, eagerState: null, next: null }, Tn(e3)) {
      if (n5) throw Error(r3(479));
    } else null !== (n5 = D(e3, t4, l3, 2)) && yr(n5, 0, 2);
  }
  function Tn(e3) {
    var n5 = e3.alternate;
    return e3 === Zo || null !== n5 && n5 === Zo;
  }
  function Nn(e3, n5) {
    ru = tu = true;
    var t4 = e3.pending;
    null === t4 ? n5.next = n5 : (n5.next = t4.next, t4.next = n5), e3.pending = n5;
  }
  function Ln(e3, n5, t4) {
    if (0 != (4194176 & t4)) {
      var r4 = n5.lanes;
      t4 |= r4 &= e3.pendingLanes, n5.lanes = t4, w(e3, t4);
    }
  }
  function Un(e3, n5, t4, r4) {
    t4 = null == (t4 = t4(r4, n5 = e3.memoizedState)) ? n5 : cl({}, n5, t4), e3.memoizedState = t4, 0 === e3.lanes && (e3.updateQueue.baseState = t4);
  }
  function In(e3, n5, t4, r4, l3, a4, o3) {
    return "function" == typeof (e3 = e3.stateNode).shouldComponentUpdate ? e3.shouldComponentUpdate(r4, a4, o3) : !(n5.prototype && n5.prototype.isPureReactComponent && re(t4, r4) && re(l3, a4));
  }
  function Dn(e3, n5, t4, r4) {
    e3 = n5.state, "function" == typeof n5.componentWillReceiveProps && n5.componentWillReceiveProps(t4, r4), "function" == typeof n5.UNSAFE_componentWillReceiveProps && n5.UNSAFE_componentWillReceiveProps(t4, r4), n5.state !== e3 && mu.enqueueReplaceState(n5, n5.state, null);
  }
  function Fn(e3, n5) {
    var t4 = n5;
    if ("ref" in n5) for (var r4 in t4 = {}, n5) "ref" !== r4 && (t4[r4] = n5[r4]);
    if (e3 = e3.defaultProps) for (var l3 in t4 === n5 && (t4 = cl({}, t4)), e3) void 0 === t4[l3] && (t4[l3] = e3[l3]);
    return t4;
  }
  function Mn(e3, n5) {
    try {
      (0, e3.onUncaughtError)(n5.value, { componentStack: n5.stack });
    } catch (e4) {
      setTimeout(function() {
        throw e4;
      });
    }
  }
  function Hn(e3, n5, t4) {
    try {
      (0, e3.onCaughtError)(t4.value, { componentStack: t4.stack, errorBoundary: 1 === n5.tag ? n5.stateNode : null });
    } catch (e4) {
      setTimeout(function() {
        throw e4;
      });
    }
  }
  function jn(e3, n5, t4) {
    return (t4 = J(t4)).tag = 3, t4.payload = { element: null }, t4.callback = function() {
      Mn(e3, n5);
    }, t4;
  }
  function Wn(e3) {
    return (e3 = J(e3)).tag = 3, e3;
  }
  function On(e3, n5, t4, r4) {
    var l3 = t4.type.getDerivedStateFromError;
    if ("function" == typeof l3) {
      var a4 = r4.value;
      e3.payload = function() {
        return l3(a4);
      }, e3.callback = function() {
        Hn(n5, t4, r4);
      };
    }
    var o3 = t4.stateNode;
    null !== o3 && "function" == typeof o3.componentDidCatch && (e3.callback = function() {
      Hn(n5, t4, r4), "function" != typeof l3 && (null === ii ? ii = /* @__PURE__ */ new Set([this]) : ii.add(this));
      var e4 = r4.stack;
      this.componentDidCatch(r4.value, { componentStack: null !== e4 ? e4 : "" });
    });
  }
  function An(e3, n5, t4, r4) {
    n5.child = null === e3 ? $o(n5, null, t4, r4) : Vo(n5, e3.child, t4, r4);
  }
  function Qn(e3, n5, t4, r4, l3) {
    t4 = t4.render;
    var a4 = n5.ref;
    if ("ref" in r4) {
      var o3 = {};
      for (var u3 in r4) "ref" !== u3 && (o3[u3] = r4[u3]);
    } else o3 = r4;
    return yt(n5), r4 = xe(e3, n5, t4, o3, a4, l3), u3 = Ee(), null === e3 || gu ? (n5.flags |= 1, An(e3, n5, r4, l3), n5.child) : (_e(e3, n5, l3), ut(e3, n5, l3));
  }
  function Bn(e3, n5, t4, r4, l3) {
    if (null === e3) {
      var a4 = t4.type;
      return "function" != typeof a4 || Jr(a4) || void 0 !== a4.defaultProps || null !== t4.compare ? ((e3 = Xr(t4.type, null, r4, n5, n5.mode, l3)).ref = n5.ref, e3.return = n5, n5.child = e3) : (n5.tag = 15, n5.type = a4, Vn(e3, n5, a4, r4, l3));
    }
    if (a4 = e3.child, !it(e3, l3)) {
      var o3 = a4.memoizedProps;
      if ((t4 = null !== (t4 = t4.compare) ? t4 : re)(o3, r4) && e3.ref === n5.ref) return ut(e3, n5, l3);
    }
    return n5.flags |= 1, (e3 = Gr(a4, r4)).ref = n5.ref, e3.return = n5, n5.child = e3;
  }
  function Vn(e3, n5, t4, r4, l3) {
    if (null !== e3) {
      var a4 = e3.memoizedProps;
      if (re(a4, r4) && e3.ref === n5.ref) {
        if (gu = false, n5.pendingProps = r4 = a4, !it(e3, l3)) return n5.lanes = e3.lanes, ut(e3, n5, l3);
        0 != (131072 & e3.flags) && (gu = true);
      }
    }
    return Jn(e3, n5, t4, r4, l3);
  }
  function $n(e3, n5, t4) {
    var r4 = n5.pendingProps, l3 = r4.children, a4 = 0 != (2 & n5.stateNode._pendingVisibility), o3 = null !== e3 ? e3.memoizedState : null;
    if (Yn(e3, n5), "hidden" === r4.mode || a4) {
      if (0 != (128 & n5.flags)) {
        if (r4 = null !== o3 ? o3.baseLanes | t4 : t4, null !== e3) {
          for (l3 = n5.child = e3.child, a4 = 0; null !== l3; ) a4 = a4 | l3.lanes | l3.childLanes, l3 = l3.sibling;
          n5.childLanes = a4 & ~r4;
        } else n5.childLanes = 0, n5.child = null;
        return qn(e3, n5, r4, t4);
      }
      if (0 == (536870912 & t4)) return n5.lanes = n5.childLanes = 536870912, qn(e3, n5, null !== o3 ? o3.baseLanes | t4 : t4, t4);
      n5.memoizedState = { baseLanes: 0, cachePool: null }, null !== e3 && zt(0, null !== o3 ? o3.cachePool : null), null !== o3 ? pe(n5, o3) : me(), ye(n5);
    } else null !== o3 ? (zt(0, o3.cachePool), pe(n5, o3), be(), n5.memoizedState = null) : (null !== e3 && zt(0, null), me(), be());
    return An(e3, n5, l3, t4), n5.child;
  }
  function qn(e3, n5, t4, r4) {
    var l3 = xt();
    return l3 = null === l3 ? null : { parent: Cu._currentValue2, pool: l3 }, n5.memoizedState = { baseLanes: t4, cachePool: l3 }, null !== e3 && zt(0, null), me(), ye(n5), null !== e3 && ht(e3, n5, r4, true), null;
  }
  function Yn(e3, n5) {
    var t4 = n5.ref;
    if (null === t4) null !== e3 && null !== e3.ref && (n5.flags |= 2097664);
    else {
      if ("function" != typeof t4 && "object" != typeof t4) throw Error(r3(284));
      null !== e3 && e3.ref === t4 || (n5.flags |= 2097664);
    }
  }
  function Jn(e3, n5, t4, r4, l3) {
    return yt(n5), t4 = xe(e3, n5, t4, r4, void 0, l3), r4 = Ee(), null === e3 || gu ? (n5.flags |= 1, An(e3, n5, t4, l3), n5.child) : (_e(e3, n5, l3), ut(e3, n5, l3));
  }
  function Gn(e3, n5, t4, r4, l3, a4) {
    return yt(n5), n5.updateQueue = null, t4 = Ce(n5, r4, t4, l3), ze(e3), r4 = Ee(), null === e3 || gu ? (n5.flags |= 1, An(e3, n5, t4, a4), n5.child) : (_e(e3, n5, a4), ut(e3, n5, a4));
  }
  function Kn(e3, n5, t4, r4, l3) {
    if (yt(n5), null === n5.stateNode) {
      var a4 = Oa, o3 = t4.contextType;
      "object" == typeof o3 && null !== o3 && (a4 = bt(o3)), a4 = new t4(r4, a4), n5.memoizedState = null !== a4.state && void 0 !== a4.state ? a4.state : null, a4.updater = mu, n5.stateNode = a4, a4._reactInternals = n5, (a4 = n5.stateNode).props = r4, a4.state = n5.memoizedState, a4.refs = {}, q(n5), o3 = t4.contextType, a4.context = "object" == typeof o3 && null !== o3 ? bt(o3) : Oa, a4.state = n5.memoizedState, "function" == typeof (o3 = t4.getDerivedStateFromProps) && (Un(n5, t4, o3, r4), a4.state = n5.memoizedState), "function" == typeof t4.getDerivedStateFromProps || "function" == typeof a4.getSnapshotBeforeUpdate || "function" != typeof a4.UNSAFE_componentWillMount && "function" != typeof a4.componentWillMount || (o3 = a4.state, "function" == typeof a4.componentWillMount && a4.componentWillMount(), "function" == typeof a4.UNSAFE_componentWillMount && a4.UNSAFE_componentWillMount(), o3 !== a4.state && mu.enqueueReplaceState(a4, a4.state, null), ee(n5, r4, a4, l3), Z(), a4.state = n5.memoizedState), "function" == typeof a4.componentDidMount && (n5.flags |= 4194308), r4 = true;
    } else if (null === e3) {
      a4 = n5.stateNode;
      var u3 = n5.memoizedProps, i4 = Fn(t4, u3);
      a4.props = i4;
      var s3 = a4.context, c4 = t4.contextType;
      o3 = Oa, "object" == typeof c4 && null !== c4 && (o3 = bt(c4));
      var f3 = t4.getDerivedStateFromProps;
      c4 = "function" == typeof f3 || "function" == typeof a4.getSnapshotBeforeUpdate, u3 = n5.pendingProps !== u3, c4 || "function" != typeof a4.UNSAFE_componentWillReceiveProps && "function" != typeof a4.componentWillReceiveProps || (u3 || s3 !== o3) && Dn(n5, a4, r4, o3), Fo = false;
      var d3 = n5.memoizedState;
      a4.state = d3, ee(n5, r4, a4, l3), Z(), s3 = n5.memoizedState, u3 || d3 !== s3 || Fo ? ("function" == typeof f3 && (Un(n5, t4, f3, r4), s3 = n5.memoizedState), (i4 = Fo || In(n5, t4, i4, r4, d3, s3, o3)) ? (c4 || "function" != typeof a4.UNSAFE_componentWillMount && "function" != typeof a4.componentWillMount || ("function" == typeof a4.componentWillMount && a4.componentWillMount(), "function" == typeof a4.UNSAFE_componentWillMount && a4.UNSAFE_componentWillMount()), "function" == typeof a4.componentDidMount && (n5.flags |= 4194308)) : ("function" == typeof a4.componentDidMount && (n5.flags |= 4194308), n5.memoizedProps = r4, n5.memoizedState = s3), a4.props = r4, a4.state = s3, a4.context = o3, r4 = i4) : ("function" == typeof a4.componentDidMount && (n5.flags |= 4194308), r4 = false);
    } else {
      a4 = n5.stateNode, Y(e3, n5), c4 = Fn(t4, o3 = n5.memoizedProps), a4.props = c4, f3 = n5.pendingProps, d3 = a4.context, s3 = t4.contextType, i4 = Oa, "object" == typeof s3 && null !== s3 && (i4 = bt(s3)), (s3 = "function" == typeof (u3 = t4.getDerivedStateFromProps) || "function" == typeof a4.getSnapshotBeforeUpdate) || "function" != typeof a4.UNSAFE_componentWillReceiveProps && "function" != typeof a4.componentWillReceiveProps || (o3 !== f3 || d3 !== i4) && Dn(n5, a4, r4, i4), Fo = false, d3 = n5.memoizedState, a4.state = d3, ee(n5, r4, a4, l3), Z();
      var p3 = n5.memoizedState;
      o3 !== f3 || d3 !== p3 || Fo || null !== e3 && null !== e3.dependencies && gt(e3.dependencies) ? ("function" == typeof u3 && (Un(n5, t4, u3, r4), p3 = n5.memoizedState), (c4 = Fo || In(n5, t4, c4, r4, d3, p3, i4) || null !== e3 && null !== e3.dependencies && gt(e3.dependencies)) ? (s3 || "function" != typeof a4.UNSAFE_componentWillUpdate && "function" != typeof a4.componentWillUpdate || ("function" == typeof a4.componentWillUpdate && a4.componentWillUpdate(r4, p3, i4), "function" == typeof a4.UNSAFE_componentWillUpdate && a4.UNSAFE_componentWillUpdate(r4, p3, i4)), "function" == typeof a4.componentDidUpdate && (n5.flags |= 4), "function" == typeof a4.getSnapshotBeforeUpdate && (n5.flags |= 1024)) : ("function" != typeof a4.componentDidUpdate || o3 === e3.memoizedProps && d3 === e3.memoizedState || (n5.flags |= 4), "function" != typeof a4.getSnapshotBeforeUpdate || o3 === e3.memoizedProps && d3 === e3.memoizedState || (n5.flags |= 1024), n5.memoizedProps = r4, n5.memoizedState = p3), a4.props = r4, a4.state = p3, a4.context = i4, r4 = c4) : ("function" != typeof a4.componentDidUpdate || o3 === e3.memoizedProps && d3 === e3.memoizedState || (n5.flags |= 4), "function" != typeof a4.getSnapshotBeforeUpdate || o3 === e3.memoizedProps && d3 === e3.memoizedState || (n5.flags |= 1024), r4 = false);
    }
    return a4 = r4, Yn(e3, n5), r4 = 0 != (128 & n5.flags), a4 || r4 ? (a4 = n5.stateNode, t4 = r4 && "function" != typeof t4.getDerivedStateFromError ? null : a4.render(), n5.flags |= 1, null !== e3 && r4 ? (n5.child = Vo(n5, e3.child, null, l3), n5.child = Vo(n5, null, t4, l3)) : An(e3, n5, t4, l3), n5.memoizedState = a4.state, e3 = n5.child) : e3 = ut(e3, n5, l3), e3;
  }
  function Xn(e3) {
    return { baseLanes: e3, cachePool: Ct() };
  }
  function Zn(e3, n5, t4) {
    return e3 = null !== e3 ? e3.childLanes & ~t4 : 0, n5 && (e3 |= ei), e3;
  }
  function et(e3, n5, t4) {
    var l3, a4, o3, u3 = n5.pendingProps, i4 = false, s3 = 0 != (128 & n5.flags);
    if ((l3 = s3) || (l3 = (null === e3 || null !== e3.memoizedState) && 0 != (2 & Ko.current)), l3 && (i4 = true, n5.flags &= -129), l3 = 0 != (32 & n5.flags), n5.flags &= -33, null === e3) return a4 = u3.children, u3 = u3.fallback, i4 ? (be(), a4 = tt({ mode: "hidden", children: a4 }, i4 = n5.mode), u3 = Zr(u3, i4, t4, null), a4.return = n5, u3.return = n5, a4.sibling = u3, n5.child = a4, (i4 = n5.child).memoizedState = Xn(t4), i4.childLanes = Zn(e3, l3, t4), n5.memoizedState = yu, u3) : (ge(n5), nt(n5, a4));
    if (null !== (o3 = e3.memoizedState) && null !== (a4 = o3.dehydrated)) {
      if (s3) 256 & n5.flags ? (ge(n5), n5.flags &= -257, n5 = rt(e3, n5, t4)) : null !== n5.memoizedState ? (be(), n5.child = e3.child, n5.flags |= 128, n5 = null) : (be(), i4 = u3.fallback, a4 = n5.mode, u3 = tt({ mode: "visible", children: u3.children }, a4), (i4 = Zr(i4, a4, t4, null)).flags |= 2, u3.return = n5, i4.return = n5, u3.sibling = i4, n5.child = u3, Vo(n5, e3.child, null, t4), (u3 = n5.child).memoizedState = Xn(t4), u3.childLanes = Zn(e3, l3, t4), n5.memoizedState = yu, n5 = i4);
      else if (ge(n5), Ca(a4)) l3 = Pa(a4).digest, (u3 = Error(r3(419))).stack = "", u3.digest = l3, L({ value: u3, source: null, stack: null }), n5 = rt(e3, n5, t4);
      else if (gu || ht(e3, n5, t4, false), l3 = 0 != (t4 & e3.childLanes), gu || l3) {
        if (null !== (l3 = Au)) {
          if (0 != (42 & (u3 = t4 & -t4))) u3 = 1;
          else switch (u3) {
            case 2:
              u3 = 1;
              break;
            case 8:
              u3 = 4;
              break;
            case 32:
              u3 = 16;
              break;
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              u3 = 64;
              break;
            case 268435456:
              u3 = 134217728;
              break;
            default:
              u3 = 0;
          }
          if (0 !== (u3 = 0 != (u3 & (l3.suspendedLanes | t4)) ? 0 : u3) && u3 !== o3.retryLane) throw o3.retryLane = u3, F(e3, u3), yr(l3, 0, u3), hu;
        }
        za(a4) || Rr(), n5 = rt(e3, n5, t4);
      } else za(a4) ? (n5.flags |= 128, n5.child = e3.child, n5 = $r.bind(null, e3), Ea(a4, n5), n5 = null) : (e3 = o3.treeContext, (n5 = nt(n5, u3.children)).flags |= 4096);
      return n5;
    }
    return i4 ? (be(), i4 = u3.fallback, a4 = n5.mode, s3 = (o3 = e3.child).sibling, (u3 = Gr(o3, { mode: "hidden", children: u3.children })).subtreeFlags = 31457280 & o3.subtreeFlags, null !== s3 ? i4 = Gr(s3, i4) : (i4 = Zr(i4, a4, t4, null)).flags |= 2, i4.return = n5, u3.return = n5, u3.sibling = i4, n5.child = u3, u3 = i4, i4 = n5.child, null === (a4 = e3.child.memoizedState) ? a4 = Xn(t4) : (null !== (o3 = a4.cachePool) ? (s3 = Cu._currentValue2, o3 = o3.parent !== s3 ? { parent: s3, pool: s3 } : o3) : o3 = Ct(), a4 = { baseLanes: a4.baseLanes | t4, cachePool: o3 }), i4.memoizedState = a4, i4.childLanes = Zn(e3, l3, t4), n5.memoizedState = yu, u3) : (ge(n5), e3 = (t4 = e3.child).sibling, (t4 = Gr(t4, { mode: "visible", children: u3.children })).return = n5, t4.sibling = null, null !== e3 && (null === (l3 = n5.deletions) ? (n5.deletions = [e3], n5.flags |= 16) : l3.push(e3)), n5.child = t4, n5.memoizedState = null, t4);
  }
  function nt(e3, n5) {
    return (n5 = tt({ mode: "visible", children: n5 }, e3.mode)).return = e3, e3.child = n5;
  }
  function tt(e3, n5) {
    return el(e3, n5, 0, null);
  }
  function rt(e3, n5, t4) {
    return Vo(n5, e3.child, null, t4), (e3 = nt(n5, n5.pendingProps.children)).flags |= 2, n5.memoizedState = null, e3;
  }
  function lt(e3, n5, t4) {
    e3.lanes |= n5;
    var r4 = e3.alternate;
    null !== r4 && (r4.lanes |= n5), pt(e3.return, n5, t4);
  }
  function at(e3, n5, t4, r4, l3) {
    var a4 = e3.memoizedState;
    null === a4 ? e3.memoizedState = { isBackwards: n5, rendering: null, renderingStartTime: 0, last: r4, tail: t4, tailMode: l3 } : (a4.isBackwards = n5, a4.rendering = null, a4.renderingStartTime = 0, a4.last = r4, a4.tail = t4, a4.tailMode = l3);
  }
  function ot(e3, n5, t4) {
    var r4 = n5.pendingProps, l3 = r4.revealOrder, a4 = r4.tail;
    if (An(e3, n5, r4.children, t4), 0 != (2 & (r4 = Ko.current))) r4 = 1 & r4 | 2, n5.flags |= 128;
    else {
      if (null !== e3 && 0 != (128 & e3.flags)) e: for (e3 = n5.child; null !== e3; ) {
        if (13 === e3.tag) null !== e3.memoizedState && lt(e3, t4, n5);
        else if (19 === e3.tag) lt(e3, t4, n5);
        else if (null !== e3.child) {
          e3.child.return = e3, e3 = e3.child;
          continue;
        }
        if (e3 === n5) break e;
        for (; null === e3.sibling; ) {
          if (null === e3.return || e3.return === n5) break e;
          e3 = e3.return;
        }
        e3.sibling.return = e3.return, e3 = e3.sibling;
      }
      r4 &= 1;
    }
    switch (p2(Ko, r4), l3) {
      case "forwards":
        for (t4 = n5.child, l3 = null; null !== t4; ) null !== (e3 = t4.alternate) && null === Se(e3) && (l3 = t4), t4 = t4.sibling;
        null === (t4 = l3) ? (l3 = n5.child, n5.child = null) : (l3 = t4.sibling, t4.sibling = null), at(n5, false, l3, t4, a4);
        break;
      case "backwards":
        for (t4 = null, l3 = n5.child, n5.child = null; null !== l3; ) {
          if (null !== (e3 = l3.alternate) && null === Se(e3)) {
            n5.child = l3;
            break;
          }
          e3 = l3.sibling, l3.sibling = t4, t4 = l3, l3 = e3;
        }
        at(n5, true, t4, null, a4);
        break;
      case "together":
        at(n5, false, null, null, void 0);
        break;
      default:
        n5.memoizedState = null;
    }
    return n5.child;
  }
  function ut(e3, n5, t4) {
    if (null !== e3 && (n5.dependencies = e3.dependencies), Ku |= n5.lanes, 0 == (t4 & n5.childLanes)) {
      if (null === e3) return null;
      if (ht(e3, n5, t4, false), 0 == (t4 & n5.childLanes)) return null;
    }
    if (null !== e3 && n5.child !== e3.child) throw Error(r3(153));
    if (null !== n5.child) {
      for (t4 = Gr(e3 = n5.child, e3.pendingProps), n5.child = t4, t4.return = n5; null !== e3.sibling; ) e3 = e3.sibling, (t4 = t4.sibling = Gr(e3, e3.pendingProps)).return = n5;
      t4.sibling = null;
    }
    return n5.child;
  }
  function it(e3, n5) {
    return 0 != (e3.lanes & n5) || !(null === (e3 = e3.dependencies) || !gt(e3));
  }
  function st(e3, n5, t4) {
    if (null !== e3) if (e3.memoizedProps !== n5.pendingProps) gu = true;
    else {
      if (!it(e3, t4) && 0 == (128 & n5.flags)) return gu = false, function(e4, n6, t5) {
        switch (n6.tag) {
          case 3:
            E(n6, n6.stateNode.containerInfo), ft(0, Cu, e4.memoizedState.cache);
            break;
          case 27:
          case 5:
            R(n6);
            break;
          case 4:
            E(n6, n6.stateNode.containerInfo);
            break;
          case 10:
            ft(0, n6.type, n6.memoizedProps.value);
            break;
          case 13:
            var r4 = n6.memoizedState;
            if (null !== r4) return null !== r4.dehydrated ? (ge(n6), n6.flags |= 128, null) : 0 != (t5 & n6.child.childLanes) ? et(e4, n6, t5) : (ge(n6), null !== (e4 = ut(e4, n6, t5)) ? e4.sibling : null);
            ge(n6);
            break;
          case 19:
            var l4 = 0 != (128 & e4.flags);
            if ((r4 = 0 != (t5 & n6.childLanes)) || (ht(e4, n6, t5, false), r4 = 0 != (t5 & n6.childLanes)), l4) {
              if (r4) return ot(e4, n6, t5);
              n6.flags |= 128;
            }
            if (null !== (l4 = n6.memoizedState) && (l4.rendering = null, l4.tail = null, l4.lastEffect = null), p2(Ko, Ko.current), r4) break;
            return null;
          case 22:
          case 23:
            return n6.lanes = 0, $n(e4, n6, t5);
          case 24:
            ft(0, Cu, e4.memoizedState.cache);
        }
        return ut(e4, n6, t5);
      }(e3, n5, t4);
      gu = 0 != (131072 & e3.flags);
    }
    else gu = false;
    switch (n5.lanes = 0, n5.tag) {
      case 16:
        e: {
          e3 = n5.pendingProps;
          var l3 = n5.elementType, o3 = l3._init;
          if (l3 = o3(l3._payload), n5.type = l3, "function" != typeof l3) {
            if (null != l3) {
              if ((o3 = l3.$$typeof) === Sl) {
                n5.tag = 11, n5 = Qn(null, n5, l3, e3, t4);
                break e;
              }
              if (o3 === xl) {
                n5.tag = 14, n5 = Bn(null, n5, l3, e3, t4);
                break e;
              }
            }
            throw n5 = a3(l3) || l3, Error(r3(306, n5, ""));
          }
          Jr(l3) ? (e3 = Fn(l3, e3), n5.tag = 1, n5 = Kn(null, n5, l3, e3, t4)) : (n5.tag = 0, n5 = Jn(null, n5, l3, e3, t4));
        }
        return n5;
      case 0:
        return Jn(e3, n5, n5.type, n5.pendingProps, t4);
      case 1:
        return Kn(e3, n5, l3 = n5.type, o3 = Fn(l3, n5.pendingProps), t4);
      case 3:
        if (E(n5, n5.stateNode.containerInfo), null === e3) throw Error(r3(387));
        var u3 = n5.pendingProps;
        l3 = (o3 = n5.memoizedState).element, Y(e3, n5), ee(n5, u3, null, t4);
        var i4 = n5.memoizedState;
        return u3 = i4.cache, ft(0, Cu, u3), u3 !== o3.cache && mt(n5, [Cu], t4, true), Z(), (u3 = i4.element) !== l3 ? (An(e3, n5, u3, t4), n5 = n5.child) : n5 = ut(e3, n5, t4), n5;
      case 26:
      case 27:
      case 5:
        return null === e3 && vo && (Ua(n5.type, n5.pendingProps, mo.current), (o3 = l3 = bo) && (null !== (l3 = Ra(l3, n5.type, n5.pendingProps, ko)) ? (n5.stateNode = l3, bo = _a(l3), ko = false, o3 = true) : o3 = false), o3 || N(n5)), R(n5), o3 = n5.type, u3 = n5.pendingProps, i4 = null !== e3 ? e3.memoizedProps : null, l3 = u3.children, Wl(o3, u3) ? l3 = null : null !== i4 && Wl(o3, i4) && (n5.flags |= 32), null !== n5.memoizedState && (o3 = xe(e3, n5, Pe, null, null, t4), oa._currentValue2 = o3), Yn(e3, n5), An(e3, n5, l3, t4), n5.child;
      case 6:
        return null === e3 && vo && (Ia(n5.pendingProps, mo.current), (e3 = t4 = bo) && (null !== (t4 = Ta(t4, n5.pendingProps, ko)) ? (n5.stateNode = t4, bo = null, e3 = true) : e3 = false), e3 || N(n5)), null;
      case 13:
        return et(e3, n5, t4);
      case 4:
        return E(n5, n5.stateNode.containerInfo), l3 = n5.pendingProps, null === e3 ? n5.child = Vo(n5, null, l3, t4) : An(e3, n5, l3, t4), n5.child;
      case 11:
        return Qn(e3, n5, n5.type, n5.pendingProps, t4);
      case 7:
        return An(e3, n5, n5.pendingProps, t4), n5.child;
      case 8:
      case 12:
        return An(e3, n5, n5.pendingProps.children, t4), n5.child;
      case 10:
        return l3 = n5.pendingProps, ft(0, n5.type, l3.value), An(e3, n5, l3.children, t4), n5.child;
      case 9:
        return o3 = n5.type._context, l3 = n5.pendingProps.children, yt(n5), l3 = l3(o3 = bt(o3)), n5.flags |= 1, An(e3, n5, l3, t4), n5.child;
      case 14:
        return Bn(e3, n5, n5.type, n5.pendingProps, t4);
      case 15:
        return Vn(e3, n5, n5.type, n5.pendingProps, t4);
      case 19:
        return ot(e3, n5, t4);
      case 22:
        return $n(e3, n5, t4);
      case 24:
        return yt(n5), l3 = bt(Cu), null === e3 ? (null === (o3 = xt()) && (o3 = Au, u3 = kt(), o3.pooledCache = u3, u3.refCount++, null !== u3 && (o3.pooledCacheLanes |= t4), o3 = u3), n5.memoizedState = { parent: l3, cache: o3 }, q(n5), ft(0, Cu, o3)) : (0 != (e3.lanes & t4) && (Y(e3, n5), ee(n5, null, null, t4), Z()), o3 = e3.memoizedState, u3 = n5.memoizedState, o3.parent !== l3 ? (o3 = { parent: l3, cache: l3 }, n5.memoizedState = o3, 0 === n5.lanes && (n5.memoizedState = n5.updateQueue.baseState = o3), ft(0, Cu, l3)) : (l3 = u3.cache, ft(0, Cu, l3), l3 !== o3.cache && mt(n5, [Cu], t4, true))), An(e3, n5, n5.pendingProps.children, t4), n5.child;
      case 29:
        throw n5.pendingProps;
    }
    throw Error(r3(156, n5.tag));
  }
  function ct() {
    ku = Su = vu = null;
  }
  function ft(e3, n5, t4) {
    p2(bu, n5._currentValue2), n5._currentValue2 = t4;
  }
  function dt(e3) {
    var n5 = bu.current;
    e3._currentValue2 = n5, d2(bu);
  }
  function pt(e3, n5, t4) {
    for (; null !== e3; ) {
      var r4 = e3.alternate;
      if ((e3.childLanes & n5) !== n5 ? (e3.childLanes |= n5, null !== r4 && (r4.childLanes |= n5)) : null !== r4 && (r4.childLanes & n5) !== n5 && (r4.childLanes |= n5), e3 === t4) break;
      e3 = e3.return;
    }
  }
  function mt(e3, n5, t4, l3) {
    var a4 = e3.child;
    for (null !== a4 && (a4.return = e3); null !== a4; ) {
      var o3 = a4.dependencies;
      if (null !== o3) {
        var u3 = a4.child;
        o3 = o3.firstContext;
        e: for (; null !== o3; ) {
          var i4 = o3;
          o3 = a4;
          for (var s3 = 0; s3 < n5.length; s3++) if (i4.context === n5[s3]) {
            o3.lanes |= t4, null !== (i4 = o3.alternate) && (i4.lanes |= t4), pt(o3.return, t4, e3), l3 || (u3 = null);
            break e;
          }
          o3 = i4.next;
        }
      } else if (18 === a4.tag) {
        if (null === (u3 = a4.return)) throw Error(r3(341));
        u3.lanes |= t4, null !== (o3 = u3.alternate) && (o3.lanes |= t4), pt(u3, t4, e3), u3 = null;
      } else u3 = a4.child;
      if (null !== u3) u3.return = a4;
      else for (u3 = a4; null !== u3; ) {
        if (u3 === e3) {
          u3 = null;
          break;
        }
        if (null !== (a4 = u3.sibling)) {
          a4.return = u3.return, u3 = a4;
          break;
        }
        u3 = u3.return;
      }
      a4 = u3;
    }
  }
  function ht(e3, n5, t4, l3) {
    e3 = null;
    for (var a4 = n5, o3 = false; null !== a4; ) {
      if (!o3) {
        if (0 != (524288 & a4.flags)) o3 = true;
        else if (0 != (262144 & a4.flags)) break;
      }
      if (10 === a4.tag) {
        var u3 = a4.alternate;
        if (null === u3) throw Error(r3(387));
        if (null !== (u3 = u3.memoizedProps)) {
          var i4 = a4.type;
          ao(a4.pendingProps.value, u3.value) || (null !== e3 ? e3.push(i4) : e3 = [i4]);
        }
      } else if (a4 === yo.current) {
        if (null === (u3 = a4.alternate)) throw Error(r3(387));
        u3.memoizedState.memoizedState !== a4.memoizedState.memoizedState && (null !== e3 ? e3.push(oa) : e3 = [oa]);
      }
      a4 = a4.return;
    }
    null !== e3 && mt(n5, e3, t4, l3), n5.flags |= 262144;
  }
  function gt(e3) {
    for (e3 = e3.firstContext; null !== e3; ) {
      var n5 = e3.context;
      if (!ao(n5._currentValue2, e3.memoizedValue)) return true;
      e3 = e3.next;
    }
    return false;
  }
  function yt(e3) {
    vu = e3, ku = Su = null, null !== (e3 = e3.dependencies) && (e3.firstContext = null);
  }
  function bt(e3) {
    return St(vu, e3);
  }
  function vt(e3, n5) {
    return null === vu && yt(e3), St(e3, n5);
  }
  function St(e3, n5) {
    var t4 = n5._currentValue2;
    if (ku !== n5) if (n5 = { context: n5, memoizedValue: t4, next: null }, null === Su) {
      if (null === e3) throw Error(r3(308));
      Su = n5, e3.dependencies = { lanes: 0, firstContext: n5 }, e3.flags |= 524288;
    } else Su = Su.next = n5;
    return t4;
  }
  function kt() {
    return { controller: new wu(), data: /* @__PURE__ */ new Map(), refCount: 0 };
  }
  function wt(e3) {
    e3.refCount--, 0 === e3.refCount && xu(zu, function() {
      e3.controller.abort();
    });
  }
  function xt() {
    var e3 = Eu.current;
    return null !== e3 ? e3 : Au.pooledCache;
  }
  function zt(e3, n5) {
    p2(Eu, null === n5 ? Eu.current : n5.pool);
  }
  function Ct() {
    var e3 = xt();
    return null === e3 ? null : { parent: Cu._currentValue2, pool: e3 };
  }
  function Pt(e3) {
    e3.flags |= 4;
  }
  function Et(e3, n5) {
    null !== n5 && (e3.flags |= 4), 16384 & e3.flags && (n5 = 22 !== e3.tag ? b2() : 536870912, e3.lanes |= n5);
  }
  function _t(e3, n5) {
    switch (e3.tailMode) {
      case "hidden":
        n5 = e3.tail;
        for (var t4 = null; null !== n5; ) null !== n5.alternate && (t4 = n5), n5 = n5.sibling;
        null === t4 ? e3.tail = null : t4.sibling = null;
        break;
      case "collapsed":
        t4 = e3.tail;
        for (var r4 = null; null !== t4; ) null !== t4.alternate && (r4 = t4), t4 = t4.sibling;
        null === r4 ? n5 || null === e3.tail ? e3.tail = null : e3.tail.sibling = null : r4.sibling = null;
    }
  }
  function Rt(e3) {
    var n5 = null !== e3.alternate && e3.alternate.child === e3.child, t4 = 0, r4 = 0;
    if (n5) for (var l3 = e3.child; null !== l3; ) t4 |= l3.lanes | l3.childLanes, r4 |= 31457280 & l3.subtreeFlags, r4 |= 31457280 & l3.flags, l3.return = e3, l3 = l3.sibling;
    else for (l3 = e3.child; null !== l3; ) t4 |= l3.lanes | l3.childLanes, r4 |= l3.subtreeFlags, r4 |= l3.flags, l3.return = e3, l3 = l3.sibling;
    return e3.subtreeFlags |= r4, e3.childLanes = t4, n5;
  }
  function Tt(e3, n5, t4) {
    var l3 = n5.pendingProps;
    switch (P(n5), n5.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
      case 1:
        return Rt(n5), null;
      case 3:
        return t4 = n5.stateNode, l3 = null, null !== e3 && (l3 = e3.memoizedState.cache), n5.memoizedState.cache !== l3 && (n5.flags |= 2048), dt(Cu), _(), t4.pendingContext && (t4.context = t4.pendingContext, t4.pendingContext = null), null !== e3 && null !== e3.child || null === e3 || e3.memoizedState.isDehydrated && 0 == (256 & n5.flags) || (n5.flags |= 1024, null !== So && (vr(So), So = null)), Rt(n5), null;
      case 26:
        var a4;
      case 27:
      case 5:
        if (T(n5), t4 = n5.type, null !== e3 && null != n5.stateNode) !function(e4, n6, t5, r4) {
          e4.memoizedProps !== r4 && Pt(n6);
        }(e3, n5, 0, l3);
        else {
          if (!l3) {
            if (null === n5.stateNode) throw Error(r3(166));
            return Rt(n5), null;
          }
          e3 = mo.current, function(e4, n6, t5, r4) {
            for (t5 = n6.child; null !== t5; ) {
              if (5 === t5.tag || 6 === t5.tag) Hl(e4, t5.stateNode);
              else if (4 !== t5.tag && !Ha && null !== t5.child) {
                t5.child.return = t5, t5 = t5.child;
                continue;
              }
              if (t5 === n6) break;
              for (; null === t5.sibling; ) {
                if (null === t5.return || t5.return === n6) return;
                t5 = t5.return;
              }
              t5.sibling.return = t5.return, t5 = t5.sibling;
            }
          }(a4 = Ml(t4, l3, go.current, e3, n5), n5, false), n5.stateNode = a4, jl(a4, t4, l3, e3) && Pt(n5);
        }
        return Rt(n5), function(e4, n6, t5) {
          if (ea(n6, t5)) {
            if (e4.flags |= 16777216, !na(n6, t5)) {
              if (!Pr()) throw Ao = Oo, Wo;
              e4.flags |= 8192;
            }
          } else e4.flags &= -16777217;
        }(n5, n5.type, n5.pendingProps), null;
      case 6:
        if (e3 && null != n5.stateNode) (t4 = e3.memoizedProps) !== l3 && Pt(n5);
        else {
          if ("string" != typeof l3 && null === n5.stateNode) throw Error(r3(166));
          e3 = go.current, t4 = mo.current, n5.stateNode = Ol(l3, e3, t4, n5);
        }
        return Rt(n5), null;
      case 13:
        if (l3 = n5.memoizedState, null === e3 || null !== e3.memoizedState && null !== e3.memoizedState.dehydrated) {
          if (a4 = false, null !== l3 && null !== l3.dehydrated) {
            if (null === e3) {
              if (!a4) throw Error(r3(318));
              throw Error(r3(344));
            }
            0 == (128 & n5.flags) && (n5.memoizedState = null), n5.flags |= 4, Rt(n5), a4 = false;
          } else null !== So && (vr(So), So = null), a4 = true;
          if (!a4) return 256 & n5.flags ? (ve(n5), n5) : (ve(n5), null);
        }
        if (ve(n5), 0 != (128 & n5.flags)) return n5.lanes = t4, n5;
        if (t4 = null !== l3, e3 = null !== e3 && null !== e3.memoizedState, t4) {
          a4 = null, null !== (l3 = n5.child).alternate && null !== l3.alternate.memoizedState && null !== l3.alternate.memoizedState.cachePool && (a4 = l3.alternate.memoizedState.cachePool.pool);
          var o3 = null;
          null !== l3.memoizedState && null !== l3.memoizedState.cachePool && (o3 = l3.memoizedState.cachePool.pool), o3 !== a4 && (l3.flags |= 2048);
        }
        return t4 !== e3 && t4 && (n5.child.flags |= 8192), Et(n5, n5.updateQueue), Rt(n5), null;
      case 4:
        return _(), null === e3 && Yl(n5.stateNode.containerInfo), Rt(n5), null;
      case 10:
        return dt(n5.type), Rt(n5), null;
      case 19:
        if (d2(Ko), null === (a4 = n5.memoizedState)) return Rt(n5), null;
        if (l3 = 0 != (128 & n5.flags), null === (o3 = a4.rendering)) if (l3) _t(a4, false);
        else {
          if (0 !== Gu || null !== e3 && 0 != (128 & e3.flags)) for (e3 = n5.child; null !== e3; ) {
            if (null !== (o3 = Se(e3))) {
              for (n5.flags |= 128, _t(a4, false), e3 = o3.updateQueue, n5.updateQueue = e3, Et(n5, e3), n5.subtreeFlags = 0, e3 = t4, t4 = n5.child; null !== t4; ) Kr(t4, e3), t4 = t4.sibling;
              return p2(Ko, 1 & Ko.current | 2), n5.child;
            }
            e3 = e3.sibling;
          }
          null !== a4.tail && Ka() > oi && (n5.flags |= 128, l3 = true, _t(a4, false), n5.lanes = 4194304);
        }
        else {
          if (!l3) if (null !== (e3 = Se(o3))) {
            if (n5.flags |= 128, l3 = true, e3 = e3.updateQueue, n5.updateQueue = e3, Et(n5, e3), _t(a4, true), null === a4.tail && "hidden" === a4.tailMode && !o3.alternate && !vo) return Rt(n5), null;
          } else 2 * Ka() - a4.renderingStartTime > oi && 536870912 !== t4 && (n5.flags |= 128, l3 = true, _t(a4, false), n5.lanes = 4194304);
          a4.isBackwards ? (o3.sibling = n5.child, n5.child = o3) : (null !== (e3 = a4.last) ? e3.sibling = o3 : n5.child = o3, a4.last = o3);
        }
        return null !== a4.tail ? (n5 = a4.tail, a4.rendering = n5, a4.tail = n5.sibling, a4.renderingStartTime = Ka(), n5.sibling = null, e3 = Ko.current, p2(Ko, l3 ? 1 & e3 | 2 : 1 & e3), n5) : (Rt(n5), null);
      case 22:
      case 23:
        return ve(n5), he(), l3 = null !== n5.memoizedState, null !== e3 ? null !== e3.memoizedState !== l3 && (n5.flags |= 8192) : l3 && (n5.flags |= 8192), l3 ? 0 != (536870912 & t4) && 0 == (128 & n5.flags) && (Rt(n5), 6 & n5.subtreeFlags && (n5.flags |= 8192)) : Rt(n5), null !== (t4 = n5.updateQueue) && Et(n5, t4.retryQueue), t4 = null, null !== e3 && null !== e3.memoizedState && null !== e3.memoizedState.cachePool && (t4 = e3.memoizedState.cachePool.pool), l3 = null, null !== n5.memoizedState && null !== n5.memoizedState.cachePool && (l3 = n5.memoizedState.cachePool.pool), l3 !== t4 && (n5.flags |= 2048), null !== e3 && d2(Eu), null;
      case 24:
        return t4 = null, null !== e3 && (t4 = e3.memoizedState.cache), n5.memoizedState.cache !== t4 && (n5.flags |= 2048), dt(Cu), Rt(n5), null;
      case 25:
        return null;
    }
    throw Error(r3(156, n5.tag));
  }
  function Nt(e3, n5) {
    switch (P(n5), n5.tag) {
      case 1:
        return 65536 & (e3 = n5.flags) ? (n5.flags = -65537 & e3 | 128, n5) : null;
      case 3:
        return dt(Cu), _(), 0 != (65536 & (e3 = n5.flags)) && 0 == (128 & e3) ? (n5.flags = -65537 & e3 | 128, n5) : null;
      case 26:
      case 27:
      case 5:
        return T(n5), null;
      case 13:
        if (ve(n5), null !== (e3 = n5.memoizedState) && null !== e3.dehydrated && null === n5.alternate) throw Error(r3(340));
        return 65536 & (e3 = n5.flags) ? (n5.flags = -65537 & e3 | 128, n5) : null;
      case 19:
        return d2(Ko), null;
      case 4:
        return _(), null;
      case 10:
        return dt(n5.type), null;
      case 22:
      case 23:
        return ve(n5), he(), null !== e3 && d2(Eu), 65536 & (e3 = n5.flags) ? (n5.flags = -65537 & e3 | 128, n5) : null;
      case 24:
        return dt(Cu), null;
      default:
        return null;
    }
  }
  function Lt(e3, n5) {
    switch (P(n5), n5.tag) {
      case 3:
        dt(Cu), _();
        break;
      case 26:
      case 27:
      case 5:
        T(n5);
        break;
      case 4:
        _();
        break;
      case 13:
        ve(n5);
        break;
      case 19:
        d2(Ko);
        break;
      case 10:
        dt(n5.type);
        break;
      case 22:
      case 23:
        ve(n5), he(), null !== e3 && d2(Eu);
        break;
      case 24:
        dt(Cu);
    }
  }
  function Ut(e3, n5) {
    try {
      var t4 = n5.updateQueue, r4 = null !== t4 ? t4.lastEffect : null;
      if (null !== r4) {
        var l3 = r4.next;
        t4 = l3;
        do {
          if ((t4.tag & e3) === e3) {
            r4 = void 0;
            var a4 = t4.create, o3 = t4.inst;
            r4 = a4(), o3.destroy = r4;
          }
          t4 = t4.next;
        } while (t4 !== l3);
      }
    } catch (e4) {
      Ar(n5, n5.return, e4);
    }
  }
  function It(e3, n5, t4) {
    try {
      var r4 = n5.updateQueue, l3 = null !== r4 ? r4.lastEffect : null;
      if (null !== l3) {
        var a4 = l3.next;
        r4 = a4;
        do {
          if ((r4.tag & e3) === e3) {
            var o3 = r4.inst, u3 = o3.destroy;
            if (void 0 !== u3) {
              o3.destroy = void 0, l3 = n5;
              var i4 = t4;
              try {
                u3();
              } catch (e4) {
                Ar(l3, i4, e4);
              }
            }
          }
          r4 = r4.next;
        } while (r4 !== a4);
      }
    } catch (e4) {
      Ar(n5, n5.return, e4);
    }
  }
  function Dt(e3) {
    var n5 = e3.updateQueue;
    if (null !== n5) {
      var t4 = e3.stateNode;
      try {
        te(n5, t4);
      } catch (n6) {
        Ar(e3, e3.return, n6);
      }
    }
  }
  function Ft(e3, n5, t4) {
    t4.props = Fn(e3.type, e3.memoizedProps), t4.state = e3.memoizedState;
    try {
      t4.componentWillUnmount();
    } catch (t5) {
      Ar(e3, n5, t5);
    }
  }
  function Mt(e3, n5) {
    try {
      var t4 = e3.ref;
      if (null !== t4) {
        var r4 = e3.stateNode;
        switch (e3.tag) {
          case 26:
          case 27:
          case 5:
            var l3 = Ll(r4);
            break;
          default:
            l3 = r4;
        }
        "function" == typeof t4 ? e3.refCleanup = t4(l3) : t4.current = l3;
      }
    } catch (t5) {
      Ar(e3, n5, t5);
    }
  }
  function Ht(e3, n5) {
    var t4 = e3.ref, r4 = e3.refCleanup;
    if (null !== t4) if ("function" == typeof r4) try {
      r4();
    } catch (t5) {
      Ar(e3, n5, t5);
    } finally {
      e3.refCleanup = null, null != (e3 = e3.alternate) && (e3.refCleanup = null);
    }
    else if ("function" == typeof t4) try {
      t4(null);
    } catch (t5) {
      Ar(e3, n5, t5);
    }
    else t4.current = null;
  }
  function jt(e3) {
    var n5 = e3.type, t4 = e3.memoizedProps, r4 = e3.stateNode;
    try {
      fa(r4, n5, t4, e3);
    } catch (n6) {
      Ar(e3, e3.return, n6);
    }
  }
  function Wt(e3) {
    return 5 === e3.tag || 3 === e3.tag || 4 === e3.tag;
  }
  function Ot(e3) {
    e: for (; ; ) {
      for (; null === e3.sibling; ) {
        if (null === e3.return || Wt(e3.return)) return null;
        e3 = e3.return;
      }
      for (e3.sibling.return = e3.return, e3 = e3.sibling; 5 !== e3.tag && 6 !== e3.tag && 18 !== e3.tag; ) {
        if (2 & e3.flags) continue e;
        if (null === e3.child || 4 === e3.tag) continue e;
        e3.child.return = e3, e3 = e3.child;
      }
      if (!(2 & e3.flags)) return e3.stateNode;
    }
  }
  function At(e3, n5, t4) {
    var r4 = e3.tag;
    if (5 === r4 || 6 === r4) e3 = e3.stateNode, n5 ? ma(t4, e3, n5) : sa(t4, e3);
    else if (4 !== r4 && !Ha && null !== (e3 = e3.child)) for (At(e3, n5, t4), e3 = e3.sibling; null !== e3; ) At(e3, n5, t4), e3 = e3.sibling;
  }
  function Qt(e3, n5, t4) {
    var r4 = e3.tag;
    if (5 === r4 || 6 === r4) e3 = e3.stateNode, n5 ? pa(t4, e3, n5) : ia(t4, e3);
    else if (4 !== r4 && !Ha && null !== (e3 = e3.child)) for (Qt(e3, n5, t4), e3 = e3.sibling; null !== e3; ) Qt(e3, n5, t4), e3 = e3.sibling;
  }
  function Bt(e3, n5, t4) {
    var r4 = t4.flags;
    switch (t4.tag) {
      case 0:
      case 11:
      case 15:
        Zt(e3, t4), 4 & r4 && Ut(5, t4);
        break;
      case 1:
        if (Zt(e3, t4), 4 & r4) if (e3 = t4.stateNode, null === n5) try {
          e3.componentDidMount();
        } catch (e4) {
          Ar(t4, t4.return, e4);
        }
        else {
          var l3 = Fn(t4.type, n5.memoizedProps);
          n5 = n5.memoizedState;
          try {
            e3.componentDidUpdate(l3, n5, e3.__reactInternalSnapshotBeforeUpdate);
          } catch (e4) {
            Ar(t4, t4.return, e4);
          }
        }
        64 & r4 && Dt(t4), 512 & r4 && Mt(t4, t4.return);
        break;
      case 3:
        if (Zt(e3, t4), 64 & r4 && null !== (r4 = t4.updateQueue)) {
          if (e3 = null, null !== t4.child) switch (t4.child.tag) {
            case 27:
            case 5:
              e3 = Ll(t4.child.stateNode);
              break;
            case 1:
              e3 = t4.child.stateNode;
          }
          try {
            te(r4, e3);
          } catch (e4) {
            Ar(t4, t4.return, e4);
          }
        }
        break;
      case 26:
      case 27:
      case 5:
        Zt(e3, t4), null === n5 && 4 & r4 && jt(t4), 512 & r4 && Mt(t4, t4.return);
        break;
      case 12:
      case 13:
      default:
        Zt(e3, t4);
        break;
      case 22:
        if (!(l3 = null !== t4.memoizedState || _u)) {
          n5 = null !== n5 && null !== n5.memoizedState || Ru;
          var a4 = _u, o3 = Ru;
          _u = l3, (Ru = n5) && !o3 ? nr(e3, t4, 0 != (8772 & t4.subtreeFlags)) : Zt(e3, t4), _u = a4, Ru = o3;
        }
        512 & r4 && ("manual" === t4.memoizedProps.mode ? Mt(t4, t4.return) : Ht(t4, t4.return));
    }
  }
  function Vt(e3) {
    var n5 = e3.alternate;
    null !== n5 && (e3.alternate = null, Vt(n5)), e3.child = null, e3.deletions = null, e3.sibling = null, 5 === e3.tag && null !== (n5 = e3.stateNode) && Zl(n5), e3.stateNode = null, e3.return = null, e3.dependencies = null, e3.memoizedProps = null, e3.memoizedState = null, e3.pendingProps = null, e3.stateNode = null, e3.updateQueue = null;
  }
  function $t(e3, n5, t4) {
    for (t4 = t4.child; null !== t4; ) qt(e3, n5, t4), t4 = t4.sibling;
  }
  function qt(e3, n5, t4) {
    switch (t4.tag) {
      case 26:
      case 27:
        var r4, l3;
      case 5:
        Ru || Ht(t4, n5);
      case 6:
        if (r4 = Iu, l3 = Du, Iu = null, $t(e3, n5, t4), Du = l3, null !== (Iu = r4)) if (Du) try {
          ga(Iu, t4.stateNode);
        } catch (e4) {
          Ar(t4, n5, e4);
        }
        else try {
          ha(Iu, t4.stateNode);
        } catch (e4) {
          Ar(t4, n5, e4);
        }
        break;
      case 18:
        null !== Iu && (Du ? La(Iu, t4.stateNode) : Na(Iu, t4.stateNode));
        break;
      case 4:
        r4 = Iu, l3 = Du, Iu = t4.stateNode.containerInfo, Du = true, $t(e3, n5, t4), Iu = r4, Du = l3;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        Ru || It(2, t4, n5), Ru || It(4, t4, n5), $t(e3, n5, t4);
        break;
      case 1:
        Ru || (Ht(t4, n5), "function" == typeof (r4 = t4.stateNode).componentWillUnmount && Ft(t4, n5, r4)), $t(e3, n5, t4);
        break;
      case 21:
        $t(e3, n5, t4);
        break;
      case 22:
        Ht(t4, n5), Ru = (r4 = Ru) || null !== t4.memoizedState, $t(e3, n5, t4), Ru = r4;
        break;
      default:
        $t(e3, n5, t4);
    }
  }
  function Yt(e3, n5) {
    var t4 = function(e4) {
      switch (e4.tag) {
        case 13:
        case 19:
          var n6 = e4.stateNode;
          return null === n6 && (n6 = e4.stateNode = new Nu()), n6;
        case 22:
          return null === (n6 = (e4 = e4.stateNode)._retryCache) && (n6 = e4._retryCache = new Nu()), n6;
        default:
          throw Error(r3(435, e4.tag));
      }
    }(e3);
    n5.forEach(function(n6) {
      var r4 = qr.bind(null, e3, n6);
      t4.has(n6) || (t4.add(n6), n6.then(r4, r4));
    });
  }
  function Jt(e3, n5) {
    var t4 = n5.deletions;
    if (null !== t4) for (var l3 = 0; l3 < t4.length; l3++) {
      var a4 = t4[l3], o3 = e3, u3 = n5, i4 = u3;
      e: for (; null !== i4; ) {
        switch (i4.tag) {
          case 27:
          case 5:
            Iu = i4.stateNode, Du = false;
            break e;
          case 3:
          case 4:
            Iu = i4.stateNode.containerInfo, Du = true;
            break e;
        }
        i4 = i4.return;
      }
      if (null === Iu) throw Error(r3(160));
      qt(o3, u3, a4), Iu = null, Du = false, null !== (o3 = a4.alternate) && (o3.return = null), a4.return = null;
    }
    if (13878 & n5.subtreeFlags) for (n5 = n5.child; null !== n5; ) Gt(n5, e3), n5 = n5.sibling;
  }
  function Gt(e3, n5) {
    var t4 = e3.alternate, l3 = e3.flags;
    switch (e3.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Jt(n5, e3), Kt(e3), 4 & l3 && (It(3, e3, e3.return), Ut(3, e3), It(5, e3, e3.return));
        break;
      case 1:
        Jt(n5, e3), Kt(e3), 512 & l3 && null !== t4 && Ht(t4, t4.return), 64 & l3 && _u && null !== (e3 = e3.updateQueue) && null !== (l3 = e3.callbacks) && (t4 = e3.shared.hiddenCallbacks, e3.shared.hiddenCallbacks = null === t4 ? l3 : t4.concat(l3));
        break;
      case 26:
        var a4;
      case 27:
        var o3;
      case 5:
        if (Jt(n5, e3), Kt(e3), 512 & l3 && null !== t4 && Ht(t4, t4.return), 32 & e3.flags) {
          n5 = e3.stateNode;
          try {
            ya(n5);
          } catch (n6) {
            Ar(e3, e3.return, n6);
          }
        }
        4 & l3 && null != e3.stateNode && function(e4, n6, t5) {
          try {
            da(e4.stateNode, e4.type, t5, n6, e4);
          } catch (n7) {
            Ar(e4, e4.return, n7);
          }
        }(e3, n5 = e3.memoizedProps, null !== t4 ? t4.memoizedProps : n5), 1024 & l3 && (Tu = true);
        break;
      case 6:
        if (Jt(n5, e3), Kt(e3), 4 & l3 && Vl) {
          if (null === e3.stateNode) throw Error(r3(162));
          l3 = e3.memoizedProps, t4 = null !== t4 ? t4.memoizedProps : l3, n5 = e3.stateNode;
          try {
            ca(n5, t4, l3);
          } catch (n6) {
            Ar(e3, e3.return, n6);
          }
        }
        break;
      case 3:
        Jt(n5, e3), Kt(e3), Tu && (Tu = false, Xt(e3));
        break;
      case 4:
        Jt(n5, e3), Kt(e3), 4 & l3 && $l && function(e4, n6, t5) {
          e4 = e4.containerInfo;
          try {
            xa(e4, t5);
          } catch (e5) {
            Ar(n6, n6.return, e5);
          }
        }(e3.stateNode, e3, e3.stateNode.pendingChildren);
        break;
      case 12:
        Jt(n5, e3), Kt(e3);
        break;
      case 13:
        Jt(n5, e3), Kt(e3), 8192 & e3.child.flags && null !== e3.memoizedState != (null !== t4 && null !== t4.memoizedState) && (ai = Ka()), 4 & l3 && null !== (l3 = e3.updateQueue) && (e3.updateQueue = null, Yt(e3, l3));
        break;
      case 22:
        512 & l3 && null !== t4 && Ht(t4, t4.return), a4 = null !== e3.memoizedState;
        var u3 = null !== t4 && null !== t4.memoizedState, i4 = _u, s3 = Ru;
        if (_u = i4 || a4, Ru = s3 || u3, Jt(n5, e3), Ru = s3, _u = i4, Kt(e3), (n5 = e3.stateNode)._current = e3, n5._visibility &= -3, n5._visibility |= 2 & n5._pendingVisibility, 8192 & l3 && (n5._visibility = a4 ? -2 & n5._visibility : 1 | n5._visibility, a4 && (n5 = _u || Ru, null === t4 || u3 || n5 || er(e3)), null === e3.memoizedProps || "manual" !== e3.memoizedProps.mode)) {
          e: if (t4 = null, Vl) for (n5 = e3; ; ) {
            if (5 === n5.tag || Da || Ha) {
              if (null === t4) {
                u3 = t4 = n5;
                try {
                  o3 = u3.stateNode, a4 ? ba(o3) : Sa(u3.stateNode, u3.memoizedProps);
                } catch (e4) {
                  Ar(u3, u3.return, e4);
                }
              }
            } else if (6 === n5.tag) {
              if (null === t4) {
                u3 = n5;
                try {
                  var c4 = u3.stateNode;
                  a4 ? va(c4) : ka(c4, u3.memoizedProps);
                } catch (e4) {
                  Ar(u3, u3.return, e4);
                }
              }
            } else if ((22 !== n5.tag && 23 !== n5.tag || null === n5.memoizedState || n5 === e3) && null !== n5.child) {
              n5.child.return = n5, n5 = n5.child;
              continue;
            }
            if (n5 === e3) break e;
            for (; null === n5.sibling; ) {
              if (null === n5.return || n5.return === e3) break e;
              t4 === n5 && (t4 = null), n5 = n5.return;
            }
            t4 === n5 && (t4 = null), n5.sibling.return = n5.return, n5 = n5.sibling;
          }
        }
        4 & l3 && null !== (l3 = e3.updateQueue) && null !== (t4 = l3.retryQueue) && (l3.retryQueue = null, Yt(e3, t4));
        break;
      case 19:
        Jt(n5, e3), Kt(e3), 4 & l3 && null !== (l3 = e3.updateQueue) && (e3.updateQueue = null, Yt(e3, l3));
        break;
      case 21:
        break;
      default:
        Jt(n5, e3), Kt(e3);
    }
  }
  function Kt(e3) {
    var n5 = e3.flags;
    if (2 & n5) {
      try {
        if (Vl && (!Ha || 27 !== e3.tag)) {
          e: {
            for (var t4 = e3.return; null !== t4; ) {
              if (Wt(t4)) {
                var l3 = t4;
                break e;
              }
              t4 = t4.return;
            }
            throw Error(r3(160));
          }
          switch (l3.tag) {
            case 27:
            case 5:
              var a4 = l3.stateNode;
              32 & l3.flags && (ya(a4), l3.flags &= -33), Qt(e3, Ot(e3), a4);
              break;
            case 3:
            case 4:
              var o3 = l3.stateNode.containerInfo;
              At(e3, Ot(e3), o3);
              break;
            default:
              throw Error(r3(161));
          }
        }
      } catch (n6) {
        Ar(e3, e3.return, n6);
      }
      e3.flags &= -3;
    }
    4096 & n5 && (e3.flags &= -4097);
  }
  function Xt(e3) {
    if (1024 & e3.subtreeFlags) for (e3 = e3.child; null !== e3; ) {
      var n5 = e3;
      Xt(n5), 5 === n5.tag && 1024 & n5.flags && ua(n5.stateNode), e3 = e3.sibling;
    }
  }
  function Zt(e3, n5) {
    if (8772 & n5.subtreeFlags) for (n5 = n5.child; null !== n5; ) Bt(e3, n5.alternate, n5), n5 = n5.sibling;
  }
  function er(e3) {
    for (e3 = e3.child; null !== e3; ) {
      var n5 = e3;
      switch (n5.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          It(4, n5, n5.return), er(n5);
          break;
        case 1:
          Ht(n5, n5.return);
          var t4 = n5.stateNode;
          "function" == typeof t4.componentWillUnmount && Ft(n5, n5.return, t4), er(n5);
          break;
        case 26:
        case 27:
        case 5:
          Ht(n5, n5.return), er(n5);
          break;
        case 22:
          Ht(n5, n5.return), null === n5.memoizedState && er(n5);
          break;
        default:
          er(n5);
      }
      e3 = e3.sibling;
    }
  }
  function nr(e3, n5, t4) {
    for (t4 = t4 && 0 != (8772 & n5.subtreeFlags), n5 = n5.child; null !== n5; ) {
      var r4 = n5.alternate, l3 = e3, a4 = n5, o3 = a4.flags;
      switch (a4.tag) {
        case 0:
        case 11:
        case 15:
          nr(l3, a4, t4), Ut(4, a4);
          break;
        case 1:
          if (nr(l3, a4, t4), "function" == typeof (l3 = (r4 = a4).stateNode).componentDidMount) try {
            l3.componentDidMount();
          } catch (e4) {
            Ar(r4, r4.return, e4);
          }
          if (null !== (l3 = (r4 = a4).updateQueue)) {
            var u3 = r4.stateNode;
            try {
              var i4 = l3.shared.hiddenCallbacks;
              if (null !== i4) for (l3.shared.hiddenCallbacks = null, l3 = 0; l3 < i4.length; l3++) ne(i4[l3], u3);
            } catch (e4) {
              Ar(r4, r4.return, e4);
            }
          }
          t4 && 64 & o3 && Dt(a4), Mt(a4, a4.return);
          break;
        case 26:
        case 27:
        case 5:
          nr(l3, a4, t4), t4 && null === r4 && 4 & o3 && jt(a4), Mt(a4, a4.return);
          break;
        case 12:
        case 13:
        default:
          nr(l3, a4, t4);
          break;
        case 22:
          null === a4.memoizedState && nr(l3, a4, t4), Mt(a4, a4.return);
      }
      n5 = n5.sibling;
    }
  }
  function tr(e3, n5) {
    var t4 = null;
    null !== e3 && null !== e3.memoizedState && null !== e3.memoizedState.cachePool && (t4 = e3.memoizedState.cachePool.pool), e3 = null, null !== n5.memoizedState && null !== n5.memoizedState.cachePool && (e3 = n5.memoizedState.cachePool.pool), e3 !== t4 && (null != e3 && e3.refCount++, null != t4 && wt(t4));
  }
  function rr(e3, n5) {
    e3 = null, null !== n5.alternate && (e3 = n5.alternate.memoizedState.cache), (n5 = n5.memoizedState.cache) !== e3 && (n5.refCount++, null != e3 && wt(e3));
  }
  function lr(e3, n5, t4, r4) {
    if (10256 & n5.subtreeFlags) for (n5 = n5.child; null !== n5; ) ar(e3, n5, t4, r4), n5 = n5.sibling;
  }
  function ar(e3, n5, t4, r4) {
    var l3 = n5.flags;
    switch (n5.tag) {
      case 0:
      case 11:
      case 15:
        lr(e3, n5, t4, r4), 2048 & l3 && Ut(9, n5);
        break;
      case 3:
        lr(e3, n5, t4, r4), 2048 & l3 && (e3 = null, null !== n5.alternate && (e3 = n5.alternate.memoizedState.cache), (n5 = n5.memoizedState.cache) !== e3 && (n5.refCount++, null != e3 && wt(e3)));
        break;
      case 12:
        if (2048 & l3) {
          lr(e3, n5, t4, r4), e3 = n5.stateNode;
          try {
            var a4 = n5.memoizedProps, o3 = a4.id, u3 = a4.onPostCommit;
            "function" == typeof u3 && u3(o3, null === n5.alternate ? "mount" : "update", e3.passiveEffectDuration, -0);
          } catch (e4) {
            Ar(n5, n5.return, e4);
          }
        } else lr(e3, n5, t4, r4);
        break;
      case 23:
        break;
      case 22:
        a4 = n5.stateNode, null !== n5.memoizedState ? 4 & a4._visibility ? lr(e3, n5, t4, r4) : ur(e3, n5) : 4 & a4._visibility ? lr(e3, n5, t4, r4) : (a4._visibility |= 4, or(e3, n5, t4, r4, 0 != (10256 & n5.subtreeFlags))), 2048 & l3 && tr(n5.alternate, n5);
        break;
      case 24:
        lr(e3, n5, t4, r4), 2048 & l3 && rr(n5.alternate, n5);
        break;
      default:
        lr(e3, n5, t4, r4);
    }
  }
  function or(e3, n5, t4, r4, l3) {
    for (l3 = l3 && 0 != (10256 & n5.subtreeFlags), n5 = n5.child; null !== n5; ) {
      var a4 = e3, o3 = n5, u3 = t4, i4 = r4, s3 = o3.flags;
      switch (o3.tag) {
        case 0:
        case 11:
        case 15:
          or(a4, o3, u3, i4, l3), Ut(8, o3);
          break;
        case 23:
          break;
        case 22:
          var c4 = o3.stateNode;
          null !== o3.memoizedState ? 4 & c4._visibility ? or(a4, o3, u3, i4, l3) : ur(a4, o3) : (c4._visibility |= 4, or(a4, o3, u3, i4, l3)), l3 && 2048 & s3 && tr(o3.alternate, o3);
          break;
        case 24:
          or(a4, o3, u3, i4, l3), l3 && 2048 & s3 && rr(o3.alternate, o3);
          break;
        default:
          or(a4, o3, u3, i4, l3);
      }
      n5 = n5.sibling;
    }
  }
  function ur(e3, n5) {
    if (10256 & n5.subtreeFlags) for (n5 = n5.child; null !== n5; ) {
      var t4 = e3, r4 = n5, l3 = r4.flags;
      switch (r4.tag) {
        case 22:
          ur(t4, r4), 2048 & l3 && tr(r4.alternate, r4);
          break;
        case 24:
          ur(t4, r4), 2048 & l3 && rr(r4.alternate, r4);
          break;
        default:
          ur(t4, r4);
      }
      n5 = n5.sibling;
    }
  }
  function ir(e3) {
    if (e3.subtreeFlags & Mu) for (e3 = e3.child; null !== e3; ) sr(e3), e3 = e3.sibling;
  }
  function sr(e3) {
    switch (e3.tag) {
      case 26:
        ir(e3), e3.flags & Mu && (null !== e3.memoizedState ? Ma(Fu, e3.memoizedState, e3.memoizedProps) : ra(e3.type, e3.memoizedProps));
        break;
      case 5:
        ir(e3), e3.flags & Mu && ra(e3.type, e3.memoizedProps);
        break;
      case 3:
      case 4:
        var n5;
        ir(e3);
        break;
      case 22:
        null === e3.memoizedState && (null !== (n5 = e3.alternate) && null !== n5.memoizedState ? (n5 = Mu, Mu = 16777216, ir(e3), Mu = n5) : ir(e3));
        break;
      default:
        ir(e3);
    }
  }
  function cr(e3) {
    var n5 = e3.alternate;
    if (null !== n5 && null !== (e3 = n5.child)) {
      n5.child = null;
      do {
        n5 = e3.sibling, e3.sibling = null, e3 = n5;
      } while (null !== e3);
    }
  }
  function fr(e3) {
    var n5 = e3.deletions;
    if (0 != (16 & e3.flags)) {
      if (null !== n5) for (var t4 = 0; t4 < n5.length; t4++) {
        var r4 = n5[t4];
        Lu = r4, mr(r4, e3);
      }
      cr(e3);
    }
    if (10256 & e3.subtreeFlags) for (e3 = e3.child; null !== e3; ) dr(e3), e3 = e3.sibling;
  }
  function dr(e3) {
    switch (e3.tag) {
      case 0:
      case 11:
      case 15:
        fr(e3), 2048 & e3.flags && It(9, e3, e3.return);
        break;
      case 3:
      case 12:
      default:
        fr(e3);
        break;
      case 22:
        var n5 = e3.stateNode;
        null !== e3.memoizedState && 4 & n5._visibility && (null === e3.return || 13 !== e3.return.tag) ? (n5._visibility &= -5, pr(e3)) : fr(e3);
    }
  }
  function pr(e3) {
    var n5 = e3.deletions;
    if (0 != (16 & e3.flags)) {
      if (null !== n5) for (var t4 = 0; t4 < n5.length; t4++) {
        var r4 = n5[t4];
        Lu = r4, mr(r4, e3);
      }
      cr(e3);
    }
    for (e3 = e3.child; null !== e3; ) {
      switch ((n5 = e3).tag) {
        case 0:
        case 11:
        case 15:
          It(8, n5, n5.return), pr(n5);
          break;
        case 22:
          4 & (t4 = n5.stateNode)._visibility && (t4._visibility &= -5, pr(n5));
          break;
        default:
          pr(n5);
      }
      e3 = e3.sibling;
    }
  }
  function mr(e3, n5) {
    for (; null !== Lu; ) {
      var t4 = Lu;
      switch (t4.tag) {
        case 0:
        case 11:
        case 15:
          It(8, t4, n5);
          break;
        case 23:
        case 22:
          if (null !== t4.memoizedState && null !== t4.memoizedState.cachePool) {
            var r4 = t4.memoizedState.cachePool.pool;
            null != r4 && r4.refCount++;
          }
          break;
        case 24:
          wt(t4.memoizedState.cache);
      }
      if (null !== (r4 = t4.child)) r4.return = t4, Lu = r4;
      else e: for (t4 = e3; null !== Lu; ) {
        var l3 = (r4 = Lu).sibling, a4 = r4.return;
        if (Vt(r4), r4 === t4) {
          Lu = null;
          break e;
        }
        if (null !== l3) {
          l3.return = a4, Lu = l3;
          break e;
        }
        Lu = a4;
      }
    }
  }
  function hr() {
    return 0 != (2 & Ou) && 0 !== Bu ? Bu & -Bu : null !== Rl.T ? 0 !== Io ? Io : V() : Kl();
  }
  function gr() {
    0 === ei && (ei = 0 == (536870912 & Bu) || vo ? y2() : 536870912);
    var e3 = Jo.current;
    return null !== e3 && (e3.flags |= 32), ei;
  }
  function yr(e3, n5, t4) {
    (e3 === Au && 2 === Vu || null !== e3.cancelPendingCommit) && (zr(e3, 0), wr(e3, Bu, ei)), S2(e3, t4), 0 != (2 & Ou) && e3 === Au || (e3 === Au && (0 == (2 & Ou) && (Xu |= t4), 4 === Gu && wr(e3, Bu, ei)), j(e3));
  }
  function br(e3, n5, t4) {
    if (0 != (6 & Ou)) throw Error(r3(327));
    var l3 = (t4 = !t4 && 0 == (60 & n5) && 0 == (n5 & e3.expiredLanes)) ? function(e4, n6) {
      var t5 = Ou;
      Ou |= 2;
      var l4 = Er(), a5 = _r();
      Au === e4 && Bu === n6 || (ui = null, oi = Ka() + 500, zr(e4, n6));
      e: for (; ; ) try {
        if (0 !== Vu && null !== Qu) {
          n6 = Qu;
          var o4 = $u;
          n: switch (Vu) {
            case 1:
            case 6:
              Vu = 0, $u = null, Dr(e4, n6, o4);
              break;
            case 2:
              if (le(o4)) {
                Vu = 0, $u = null, Ir(n6);
                break;
              }
              n6 = function() {
                2 === Vu && Au === e4 && (Vu = 7), j(e4);
              }, o4.then(n6, n6);
              break e;
            case 3:
              Vu = 7;
              break e;
            case 4:
              Vu = 5;
              break e;
            case 7:
              le(o4) ? (Vu = 0, $u = null, Ir(n6)) : (Vu = 0, $u = null, Dr(e4, n6, o4));
              break;
            case 5:
              var u4 = null;
              switch (Qu.tag) {
                case 26:
                  u4 = Qu.memoizedState;
                case 5:
                case 27:
                  var i5 = Qu, s3 = i5.type, c4 = i5.pendingProps;
                  if (u4 ? Fa(u4) : na(s3, c4)) {
                    Vu = 0, $u = null;
                    var f3 = i5.sibling;
                    if (null !== f3) Qu = f3;
                    else {
                      var d3 = i5.return;
                      null !== d3 ? (Qu = d3, Fr(d3)) : Qu = null;
                    }
                    break n;
                  }
              }
              Vu = 0, $u = null, Dr(e4, n6, o4);
              break;
            case 8:
              xr(), Gu = 6;
              break e;
            default:
              throw Error(r3(462));
          }
        }
        Lr();
        break;
      } catch (n7) {
        Cr(e4, n7);
      }
      return ct(), Rl.H = l4, Rl.A = a5, Ou = t5, null !== Qu ? 0 : (Au = null, Bu = 0, U(), Gu);
    }(e3, n5) : Tr(e3, n5);
    if (0 !== l3) for (var a4 = t4; ; ) {
      if (6 === l3) wr(e3, n5, 0);
      else {
        if (t4 = e3.current.alternate, a4 && !kr(t4)) {
          l3 = Tr(e3, n5), a4 = false;
          continue;
        }
        if (2 === l3) {
          if (a4 = n5, e3.errorRecoveryDisabledLanes & a4) var o3 = 0;
          else o3 = 0 != (o3 = -536870913 & e3.pendingLanes) ? o3 : 536870912 & o3 ? 536870912 : 0;
          if (0 !== o3) {
            n5 = o3;
            e: {
              var u3 = e3;
              l3 = ti;
              var i4 = ql;
              if (i4 && (zr(u3, o3).flags |= 256), 2 !== (o3 = Tr(u3, o3))) {
                if (Yu && !i4) {
                  u3.errorRecoveryDisabledLanes |= a4, Xu |= a4, l3 = 4;
                  break e;
                }
                a4 = ri, ri = l3, null !== a4 && vr(a4);
              }
              l3 = o3;
            }
            if (a4 = false, 2 !== l3) continue;
          }
        }
        if (1 === l3) {
          zr(e3, 0), wr(e3, n5, 0);
          break;
        }
        e: {
          switch (a4 = e3, l3) {
            case 0:
            case 1:
              throw Error(r3(345));
            case 4:
              if ((4194176 & n5) === n5) {
                wr(a4, n5, ei);
                break e;
              }
              break;
            case 2:
              ri = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r3(329));
          }
          if (a4.finishedWork = t4, a4.finishedLanes = n5, (62914560 & n5) === n5 && 10 < (l3 = ai + 300 - Ka())) {
            if (wr(a4, n5, ei), 0 !== h2(a4, 0)) break e;
            a4.timeoutHandle = Al(Sr.bind(null, a4, t4, ri, ui, li, n5, ei, Xu, ni, qu, 2, -0, 0), l3);
          } else Sr(a4, t4, ri, ui, li, n5, ei, Xu, ni, qu, 0, -0, 0);
        }
      }
      break;
    }
    j(e3);
  }
  function vr(e3) {
    null === ri ? ri = e3 : ri.push.apply(ri, e3);
  }
  function Sr(e3, n5, t4, r4, l3, a4, o3, u3, i4, s3, c4, f3, d3) {
    if ((8192 & (s3 = n5.subtreeFlags) || 16785408 == (16785408 & s3)) && (ta(), sr(n5), null !== (n5 = la()))) return e3.cancelPendingCommit = n5(Hr.bind(null, e3, t4, r4, l3, o3, u3, i4, 1, f3, d3)), void wr(e3, a4, o3);
    Hr(e3, t4, r4, l3, o3);
  }
  function kr(e3) {
    for (var n5 = e3; ; ) {
      var t4 = n5.tag;
      if ((0 === t4 || 11 === t4 || 15 === t4) && 16384 & n5.flags && null !== (t4 = n5.updateQueue) && null !== (t4 = t4.stores)) for (var r4 = 0; r4 < t4.length; r4++) {
        var l3 = t4[r4], a4 = l3.getSnapshot;
        l3 = l3.value;
        try {
          if (!ao(a4(), l3)) return false;
        } catch (e4) {
          return false;
        }
      }
      if (t4 = n5.child, 16384 & n5.subtreeFlags && null !== t4) t4.return = n5, n5 = t4;
      else {
        if (n5 === e3) break;
        for (; null === n5.sibling; ) {
          if (null === n5.return || n5.return === e3) return true;
          n5 = n5.return;
        }
        n5.sibling.return = n5.return, n5 = n5.sibling;
      }
    }
    return true;
  }
  function wr(e3, n5, t4) {
    n5 &= ~Zu, n5 &= ~Xu, e3.suspendedLanes |= n5, e3.pingedLanes &= ~n5;
    for (var r4 = e3.expirationTimes, l3 = n5; 0 < l3; ) {
      var a4 = 31 - Aa(l3), o3 = 1 << a4;
      r4[a4] = -1, l3 &= ~o3;
    }
    0 !== t4 && k2(e3, t4, n5);
  }
  function xr() {
    if (null !== Qu) {
      if (0 === Vu) var e3 = Qu.return;
      else e3 = Qu, ct(), Re(e3), Qo = null, Bo = 0, e3 = Qu;
      for (; null !== e3; ) Lt(e3.alternate, e3), e3 = e3.return;
      Qu = null;
    }
  }
  function zr(e3, n5) {
    e3.finishedWork = null, e3.finishedLanes = 0;
    var t4 = e3.timeoutHandle;
    t4 !== Bl && (e3.timeoutHandle = Bl, Ql(t4)), null !== (t4 = e3.cancelPendingCommit) && (e3.cancelPendingCommit = null, t4()), xr(), Au = e3, Qu = t4 = Gr(e3.current, null), Bu = n5, Vu = 0, $u = null, Yu = qu = false, ni = ei = Zu = Xu = Ku = Gu = 0, ri = ti = null, li = false, 0 != (8 & n5) && (n5 |= 32 & n5);
    var r4 = e3.entangledLanes;
    if (0 !== r4) for (e3 = e3.entanglements, r4 &= n5; 0 < r4; ) {
      var l3 = 31 - Aa(r4), a4 = 1 << l3;
      n5 |= e3[l3], r4 &= ~a4;
    }
    return Ju = n5, U(), t4;
  }
  function Cr(e3, n5) {
    Zo = null, Rl.H = cu, n5 === jo ? (n5 = ue(), Vu = Pr() && 0 == (134217727 & Ku) && 0 == (134217727 & Xu) ? 2 : 3) : n5 === Wo ? (n5 = ue(), Vu = 4) : Vu = n5 === hu ? 8 : null !== n5 && "object" == typeof n5 && "function" == typeof n5.then ? 6 : 1, $u = n5, null === Qu && (Gu = 1, Mn(e3, C(n5, e3.current)));
  }
  function Pr() {
    var e3 = Jo.current;
    return null === e3 || ((4194176 & Bu) === Bu ? null === Go : ((62914560 & Bu) === Bu || 0 != (536870912 & Bu)) && e3 === Go);
  }
  function Er() {
    var e3 = Rl.H;
    return Rl.H = cu, null === e3 ? cu : e3;
  }
  function _r() {
    var e3 = Rl.A;
    return Rl.A = Hu, e3;
  }
  function Rr() {
    Gu = 4, 0 == (134217727 & Ku) && 0 == (134217727 & Xu) || null === Au || wr(Au, Bu, ei);
  }
  function Tr(e3, n5) {
    var t4 = Ou;
    Ou |= 2;
    var l3 = Er(), a4 = _r();
    Au === e3 && Bu === n5 || (ui = null, zr(e3, n5)), n5 = false;
    e: for (; ; ) try {
      if (0 !== Vu && null !== Qu) {
        var o3 = Qu, u3 = $u;
        switch (Vu) {
          case 8:
            xr(), Gu = 6;
            break e;
          case 3:
          case 2:
            n5 || null !== Jo.current || (n5 = true);
          default:
            Vu = 0, $u = null, Dr(e3, o3, u3);
        }
      }
      Nr();
      break;
    } catch (n6) {
      Cr(e3, n6);
    }
    if (n5 && e3.shellSuspendCounter++, ct(), Ou = t4, Rl.H = l3, Rl.A = a4, null !== Qu) throw Error(r3(261));
    return Au = null, Bu = 0, U(), Gu;
  }
  function Nr() {
    for (; null !== Qu; ) Ur(Qu);
  }
  function Lr() {
    for (; null !== Qu && !Ja(); ) Ur(Qu);
  }
  function Ur(e3) {
    var n5 = st(e3.alternate, e3, Ju);
    e3.memoizedProps = e3.pendingProps, null === n5 ? Fr(e3) : Qu = n5;
  }
  function Ir(e3) {
    var n5 = e3, t4 = n5.alternate;
    switch (n5.tag) {
      case 15:
      case 0:
        n5 = Gn(t4, n5, n5.pendingProps, n5.type, void 0, Bu);
        break;
      case 11:
        n5 = Gn(t4, n5, n5.pendingProps, n5.type.render, n5.ref, Bu);
        break;
      case 5:
        Re(n5);
      default:
        Lt(t4, n5), n5 = st(t4, n5 = Qu = Kr(n5, Ju), Ju);
    }
    e3.memoizedProps = e3.pendingProps, null === n5 ? Fr(e3) : Qu = n5;
  }
  function Dr(e3, n5, t4) {
    ct(), Re(n5), Qo = null, Bo = 0;
    var l3 = n5.return;
    try {
      if (function(e4, n6, t5, l4, a4) {
        if (t5.flags |= 32768, null !== l4 && "object" == typeof l4 && "function" == typeof l4.then) {
          if (null !== (n6 = t5.alternate) && ht(n6, t5, a4, true), null !== (t5 = Jo.current)) {
            switch (t5.tag) {
              case 13:
                return null === Go ? Rr() : null === t5.alternate && 0 === Gu && (Gu = 3), t5.flags &= -257, t5.flags |= 65536, t5.lanes = a4, l4 === Oo ? t5.flags |= 16384 : (null === (n6 = t5.updateQueue) ? t5.updateQueue = /* @__PURE__ */ new Set([l4]) : n6.add(l4), Qr(e4, l4, a4)), false;
              case 22:
                return t5.flags |= 65536, l4 === Oo ? t5.flags |= 16384 : (null === (n6 = t5.updateQueue) ? (n6 = { transitions: null, markerInstances: null, retryQueue: /* @__PURE__ */ new Set([l4]) }, t5.updateQueue = n6) : null === (t5 = n6.retryQueue) ? n6.retryQueue = /* @__PURE__ */ new Set([l4]) : t5.add(l4), Qr(e4, l4, a4)), false;
            }
            throw Error(r3(435, t5.tag));
          }
          return Qr(e4, l4, a4), Rr(), false;
        }
        var o3 = Error(r3(520), { cause: l4 });
        if (o3 = C(o3, t5), null === ti ? ti = [o3] : ti.push(o3), 4 !== Gu && (Gu = 2), null === n6) return true;
        l4 = C(l4, t5), t5 = n6;
        do {
          switch (t5.tag) {
            case 3:
              return t5.flags |= 65536, e4 = a4 & -a4, t5.lanes |= e4, X(t5, e4 = jn(t5.stateNode, l4, e4)), false;
            case 1:
              if (n6 = t5.type, o3 = t5.stateNode, 0 == (128 & t5.flags) && ("function" == typeof n6.getDerivedStateFromError || null !== o3 && "function" == typeof o3.componentDidCatch && (null === ii || !ii.has(o3)))) return t5.flags |= 65536, a4 &= -a4, t5.lanes |= a4, On(a4 = Wn(a4), e4, t5, l4), X(t5, a4), false;
          }
          t5 = t5.return;
        } while (null !== t5);
        return false;
      }(e3, l3, n5, t4, Bu)) return Gu = 1, Mn(e3, C(t4, e3.current)), void (Qu = null);
    } catch (n6) {
      if (null !== l3) throw Qu = l3, n6;
      return Gu = 1, Mn(e3, C(t4, e3.current)), void (Qu = null);
    }
    32768 & n5.flags ? Mr(n5, true) : Fr(n5);
  }
  function Fr(e3) {
    var n5 = e3;
    do {
      if (0 != (32768 & n5.flags)) return void Mr(n5, qu);
      e3 = n5.return;
      var t4 = Tt(n5.alternate, n5, Ju);
      if (null !== t4) return void (Qu = t4);
      if (null !== (n5 = n5.sibling)) return void (Qu = n5);
      Qu = n5 = e3;
    } while (null !== n5);
    0 === Gu && (Gu = 5);
  }
  function Mr(e3, n5) {
    do {
      var t4 = Nt(e3.alternate, e3);
      if (null !== t4) return t4.flags &= 32767, void (Qu = t4);
      if (null !== (t4 = e3.return) && (t4.flags |= 32768, t4.subtreeFlags = 0, t4.deletions = null), !n5 && null !== (e3 = e3.sibling)) return void (Qu = e3);
      Qu = e3 = t4;
    } while (null !== e3);
    Gu = 6, Qu = null;
  }
  function Hr(e3, n5, t4, l3, a4, o3, u3, i4, s3, c4) {
    var f3 = Rl.T, d3 = Gl();
    try {
      Jl(2), Rl.T = null, function(e4, n6, t5, l4, a5, o4) {
        do {
          Wr();
        } while (null !== ci);
        if (0 != (6 & Ou)) throw Error(r3(327));
        var u4 = e4.finishedWork;
        if (l4 = e4.finishedLanes, null === u4) return null;
        if (e4.finishedWork = null, e4.finishedLanes = 0, u4 === e4.current) throw Error(r3(177));
        e4.callbackNode = null, e4.callbackPriority = 0, e4.cancelPendingCommit = null;
        var i5 = u4.lanes | u4.childLanes;
        if (function(e5, n7, t6, r4) {
          var l5 = e5.pendingLanes;
          e5.pendingLanes = t6, e5.suspendedLanes = 0, e5.pingedLanes = 0, e5.warmLanes = 0, e5.expiredLanes &= t6, e5.entangledLanes &= t6, e5.errorRecoveryDisabledLanes &= t6, e5.shellSuspendCounter = 0, n7 = e5.entanglements;
          var a6 = e5.expirationTimes, o5 = e5.hiddenUpdates;
          for (t6 = l5 & ~t6; 0 < t6; ) {
            var u5 = 31 - Aa(t6);
            l5 = 1 << u5, n7[u5] = 0, a6[u5] = -1;
            var i6 = o5[u5];
            if (null !== i6) for (o5[u5] = null, u5 = 0; u5 < i6.length; u5++) {
              var s5 = i6[u5];
              null !== s5 && (s5.lane &= -536870913);
            }
            t6 &= ~l5;
          }
          0 !== r4 && k2(e5, r4, 0);
        }(e4, l4, i5 |= Co, o4), e4 === Au && (Qu = Au = null, Bu = 0), 0 == (10256 & u4.subtreeFlags) && 0 == (10256 & u4.flags) || si || (si = true, di = i5, pi = t5, qa(eo, function() {
          return Wr(), null;
        })), t5 = 0 != (15990 & u4.flags), 0 != (15990 & u4.subtreeFlags) || t5) {
          t5 = Rl.T, Rl.T = null, o4 = Gl(), Jl(2);
          var s4 = Ou;
          Ou |= 4, function(e5, n7) {
            for (Dl(e5.containerInfo), Lu = n7; null !== Lu; ) if (n7 = (e5 = Lu).child, 0 != (1028 & e5.subtreeFlags) && null !== n7) n7.return = e5, Lu = n7;
            else for (; null !== Lu; ) {
              var t6 = (e5 = Lu).alternate;
              switch (n7 = e5.flags, e5.tag) {
                case 0:
                case 11:
                case 15:
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                case 1:
                  if (0 != (1024 & n7) && null !== t6) {
                    n7 = void 0;
                    var l5 = e5, a6 = t6.memoizedProps;
                    t6 = t6.memoizedState;
                    var o5 = l5.stateNode;
                    try {
                      var u5 = Fn(l5.type, a6, (l5.elementType, l5.type));
                      n7 = o5.getSnapshotBeforeUpdate(u5, t6), o5.__reactInternalSnapshotBeforeUpdate = n7;
                    } catch (e6) {
                      Ar(l5, l5.return, e6);
                    }
                  }
                  break;
                case 3:
                  0 != (1024 & n7) && Vl && wa(e5.stateNode.containerInfo);
                  break;
                default:
                  if (0 != (1024 & n7)) throw Error(r3(163));
              }
              if (null !== (n7 = e5.sibling)) {
                n7.return = e5.return, Lu = n7;
                break;
              }
              Lu = e5.return;
            }
            u5 = Uu, Uu = false;
          }(e4, u4), Gt(u4, e4), Fl(e4.containerInfo), e4.current = u4, Bt(e4, u4.alternate, u4), Ga(), Ou = s4, Jl(o4), Rl.T = t5;
        } else e4.current = u4;
        if (si ? (si = false, ci = e4, fi = l4) : jr(e4, i5), 0 === (i5 = e4.pendingLanes) && (ii = null), u4.stateNode, j(e4), null !== n6) for (a5 = e4.onRecoverableError, u4 = 0; u4 < n6.length; u4++) a5((i5 = n6[u4]).value, { componentStack: i5.stack });
        0 != (3 & fi) && Wr(), i5 = e4.pendingLanes, 0 != (4194218 & l4) && 0 != (42 & i5) ? e4 === hi ? mi++ : (mi = 0, hi = e4) : mi = 0, W(0);
      }(e3, n5, t4, l3, d3, a4);
    } finally {
      Rl.T = f3, Jl(d3);
    }
  }
  function jr(e3, n5) {
    0 == (e3.pooledCacheLanes &= n5) && null != (n5 = e3.pooledCache) && (e3.pooledCache = null, wt(n5));
  }
  function Wr() {
    if (null !== ci) {
      var e3 = ci, n5 = di;
      di = 0;
      var t4 = x(fi), l3 = 32 > t4 ? 32 : t4;
      t4 = Rl.T;
      var a4 = Gl();
      try {
        if (Jl(l3), Rl.T = null, null === ci) var o3 = false;
        else {
          l3 = pi, pi = null;
          var u3 = ci, i4 = fi;
          if (ci = null, fi = 0, 0 != (6 & Ou)) throw Error(r3(331));
          var s3 = Ou;
          Ou |= 4, dr(u3.current), ar(u3, u3.current, i4, l3), Ou = s3, W(0), lo && lo.onPostCommitFiberRoot, o3 = true;
        }
        return o3;
      } finally {
        Jl(a4), Rl.T = t4, jr(e3, n5);
      }
    }
    return false;
  }
  function Or(e3, n5, t4) {
    n5 = C(t4, n5), null !== (e3 = G2(e3, n5 = jn(e3.stateNode, n5, 2), 2)) && (S2(e3, 2), j(e3));
  }
  function Ar(e3, n5, t4) {
    if (3 === e3.tag) Or(e3, e3, t4);
    else for (; null !== n5; ) {
      if (3 === n5.tag) {
        Or(n5, e3, t4);
        break;
      }
      if (1 === n5.tag) {
        var r4 = n5.stateNode;
        if ("function" == typeof n5.type.getDerivedStateFromError || "function" == typeof r4.componentDidCatch && (null === ii || !ii.has(r4))) {
          e3 = C(t4, e3), null !== (r4 = G2(n5, t4 = Wn(2), 2)) && (On(t4, r4, n5, e3), S2(r4, 2), j(r4));
          break;
        }
      }
      n5 = n5.return;
    }
  }
  function Qr(e3, n5, t4) {
    var r4 = e3.pingCache;
    if (null === r4) {
      r4 = e3.pingCache = new Wu();
      var l3 = /* @__PURE__ */ new Set();
      r4.set(n5, l3);
    } else void 0 === (l3 = r4.get(n5)) && (l3 = /* @__PURE__ */ new Set(), r4.set(n5, l3));
    l3.has(t4) || (Yu = true, l3.add(t4), e3 = Br.bind(null, e3, n5, t4), n5.then(e3, e3));
  }
  function Br(e3, n5, t4) {
    var r4 = e3.pingCache;
    null !== r4 && r4.delete(n5), e3.pingedLanes |= e3.suspendedLanes & t4, e3.warmLanes &= ~t4, Au === e3 && (Bu & t4) === t4 && (4 === Gu || 3 === Gu && (62914560 & Bu) === Bu && 300 > Ka() - ai ? 0 == (2 & Ou) && zr(e3, 0) : Zu |= t4, ni === Bu && (ni = 0)), j(e3);
  }
  function Vr(e3, n5) {
    0 === n5 && (n5 = b2()), null !== (e3 = F(e3, n5)) && (S2(e3, n5), j(e3));
  }
  function $r(e3) {
    var n5 = e3.memoizedState, t4 = 0;
    null !== n5 && (t4 = n5.retryLane), Vr(e3, t4);
  }
  function qr(e3, n5) {
    var t4 = 0;
    switch (e3.tag) {
      case 13:
        var l3 = e3.stateNode, a4 = e3.memoizedState;
        null !== a4 && (t4 = a4.retryLane);
        break;
      case 19:
        l3 = e3.stateNode;
        break;
      case 22:
        l3 = e3.stateNode._retryCache;
        break;
      default:
        throw Error(r3(314));
    }
    null !== l3 && l3.delete(n5), Vr(e3, t4);
  }
  function Yr(e3, n5, t4, r4) {
    this.tag = e3, this.key = t4, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = n5, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r4, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Jr(e3) {
    return !(!(e3 = e3.prototype) || !e3.isReactComponent);
  }
  function Gr(e3, n5) {
    var r4 = e3.alternate;
    return null === r4 ? ((r4 = t3(e3.tag, n5, e3.key, e3.mode)).elementType = e3.elementType, r4.type = e3.type, r4.stateNode = e3.stateNode, r4.alternate = e3, e3.alternate = r4) : (r4.pendingProps = n5, r4.type = e3.type, r4.flags = 0, r4.subtreeFlags = 0, r4.deletions = null), r4.flags = 31457280 & e3.flags, r4.childLanes = e3.childLanes, r4.lanes = e3.lanes, r4.child = e3.child, r4.memoizedProps = e3.memoizedProps, r4.memoizedState = e3.memoizedState, r4.updateQueue = e3.updateQueue, n5 = e3.dependencies, r4.dependencies = null === n5 ? null : { lanes: n5.lanes, firstContext: n5.firstContext }, r4.sibling = e3.sibling, r4.index = e3.index, r4.ref = e3.ref, r4.refCleanup = e3.refCleanup, r4;
  }
  function Kr(e3, n5) {
    e3.flags &= 31457282;
    var t4 = e3.alternate;
    return null === t4 ? (e3.childLanes = 0, e3.lanes = n5, e3.child = null, e3.subtreeFlags = 0, e3.memoizedProps = null, e3.memoizedState = null, e3.updateQueue = null, e3.dependencies = null, e3.stateNode = null) : (e3.childLanes = t4.childLanes, e3.lanes = t4.lanes, e3.child = t4.child, e3.subtreeFlags = 0, e3.deletions = null, e3.memoizedProps = t4.memoizedProps, e3.memoizedState = t4.memoizedState, e3.updateQueue = t4.updateQueue, e3.type = t4.type, n5 = t4.dependencies, e3.dependencies = null === n5 ? null : { lanes: n5.lanes, firstContext: n5.firstContext }), e3;
  }
  function Xr(e3, n5, l3, a4, o3, u3) {
    var i4 = 0;
    if (a4 = e3, "function" == typeof e3) Jr(e3) && (i4 = 1);
    else if ("string" == typeof e3) i4 = 5;
    else e: switch (e3) {
      case ml:
        return Zr(l3.children, o3, u3, n5);
      case hl:
        i4 = 8, o3 |= 24;
        break;
      case gl:
        return (e3 = t3(12, l3, n5, 2 | o3)).elementType = gl, e3.lanes = u3, e3;
      case kl:
        return (e3 = t3(13, l3, n5, o3)).elementType = kl, e3.lanes = u3, e3;
      case wl:
        return (e3 = t3(19, l3, n5, o3)).elementType = wl, e3.lanes = u3, e3;
      case Cl:
        return el(l3, o3, u3, n5);
      default:
        if ("object" == typeof e3 && null !== e3) switch (e3.$$typeof) {
          case yl:
          case vl:
            i4 = 10;
            break e;
          case bl:
            i4 = 9;
            break e;
          case Sl:
            i4 = 11;
            break e;
          case xl:
            i4 = 14;
            break e;
          case zl:
            i4 = 16, a4 = null;
            break e;
        }
        i4 = 29, l3 = Error(r3(130, null === e3 ? "null" : typeof e3, "")), a4 = null;
    }
    return (n5 = t3(i4, l3, n5, o3)).elementType = e3, n5.type = a4, n5.lanes = u3, n5;
  }
  function Zr(e3, n5, r4, l3) {
    return (e3 = t3(7, e3, l3, n5)).lanes = r4, e3;
  }
  function el(e3, n5, l3, a4) {
    (e3 = t3(22, e3, a4, n5)).elementType = Cl, e3.lanes = l3;
    var o3 = { _visibility: 1, _pendingVisibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null, _current: null, detach: function() {
      var e4 = o3._current;
      if (null === e4) throw Error(r3(456));
      if (0 == (2 & o3._pendingVisibility)) {
        var n6 = F(e4, 2);
        null !== n6 && (o3._pendingVisibility |= 2, yr(n6, 0, 2));
      }
    }, attach: function() {
      var e4 = o3._current;
      if (null === e4) throw Error(r3(456));
      if (0 != (2 & o3._pendingVisibility)) {
        var n6 = F(e4, 2);
        null !== n6 && (o3._pendingVisibility &= -3, yr(n6, 0, 2));
      }
    } };
    return e3.stateNode = o3, e3;
  }
  function nl(e3, n5, r4) {
    return (e3 = t3(6, e3, null, n5)).lanes = r4, e3;
  }
  function tl(e3, n5, r4) {
    return (n5 = t3(4, null !== e3.children ? e3.children : [], e3.key, n5)).lanes = r4, n5.stateNode = { containerInfo: e3.containerInfo, pendingChildren: null, implementation: e3.implementation }, n5;
  }
  function rl(e3, n5, t4, r4, l3, a4, o3, u3) {
    this.tag = 1, this.containerInfo = e3, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Bl, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = v2(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = v2(0), this.hiddenUpdates = v2(null), this.identifierPrefix = r4, this.onUncaughtError = l3, this.onCaughtError = a4, this.onRecoverableError = o3, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = u3, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function ll(e3, n5, t4, r4, l3, a4) {
    l3 = function(e4) {
      return e4 ? e4 = Oa : Oa;
    }(l3), null === r4.context ? r4.context = l3 : r4.pendingContext = l3, (r4 = J(n5)).payload = { element: t4 }, null !== (a4 = void 0 === a4 ? null : a4) && (r4.callback = a4), null !== (t4 = G2(e3, r4, n5)) && (yr(t4, 0, n5), K(t4, e3, n5));
  }
  var al, ol, ul = {}, il = import_react.default, sl = u, cl = Object.assign, fl = Symbol.for("react.element"), dl = Symbol.for("react.transitional.element"), pl = Symbol.for("react.portal"), ml = Symbol.for("react.fragment"), hl = Symbol.for("react.strict_mode"), gl = Symbol.for("react.profiler"), yl = Symbol.for("react.provider"), bl = Symbol.for("react.consumer"), vl = Symbol.for("react.context"), Sl = Symbol.for("react.forward_ref"), kl = Symbol.for("react.suspense"), wl = Symbol.for("react.suspense_list"), xl = Symbol.for("react.memo"), zl = Symbol.for("react.lazy"), Cl = Symbol.for("react.offscreen"), Pl = Symbol.for("react.memo_cache_sentinel"), El = Symbol.iterator, _l = Symbol.for("react.client.reference"), Rl = il.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Tl = false, Nl = Array.isArray, Ll = n4.getPublicInstance, Ul = n4.getRootHostContext, Il = n4.getChildHostContext, Dl = n4.prepareForCommit, Fl = n4.resetAfterCommit, Ml = n4.createInstance, Hl = n4.appendInitialChild, jl = n4.finalizeInitialChildren, Wl = n4.shouldSetTextContent, Ol = n4.createTextInstance, Al = null, Ql = null, Bl = n4.noTimeout, Vl = true, $l = null, ql = null, Yl = null, Jl = n4.setCurrentUpdatePriority, Gl = n4.getCurrentUpdatePriority, Kl = n4.resolveUpdatePriority, Xl = n4.shouldAttemptEagerTransition, Zl = null;
  n4.requestPostPaintCallback;
  var ea = n4.maySuspendCommit, na = null, ta = null, ra = null, la = null, aa = null, oa = null, ua = null, ia = n4.appendChild, sa = n4.appendChildToContainer, ca = n4.commitTextUpdate, fa = null, da = n4.commitUpdate, pa = n4.insertBefore, ma = null, ha = n4.removeChild, ga = n4.removeChildFromContainer, ya = n4.resetTextContent, ba = null, va = null, Sa = null, ka = null, wa = n4.clearContainer, xa = null, za = null, Ca = null, Pa = null, Ea = null, _a = null, Ra = null, Ta = null, Na = null, La = null, Ua = null, Ia = null, Da = null, Fa = null, Ma = null, Ha = null, ja = [], Wa = -1, Oa = {}, Aa = Math.clz32 ? Math.clz32 : function(e3) {
    return 0 == (e3 >>>= 0) ? 32 : 31 - (Qa(e3) / Ba | 0) | 0;
  }, Qa = Math.log, Ba = Math.LN2, Va = 128, $a = 4194304, qa = sl.unstable_scheduleCallback, Ya = sl.unstable_cancelCallback, Ja = sl.unstable_shouldYield, Ga = sl.unstable_requestPaint, Ka = sl.unstable_now, Xa = sl.unstable_ImmediatePriority, Za = sl.unstable_UserBlockingPriority, eo = sl.unstable_NormalPriority, no = sl.unstable_IdlePriority, to = sl.log, ro = sl.unstable_setDisableYieldValue, lo = null, ao = "function" == typeof Object.is ? Object.is : function(e3, n5) {
    return e3 === n5 && (0 !== e3 || 1 / e3 == 1 / n5) || e3 != e3 && n5 != n5;
  }, oo = /* @__PURE__ */ new WeakMap(), uo = [], io = 0, so = null, co = [], fo = 0, po = null, mo = f2(null), ho = f2(null), go = f2(null), yo = f2(null), bo = null, vo = false, So = null, ko = false, wo = Error(r3(519)), xo = [], zo = 0, Co = 0, Po = null, Eo = null, _o = false, Ro = false, To = false, No = 0, Lo = null, Uo = 0, Io = 0, Do = null, Fo = false, Mo = false, Ho = Object.prototype.hasOwnProperty, jo = Error(r3(460)), Wo = Error(r3(474)), Oo = { then: function() {
  } }, Ao = null, Qo = null, Bo = 0, Vo = de(true), $o = de(false), qo = f2(null), Yo = f2(0), Jo = f2(null), Go = null, Ko = f2(0), Xo = 0, Zo = null, eu = null, nu = null, tu = false, ru = false, lu = false, au = 0, ou = 0, uu = null, iu = 0, su = function() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }, cu = { readContext: bt, use: Ue, useCallback: ke, useContext: ke, useEffect: ke, useImperativeHandle: ke, useLayoutEffect: ke, useInsertionEffect: ke, useMemo: ke, useReducer: ke, useRef: ke, useState: ke, useDebugValue: ke, useDeferredValue: ke, useTransition: ke, useSyncExternalStore: ke, useId: ke };
  cu.useCacheRefresh = ke, cu.useMemoCache = ke, cu.useHostTransitionStatus = ke, cu.useFormState = ke, cu.useActionState = ke, cu.useOptimistic = ke;
  var fu = { readContext: bt, use: Ue, useCallback: function(e3, n5) {
    return Te().memoizedState = [e3, void 0 === n5 ? null : n5], e3;
  }, useContext: bt, useEffect: cn, useImperativeHandle: function(e3, n5, t4) {
    t4 = null != t4 ? t4.concat([e3]) : null, un(4194308, 4, mn.bind(null, n5, e3), t4);
  }, useLayoutEffect: function(e3, n5) {
    return un(4194308, 4, e3, n5);
  }, useInsertionEffect: function(e3, n5) {
    un(4, 2, e3, n5);
  }, useMemo: function(e3, n5) {
    var t4 = Te();
    n5 = void 0 === n5 ? null : n5;
    var r4 = e3();
    if (lu) {
      z(true);
      try {
        e3();
      } finally {
        z(false);
      }
    }
    return t4.memoizedState = [r4, n5], r4;
  }, useReducer: function(e3, n5, t4) {
    var r4 = Te();
    if (void 0 !== t4) {
      var l3 = t4(n5);
      if (lu) {
        z(true);
        try {
          t4(n5);
        } finally {
          z(false);
        }
      }
    } else l3 = n5;
    return r4.memoizedState = r4.baseState = l3, e3 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: e3, lastRenderedState: l3 }, r4.queue = e3, e3 = e3.dispatch = Pn.bind(null, Zo, e3), [r4.memoizedState, e3];
  }, useRef: function(e3) {
    return e3 = { current: e3 }, Te().memoizedState = e3;
  }, useState: function(e3) {
    var n5 = (e3 = Ve(e3)).queue, t4 = En.bind(null, Zo, n5);
    return n5.dispatch = t4, [e3.memoizedState, t4];
  }, useDebugValue: gn, useDeferredValue: function(e3, n5) {
    return vn(Te(), e3, n5);
  }, useTransition: function() {
    var e3 = Ve(false);
    return e3 = kn.bind(null, Zo, e3.queue, true, false), Te().memoizedState = e3, [false, e3];
  }, useSyncExternalStore: function(e3, n5, t4) {
    var l3 = Zo, a4 = Te();
    if (t4 = n5(), null === Au) throw Error(r3(349));
    0 != (60 & Bu) || We(l3, n5, t4), a4.memoizedState = t4;
    var o3 = { value: t4, getSnapshot: n5 };
    return a4.queue = o3, cn(Ae.bind(null, l3, o3, e3), [e3]), l3.flags |= 2048, an(9, Oe.bind(null, l3, o3, t4, n5), { destroy: void 0 }, null), t4;
  }, useId: function() {
    var e3 = Te(), n5 = Au.identifierPrefix;
    return n5 = ":" + n5 + "r" + (iu++).toString(32) + ":", e3.memoizedState = n5;
  }, useCacheRefresh: function() {
    return Te().memoizedState = Cn.bind(null, Zo);
  } };
  fu.useMemoCache = Ie, fu.useHostTransitionStatus = wn, fu.useFormState = en, fu.useActionState = en, fu.useOptimistic = function(e3) {
    var n5 = Te();
    n5.memoizedState = n5.baseState = e3;
    var t4 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null };
    return n5.queue = t4, n5 = Rn.bind(null, Zo, true, t4), t4.dispatch = n5, [e3, n5];
  };
  var du = { readContext: bt, use: Ue, useCallback: yn, useContext: bt, useEffect: fn, useImperativeHandle: hn, useInsertionEffect: dn, useLayoutEffect: pn, useMemo: bn, useReducer: Fe, useRef: on3, useState: function() {
    return Fe(De);
  }, useDebugValue: gn, useDeferredValue: function(e3, n5) {
    return Sn(Ne(), eu.memoizedState, e3, n5);
  }, useTransition: function() {
    var e3 = Fe(De)[0], n5 = Ne().memoizedState;
    return ["boolean" == typeof e3 ? e3 : Le(e3), n5];
  }, useSyncExternalStore: je, useId: xn };
  du.useCacheRefresh = zn, du.useMemoCache = Ie, du.useHostTransitionStatus = wn, du.useFormState = nn, du.useActionState = nn, du.useOptimistic = function(e3, n5) {
    return $e(Ne(), 0, e3, n5);
  };
  var pu = { readContext: bt, use: Ue, useCallback: yn, useContext: bt, useEffect: fn, useImperativeHandle: hn, useInsertionEffect: dn, useLayoutEffect: pn, useMemo: bn, useReducer: He, useRef: on3, useState: function() {
    return He(De);
  }, useDebugValue: gn, useDeferredValue: function(e3, n5) {
    var t4 = Ne();
    return null === eu ? vn(t4, e3, n5) : Sn(t4, eu.memoizedState, e3, n5);
  }, useTransition: function() {
    var e3 = He(De)[0], n5 = Ne().memoizedState;
    return ["boolean" == typeof e3 ? e3 : Le(e3), n5];
  }, useSyncExternalStore: je, useId: xn };
  pu.useCacheRefresh = zn, pu.useMemoCache = Ie, pu.useHostTransitionStatus = wn, pu.useFormState = ln, pu.useActionState = ln, pu.useOptimistic = function(e3, n5) {
    var t4 = Ne();
    return null !== eu ? $e(t4, 0, e3, n5) : (t4.baseState = e3, [e3, t4.queue.dispatch]);
  };
  var mu = { isMounted: function(e3) {
    return !!(e3 = e3._reactInternals) && function(e4) {
      var n5 = e4, t4 = e4;
      if (e4.alternate) for (; n5.return; ) n5 = n5.return;
      else {
        e4 = n5;
        do {
          0 != (4098 & (n5 = e4).flags) && (t4 = n5.return), e4 = n5.return;
        } while (e4);
      }
      return 3 === n5.tag ? t4 : null;
    }(e3) === e3;
  }, enqueueSetState: function(e3, n5, t4) {
    e3 = e3._reactInternals;
    var r4 = hr(), l3 = J(r4);
    l3.payload = n5, null != t4 && (l3.callback = t4), null !== (n5 = G2(e3, l3, r4)) && (yr(n5, 0, r4), K(n5, e3, r4));
  }, enqueueReplaceState: function(e3, n5, t4) {
    e3 = e3._reactInternals;
    var r4 = hr(), l3 = J(r4);
    l3.tag = 1, l3.payload = n5, null != t4 && (l3.callback = t4), null !== (n5 = G2(e3, l3, r4)) && (yr(n5, 0, r4), K(n5, e3, r4));
  }, enqueueForceUpdate: function(e3, n5) {
    e3 = e3._reactInternals;
    var t4 = hr(), r4 = J(t4);
    r4.tag = 2, null != n5 && (r4.callback = n5), null !== (n5 = G2(e3, r4, t4)) && (yr(n5, 0, t4), K(n5, e3, t4));
  } };
  "function" == typeof reportError && reportError;
  var hu = Error(r3(461)), gu = false, yu = { dehydrated: null, treeContext: null, retryLane: 0 }, bu = f2(null), vu = null, Su = null, ku = null, wu = "undefined" != typeof AbortController ? AbortController : function() {
    var e3 = [], n5 = this.signal = { aborted: false, addEventListener: function(n6, t4) {
      e3.push(t4);
    } };
    this.abort = function() {
      n5.aborted = true, e3.forEach(function(e4) {
        return e4();
      });
    };
  }, xu = sl.unstable_scheduleCallback, zu = sl.unstable_NormalPriority, Cu = { $$typeof: vl, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }, Pu = Rl.S;
  Rl.S = function(e3, n5) {
    "object" == typeof n5 && null !== n5 && "function" == typeof n5.then && function(e4, n6) {
      if (null === Lo) {
        var t4 = Lo = [];
        Uo = 0, Io = V(), Do = { status: "pending", value: void 0, then: function(e5) {
          t4.push(e5);
        } };
      }
      Uo++, n6.then($, $);
    }(0, n5), null !== Pu && Pu(e3, n5);
  };
  var Eu = f2(null), _u = false, Ru = false, Tu = false, Nu = "function" == typeof WeakSet ? WeakSet : Set, Lu = null, Uu = false, Iu = null, Du = false, Fu = null, Mu = 8192, Hu = { getCacheForType: function(e3) {
    var n5 = bt(Cu), t4 = n5.data.get(e3);
    return void 0 === t4 && (t4 = e3(), n5.data.set(e3, t4)), t4;
  } };
  if ("function" == typeof Symbol && Symbol.for) {
    var ju = Symbol.for;
    ju("selector.component"), ju("selector.has_pseudo_class"), ju("selector.role"), ju("selector.test_id"), ju("selector.text");
  }
  var Wu = "function" == typeof WeakMap ? WeakMap : Map, Ou = 0, Au = null, Qu = null, Bu = 0, Vu = 0, $u = null, qu = false, Yu = false, Ju = 0, Gu = 0, Ku = 0, Xu = 0, Zu = 0, ei = 0, ni = 0, ti = null, ri = null, li = false, ai = 0, oi = 1 / 0, ui = null, ii = null, si = false, ci = null, fi = 0, di = 0, pi = null, mi = 0, hi = null;
  return ul.createContainer = function(e3, n5, r4, l3, a4, o3, u3, i4, s3, c4) {
    return function(e4, n6, r5, l4, a5, o4, u4, i5, s4, c5, f3, d3) {
      return e4 = new rl(e4, n6, r5, u4, i5, s4, c5, null), n6 = 1, true === o4 && (n6 |= 24), o4 = t3(3, null, null, n6), e4.current = o4, o4.stateNode = e4, (n6 = kt()).refCount++, e4.pooledCache = n6, n6.refCount++, o4.memoizedState = { element: l4, isDehydrated: r5, cache: n6 }, q(o4), e4;
    }(e3, n5, false, null, 0, l3, o3, u3, i4, s3);
  }, ul.flushSyncWork = function() {
    return 0 != (6 & Ou) || (W(0), false);
  }, ul.updateContainer = function(e3, n5, t4, r4) {
    var l3 = n5.current, a4 = hr();
    return ll(l3, a4, e3, n5, t4, r4), a4;
  }, ul.updateContainerSync = function(e3, n5, t4, r4) {
    return 0 === n5.tag && Wr(), ll(n5.current, 2, e3, n5, t4, r4), 2;
  }, ul;
}, s.exports.default = s.exports, Object.defineProperty(s.exports, "__esModule", { value: true })), o.exports) : a.exports = function() {
  return i || (i = 1, n4 = c, n4.exports = function(n5) {
    function t3(e3, n6, t4, r4) {
      return new Ra(e3, n6, t4, r4);
    }
    function r3() {
      console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
    }
    function l2() {
      console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    }
    function a3() {
    }
    function o2(e3) {
      var n6 = [];
      return e3.forEach(function(e4) {
        n6.push(e4);
      }), n6.sort().join(", ");
    }
    function i3(e3) {
      return null === e3 || "object" != typeof e3 ? null : "function" == typeof (e3 = ho && e3[ho] || e3["@@iterator"]) ? e3 : null;
    }
    function s2(e3) {
      if (null == e3) return null;
      if ("function" == typeof e3) return e3.$$typeof === go ? null : e3.displayName || e3.name || null;
      if ("string" == typeof e3) return e3;
      switch (e3) {
        case no:
          return "Fragment";
        case eo:
          return "Portal";
        case ro:
          return "Profiler";
        case to:
          return "StrictMode";
        case io:
          return "Suspense";
        case so:
          return "SuspenseList";
      }
      if ("object" == typeof e3) switch ("number" == typeof e3.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), e3.$$typeof) {
        case oo:
          return (e3.displayName || "Context") + ".Provider";
        case ao:
          return (e3._context.displayName || "Context") + ".Consumer";
        case uo:
          var n6 = e3.render;
          return (e3 = e3.displayName) || (e3 = "" !== (e3 = n6.displayName || n6.name || "") ? "ForwardRef(" + e3 + ")" : "ForwardRef"), e3;
        case co:
          return null !== (n6 = e3.displayName || null) ? n6 : s2(e3.type) || "Memo";
        case fo:
          n6 = e3._payload, e3 = e3._init;
          try {
            return s2(e3(n6));
          } catch (e4) {
          }
      }
      return null;
    }
    function c3(e3) {
      var n6 = e3.type;
      switch (e3.tag) {
        case 24:
          return "Cache";
        case 9:
          return (n6._context.displayName || "Context") + ".Consumer";
        case 10:
          return (n6.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return e3 = (e3 = n6.render).displayName || e3.name || "", n6.displayName || ("" !== e3 ? "ForwardRef(" + e3 + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return n6;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return s2(n6);
        case 8:
          return n6 === to ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if ("function" == typeof n6) return n6.displayName || n6.name || null;
          if ("string" == typeof n6) return n6;
          break;
        case 29:
          if (null != (n6 = e3._debugInfo)) {
            for (var t4 = n6.length - 1; 0 <= t4; t4--) if ("string" == typeof n6[t4].name) return n6[t4].name;
          }
          if (null !== e3.return) return c3(e3.return);
      }
      return null;
    }
    function f2() {
    }
    function d2(e3) {
      if (void 0 === vo) try {
        throw Error();
      } catch (e4) {
        var n6 = e4.stack.trim().match(/\n( *(at )?)/);
        vo = n6 && n6[1] || "", So = -1 < e4.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < e4.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
      return "\n" + vo + e3 + So;
    }
    function p2(e3, n6) {
      if (!e3 || ko) return "";
      var t4, r4 = wo.get(e3);
      if (void 0 !== r4) return r4;
      ko = true, r4 = Error.prepareStackTrace, Error.prepareStackTrace = void 0, t4 = yo.H, yo.H = null, function() {
        if (0 === bo) {
          Oa = console.log, Aa = console.info, Qa = console.warn, Ba = console.error, Va = console.group, $a = console.groupCollapsed, qa = console.groupEnd;
          var e4 = { configurable: true, enumerable: true, value: f2, writable: true };
          Object.defineProperties(console, { info: e4, log: e4, warn: e4, error: e4, group: e4, groupCollapsed: e4, groupEnd: e4 });
        }
        bo++;
      }();
      try {
        var l3 = { DetermineComponentFrameRoot: function() {
          try {
            if (n6) {
              var t5 = function() {
                throw Error();
              };
              if (Object.defineProperty(t5.prototype, "props", { set: function() {
                throw Error();
              } }), "object" == typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(t5, []);
                } catch (e4) {
                  var r5 = e4;
                }
                Reflect.construct(e3, [], t5);
              } else {
                try {
                  t5.call();
                } catch (e4) {
                  r5 = e4;
                }
                e3.call(t5.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (e4) {
                r5 = e4;
              }
              (t5 = e3()) && "function" == typeof t5.catch && t5.catch(function() {
              });
            }
          } catch (e4) {
            if (e4 && r5 && "string" == typeof e4.stack) return [e4.stack, r5.stack];
          }
          return [null, null];
        } };
        l3.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var a4 = Object.getOwnPropertyDescriptor(l3.DetermineComponentFrameRoot, "name");
        a4 && a4.configurable && Object.defineProperty(l3.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
        var o3 = l3.DetermineComponentFrameRoot(), u3 = o3[0], i4 = o3[1];
        if (u3 && i4) {
          var s3 = u3.split("\n"), c4 = i4.split("\n");
          for (o3 = a4 = 0; a4 < s3.length && !s3[a4].includes("DetermineComponentFrameRoot"); ) a4++;
          for (; o3 < c4.length && !c4[o3].includes("DetermineComponentFrameRoot"); ) o3++;
          if (a4 === s3.length || o3 === c4.length) for (a4 = s3.length - 1, o3 = c4.length - 1; 1 <= a4 && 0 <= o3 && s3[a4] !== c4[o3]; ) o3--;
          for (; 1 <= a4 && 0 <= o3; a4--, o3--) if (s3[a4] !== c4[o3]) {
            if (1 !== a4 || 1 !== o3) do {
              if (a4--, 0 > --o3 || s3[a4] !== c4[o3]) {
                var p3 = "\n" + s3[a4].replace(" at new ", " at ");
                return e3.displayName && p3.includes("<anonymous>") && (p3 = p3.replace("<anonymous>", e3.displayName)), "function" == typeof e3 && wo.set(e3, p3), p3;
              }
            } while (1 <= a4 && 0 <= o3);
            break;
          }
        }
      } finally {
        ko = false, yo.H = t4, function() {
          if (0 == --bo) {
            var e4 = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, { log: Ka({}, e4, { value: Oa }), info: Ka({}, e4, { value: Aa }), warn: Ka({}, e4, { value: Qa }), error: Ka({}, e4, { value: Ba }), group: Ka({}, e4, { value: Va }), groupCollapsed: Ka({}, e4, { value: $a }), groupEnd: Ka({}, e4, { value: qa }) });
          }
          0 > bo && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }(), Error.prepareStackTrace = r4;
      }
      return s3 = (s3 = e3 ? e3.displayName || e3.name : "") ? d2(s3) : "", "function" == typeof e3 && wo.set(e3, s3), s3;
    }
    function m(e3) {
      switch (e3.tag) {
        case 26:
        case 27:
        case 5:
          return d2(e3.type);
        case 16:
          return d2("Lazy");
        case 13:
          return d2("Suspense");
        case 19:
          return d2("SuspenseList");
        case 0:
        case 15:
          return p2(e3.type, false);
        case 11:
          return p2(e3.type.render, false);
        case 1:
          return p2(e3.type, true);
        default:
          return "";
      }
    }
    function h2(e3) {
      try {
        var n6 = "";
        do {
          n6 += m(e3);
          var t4 = e3._debugInfo;
          if (t4) for (var r4 = t4.length - 1; 0 <= r4; r4--) {
            var l3 = t4[r4];
            if ("string" == typeof l3.name) {
              var a4 = n6, o3 = l3.env;
              n6 = a4 + d2(l3.name + (o3 ? " [" + o3 + "]" : ""));
            }
          }
          e3 = e3.return;
        } while (e3);
        return n6;
      } catch (e4) {
        return "\nError generating stack: " + e4.message + "\n" + e4.stack;
      }
    }
    function g2() {
      return null === xo ? "" : h2(xo);
    }
    function y2(e3, n6, t4, r4, l3, a4, o3) {
      var u3 = xo;
      yo.getCurrentStack = null === e3 ? null : g2, zo = false, xo = e3;
      try {
        return n6(t4, r4, l3, a4, o3);
      } finally {
        xo = u3;
      }
      throw Error("runWithFiberInDEV should never be called in production. This is a bug in React.");
    }
    function b2(e3) {
      return { current: e3 };
    }
    function v2(e3, n6) {
      0 > Mu ? console.error("Unexpected pop.") : (n6 !== Fu[Mu] && console.error("Unexpected Fiber popped."), e3.current = Du[Mu], Du[Mu] = null, Fu[Mu] = null, Mu--);
    }
    function S2(e3, n6, t4) {
      Mu++, Du[Mu] = e3.current, Fu[Mu] = t4, e3.current = n6;
    }
    function k2(e3) {
      var n6 = 42 & e3;
      if (0 !== n6) return n6;
      switch (e3 & -e3) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return 4194176 & e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return 62914560 & e3;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), e3;
      }
    }
    function w(e3, n6) {
      var t4 = e3.pendingLanes;
      if (0 === t4) return 0;
      var r4 = 0, l3 = e3.suspendedLanes;
      e3 = e3.pingedLanes;
      var a4 = 134217727 & t4;
      return 0 !== a4 ? 0 != (t4 = a4 & ~l3) ? r4 = k2(t4) : 0 != (e3 &= a4) && (r4 = k2(e3)) : 0 != (t4 &= ~l3) ? r4 = k2(t4) : 0 !== e3 && (r4 = k2(e3)), 0 === r4 ? 0 : 0 !== n6 && n6 !== r4 && 0 == (n6 & l3) && ((l3 = r4 & -r4) >= (e3 = n6 & -n6) || 32 === l3 && 0 != (4194176 & e3)) ? n6 : r4;
    }
    function x(e3, n6) {
      switch (e3) {
        case 1:
        case 2:
        case 4:
        case 8:
          return n6 + 250;
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return n6 + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), -1;
      }
    }
    function z() {
      var e3 = Au;
      return 0 == (4194176 & (Au <<= 1)) && (Au = 128), e3;
    }
    function C() {
      var e3 = Qu;
      return 0 == (62914560 & (Qu <<= 1)) && (Qu = 4194304), e3;
    }
    function P(e3) {
      for (var n6 = [], t4 = 0; 31 > t4; t4++) n6.push(e3);
      return n6;
    }
    function E(e3, n6) {
      e3.pendingLanes |= n6, 268435456 !== n6 && (e3.suspendedLanes = 0, e3.pingedLanes = 0, e3.warmLanes = 0);
    }
    function _(e3, n6, t4) {
      e3.pendingLanes |= n6, e3.suspendedLanes &= ~n6;
      var r4 = 31 - ju(n6);
      e3.entangledLanes |= n6, e3.entanglements[r4] = 1073741824 | e3.entanglements[r4] | 4194218 & t4;
    }
    function R(e3, n6) {
      var t4 = e3.entangledLanes |= n6;
      for (e3 = e3.entanglements; t4; ) {
        var r4 = 31 - ju(t4), l3 = 1 << r4;
        l3 & n6 | e3[r4] & n6 && (e3[r4] |= n6), t4 &= ~l3;
      }
    }
    function T(e3, n6, t4) {
      if (ri) for (e3 = e3.pendingUpdatersLaneMap; 0 < t4; ) {
        var r4 = 31 - ju(t4), l3 = 1 << r4;
        e3[r4].add(n6), t4 &= ~l3;
      }
    }
    function N(e3, n6) {
      if (ri) for (var t4 = e3.pendingUpdatersLaneMap, r4 = e3.memoizedUpdaters; 0 < n6; ) {
        var l3 = 31 - ju(n6);
        e3 = 1 << l3, 0 < (l3 = t4[l3]).size && (l3.forEach(function(e4) {
          var n7 = e4.alternate;
          null !== n7 && r4.has(n7) || r4.add(e4);
        }), l3.clear()), n6 &= ~e3;
      }
    }
    function L(e3) {
      return 2 < (e3 &= -e3) ? 8 < e3 ? 0 != (134217727 & e3) ? 32 : 268435456 : 8 : 2;
    }
    function U(e3) {
      "function" == typeof Zu && ei(e3);
    }
    function I(e3, n6) {
      if ("object" == typeof e3 && null !== e3) {
        var t4 = ai.get(e3);
        return void 0 !== t4 ? t4 : (n6 = { value: e3, source: n6, stack: h2(n6) }, ai.set(e3, n6), n6);
      }
      return { value: e3, source: n6, stack: h2(n6) };
    }
    function D(e3) {
      for (; e3 === ii; ) ii = oi[--ui], oi[ui] = null, si = oi[--ui], oi[ui] = null;
      for (; e3 === di; ) di = ci[--fi], ci[fi] = null, mi = ci[--fi], ci[fi] = null, pi = ci[--fi], ci[fi] = null;
    }
    function F() {
      console.error("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    function M(e3) {
      return null === e3 && console.error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."), e3;
    }
    function H(e3, n6) {
      S2(yi, n6, e3), S2(gi, e3, e3), S2(hi, null, e3), n6 = Eo(n6), v2(hi, e3), S2(hi, n6, e3);
    }
    function j(e3) {
      v2(hi, e3), v2(gi, e3), v2(yi, e3);
    }
    function W() {
      return M(hi.current);
    }
    function O(e3) {
      null !== e3.memoizedState && S2(bi, e3, e3);
      var n6 = M(hi.current), t4 = _o(n6, e3.type);
      n6 !== t4 && (S2(gi, e3, e3), S2(hi, t4, e3));
    }
    function A(e3) {
      gi.current === e3 && (v2(hi, e3), v2(gi, e3)), bi.current === e3 && (v2(bi, e3), eu._currentValue2 = Zo);
    }
    function Q(e3, n6) {
      return void 0 === e3.serverProps && 0 === e3.serverTail.length && 1 === e3.children.length && 3 < e3.distanceFromLeaf && e3.distanceFromLeaf > 15 - n6 ? Q(e3.children[0], n6) : e3;
    }
    function B(e3) {
      return "  " + "  ".repeat(e3);
    }
    function V(e3) {
      return "+ " + "  ".repeat(e3);
    }
    function $(e3) {
      return "- " + "  ".repeat(e3);
    }
    function q(e3) {
      switch (e3.tag) {
        case 26:
        case 27:
        case 5:
          return e3.type;
        case 16:
          return "Lazy";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
        case 1:
          return (e3 = e3.type).displayName || e3.name || null;
        case 11:
          return (e3 = e3.type.render).displayName || e3.name || null;
        default:
          return null;
      }
    }
    function Y(e3, n6) {
      return vi.test(e3) ? (e3 = JSON.stringify(e3)).length > n6 - 2 ? 8 > n6 ? '{"..."}' : "{" + e3.slice(0, n6 - 7) + '..."}' : "{" + e3 + "}" : e3.length > n6 ? 5 > n6 ? '{"..."}' : e3.slice(0, n6 - 3) + "..." : e3;
    }
    function J(e3, n6, t4) {
      var r4 = 120 - 2 * t4;
      if (null === n6) return V(t4) + Y(e3, r4) + "\n";
      if ("string" == typeof n6) {
        for (var l3 = 0; l3 < n6.length && l3 < e3.length && n6.charCodeAt(l3) === e3.charCodeAt(l3); l3++) ;
        return l3 > r4 - 8 && 10 < l3 && (e3 = "..." + e3.slice(l3 - 8), n6 = "..." + n6.slice(l3 - 8)), V(t4) + Y(e3, r4) + "\n" + $(t4) + Y(n6, r4) + "\n";
      }
      return B(t4) + Y(e3, r4) + "\n";
    }
    function G2(e3) {
      return Object.prototype.toString.call(e3).replace(/^\[object (.*)\]$/, function(e4, n6) {
        return n6;
      });
    }
    function K(e3, n6) {
      switch (typeof e3) {
        case "string":
          return (e3 = JSON.stringify(e3)).length > n6 ? 5 > n6 ? '"..."' : e3.slice(0, n6 - 4) + '..."' : e3;
        case "object":
          if (null === e3) return "null";
          if (Co(e3)) return "[...]";
          if (e3.$$typeof === Za) return (n6 = s2(e3.type)) ? "<" + n6 + ">" : "<...>";
          var t4 = G2(e3);
          if ("Object" === t4) {
            for (var r4 in t4 = "", n6 -= 2, e3) if (e3.hasOwnProperty(r4)) {
              var l3 = JSON.stringify(r4);
              if (l3 !== '"' + r4 + '"' && (r4 = l3), n6 -= r4.length - 2, 0 > (n6 -= (l3 = K(e3[r4], 15 > n6 ? n6 : 15)).length)) {
                t4 += "" === t4 ? "..." : ", ...";
                break;
              }
              t4 += ("" === t4 ? "" : ",") + r4 + ":" + l3;
            }
            return "{" + t4 + "}";
          }
          return t4;
        case "function":
          return (n6 = e3.displayName || e3.name) ? "function " + n6 : "function";
        default:
          return String(e3);
      }
    }
    function X(e3, n6) {
      return "string" != typeof e3 || vi.test(e3) ? "{" + K(e3, n6 - 2) + "}" : e3.length > n6 - 2 ? 5 > n6 ? '"..."' : '"' + e3.slice(0, n6 - 5) + '..."' : '"' + e3 + '"';
    }
    function Z(e3, n6, t4) {
      var r4, l3 = 120 - t4.length - e3.length, a4 = [];
      for (r4 in n6) if (n6.hasOwnProperty(r4) && "children" !== r4) {
        var o3 = X(n6[r4], 120 - t4.length - r4.length - 1);
        l3 -= r4.length + o3.length + 2, a4.push(r4 + "=" + o3);
      }
      return 0 === a4.length ? t4 + "<" + e3 + ">\n" : 0 < l3 ? t4 + "<" + e3 + " " + a4.join(" ") + ">\n" : t4 + "<" + e3 + "\n" + t4 + "  " + a4.join("\n" + t4 + "  ") + "\n" + t4 + ">\n";
    }
    function ee(e3, n6, t4) {
      var r4, l3 = "", a4 = Ka({}, n6);
      for (r4 in e3) if (e3.hasOwnProperty(r4)) {
        delete a4[r4];
        var o3 = 120 - 2 * t4 - r4.length - 2, u3 = K(e3[r4], o3);
        n6.hasOwnProperty(r4) ? (o3 = K(n6[r4], o3), l3 += V(t4) + r4 + ": " + u3 + "\n", l3 += $(t4) + r4 + ": " + o3 + "\n") : l3 += V(t4) + r4 + ": " + u3 + "\n";
      }
      for (var i4 in a4) a4.hasOwnProperty(i4) && (e3 = K(a4[i4], 120 - 2 * t4 - i4.length - 2), l3 += $(t4) + i4 + ": " + e3 + "\n");
      return l3;
    }
    function ne(e3, n6) {
      var t4 = q(e3);
      if (null === t4) {
        for (t4 = "", e3 = e3.child; e3; ) t4 += ne(e3, n6), e3 = e3.sibling;
        return t4;
      }
      return B(n6) + "<" + t4 + ">\n";
    }
    function te(e3, n6) {
      var t4 = Q(e3, n6);
      if (t4 !== e3 && (1 !== e3.children.length || e3.children[0] !== t4)) return B(n6) + "...\n" + te(t4, n6 + 1);
      t4 = "";
      var r4 = e3.fiber._debugInfo;
      if (r4) for (var l3 = 0; l3 < r4.length; l3++) {
        var a4 = r4[l3].name;
        "string" == typeof a4 && (t4 += B(n6) + "<" + a4 + ">\n", n6++);
      }
      if (r4 = "", l3 = e3.fiber.pendingProps, 6 === e3.fiber.tag) r4 = J(l3, e3.serverProps, n6), n6++;
      else if (null !== (a4 = q(e3.fiber))) if (void 0 === e3.serverProps) {
        var o3 = 120 - 2 * (r4 = n6) - a4.length - 2, u3 = "";
        for (s3 in l3) if (l3.hasOwnProperty(s3) && "children" !== s3) {
          var i4 = X(l3[s3], 15);
          if (0 > (o3 -= s3.length + i4.length + 2)) {
            u3 += " ...";
            break;
          }
          u3 += " " + s3 + "=" + i4;
        }
        r4 = B(r4) + "<" + a4 + u3 + ">\n", n6++;
      } else null === e3.serverProps ? (r4 = Z(a4, l3, V(n6)), n6++) : "string" == typeof e3.serverProps ? console.error("Should not have matched a non HostText fiber to a Text node. This is a bug in React.") : (r4 = function(e4, n7, t5, r5) {
        var l4 = "", a5 = /* @__PURE__ */ new Map();
        for (s4 in t5) t5.hasOwnProperty(s4) && a5.set(s4.toLowerCase(), s4);
        if (1 === a5.size && a5.has("children")) l4 += Z(e4, n7, B(r5));
        else {
          for (var o4 in n7) if (n7.hasOwnProperty(o4) && "children" !== o4) {
            var u4 = 120 - 2 * (r5 + 1) - o4.length - 1, i5 = a5.get(o4.toLowerCase());
            if (void 0 !== i5) {
              a5.delete(o4.toLowerCase());
              var s4 = n7[o4];
              i5 = t5[i5];
              var c4 = X(s4, u4);
              u4 = X(i5, u4), "object" == typeof s4 && null !== s4 && "object" == typeof i5 && null !== i5 && "Object" === G2(s4) && "Object" === G2(i5) && (2 < Object.keys(s4).length || 2 < Object.keys(i5).length || -1 < c4.indexOf("...") || -1 < u4.indexOf("...")) ? l4 += B(r5 + 1) + o4 + "={{\n" + ee(s4, i5, r5 + 2) + B(r5 + 1) + "}}\n" : (l4 += V(r5 + 1) + o4 + "=" + c4 + "\n", l4 += $(r5 + 1) + o4 + "=" + u4 + "\n");
            } else l4 += B(r5 + 1) + o4 + "=" + X(n7[o4], u4) + "\n";
          }
          a5.forEach(function(e5) {
            if ("children" !== e5) {
              var n8 = 120 - 2 * (r5 + 1) - e5.length - 1;
              l4 += $(r5 + 1) + e5 + "=" + X(t5[e5], n8) + "\n";
            }
          }), l4 = "" === l4 ? B(r5) + "<" + e4 + ">\n" : B(r5) + "<" + e4 + "\n" + l4 + B(r5) + ">\n";
        }
        return e4 = t5.children, n7 = n7.children, "string" == typeof e4 || "number" == typeof e4 || "bigint" == typeof e4 ? (a5 = "", "string" != typeof n7 && "number" != typeof n7 && "bigint" != typeof n7 || (a5 = "" + n7), l4 += J(a5, "" + e4, r5 + 1)) : "string" != typeof n7 && "number" != typeof n7 && "bigint" != typeof n7 || (l4 = null == e4 ? l4 + J("" + n7, null, r5 + 1) : l4 + J("" + n7, void 0, r5 + 1)), l4;
      }(a4, l3, e3.serverProps, n6), n6++);
      var s3 = "";
      for (l3 = e3.fiber.child, a4 = 0; l3 && a4 < e3.children.length; ) (o3 = e3.children[a4]).fiber === l3 ? (s3 += te(o3, n6), a4++) : s3 += ne(l3, n6), l3 = l3.sibling;
      for (l3 && 0 < e3.children.length && (s3 += B(n6) + "...\n"), l3 = e3.serverTail, null === e3.serverProps && n6--, e3 = 0; e3 < l3.length; e3++) s3 = "string" == typeof (a4 = l3[e3]) ? s3 + ($(n6) + Y(a4, 120 - 2 * n6) + "\n") : s3 + Z(a4.type, a4.props, $(n6));
      return t4 + r4 + s3;
    }
    function re(e3) {
      try {
        return "\n\n" + te(e3, 0);
      } catch (e4) {
        return "";
      }
    }
    function le(e3, n6) {
      if (null === e3.return) {
        if (null === wi) wi = { fiber: e3, children: [], serverProps: void 0, serverTail: [], distanceFromLeaf: n6 };
        else {
          if (wi.fiber !== e3) throw Error("Saw multiple hydration diff roots in a pass. This is a bug in React.");
          wi.distanceFromLeaf > n6 && (wi.distanceFromLeaf = n6);
        }
        return wi;
      }
      var t4 = le(e3.return, n6 + 1).children;
      return 0 < t4.length && t4[t4.length - 1].fiber === e3 ? ((t4 = t4[t4.length - 1]).distanceFromLeaf > n6 && (t4.distanceFromLeaf = n6), t4) : (n6 = { fiber: e3, children: [], serverProps: void 0, serverTail: [], distanceFromLeaf: n6 }, t4.push(n6), n6);
    }
    function ae(e3, n6) {
      (e3 = le(e3, 0)).serverProps = null, null !== n6 && (n6 = _u(n6), e3.serverTail.push(n6));
    }
    function oe(e3) {
      var n6 = "", t4 = wi;
      throw null !== t4 && (wi = null, n6 = re(t4)), ue(I(Error("Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + n6), e3)), Ci;
    }
    function ue(e3) {
      null === xi ? xi = [e3] : xi.push(e3);
    }
    function ie() {
      var e3 = wi;
      null !== e3 && (wi = null, e3 = re(e3), console.error("A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s", "https://react.dev/link/hydration-mismatch", e3));
    }
    function se() {
      for (var e3 = _i, n6 = Ri = _i = 0; n6 < e3; ) {
        var t4 = Ei[n6];
        Ei[n6++] = null;
        var r4 = Ei[n6];
        Ei[n6++] = null;
        var l3 = Ei[n6];
        Ei[n6++] = null;
        var a4 = Ei[n6];
        if (Ei[n6++] = null, null !== r4 && null !== l3) {
          var o3 = r4.pending;
          null === o3 ? l3.next = l3 : (l3.next = o3.next, o3.next = l3), r4.pending = l3;
        }
        0 !== a4 && pe(t4, l3, a4);
      }
    }
    function ce(e3, n6, t4, r4) {
      Ei[_i++] = e3, Ei[_i++] = n6, Ei[_i++] = t4, Ei[_i++] = r4, Ri |= r4, e3.lanes |= r4, null !== (e3 = e3.alternate) && (e3.lanes |= r4);
    }
    function fe(e3, n6, t4, r4) {
      return ce(e3, n6, t4, r4), me(e3);
    }
    function de(e3, n6) {
      return ce(e3, null, null, n6), me(e3);
    }
    function pe(e3, n6, t4) {
      e3.lanes |= t4;
      var r4 = e3.alternate;
      null !== r4 && (r4.lanes |= t4);
      for (var l3 = false, a4 = e3.return; null !== a4; ) a4.childLanes |= t4, null !== (r4 = a4.alternate) && (r4.childLanes |= t4), 22 === a4.tag && (null === (e3 = a4.stateNode) || 1 & e3._visibility || (l3 = true)), e3 = a4, a4 = a4.return;
      l3 && null !== n6 && 3 === e3.tag && (a4 = e3.stateNode, l3 = 31 - ju(t4), null === (e3 = (a4 = a4.hiddenUpdates)[l3]) ? a4[l3] = [n6] : e3.push(n6), n6.lane = 536870912 | t4);
    }
    function me(e3) {
      if (_d > Ed) throw Ud = _d = 0, Id = Rd = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Ud > Ld && (Ud = 0, Id = null, console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.")), null === e3.alternate && 0 != (4098 & e3.flags) && Ea(e3);
      for (var n6 = e3, t4 = n6.return; null !== t4; ) null === n6.alternate && 0 != (4098 & n6.flags) && Ea(e3), t4 = (n6 = t4).return;
      return 3 === n6.tag ? n6.stateNode : null;
    }
    function he() {
      var e3 = Ui;
      return Ui = 0, e3;
    }
    function ge(e3) {
      var n6 = Ui;
      return Ui = e3, n6;
    }
    function ye(e3) {
      var n6 = Ui;
      return Ui += e3, n6;
    }
    function be(e3) {
      Li = Ti(), 0 > e3.actualStartTime && (e3.actualStartTime = Li);
    }
    function ve(e3) {
      if (0 <= Li) {
        var n6 = Ti() - Li;
        e3.actualDuration += n6, e3.selfBaseDuration = n6, Li = -1;
      }
    }
    function Se(e3) {
      if (0 <= Li) {
        var n6 = Ti() - Li;
        e3.actualDuration += n6, Li = -1;
      }
    }
    function ke() {
      if (0 <= Li) {
        var e3 = Ti() - Li;
        Li = -1, Ui += e3;
      }
    }
    function we() {
      Li = Ti();
    }
    function xe(e3) {
      for (var n6 = e3.child; n6; ) e3.actualDuration += n6.actualDuration, n6 = n6.sibling;
    }
    function ze(e3) {
      e3 !== Mi && null === e3.next && (null === Mi ? Fi = Mi = e3 : Mi = Mi.next = e3), Wi = true, null !== yo.actQueue ? ji || (ji = true, Ne(Pe)) : Hi || (Hi = true, Ne(Pe));
    }
    function Ce(e3, n6) {
      if (!Oi && Wi) {
        Oi = true;
        do {
          for (var t4 = false, r4 = Fi; null !== r4; ) {
            if (0 !== e3) {
              var l3 = r4.pendingLanes;
              if (0 === l3) var a4 = 0;
              else {
                var o3 = r4.suspendedLanes, u3 = r4.pingedLanes;
                a4 = (1 << 31 - ju(42 | e3) + 1) - 1, a4 = 201326677 & (a4 &= l3 & ~(o3 & ~u3)) ? 201326677 & a4 | 1 : a4 ? 2 | a4 : 0;
              }
              0 !== a4 && (t4 = true, Re(r4, a4));
            } else a4 = $f, 0 != (3 & (a4 = w(r4, r4 === Bf ? a4 : 0))) && (t4 = true, Re(r4, a4));
            r4 = r4.next;
          }
        } while (t4);
        Oi = false;
      }
    }
    function Pe() {
      Wi = ji = Hi = false;
      var e3 = 0;
      0 !== Ai && ($o() && (e3 = Ai), Ai = 0);
      for (var n6 = Yu(), t4 = null, r4 = Fi; null !== r4; ) {
        var l3 = r4.next, a4 = Ee(r4, n6);
        0 === a4 ? (r4.next = null, null === t4 ? Fi = l3 : t4.next = l3, null === l3 && (Mi = t4)) : (t4 = r4, (0 !== e3 || 0 != (3 & a4)) && (Wi = true)), r4 = l3;
      }
      Ce(e3);
    }
    function Ee(e3, n6) {
      for (var t4 = e3.suspendedLanes, r4 = e3.pingedLanes, l3 = e3.expirationTimes, a4 = -62914561 & e3.pendingLanes; 0 < a4; ) {
        var o3 = 31 - ju(a4), u3 = 1 << o3, i4 = l3[o3];
        -1 === i4 ? 0 != (u3 & t4) && 0 == (u3 & r4) || (l3[o3] = x(u3, n6)) : i4 <= n6 && (e3.expiredLanes |= u3), a4 &= ~u3;
      }
      if (t4 = $f, t4 = w(e3, e3 === (n6 = Bf) ? t4 : 0), r4 = e3.callbackNode, 0 === t4 || e3 === n6 && td === Jf || null !== e3.cancelPendingCommit) return null !== r4 && Te(r4), e3.callbackNode = null, e3.callbackPriority = 0;
      if (0 != (3 & t4)) return null !== r4 && Te(r4), e3.callbackPriority = 2, e3.callbackNode = null, 2;
      if ((n6 = t4 & -t4) === e3.callbackPriority && (null === yo.actQueue || r4 === Qi)) return n6;
      switch (Te(r4), L(t4)) {
        case 2:
          t4 = Ju;
          break;
        case 8:
          t4 = Gu;
          break;
        case 32:
        default:
          t4 = Ku;
          break;
        case 268435456:
          t4 = Xu;
      }
      return r4 = _e.bind(null, e3), null !== yo.actQueue ? (yo.actQueue.push(r4), t4 = Qi) : t4 = Bu(t4, r4), e3.callbackPriority = n6, e3.callbackNode = t4, n6;
    }
    function _e(e3, n6) {
      Di = Ii = false;
      var t4 = e3.callbackNode;
      if (ga() && e3.callbackNode !== t4) return null;
      var r4 = $f;
      return 0 === (r4 = w(e3, e3 === Bf ? r4 : 0)) ? null : ($l(e3, r4, n6), Ee(e3, Yu()), e3.callbackNode === t4 ? _e.bind(null, e3) : null);
    }
    function Re(e3, n6) {
      if (ga()) return null;
      Ii = Di, Di = false, $l(e3, n6, true);
    }
    function Te(e3) {
      e3 !== Qi && null !== e3 && Vu(e3);
    }
    function Ne(e3) {
      null !== yo.actQueue && yo.actQueue.push(function() {
        return e3(), null;
      }), Bu(Ju, e3);
    }
    function Le() {
      return 0 === Ai && (Ai = z()), Ai;
    }
    function Ue() {
      if (0 == --Vi && null !== Bi) {
        null !== qi && (qi.status = "fulfilled");
        var e3 = Bi;
        Bi = null, $i = 0, qi = null;
        for (var n6 = 0; n6 < e3.length; n6++) (0, e3[n6])();
      }
    }
    function Ie(e3) {
      e3.updateQueue = { baseState: e3.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null };
    }
    function De(e3, n6) {
      e3 = e3.updateQueue, n6.updateQueue === e3 && (n6.updateQueue = { baseState: e3.baseState, firstBaseUpdate: e3.firstBaseUpdate, lastBaseUpdate: e3.lastBaseUpdate, shared: e3.shared, callbacks: null });
    }
    function Fe(e3) {
      return { lane: e3, tag: Yi, payload: null, callback: null, next: null };
    }
    function Me(e3, n6, t4) {
      var r4 = e3.updateQueue;
      if (null === r4) return null;
      if (r4 = r4.shared, es === r4 && !Zi) {
        var l3 = c3(e3);
        console.error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s", l3), Zi = true;
      }
      return (Qf & If) !== Uf ? (null === (l3 = r4.pending) ? n6.next = n6 : (n6.next = l3.next, l3.next = n6), r4.pending = n6, n6 = me(e3), pe(e3, null, t4), n6) : (ce(e3, r4, n6, t4), me(e3));
    }
    function He(e3, n6, t4) {
      if (null !== (n6 = n6.updateQueue) && (n6 = n6.shared, 0 != (4194176 & t4))) {
        var r4 = n6.lanes;
        t4 |= r4 &= e3.pendingLanes, n6.lanes = t4, R(e3, t4);
      }
    }
    function je(e3, n6) {
      var t4 = e3.updateQueue, r4 = e3.alternate;
      if (null !== r4 && t4 === (r4 = r4.updateQueue)) {
        var l3 = null, a4 = null;
        if (null !== (t4 = t4.firstBaseUpdate)) {
          do {
            var o3 = { lane: t4.lane, tag: t4.tag, payload: t4.payload, callback: null, next: null };
            null === a4 ? l3 = a4 = o3 : a4 = a4.next = o3, t4 = t4.next;
          } while (null !== t4);
          null === a4 ? l3 = a4 = n6 : a4 = a4.next = n6;
        } else l3 = a4 = n6;
        return t4 = { baseState: r4.baseState, firstBaseUpdate: l3, lastBaseUpdate: a4, shared: r4.shared, callbacks: r4.callbacks }, void (e3.updateQueue = t4);
      }
      null === (e3 = t4.lastBaseUpdate) ? t4.firstBaseUpdate = n6 : e3.next = n6, t4.lastBaseUpdate = n6;
    }
    function We() {
      if (ns && null !== qi) throw qi;
    }
    function Oe(e3, n6, t4, r4) {
      ns = false;
      var l3 = e3.updateQueue;
      Xi = false, es = l3.shared;
      var a4 = l3.firstBaseUpdate, o3 = l3.lastBaseUpdate, u3 = l3.shared.pending;
      if (null !== u3) {
        l3.shared.pending = null;
        var i4 = u3, s3 = i4.next;
        i4.next = null, null === o3 ? a4 = s3 : o3.next = s3, o3 = i4;
        var c4 = e3.alternate;
        null !== c4 && (u3 = (c4 = c4.updateQueue).lastBaseUpdate) !== o3 && (null === u3 ? c4.firstBaseUpdate = s3 : u3.next = s3, c4.lastBaseUpdate = i4);
      }
      if (null !== a4) {
        var f3 = l3.baseState;
        for (o3 = 0, c4 = s3 = i4 = null, u3 = a4; ; ) {
          var d3 = -536870913 & u3.lane, p3 = d3 !== u3.lane;
          if (p3 ? ($f & d3) === d3 : (r4 & d3) === d3) {
            0 !== d3 && d3 === $i && (ns = true), null !== c4 && (c4 = c4.next = { lane: 0, tag: u3.tag, payload: u3.payload, callback: null, next: null });
            e: {
              d3 = e3;
              var m2 = u3, h3 = n6, g3 = t4;
              switch (m2.tag) {
                case Ji:
                  if ("function" == typeof (m2 = m2.payload)) {
                    cf = true;
                    var y3 = m2.call(g3, f3, h3);
                    if (8 & d3.mode) {
                      U(true);
                      try {
                        m2.call(g3, f3, h3);
                      } finally {
                        U(false);
                      }
                    }
                    cf = false, f3 = y3;
                    break e;
                  }
                  f3 = m2;
                  break e;
                case Ki:
                  d3.flags = -65537 & d3.flags | 128;
                case Yi:
                  if ("function" == typeof (y3 = m2.payload)) {
                    if (cf = true, m2 = y3.call(g3, f3, h3), 8 & d3.mode) {
                      U(true);
                      try {
                        y3.call(g3, f3, h3);
                      } finally {
                        U(false);
                      }
                    }
                    cf = false;
                  } else m2 = y3;
                  if (null == m2) break e;
                  f3 = Ka({}, f3, m2);
                  break e;
                case Gi:
                  Xi = true;
              }
            }
            null !== (d3 = u3.callback) && (e3.flags |= 64, p3 && (e3.flags |= 8192), null === (p3 = l3.callbacks) ? l3.callbacks = [d3] : p3.push(d3));
          } else p3 = { lane: d3, tag: u3.tag, payload: u3.payload, callback: u3.callback, next: null }, null === c4 ? (s3 = c4 = p3, i4 = f3) : c4 = c4.next = p3, o3 |= d3;
          if (null === (u3 = u3.next)) {
            if (null === (u3 = l3.shared.pending)) break;
            u3 = (p3 = u3).next, p3.next = null, l3.lastBaseUpdate = p3, l3.shared.pending = null;
          }
        }
        null === c4 && (i4 = f3), l3.baseState = i4, l3.firstBaseUpdate = s3, l3.lastBaseUpdate = c4, null === a4 && (l3.shared.lanes = 0), id |= o3, e3.lanes = o3, e3.memoizedState = f3;
      }
      es = null;
    }
    function Ae(e3, n6) {
      if ("function" != typeof e3) throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + e3);
      e3.call(n6);
    }
    function Qe(e3, n6) {
      var t4 = e3.shared.hiddenCallbacks;
      if (null !== t4) for (e3.shared.hiddenCallbacks = null, e3 = 0; e3 < t4.length; e3++) Ae(t4[e3], n6);
    }
    function Be(e3, n6) {
      var t4 = e3.callbacks;
      if (null !== t4) for (e3.callbacks = null, e3 = 0; e3 < t4.length; e3++) Ae(t4[e3], n6);
    }
    function Ve(e3, n6) {
      if (li(e3, n6)) return true;
      if ("object" != typeof e3 || null === e3 || "object" != typeof n6 || null === n6) return false;
      var t4 = Object.keys(e3), r4 = Object.keys(n6);
      if (t4.length !== r4.length) return false;
      for (r4 = 0; r4 < t4.length; r4++) {
        var l3 = t4[r4];
        if (!ts.call(n6, l3) || !li(e3[l3], n6[l3])) return false;
      }
      return true;
    }
    function $e(e3) {
      return "fulfilled" === (e3 = e3.status) || "rejected" === e3;
    }
    function qe() {
    }
    function Ye(e3, n6, t4) {
      null !== yo.actQueue && (yo.didUsePromise = true);
      var r4 = e3.thenables;
      switch (void 0 === (t4 = r4[t4]) ? r4.push(n6) : t4 !== n6 && (e3.didWarnAboutUncachedPromise || (e3.didWarnAboutUncachedPromise = true, console.error("A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.")), n6.then(qe, qe), n6 = t4), n6.status) {
        case "fulfilled":
          return n6.value;
        case "rejected":
          throw Ge(e3 = n6.reason), e3;
        default:
          if ("string" == typeof n6.status) n6.then(qe, qe);
          else {
            if (null !== (e3 = Bf) && 100 < e3.shellSuspendCounter) throw Error("async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
            (e3 = n6).status = "pending", e3.then(function(e4) {
              if ("pending" === n6.status) {
                var t5 = n6;
                t5.status = "fulfilled", t5.value = e4;
              }
            }, function(e4) {
              if ("pending" === n6.status) {
                var t5 = n6;
                t5.status = "rejected", t5.reason = e4;
              }
            });
          }
          switch (n6.status) {
            case "fulfilled":
              return n6.value;
            case "rejected":
              throw Ge(e3 = n6.reason), e3;
          }
          throw ys = n6, bs = true, ms;
      }
    }
    function Je() {
      if (null === ys) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
      var e3 = ys;
      return ys = null, bs = false, e3;
    }
    function Ge(e3) {
      if (e3 === ms) throw Error("Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
    }
    function Ke(e3) {
      var n6 = js;
      return null != e3 && (js = null === n6 ? e3 : n6.concat(e3)), n6;
    }
    function Xe(e3, n6, t4) {
      for (var r4 = Object.keys(e3.props), l3 = 0; l3 < r4.length; l3++) {
        var a4 = r4[l3];
        if ("children" !== a4 && "key" !== a4) {
          null === n6 && ((n6 = Ia(e3, t4.mode, 0))._debugInfo = js, n6.return = t4), y2(n6, function(e4) {
            console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", e4);
          }, a4);
          break;
        }
      }
    }
    function Ze(e3) {
      var n6 = Hs;
      return Hs += 1, null === Ms && (Ms = { didWarnAboutUncachedPromise: false, thenables: [] }), Ye(Ms, e3, n6);
    }
    function en(e3, n6, t4, r4) {
      e3 = r4.props.ref, t4.ref = void 0 !== e3 ? e3 : null;
    }
    function nn(e3, n6) {
      if (n6.$$typeof === Xa) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.');
      throw e3 = Object.prototype.toString.call(n6), Error("Objects are not valid as a React child (found: " + ("[object Object]" === e3 ? "object with keys {" + Object.keys(n6).join(", ") + "}" : e3) + "). If you meant to render a collection of children, use an array instead.");
    }
    function tn(e3, n6) {
      var t4 = c3(e3) || "Component";
      As[t4] || (As[t4] = true, n6 = n6.displayName || n6.name || "Component", 3 === e3.tag ? console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)", n6, n6, n6) : console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>", n6, n6, t4, n6, t4));
    }
    function rn(e3, n6) {
      var t4 = c3(e3) || "Component";
      Qs[t4] || (Qs[t4] = true, n6 = String(n6), 3 === e3.tag ? console.error("Symbols are not valid as a React child.\n  root.render(%s)", n6) : console.error("Symbols are not valid as a React child.\n  <%s>%s</%s>", t4, n6, t4));
    }
    function ln(e3) {
      function n6(n7, t4) {
        if (e3) {
          var r5 = n7.deletions;
          null === r5 ? (n7.deletions = [t4], n7.flags |= 16) : r5.push(t4);
        }
      }
      function r4(t4, r5) {
        if (!e3) return null;
        for (; null !== r5; ) n6(t4, r5), r5 = r5.sibling;
        return null;
      }
      function l3(e4) {
        for (var n7 = /* @__PURE__ */ new Map(); null !== e4; ) null !== e4.key ? n7.set(e4.key, e4) : n7.set(e4.index, e4), e4 = e4.sibling;
        return n7;
      }
      function o3(e4, n7) {
        return (e4 = Na(e4, n7)).index = 0, e4.sibling = null, e4;
      }
      function u3(n7, t4, r5) {
        return n7.index = r5, e3 ? null !== (r5 = n7.alternate) ? (r5 = r5.index) < t4 ? (n7.flags |= 33554434, t4) : r5 : (n7.flags |= 33554434, t4) : (n7.flags |= 1048576, t4);
      }
      function s3(n7) {
        return e3 && null === n7.alternate && (n7.flags |= 33554434), n7;
      }
      function c4(e4, n7, t4, r5) {
        return null === n7 || 6 !== n7.tag ? ((n7 = Ma(t4, e4.mode, r5)).return = e4, n7._debugOwner = e4, n7._debugInfo = js, n7) : ((n7 = o3(n7, t4)).return = e4, n7._debugInfo = js, n7);
      }
      function f3(e4, n7, t4, r5) {
        var l4 = t4.type;
        return l4 === no ? (Xe(t4, n7 = p3(e4, n7, t4.props.children, r5, t4.key), e4), n7) : null !== n7 && (n7.elementType === l4 || "object" == typeof l4 && null !== l4 && l4.$$typeof === fo && Fs(l4) === n7.type) ? (en(e4, 0, r5 = o3(n7, t4.props), t4), r5.return = e4, r5._debugOwner = t4._owner, r5._debugInfo = js, r5) : (en(e4, 0, r5 = Ia(t4, e4.mode, r5), t4), r5.return = e4, r5._debugInfo = js, r5);
      }
      function d3(e4, n7, t4, r5) {
        return null === n7 || 4 !== n7.tag || n7.stateNode.containerInfo !== t4.containerInfo || n7.stateNode.implementation !== t4.implementation ? ((n7 = Ha(t4, e4.mode, r5)).return = e4, n7._debugInfo = js, n7) : ((n7 = o3(n7, t4.children || [])).return = e4, n7._debugInfo = js, n7);
      }
      function p3(e4, n7, t4, r5, l4) {
        return null === n7 || 7 !== n7.tag ? ((n7 = Da(t4, e4.mode, r5, l4)).return = e4, n7._debugOwner = e4, n7._debugInfo = js, n7) : ((n7 = o3(n7, t4)).return = e4, n7._debugInfo = js, n7);
      }
      function m2(e4, n7, t4) {
        if ("string" == typeof n7 && "" !== n7 || "number" == typeof n7 || "bigint" == typeof n7) return (n7 = Ma("" + n7, e4.mode, t4)).return = e4, n7._debugOwner = e4, n7._debugInfo = js, n7;
        if ("object" == typeof n7 && null !== n7) {
          switch (n7.$$typeof) {
            case Za:
              return en(e4, 0, t4 = Ia(n7, e4.mode, t4), n7), t4.return = e4, e4 = Ke(n7._debugInfo), t4._debugInfo = js, js = e4, t4;
            case eo:
              return (n7 = Ha(n7, e4.mode, t4)).return = e4, n7._debugInfo = js, n7;
            case fo:
              var r5 = Ke(n7._debugInfo);
              return e4 = m2(e4, n7 = Fs(n7), t4), js = r5, e4;
          }
          if (Co(n7) || i3(n7)) return (t4 = Da(n7, e4.mode, t4, null)).return = e4, t4._debugOwner = e4, e4 = Ke(n7._debugInfo), t4._debugInfo = js, js = e4, t4;
          if ("function" == typeof n7.then) return r5 = Ke(n7._debugInfo), e4 = m2(e4, Ze(n7), t4), js = r5, e4;
          if (n7.$$typeof === oo) return m2(e4, Tr(e4, n7), t4);
          nn(e4, n7);
        }
        return "function" == typeof n7 && tn(e4, n7), "symbol" == typeof n7 && rn(e4, n7), null;
      }
      function h3(e4, n7, t4, r5) {
        var l4 = null !== n7 ? n7.key : null;
        if ("string" == typeof t4 && "" !== t4 || "number" == typeof t4 || "bigint" == typeof t4) return null !== l4 ? null : c4(e4, n7, "" + t4, r5);
        if ("object" == typeof t4 && null !== t4) {
          switch (t4.$$typeof) {
            case Za:
              return t4.key === l4 ? (l4 = Ke(t4._debugInfo), e4 = f3(e4, n7, t4, r5), js = l4, e4) : null;
            case eo:
              return t4.key === l4 ? d3(e4, n7, t4, r5) : null;
            case fo:
              return l4 = Ke(t4._debugInfo), e4 = h3(e4, n7, t4 = Fs(t4), r5), js = l4, e4;
          }
          if (Co(t4) || i3(t4)) return null !== l4 ? null : (l4 = Ke(t4._debugInfo), e4 = p3(e4, n7, t4, r5, null), js = l4, e4);
          if ("function" == typeof t4.then) return l4 = Ke(t4._debugInfo), e4 = h3(e4, n7, Ze(t4), r5), js = l4, e4;
          if (t4.$$typeof === oo) return h3(e4, n7, Tr(e4, t4), r5);
          nn(e4, t4);
        }
        return "function" == typeof t4 && tn(e4, t4), "symbol" == typeof t4 && rn(e4, t4), null;
      }
      function g3(e4, n7, t4, r5, l4) {
        if ("string" == typeof r5 && "" !== r5 || "number" == typeof r5 || "bigint" == typeof r5) return c4(n7, e4 = e4.get(t4) || null, "" + r5, l4);
        if ("object" == typeof r5 && null !== r5) {
          switch (r5.$$typeof) {
            case Za:
              return t4 = e4.get(null === r5.key ? t4 : r5.key) || null, e4 = Ke(r5._debugInfo), n7 = f3(n7, t4, r5, l4), js = e4, n7;
            case eo:
              return d3(n7, e4 = e4.get(null === r5.key ? t4 : r5.key) || null, r5, l4);
            case fo:
              var a4 = Ke(r5._debugInfo);
              return n7 = g3(e4, n7, t4, r5 = Fs(r5), l4), js = a4, n7;
          }
          if (Co(r5) || i3(r5)) return t4 = e4.get(t4) || null, e4 = Ke(r5._debugInfo), n7 = p3(n7, t4, r5, l4, null), js = e4, n7;
          if ("function" == typeof r5.then) return a4 = Ke(r5._debugInfo), n7 = g3(e4, n7, t4, Ze(r5), l4), js = a4, n7;
          if (r5.$$typeof === oo) return g3(e4, n7, t4, Tr(n7, r5), l4);
          nn(n7, r5);
        }
        return "function" == typeof r5 && tn(n7, r5), "symbol" == typeof r5 && rn(n7, r5), null;
      }
      function b3(e4, n7, t4, r5) {
        if ("object" != typeof t4 || null === t4) return r5;
        switch (t4.$$typeof) {
          case Za:
          case eo:
            a3(e4, n7, t4);
            var l4 = t4.key;
            if ("string" != typeof l4) break;
            if (null === r5) {
              (r5 = /* @__PURE__ */ new Set()).add(l4);
              break;
            }
            if (!r5.has(l4)) {
              r5.add(l4);
              break;
            }
            y2(n7, function() {
              console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", l4);
            });
            break;
          case fo:
            b3(e4, n7, t4 = Fs(t4), r5);
        }
        return r5;
      }
      function v3(t4, a4, c5, f4) {
        if ("object" == typeof c5 && null !== c5 && c5.type === no && null === c5.key && (Xe(c5, null, t4), c5 = c5.props.children), "object" == typeof c5 && null !== c5) {
          switch (c5.$$typeof) {
            case Za:
              var d4 = Ke(c5._debugInfo);
              e: {
                for (var p4 = c5.key, y3 = a4; null !== y3; ) {
                  if (y3.key === p4) {
                    if ((p4 = c5.type) === no) {
                      if (7 === y3.tag) {
                        r4(t4, y3.sibling), (a4 = o3(y3, c5.props.children)).return = t4, a4._debugOwner = c5._owner, a4._debugInfo = js, Xe(c5, a4, t4), t4 = a4;
                        break e;
                      }
                    } else if (y3.elementType === p4 || "object" == typeof p4 && null !== p4 && p4.$$typeof === fo && Fs(p4) === y3.type) {
                      r4(t4, y3.sibling), en(t4, 0, a4 = o3(y3, c5.props), c5), a4.return = t4, a4._debugOwner = c5._owner, a4._debugInfo = js, t4 = a4;
                      break e;
                    }
                    r4(t4, y3);
                    break;
                  }
                  n6(t4, y3), y3 = y3.sibling;
                }
                c5.type === no ? ((a4 = Da(c5.props.children, t4.mode, f4, c5.key)).return = t4, a4._debugOwner = t4, a4._debugInfo = js, Xe(c5, a4, t4), t4 = a4) : (en(t4, 0, f4 = Ia(c5, t4.mode, f4), c5), f4.return = t4, f4._debugInfo = js, t4 = f4);
              }
              return t4 = s3(t4), js = d4, t4;
            case eo:
              e: {
                for (c5 = (d4 = c5).key; null !== a4; ) {
                  if (a4.key === c5) {
                    if (4 === a4.tag && a4.stateNode.containerInfo === d4.containerInfo && a4.stateNode.implementation === d4.implementation) {
                      r4(t4, a4.sibling), (a4 = o3(a4, d4.children || [])).return = t4, t4 = a4;
                      break e;
                    }
                    r4(t4, a4);
                    break;
                  }
                  n6(t4, a4), a4 = a4.sibling;
                }
                (a4 = Ha(d4, t4.mode, f4)).return = t4, t4 = a4;
              }
              return s3(t4);
            case fo:
              return d4 = Ke(c5._debugInfo), t4 = v3(t4, a4, c5 = Fs(c5), f4), js = d4, t4;
          }
          if (Co(c5)) return d4 = Ke(c5._debugInfo), t4 = function(t5, a5, o4, i4) {
            for (var s4 = null, c6 = null, f5 = null, d5 = a5, p5 = a5 = 0, y4 = null; null !== d5 && p5 < o4.length; p5++) {
              d5.index > p5 ? (y4 = d5, d5 = null) : y4 = d5.sibling;
              var v4 = h3(t5, d5, o4[p5], i4);
              if (null === v4) {
                null === d5 && (d5 = y4);
                break;
              }
              s4 = b3(t5, v4, o4[p5], s4), e3 && d5 && null === v4.alternate && n6(t5, d5), a5 = u3(v4, a5, p5), null === f5 ? c6 = v4 : f5.sibling = v4, f5 = v4, d5 = y4;
            }
            if (p5 === o4.length) return r4(t5, d5), c6;
            if (null === d5) {
              for (; p5 < o4.length; p5++) null !== (d5 = m2(t5, o4[p5], i4)) && (s4 = b3(t5, d5, o4[p5], s4), a5 = u3(d5, a5, p5), null === f5 ? c6 = d5 : f5.sibling = d5, f5 = d5);
              return c6;
            }
            for (d5 = l3(d5); p5 < o4.length; p5++) null !== (y4 = g3(d5, t5, p5, o4[p5], i4)) && (s4 = b3(t5, y4, o4[p5], s4), e3 && null !== y4.alternate && d5.delete(null === y4.key ? p5 : y4.key), a5 = u3(y4, a5, p5), null === f5 ? c6 = y4 : f5.sibling = y4, f5 = y4);
            return e3 && d5.forEach(function(e4) {
              return n6(t5, e4);
            }), c6;
          }(t4, a4, c5, f4), js = d4, t4;
          if (i3(c5)) {
            if (d4 = Ke(c5._debugInfo), "function" != typeof (y3 = i3(c5))) throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            return (p4 = y3.call(c5)) === c5 ? 0 === t4.tag && "[object GeneratorFunction]" === Object.prototype.toString.call(t4.type) && "[object Generator]" === Object.prototype.toString.call(p4) || (Ws || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), Ws = true) : c5.entries !== y3 || ps || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), ps = true), t4 = function(t5, a5, o4, i4) {
              if (null == o4) throw Error("An iterable object provided no iterator.");
              for (var s4 = null, c6 = null, f5 = a5, d5 = a5 = 0, p5 = null, y4 = null, v4 = o4.next(); null !== f5 && !v4.done; d5++, v4 = o4.next()) {
                f5.index > d5 ? (p5 = f5, f5 = null) : p5 = f5.sibling;
                var S3 = h3(t5, f5, v4.value, i4);
                if (null === S3) {
                  null === f5 && (f5 = p5);
                  break;
                }
                y4 = b3(t5, S3, v4.value, y4), e3 && f5 && null === S3.alternate && n6(t5, f5), a5 = u3(S3, a5, d5), null === c6 ? s4 = S3 : c6.sibling = S3, c6 = S3, f5 = p5;
              }
              if (v4.done) return r4(t5, f5), s4;
              if (null === f5) {
                for (; !v4.done; d5++, v4 = o4.next()) null !== (f5 = m2(t5, v4.value, i4)) && (y4 = b3(t5, f5, v4.value, y4), a5 = u3(f5, a5, d5), null === c6 ? s4 = f5 : c6.sibling = f5, c6 = f5);
                return s4;
              }
              for (f5 = l3(f5); !v4.done; d5++, v4 = o4.next()) null !== (p5 = g3(f5, t5, d5, v4.value, i4)) && (y4 = b3(t5, p5, v4.value, y4), e3 && null !== p5.alternate && f5.delete(null === p5.key ? d5 : p5.key), a5 = u3(p5, a5, d5), null === c6 ? s4 = p5 : c6.sibling = p5, c6 = p5);
              return e3 && f5.forEach(function(e4) {
                return n6(t5, e4);
              }), s4;
            }(t4, a4, p4, f4), js = d4, t4;
          }
          if ("function" == typeof c5.then) return d4 = Ke(c5._debugInfo), t4 = v3(t4, a4, Ze(c5), f4), js = d4, t4;
          if (c5.$$typeof === oo) return v3(t4, a4, Tr(t4, c5), f4);
          nn(t4, c5);
        }
        return "string" == typeof c5 && "" !== c5 || "number" == typeof c5 || "bigint" == typeof c5 ? (d4 = "" + c5, null !== a4 && 6 === a4.tag ? (r4(t4, a4.sibling), (a4 = o3(a4, d4)).return = t4, t4 = a4) : (r4(t4, a4), (a4 = Ma(d4, t4.mode, f4)).return = t4, a4._debugOwner = t4, a4._debugInfo = js, t4 = a4), s3(t4)) : ("function" == typeof c5 && tn(t4, c5), "symbol" == typeof c5 && rn(t4, c5), r4(t4, a4));
      }
      return function(e4, n7, r5, l4) {
        var a4 = js;
        js = null;
        try {
          Hs = 0;
          var o4 = v3(e4, n7, r5, l4);
          return Ms = null, o4;
        } catch (n8) {
          if (n8 === ms) throw n8;
          var u4 = t3(29, n8, null, e4.mode);
          u4.lanes = l4, u4.return = e4;
          var i4 = u4._debugInfo = js;
          if (u4._debugOwner = e4._debugOwner, null != i4) {
            for (var s4 = i4.length - 1; 0 <= s4; s4--) if ("string" == typeof i4[s4].stack) {
              u4._debugOwner = i4[s4];
              break;
            }
          }
          return u4;
        } finally {
          js = a4;
        }
      };
    }
    function an(e3, n6) {
      var t4 = od;
      S2(Ys, t4, e3), S2(qs, n6, e3), od = t4 | n6.baseLanes;
    }
    function on3(e3) {
      S2(Ys, od, e3), S2(qs, qs.current, e3);
    }
    function un(e3) {
      od = Ys.current, v2(qs, e3), v2(Ys, e3);
    }
    function sn(e3) {
      var n6 = e3.alternate;
      S2(Zs, Zs.current & Ks, e3), S2(Js, e3, e3), null === Gs && (null === n6 || null !== qs.current || null !== n6.memoizedState) && (Gs = e3);
    }
    function cn(e3) {
      if (22 === e3.tag) {
        if (S2(Zs, Zs.current, e3), S2(Js, e3, e3), null === Gs) {
          var n6 = e3.alternate;
          null !== n6 && null !== n6.memoizedState && (Gs = e3);
        }
      } else fn(e3);
    }
    function fn(e3) {
      S2(Zs, Zs.current, e3), S2(Js, Js.current, e3);
    }
    function dn(e3) {
      v2(Js, e3), Gs === e3 && (Gs = null), v2(Zs, e3);
    }
    function pn(e3) {
      for (var n6 = e3; null !== n6; ) {
        if (13 === n6.tag) {
          var t4 = n6.memoizedState;
          if (null !== t4 && (null === (t4 = t4.dehydrated) || bu(t4) || vu(t4))) return n6;
        } else if (19 === n6.tag && void 0 !== n6.memoizedProps.revealOrder) {
          if (0 != (128 & n6.flags)) return n6;
        } else if (null !== n6.child) {
          n6.child.return = n6, n6 = n6.child;
          continue;
        }
        if (n6 === e3) break;
        for (; null === n6.sibling; ) {
          if (null === n6.return || n6.return === e3) return null;
          n6 = n6.return;
        }
        n6.sibling.return = n6.return, n6 = n6.sibling;
      }
      return null;
    }
    function mn() {
      var e3 = kc;
      null === wc ? wc = [e3] : wc.push(e3);
    }
    function hn() {
      var e3 = kc;
      if (null !== wc && (xc++, wc[xc] !== e3)) {
        var n6 = c3(cc);
        if (!ac.has(n6) && (ac.add(n6), null !== wc)) {
          for (var t4 = "", r4 = 0; r4 <= xc; r4++) {
            var l3 = wc[r4], a4 = r4 === xc ? e3 : l3;
            for (l3 = r4 + 1 + ". " + l3; 30 > l3.length; ) l3 += " ";
            t4 += l3 += a4 + "\n";
          }
          console.error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", n6, t4);
        }
      }
    }
    function gn(e3) {
      null == e3 || Co(e3) || console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", kc, typeof e3);
    }
    function yn() {
      var e3 = c3(cc);
      ic.has(e3) || (ic.add(e3), console.error("ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.", e3));
    }
    function bn() {
      throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
    }
    function vn(e3, n6) {
      if (zc) return false;
      if (null === n6) return console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", kc), false;
      e3.length !== n6.length && console.error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", kc, "[" + n6.join(", ") + "]", "[" + e3.join(", ") + "]");
      for (var t4 = 0; t4 < n6.length && t4 < e3.length; t4++) if (!li(e3[t4], n6[t4])) return false;
      return true;
    }
    function Sn(e3, n6, t4, r4, l3, a4) {
      sc = a4, cc = n6, wc = null !== e3 ? e3._debugHookTypes : null, xc = -1, zc = null !== e3 && e3.type !== n6.type, "[object AsyncFunction]" !== Object.prototype.toString.call(t4) && "[object AsyncGeneratorFunction]" !== Object.prototype.toString.call(t4) || (a4 = c3(cc), uc.has(a4) || (uc.add(a4), console.error("async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."))), n6.memoizedState = null, n6.updateQueue = null, n6.lanes = 0, yo.H = null !== e3 && null !== e3.memoizedState ? Rc : null !== wc ? _c : Ec, hc = a4 = (8 & n6.mode) !== Pi;
      var o3 = Ss(t4, r4, l3);
      if (hc = false, mc && (o3 = wn(n6, t4, r4, l3)), a4) {
        U(true);
        try {
          o3 = wn(n6, t4, r4, l3);
        } finally {
          U(false);
        }
      }
      return kn(e3, n6), o3;
    }
    function kn(e3, n6) {
      n6._debugHookTypes = wc, null === n6.dependencies ? null !== bc && (n6.dependencies = { lanes: 0, firstContext: null, _debugThenableState: bc }) : n6.dependencies._debugThenableState = bc, yo.H = Pc;
      var t4 = null !== fc && null !== fc.next;
      if (sc = 0, wc = kc = dc = fc = cc = null, xc = -1, null !== e3 && (31457280 & e3.flags) != (31457280 & n6.flags) && console.error("Internal React error: Expected static flag was missing. Please notify the React team."), pc = false, yc = 0, bc = null, t4) throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      null === e3 || qc || null !== (e3 = e3.dependencies) && Er(e3) && (qc = true), bs ? (bs = false, e3 = true) : e3 = false, e3 && (n6 = c3(n6) || "Unknown", oc.has(n6) || uc.has(n6) || (oc.add(n6), console.error("`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.")));
    }
    function wn(e3, n6, t4, r4) {
      cc = e3;
      var l3 = 0;
      do {
        if (mc && (bc = null), yc = 0, mc = false, l3 >= Sc) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        if (l3 += 1, zc = false, dc = fc = null, null != e3.updateQueue) {
          var a4 = e3.updateQueue;
          a4.lastEffect = null, a4.events = null, a4.stores = null, null != a4.memoCache && (a4.memoCache.index = 0);
        }
        xc = -1, yo.H = Tc, a4 = Ss(n6, t4, r4);
      } while (mc);
      return a4;
    }
    function xn() {
      var e3 = yo.H, n6 = e3.useState()[0];
      return n6 = "function" == typeof n6.then ? Rn(n6) : n6, e3 = e3.useState()[0], (null !== fc ? fc.memoizedState : null) !== e3 && (cc.flags |= 1024), n6;
    }
    function zn() {
      var e3 = 0 !== gc;
      return gc = 0, e3;
    }
    function Cn(e3, n6, t4) {
      n6.updateQueue = e3.updateQueue, n6.flags = (16 & n6.mode) !== Pi ? -201328645 & n6.flags : -2053 & n6.flags, e3.lanes &= ~t4;
    }
    function Pn(e3) {
      if (pc) {
        for (e3 = e3.memoizedState; null !== e3; ) {
          var n6 = e3.queue;
          null !== n6 && (n6.pending = null), e3 = e3.next;
        }
        pc = false;
      }
      sc = 0, wc = dc = fc = cc = null, xc = -1, kc = null, mc = false, yc = gc = 0, bc = null;
    }
    function En() {
      var e3 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return null === dc ? cc.memoizedState = dc = e3 : dc = dc.next = e3, dc;
    }
    function _n() {
      if (null === fc) {
        var e3 = cc.alternate;
        e3 = null !== e3 ? e3.memoizedState : null;
      } else e3 = fc.next;
      var n6 = null === dc ? cc.memoizedState : dc.next;
      if (null !== n6) dc = n6, fc = e3;
      else {
        if (null === e3) {
          if (null === cc.alternate) throw Error("Update hook called on initial render. This is likely a bug in React. Please file an issue.");
          throw Error("Rendered more hooks than during the previous render.");
        }
        e3 = { memoizedState: (fc = e3).memoizedState, baseState: fc.baseState, baseQueue: fc.baseQueue, queue: fc.queue, next: null }, null === dc ? cc.memoizedState = dc = e3 : dc = dc.next = e3;
      }
      return dc;
    }
    function Rn(e3) {
      var n6 = yc;
      return yc += 1, null === bc && (bc = { didWarnAboutUncachedPromise: false, thenables: [] }), e3 = Ye(bc, e3, n6), n6 = cc, null === (null === dc ? n6.memoizedState : dc.next) && (n6 = n6.alternate, yo.H = null !== n6 && null !== n6.memoizedState ? Rc : Ec), e3;
    }
    function Tn(e3) {
      if (null !== e3 && "object" == typeof e3) {
        if ("function" == typeof e3.then) return Rn(e3);
        if (e3.$$typeof === oo) return Rr(e3);
      }
      throw Error("An unsupported type was passed to use(): " + String(e3));
    }
    function Nn(e3) {
      var n6 = null, t4 = cc.updateQueue;
      if (null !== t4 && (n6 = t4.memoCache), null == n6) {
        var r4 = cc.alternate;
        null !== r4 && null !== (r4 = r4.updateQueue) && null != (r4 = r4.memoCache) && (n6 = { data: r4.data.map(function(e4) {
          return e4.slice();
        }), index: 0 });
      }
      if (null == n6 && (n6 = { data: [], index: 0 }), null === t4 && (t4 = Cc(), cc.updateQueue = t4), t4.memoCache = n6, void 0 === (t4 = n6.data[n6.index]) || zc) for (t4 = n6.data[n6.index] = Array(e3), r4 = 0; r4 < e3; r4++) t4[r4] = mo;
      else t4.length !== e3 && console.error("Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.", t4.length, e3);
      return n6.index++, t4;
    }
    function Ln(e3, n6) {
      return "function" == typeof n6 ? n6(e3) : n6;
    }
    function Un(e3, n6, t4) {
      var r4 = En();
      if (void 0 !== t4) {
        var l3 = t4(n6);
        if (hc) {
          U(true);
          try {
            t4(n6);
          } finally {
            U(false);
          }
        }
      } else l3 = n6;
      return r4.memoizedState = r4.baseState = l3, e3 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: e3, lastRenderedState: l3 }, r4.queue = e3, e3 = e3.dispatch = It.bind(null, cc, e3), [r4.memoizedState, e3];
    }
    function In(e3) {
      return Dn(_n(), fc, e3);
    }
    function Dn(e3, n6, t4) {
      var r4 = e3.queue;
      if (null === r4) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      r4.lastRenderedReducer = t4;
      var l3 = e3.baseQueue, a4 = r4.pending;
      if (null !== a4) {
        if (null !== l3) {
          var o3 = l3.next;
          l3.next = a4.next, a4.next = o3;
        }
        n6.baseQueue !== l3 && console.error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), n6.baseQueue = l3 = a4, r4.pending = null;
      }
      if (a4 = e3.baseState, null === l3) e3.memoizedState = a4;
      else {
        var u3 = o3 = null, i4 = null, s3 = n6 = l3.next, c4 = false;
        do {
          var f3 = -536870913 & s3.lane;
          if (f3 !== s3.lane ? ($f & f3) === f3 : (sc & f3) === f3) {
            var d3 = s3.revertLane;
            if (0 === d3) null !== i4 && (i4 = i4.next = { lane: 0, revertLane: 0, action: s3.action, hasEagerState: s3.hasEagerState, eagerState: s3.eagerState, next: null }), f3 === $i && (c4 = true);
            else {
              if ((sc & d3) === d3) {
                s3 = s3.next, d3 === $i && (c4 = true);
                continue;
              }
              f3 = { lane: 0, revertLane: s3.revertLane, action: s3.action, hasEagerState: s3.hasEagerState, eagerState: s3.eagerState, next: null }, null === i4 ? (u3 = i4 = f3, o3 = a4) : i4 = i4.next = f3, cc.lanes |= d3, id |= d3;
            }
            f3 = s3.action, hc && t4(a4, f3), a4 = s3.hasEagerState ? s3.eagerState : t4(a4, f3);
          } else d3 = { lane: f3, revertLane: s3.revertLane, action: s3.action, hasEagerState: s3.hasEagerState, eagerState: s3.eagerState, next: null }, null === i4 ? (u3 = i4 = d3, o3 = a4) : i4 = i4.next = d3, cc.lanes |= f3, id |= f3;
          s3 = s3.next;
        } while (null !== s3 && s3 !== n6);
        if (null === i4 ? o3 = a4 : i4.next = u3, !li(a4, e3.memoizedState) && (qc = true, c4 && null !== (t4 = qi))) throw t4;
        e3.memoizedState = a4, e3.baseState = o3, e3.baseQueue = i4, r4.lastRenderedState = a4;
      }
      return null === l3 && (r4.lanes = 0), [e3.memoizedState, r4.dispatch];
    }
    function Fn(e3) {
      var n6 = _n(), t4 = n6.queue;
      if (null === t4) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      t4.lastRenderedReducer = e3;
      var r4 = t4.dispatch, l3 = t4.pending, a4 = n6.memoizedState;
      if (null !== l3) {
        t4.pending = null;
        var o3 = l3 = l3.next;
        do {
          a4 = e3(a4, o3.action), o3 = o3.next;
        } while (o3 !== l3);
        li(a4, n6.memoizedState) || (qc = true), n6.memoizedState = a4, null === n6.baseQueue && (n6.baseState = a4), t4.lastRenderedState = a4;
      }
      return [a4, r4];
    }
    function Mn(e3, n6, t4) {
      var r4, l3 = cc, a4 = En();
      if (r4 = n6(), Bs || (t4 = n6(), li(r4, t4) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), Bs = true)), null === Bf) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
      return 0 != (60 & $f) || jn(l3, n6, r4), a4.memoizedState = r4, t4 = { value: r4, getSnapshot: n6 }, a4.queue = t4, dt(On.bind(null, l3, t4, e3), [e3]), l3.flags |= 2048, it(nc | lc, Wn.bind(null, l3, t4, r4, n6), { destroy: void 0 }, null), r4;
    }
    function Hn(e3, n6, t4) {
      var r4 = cc, l3 = _n();
      if (t4 = n6(), !Bs) {
        var a4 = n6();
        li(t4, a4) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), Bs = true);
      }
      (a4 = !li((fc || l3).memoizedState, t4)) && (l3.memoizedState = t4, qc = true), l3 = l3.queue;
      var o3 = On.bind(null, r4, l3, e3);
      if (ft(2048, lc, o3, [e3]), l3.getSnapshot !== n6 || a4 || null !== dc && dc.memoizedState.tag & nc) {
        if (r4.flags |= 2048, it(nc | lc, Wn.bind(null, r4, l3, t4, n6), { destroy: void 0 }, null), null === Bf) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        0 != (60 & sc) || jn(r4, n6, t4);
      }
      return t4;
    }
    function jn(e3, n6, t4) {
      e3.flags |= 16384, e3 = { getSnapshot: n6, value: t4 }, null === (n6 = cc.updateQueue) ? (n6 = Cc(), cc.updateQueue = n6, n6.stores = [e3]) : null === (t4 = n6.stores) ? n6.stores = [e3] : t4.push(e3);
    }
    function Wn(e3, n6, t4, r4) {
      n6.value = t4, n6.getSnapshot = r4, An(n6) && Qn(e3);
    }
    function On(e3, n6, t4) {
      return t4(function() {
        An(n6) && Qn(e3);
      });
    }
    function An(e3) {
      var n6 = e3.getSnapshot;
      e3 = e3.value;
      try {
        var t4 = n6();
        return !li(e3, t4);
      } catch (e4) {
        return true;
      }
    }
    function Qn(e3) {
      var n6 = de(e3, 2);
      null !== n6 && Vl(n6, e3, 2);
    }
    function Bn(e3) {
      var n6 = En();
      if ("function" == typeof e3) {
        var t4 = e3;
        if (e3 = t4(), hc) {
          U(true);
          try {
            t4();
          } finally {
            U(false);
          }
        }
      }
      return n6.memoizedState = n6.baseState = e3, n6.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Ln, lastRenderedState: e3 }, n6;
    }
    function Vn(e3) {
      var n6 = (e3 = Bn(e3)).queue, t4 = Dt.bind(null, cc, n6);
      return n6.dispatch = t4, [e3.memoizedState, t4];
    }
    function $n(e3) {
      var n6 = En();
      n6.memoizedState = n6.baseState = e3;
      var t4 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null };
      return n6.queue = t4, n6 = Mt.bind(null, cc, true, t4), t4.dispatch = n6, [e3, n6];
    }
    function qn(e3, n6) {
      return Yn(_n(), 0, e3, n6);
    }
    function Yn(e3, n6, t4, r4) {
      return e3.baseState = t4, Dn(e3, fc, "function" == typeof r4 ? r4 : Ln);
    }
    function Jn(e3, n6) {
      var t4 = _n();
      return null !== fc ? Yn(t4, 0, e3, n6) : (t4.baseState = e3, [e3, t4.queue.dispatch]);
    }
    function Gn(e3, n6, t4, r4, l3) {
      if (Ht(e3)) throw Error("Cannot update form state while rendering.");
      if (null !== (e3 = n6.action)) {
        var a4 = { payload: l3, action: e3, next: null, isTransition: true, status: "pending", value: null, reason: null, listeners: [], then: function(e4) {
          a4.listeners.push(e4);
        } };
        null !== yo.T ? t4(true) : a4.isTransition = false, r4(a4), null === (t4 = n6.pending) ? (a4.next = n6.pending = a4, Kn(n6, a4)) : (a4.next = t4.next, n6.pending = t4.next = a4);
      }
    }
    function Kn(e3, n6) {
      var t4 = n6.action, r4 = n6.payload, l3 = e3.state;
      if (n6.isTransition) {
        var a4 = yo.T, o3 = {};
        yo.T = o3, yo.T._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var u3 = t4(l3, r4), i4 = yo.S;
          null !== i4 && i4(o3, u3), Xn(e3, n6, u3);
        } catch (t5) {
          et(e3, n6, t5);
        } finally {
          yo.T = a4, null === a4 && o3._updatedFibers && (e3 = o3._updatedFibers.size, o3._updatedFibers.clear(), 10 < e3 && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
        }
      } else try {
        Xn(e3, n6, o3 = t4(l3, r4));
      } catch (t5) {
        et(e3, n6, t5);
      }
    }
    function Xn(e3, n6, t4) {
      null !== t4 && "object" == typeof t4 && "function" == typeof t4.then ? (t4.then(function(t5) {
        Zn(e3, n6, t5);
      }, function(t5) {
        return et(e3, n6, t5);
      }), n6.isTransition || console.error("An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`")) : Zn(e3, n6, t4);
    }
    function Zn(e3, n6, t4) {
      n6.status = "fulfilled", n6.value = t4, nt(n6), e3.state = t4, null !== (n6 = e3.pending) && ((t4 = n6.next) === n6 ? e3.pending = null : (t4 = t4.next, n6.next = t4, Kn(e3, t4)));
    }
    function et(e3, n6, t4) {
      var r4 = e3.pending;
      if (e3.pending = null, null !== r4) {
        r4 = r4.next;
        do {
          n6.status = "rejected", n6.reason = t4, nt(n6), n6 = n6.next;
        } while (n6 !== r4);
      }
      e3.action = null;
    }
    function nt(e3) {
      e3 = e3.listeners;
      for (var n6 = 0; n6 < e3.length; n6++) (0, e3[n6])();
    }
    function tt(e3, n6) {
      return n6;
    }
    function rt(e3, n6) {
      var t4, r4, l3;
      (t4 = En()).memoizedState = t4.baseState = n6, r4 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: tt, lastRenderedState: n6 }, t4.queue = r4, t4 = Dt.bind(null, cc, r4), r4.dispatch = t4, r4 = Bn(false);
      var a4 = Mt.bind(null, cc, false, r4.queue);
      return l3 = { state: n6, dispatch: null, action: e3, pending: null }, (r4 = En()).queue = l3, t4 = Gn.bind(null, cc, l3, a4, t4), l3.dispatch = t4, r4.memoizedState = e3, [n6, t4, false];
    }
    function lt(e3) {
      return at(_n(), fc, e3);
    }
    function at(e3, n6, t4) {
      n6 = Dn(e3, n6, tt)[0], e3 = In(Ln)[0], n6 = "object" == typeof n6 && null !== n6 && "function" == typeof n6.then ? Rn(n6) : n6;
      var r4 = _n(), l3 = r4.queue, a4 = l3.dispatch;
      return t4 !== r4.memoizedState && (cc.flags |= 2048, it(nc | lc, ot.bind(null, l3, t4), { destroy: void 0 }, null)), [n6, a4, e3];
    }
    function ot(e3, n6) {
      e3.action = n6;
    }
    function ut(e3) {
      var n6 = _n(), t4 = fc;
      if (null !== t4) return at(n6, t4, e3);
      _n(), n6 = n6.memoizedState;
      var r4 = (t4 = _n()).queue.dispatch;
      return t4.memoizedState = e3, [n6, r4, false];
    }
    function it(e3, n6, t4, r4) {
      return e3 = { tag: e3, create: n6, inst: t4, deps: r4, next: null }, null === (n6 = cc.updateQueue) && (n6 = Cc(), cc.updateQueue = n6), null === (t4 = n6.lastEffect) ? n6.lastEffect = e3.next = e3 : (r4 = t4.next, t4.next = e3, e3.next = r4, n6.lastEffect = e3), e3;
    }
    function st(e3) {
      return e3 = { current: e3 }, En().memoizedState = e3;
    }
    function ct(e3, n6, t4, r4) {
      var l3 = En();
      cc.flags |= e3, l3.memoizedState = it(nc | n6, t4, { destroy: void 0 }, void 0 === r4 ? null : r4);
    }
    function ft(e3, n6, t4, r4) {
      var l3 = _n();
      r4 = void 0 === r4 ? null : r4;
      var a4 = l3.memoizedState.inst;
      null !== fc && null !== r4 && vn(r4, fc.memoizedState.deps) ? l3.memoizedState = it(n6, t4, a4, r4) : (cc.flags |= e3, l3.memoizedState = it(nc | n6, t4, a4, r4));
    }
    function dt(e3, n6) {
      (16 & cc.mode) !== Pi && (64 & cc.mode) === Pi ? ct(142608384, lc, e3, n6) : ct(8390656, lc, e3, n6);
    }
    function pt(e3, n6) {
      var t4 = 4194308;
      return (16 & cc.mode) !== Pi && (t4 |= 67108864), ct(t4, rc, e3, n6);
    }
    function mt(e3, n6) {
      if ("function" == typeof n6) {
        e3 = e3();
        var t4 = n6(e3);
        return function() {
          "function" == typeof t4 ? t4() : n6(null);
        };
      }
      if (null != n6) return n6.hasOwnProperty("current") || console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(n6).join(", ") + "}"), e3 = e3(), n6.current = e3, function() {
        n6.current = null;
      };
    }
    function ht(e3, n6, t4) {
      "function" != typeof n6 && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== n6 ? typeof n6 : "null"), t4 = null != t4 ? t4.concat([e3]) : null;
      var r4 = 4194308;
      (16 & cc.mode) !== Pi && (r4 |= 67108864), ct(r4, rc, mt.bind(null, n6, e3), t4);
    }
    function gt(e3, n6, t4) {
      "function" != typeof n6 && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== n6 ? typeof n6 : "null"), t4 = null != t4 ? t4.concat([e3]) : null, ft(4, rc, mt.bind(null, n6, e3), t4);
    }
    function yt(e3, n6) {
      return En().memoizedState = [e3, void 0 === n6 ? null : n6], e3;
    }
    function bt(e3, n6) {
      var t4 = _n();
      n6 = void 0 === n6 ? null : n6;
      var r4 = t4.memoizedState;
      return null !== n6 && vn(n6, r4[1]) ? r4[0] : (t4.memoizedState = [e3, n6], e3);
    }
    function vt(e3, n6) {
      var t4 = En();
      n6 = void 0 === n6 ? null : n6;
      var r4 = e3();
      if (hc) {
        U(true);
        try {
          e3();
        } finally {
          U(false);
        }
      }
      return t4.memoizedState = [r4, n6], r4;
    }
    function St(e3, n6) {
      var t4 = _n();
      n6 = void 0 === n6 ? null : n6;
      var r4 = t4.memoizedState;
      if (null !== n6 && vn(n6, r4[1])) return r4[0];
      if (r4 = e3(), hc) {
        U(true);
        try {
          e3();
        } finally {
          U(false);
        }
      }
      return t4.memoizedState = [r4, n6], r4;
    }
    function kt(e3, n6) {
      return zt(En(), e3, n6);
    }
    function wt(e3, n6) {
      return Ct(_n(), fc.memoizedState, e3, n6);
    }
    function xt(e3, n6) {
      var t4 = _n();
      return null === fc ? zt(t4, e3, n6) : Ct(t4, fc.memoizedState, e3, n6);
    }
    function zt(e3, n6, t4) {
      return void 0 === t4 || 0 != (1073741824 & sc) ? e3.memoizedState = n6 : (e3.memoizedState = t4, e3 = Bl(), cc.lanes |= e3, id |= e3, t4);
    }
    function Ct(e3, n6, t4, r4) {
      return li(t4, n6) ? t4 : null !== qs.current ? (e3 = zt(e3, t4, r4), li(e3, n6) || (qc = true), e3) : 0 == (42 & sc) ? (qc = true, e3.memoizedState = t4) : (e3 = Bl(), cc.lanes |= e3, id |= e3, n6);
    }
    function Pt(e3, n6, t4, r4, l3) {
      var a4 = Bo();
      Qo(0 !== a4 && 8 > a4 ? a4 : 8);
      var o3, u3, i4, s3 = yo.T, c4 = {};
      yo.T = c4, Mt(e3, false, n6, t4), c4._updatedFibers = /* @__PURE__ */ new Set();
      try {
        var f3 = l3(), d3 = yo.S;
        null !== d3 && d3(c4, f3), null !== f3 && "object" == typeof f3 && "function" == typeof f3.then ? Ft(e3, n6, (o3 = r4, u3 = [], i4 = { status: "pending", value: null, reason: null, then: function(e4) {
          u3.push(e4);
        } }, f3.then(function() {
          i4.status = "fulfilled", i4.value = o3;
          for (var e4 = 0; e4 < u3.length; e4++) (0, u3[e4])(o3);
        }, function(e4) {
          for (i4.status = "rejected", i4.reason = e4, e4 = 0; e4 < u3.length; e4++) (0, u3[e4])(void 0);
        }), i4), Ql(e3)) : Ft(e3, n6, r4, Ql(e3));
      } catch (t5) {
        Ft(e3, n6, { then: function() {
        }, status: "rejected", reason: t5 }, Ql(e3));
      } finally {
        Qo(a4), yo.T = s3, null === s3 && c4._updatedFibers && (e3 = c4._updatedFibers.size, c4._updatedFibers.clear(), 10 < e3 && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
      }
    }
    function Et() {
      var e3 = Bn(false);
      return e3 = Pt.bind(null, cc, e3.queue, true, false), En().memoizedState = e3, [false, e3];
    }
    function _t() {
      var e3 = In(Ln)[0], n6 = _n().memoizedState;
      return ["boolean" == typeof e3 ? e3 : Rn(e3), n6];
    }
    function Rt() {
      var e3 = Fn(Ln)[0], n6 = _n().memoizedState;
      return ["boolean" == typeof e3 ? e3 : Rn(e3), n6];
    }
    function Tt() {
      return Rr(eu);
    }
    function Nt() {
      var e3 = En(), n6 = Bf.identifierPrefix;
      return n6 = ":" + n6 + "r" + (vc++).toString(32) + ":", e3.memoizedState = n6;
    }
    function Lt() {
      return En().memoizedState = Ut.bind(null, cc);
    }
    function Ut(e3, n6) {
      for (var t4 = e3.return; null !== t4; ) {
        switch (t4.tag) {
          case 24:
          case 3:
            var r4 = Ql(t4), l3 = Me(t4, e3 = Fe(r4), r4);
            return null !== l3 && (Vl(l3, t4, r4), He(l3, t4, r4)), t4 = Lr(), null != n6 && null !== l3 && console.error("The seed argument is not enabled outside experimental channels."), void (e3.payload = { cache: t4 });
        }
        t4 = t4.return;
      }
    }
    function It(e3, n6, t4, r4) {
      "function" == typeof r4 && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."), t4 = { lane: r4 = Ql(e3), revertLane: 0, action: t4, hasEagerState: false, eagerState: null, next: null }, Ht(e3) ? jt(n6, t4) : null !== (t4 = fe(e3, n6, t4, r4)) && (Vl(t4, e3, r4), Wt(t4, n6, r4));
    }
    function Dt(e3, n6, t4, r4) {
      "function" == typeof r4 && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."), Ft(e3, n6, t4, r4 = Ql(e3));
    }
    function Ft(e3, n6, t4, r4) {
      var l3 = { lane: r4, revertLane: 0, action: t4, hasEagerState: false, eagerState: null, next: null };
      if (Ht(e3)) jt(n6, l3);
      else {
        var a4 = e3.alternate;
        if (0 === e3.lanes && (null === a4 || 0 === a4.lanes) && null !== (a4 = n6.lastRenderedReducer)) {
          var o3 = yo.H;
          yo.H = Lc;
          try {
            var u3 = n6.lastRenderedState, i4 = a4(u3, t4);
            if (l3.hasEagerState = true, l3.eagerState = i4, li(i4, u3)) return ce(e3, n6, l3, 0), null === Bf && se(), false;
          } catch (e4) {
          } finally {
            yo.H = o3;
          }
        }
        if (null !== (t4 = fe(e3, n6, l3, r4))) return Vl(t4, e3, r4), Wt(t4, n6, r4), true;
      }
      return false;
    }
    function Mt(e3, n6, t4, r4) {
      if (null === yo.T && 0 === $i && console.error("An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."), r4 = { lane: 2, revertLane: Le(), action: r4, hasEagerState: false, eagerState: null, next: null }, Ht(e3)) {
        if (n6) throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else null !== (n6 = fe(e3, t4, r4, 2)) && Vl(n6, e3, 2);
    }
    function Ht(e3) {
      var n6 = e3.alternate;
      return e3 === cc || null !== n6 && n6 === cc;
    }
    function jt(e3, n6) {
      mc = pc = true;
      var t4 = e3.pending;
      null === t4 ? n6.next = n6 : (n6.next = t4.next, t4.next = n6), e3.pending = n6;
    }
    function Wt(e3, n6, t4) {
      if (0 != (4194176 & t4)) {
        var r4 = n6.lanes;
        t4 |= r4 &= e3.pendingLanes, n6.lanes = t4, R(e3, t4);
      }
    }
    function Ot(e3) {
      if (null !== e3 && "function" != typeof e3) {
        var n6 = String(e3);
        Bc.has(n6) || (Bc.add(n6), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", e3));
      }
    }
    function At(e3, n6, t4, r4) {
      var l3 = e3.memoizedState, a4 = t4(r4, l3);
      if (8 & e3.mode) {
        U(true);
        try {
          a4 = t4(r4, l3);
        } finally {
          U(false);
        }
      }
      void 0 === a4 && (n6 = s2(n6) || "Component", Wc.has(n6) || (Wc.add(n6), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", n6))), l3 = null == a4 ? l3 : Ka({}, l3, a4), e3.memoizedState = l3, 0 === e3.lanes && (e3.updateQueue.baseState = l3);
    }
    function Qt(e3, n6, t4, r4, l3, a4, o3) {
      var u3 = e3.stateNode;
      if ("function" == typeof u3.shouldComponentUpdate) {
        if (t4 = u3.shouldComponentUpdate(r4, a4, o3), 8 & e3.mode) {
          U(true);
          try {
            t4 = u3.shouldComponentUpdate(r4, a4, o3);
          } finally {
            U(false);
          }
        }
        return void 0 === t4 && console.error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", s2(n6) || "Component"), t4;
      }
      return !(n6.prototype && n6.prototype.isPureReactComponent && Ve(t4, r4) && Ve(l3, a4));
    }
    function Bt(e3, n6, t4, r4) {
      var l3 = n6.state;
      "function" == typeof n6.componentWillReceiveProps && n6.componentWillReceiveProps(t4, r4), "function" == typeof n6.UNSAFE_componentWillReceiveProps && n6.UNSAFE_componentWillReceiveProps(t4, r4), n6.state !== l3 && (e3 = c3(e3) || "Component", Dc.has(e3) || (Dc.add(e3), console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", e3)), Vc.enqueueReplaceState(n6, n6.state, null));
    }
    function Vt(e3, n6) {
      var t4 = n6;
      if ("ref" in n6) for (var r4 in t4 = {}, n6) "ref" !== r4 && (t4[r4] = n6[r4]);
      if (e3 = e3.defaultProps) for (var l3 in t4 === n6 && (t4 = Ka({}, t4)), e3) void 0 === t4[l3] && (t4[l3] = e3[l3]);
      return t4;
    }
    function $t(e3, n6) {
      try {
        n6.source && c3(n6.source);
        var t4 = n6.value;
        null !== yo.actQueue ? yo.thrownErrors.push(t4) : (0, e3.onUncaughtError)(t4, { componentStack: n6.stack });
      } catch (e4) {
        setTimeout(function() {
          throw e4;
        });
      }
    }
    function qt(e3, n6, t4) {
      try {
        t4.source && c3(t4.source), c3(n6), (0, e3.onCaughtError)(t4.value, { componentStack: t4.stack, errorBoundary: 1 === n6.tag ? n6.stateNode : null });
      } catch (e4) {
        setTimeout(function() {
          throw e4;
        });
      }
    }
    function Yt(e3, n6, t4) {
      return (t4 = Fe(t4)).tag = Ki, t4.payload = { element: null }, t4.callback = function() {
        y2(n6.source, $t, e3, n6);
      }, t4;
    }
    function Jt(e3) {
      return (e3 = Fe(e3)).tag = Ki, e3;
    }
    function Gt(e3, n6, t4, r4) {
      var l3 = t4.type.getDerivedStateFromError;
      if ("function" == typeof l3) {
        var a4 = r4.value;
        e3.payload = function() {
          return l3(a4);
        }, e3.callback = function() {
          y2(r4.source, qt, n6, t4, r4);
        };
      }
      var o3 = t4.stateNode;
      null !== o3 && "function" == typeof o3.componentDidCatch && (e3.callback = function() {
        y2(r4.source, qt, n6, t4, r4), "function" != typeof l3 && (null === kd ? kd = /* @__PURE__ */ new Set([this]) : kd.add(this)), _s(this, r4), "function" == typeof l3 || 0 == (2 & t4.lanes) && console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", c3(t4) || "Unknown");
      });
    }
    function Kt(e3, n6, t4, r4) {
      n6.child = null === e3 ? $s(n6, null, t4, r4) : Vs(n6, e3.child, t4, r4);
    }
    function Xt(e3, n6, t4, r4, l3) {
      t4 = t4.render;
      var a4 = n6.ref;
      if ("ref" in r4) {
        var o3 = {};
        for (var u3 in r4) "ref" !== u3 && (o3[u3] = r4[u3]);
      } else o3 = r4;
      return _r(n6), r4 = Sn(e3, n6, t4, o3, a4, l3), u3 = zn(), null === e3 || qc ? (n6.flags |= 1, Kt(e3, n6, r4, l3), n6.child) : (Cn(e3, n6, l3), br(e3, n6, l3));
    }
    function Zt(e3, n6, t4, r4, l3) {
      if (null === e3) {
        var a4 = t4.type;
        return "function" != typeof a4 || Ta(a4) || void 0 !== a4.defaultProps || null !== t4.compare ? ((e3 = Ua(t4.type, null, r4, n6, n6.mode, l3)).ref = n6.ref, e3.return = n6, n6.child = e3) : (t4 = a4, n6.tag = 15, n6.type = t4, ur(n6, a4), er(e3, n6, t4, r4, l3));
      }
      if (a4 = e3.child, !vr(e3, l3)) {
        var o3 = a4.memoizedProps;
        if ((t4 = null !== (t4 = t4.compare) ? t4 : Ve)(o3, r4) && e3.ref === n6.ref) return br(e3, n6, l3);
      }
      return n6.flags |= 1, (e3 = Na(a4, r4)).ref = n6.ref, e3.return = n6, n6.child = e3;
    }
    function er(e3, n6, t4, r4, l3) {
      if (null !== e3) {
        var a4 = e3.memoizedProps;
        if (Ve(a4, r4) && e3.ref === n6.ref && n6.type === e3.type) {
          if (qc = false, n6.pendingProps = r4 = a4, !vr(e3, l3)) return n6.lanes = e3.lanes, br(e3, n6, l3);
          0 != (131072 & e3.flags) && (qc = true);
        }
      }
      return lr(e3, n6, t4, r4, l3);
    }
    function nr(e3, n6, t4) {
      var r4 = n6.pendingProps, l3 = r4.children, a4 = 0 != (2 & n6.stateNode._pendingVisibility), o3 = null !== e3 ? e3.memoizedState : null;
      if (rr(e3, n6), "hidden" === r4.mode || a4) {
        if (0 != (128 & n6.flags)) {
          if (r4 = null !== o3 ? o3.baseLanes | t4 : t4, null !== e3) {
            for (l3 = n6.child = e3.child, a4 = 0; null !== l3; ) a4 = a4 | l3.lanes | l3.childLanes, l3 = l3.sibling;
            n6.childLanes = a4 & ~r4;
          } else n6.childLanes = 0, n6.child = null;
          return tr(e3, n6, r4, t4);
        }
        if (0 == (536870912 & t4)) return n6.lanes = n6.childLanes = 536870912, tr(e3, n6, null !== o3 ? o3.baseLanes | t4 : t4, t4);
        n6.memoizedState = { baseLanes: 0, cachePool: null }, null !== e3 && Fr(n6, null !== o3 ? o3.cachePool : null), null !== o3 ? an(n6, o3) : on3(n6), cn(n6);
      } else null !== o3 ? (Fr(n6, o3.cachePool), an(n6, o3), fn(n6), n6.memoizedState = null) : (null !== e3 && Fr(n6, null), on3(n6), fn(n6));
      return Kt(e3, n6, l3, t4), n6.child;
    }
    function tr(e3, n6, t4, r4) {
      var l3 = Dr();
      return l3 = null === l3 ? null : { parent: mf._currentValue2, pool: l3 }, n6.memoizedState = { baseLanes: t4, cachePool: l3 }, null !== e3 && Fr(n6, null), on3(n6), cn(n6), null !== e3 && Pr(e3, n6, r4, true), null;
    }
    function rr(e3, n6) {
      var t4 = n6.ref;
      if (null === t4) null !== e3 && null !== e3.ref && (n6.flags |= 2097664);
      else {
        if ("function" != typeof t4 && "object" != typeof t4) throw Error("Expected ref to be a function, an object returned by React.createRef(), or undefined/null.");
        null !== e3 && e3.ref === t4 || (n6.flags |= 2097664);
      }
    }
    function lr(e3, n6, t4, r4, l3) {
      if (t4.prototype && "function" == typeof t4.prototype.render) {
        var a4 = s2(t4) || "Unknown";
        Yc[a4] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", a4, a4), Yc[a4] = true);
      }
      return 8 & n6.mode && rs.recordLegacyContextWarning(n6, null), null === e3 && (ur(n6, n6.type), t4.contextTypes && (a4 = s2(t4) || "Unknown", Gc[a4] || (Gc[a4] = true, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", a4)))), _r(n6), t4 = Sn(e3, n6, t4, r4, void 0, l3), r4 = zn(), null === e3 || qc ? (n6.flags |= 1, Kt(e3, n6, t4, l3), n6.child) : (Cn(e3, n6, l3), br(e3, n6, l3));
    }
    function ar(e3, n6, t4, r4, l3, a4) {
      return _r(n6), xc = -1, zc = null !== e3 && e3.type !== n6.type, n6.updateQueue = null, t4 = wn(n6, r4, t4, l3), kn(e3, n6), r4 = zn(), null === e3 || qc ? (n6.flags |= 1, Kt(e3, n6, t4, a4), n6.child) : (Cn(e3, n6, a4), br(e3, n6, a4));
    }
    function or(e3, n6, t4, r4, l3) {
      var a4, o3, u3;
      if (_r(n6), null === n6.stateNode) {
        if (o3 = Hu, a4 = t4.contextType, "contextType" in t4 && null !== a4 && (void 0 === a4 || a4.$$typeof !== oo) && !Qc.has(t4) && (Qc.add(t4), u3 = void 0 === a4 ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" != typeof a4 ? " However, it is set to a " + typeof a4 + "." : a4.$$typeof === ao ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(a4).join(", ") + "}.", console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", s2(t4) || "Component", u3)), "object" == typeof a4 && null !== a4 && (o3 = Rr(a4)), a4 = new t4(r4, o3), 8 & n6.mode) {
          U(true);
          try {
            a4 = new t4(r4, o3);
          } finally {
            U(false);
          }
        }
        if (o3 = n6.memoizedState = null !== a4.state && void 0 !== a4.state ? a4.state : null, a4.updater = Vc, n6.stateNode = a4, a4._reactInternals = n6, a4._reactInternalInstance = Ic, "function" == typeof t4.getDerivedStateFromProps && null === o3 && (o3 = s2(t4) || "Component", Fc.has(o3) || (Fc.add(o3), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", o3, null === a4.state ? "null" : "undefined", o3))), "function" == typeof t4.getDerivedStateFromProps || "function" == typeof a4.getSnapshotBeforeUpdate) {
          var i4 = u3 = o3 = null;
          if ("function" == typeof a4.componentWillMount && true !== a4.componentWillMount.__suppressDeprecationWarning ? o3 = "componentWillMount" : "function" == typeof a4.UNSAFE_componentWillMount && (o3 = "UNSAFE_componentWillMount"), "function" == typeof a4.componentWillReceiveProps && true !== a4.componentWillReceiveProps.__suppressDeprecationWarning ? u3 = "componentWillReceiveProps" : "function" == typeof a4.UNSAFE_componentWillReceiveProps && (u3 = "UNSAFE_componentWillReceiveProps"), "function" == typeof a4.componentWillUpdate && true !== a4.componentWillUpdate.__suppressDeprecationWarning ? i4 = "componentWillUpdate" : "function" == typeof a4.UNSAFE_componentWillUpdate && (i4 = "UNSAFE_componentWillUpdate"), null !== o3 || null !== u3 || null !== i4) {
            a4 = s2(t4) || "Component";
            var f3 = "function" == typeof t4.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Hc.has(a4) || (Hc.add(a4), console.error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles", a4, f3, null !== o3 ? "\n  " + o3 : "", null !== u3 ? "\n  " + u3 : "", null !== i4 ? "\n  " + i4 : ""));
          }
        }
        a4 = n6.stateNode, o3 = s2(t4) || "Component", a4.render || (t4.prototype && "function" == typeof t4.prototype.render ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", o3) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", o3)), !a4.getInitialState || a4.getInitialState.isReactClassApproved || a4.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", o3), a4.getDefaultProps && !a4.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", o3), a4.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", o3), t4.childContextTypes && !Ac.has(t4) && (Ac.add(t4), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", o3)), t4.contextTypes && !Oc.has(t4) && (Oc.add(t4), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", o3)), "function" == typeof a4.componentShouldUpdate && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", o3), t4.prototype && t4.prototype.isPureReactComponent && void 0 !== a4.shouldComponentUpdate && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", s2(t4) || "A pure component"), "function" == typeof a4.componentDidUnmount && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", o3), "function" == typeof a4.componentDidReceiveProps && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", o3), "function" == typeof a4.componentWillRecieveProps && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", o3), "function" == typeof a4.UNSAFE_componentWillRecieveProps && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", o3), u3 = a4.props !== r4, void 0 !== a4.props && u3 && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", o3), a4.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", o3, o3), "function" != typeof a4.getSnapshotBeforeUpdate || "function" == typeof a4.componentDidUpdate || Mc.has(t4) || (Mc.add(t4), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", s2(t4))), "function" == typeof a4.getDerivedStateFromProps && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", o3), "function" == typeof a4.getDerivedStateFromError && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", o3), "function" == typeof t4.getSnapshotBeforeUpdate && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", o3), (u3 = a4.state) && ("object" != typeof u3 || Co(u3)) && console.error("%s.state: must be set to an object or null", o3), "function" == typeof a4.getChildContext && "object" != typeof t4.childContextTypes && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", o3), (a4 = n6.stateNode).props = r4, a4.state = n6.memoizedState, a4.refs = {}, Ie(n6), o3 = t4.contextType, a4.context = "object" == typeof o3 && null !== o3 ? Rr(o3) : Hu, a4.state === r4 && (o3 = s2(t4) || "Component", jc.has(o3) || (jc.add(o3), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", o3))), 8 & n6.mode && rs.recordLegacyContextWarning(n6, a4), rs.recordUnsafeLifecycleWarnings(n6, a4), a4.state = n6.memoizedState, "function" == typeof (o3 = t4.getDerivedStateFromProps) && (At(n6, t4, o3, r4), a4.state = n6.memoizedState), "function" == typeof t4.getDerivedStateFromProps || "function" == typeof a4.getSnapshotBeforeUpdate || "function" != typeof a4.UNSAFE_componentWillMount && "function" != typeof a4.componentWillMount || (o3 = a4.state, "function" == typeof a4.componentWillMount && a4.componentWillMount(), "function" == typeof a4.UNSAFE_componentWillMount && a4.UNSAFE_componentWillMount(), o3 !== a4.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", c3(n6) || "Component"), Vc.enqueueReplaceState(a4, a4.state, null)), Oe(n6, r4, a4, l3), We(), a4.state = n6.memoizedState), "function" == typeof a4.componentDidMount && (n6.flags |= 4194308), (16 & n6.mode) !== Pi && (n6.flags |= 67108864), a4 = true;
      } else if (null === e3) {
        a4 = n6.stateNode;
        var d3 = n6.memoizedProps;
        u3 = Vt(t4, d3), a4.props = u3;
        var p3 = a4.context;
        i4 = t4.contextType, o3 = Hu, "object" == typeof i4 && null !== i4 && (o3 = Rr(i4)), i4 = "function" == typeof (f3 = t4.getDerivedStateFromProps) || "function" == typeof a4.getSnapshotBeforeUpdate, d3 = n6.pendingProps !== d3, i4 || "function" != typeof a4.UNSAFE_componentWillReceiveProps && "function" != typeof a4.componentWillReceiveProps || (d3 || p3 !== o3) && Bt(n6, a4, r4, o3), Xi = false;
        var m2 = n6.memoizedState;
        a4.state = m2, Oe(n6, r4, a4, l3), We(), p3 = n6.memoizedState, d3 || m2 !== p3 || Xi ? ("function" == typeof f3 && (At(n6, t4, f3, r4), p3 = n6.memoizedState), (u3 = Xi || Qt(n6, t4, u3, r4, m2, p3, o3)) ? (i4 || "function" != typeof a4.UNSAFE_componentWillMount && "function" != typeof a4.componentWillMount || ("function" == typeof a4.componentWillMount && a4.componentWillMount(), "function" == typeof a4.UNSAFE_componentWillMount && a4.UNSAFE_componentWillMount()), "function" == typeof a4.componentDidMount && (n6.flags |= 4194308), (16 & n6.mode) !== Pi && (n6.flags |= 67108864)) : ("function" == typeof a4.componentDidMount && (n6.flags |= 4194308), (16 & n6.mode) !== Pi && (n6.flags |= 67108864), n6.memoizedProps = r4, n6.memoizedState = p3), a4.props = r4, a4.state = p3, a4.context = o3, a4 = u3) : ("function" == typeof a4.componentDidMount && (n6.flags |= 4194308), (16 & n6.mode) !== Pi && (n6.flags |= 67108864), a4 = false);
      } else {
        a4 = n6.stateNode, De(e3, n6), i4 = Vt(t4, o3 = n6.memoizedProps), a4.props = i4, f3 = n6.pendingProps, m2 = a4.context, p3 = t4.contextType, u3 = Hu, "object" == typeof p3 && null !== p3 && (u3 = Rr(p3)), (p3 = "function" == typeof (d3 = t4.getDerivedStateFromProps) || "function" == typeof a4.getSnapshotBeforeUpdate) || "function" != typeof a4.UNSAFE_componentWillReceiveProps && "function" != typeof a4.componentWillReceiveProps || (o3 !== f3 || m2 !== u3) && Bt(n6, a4, r4, u3), Xi = false, m2 = n6.memoizedState, a4.state = m2, Oe(n6, r4, a4, l3), We();
        var h3 = n6.memoizedState;
        o3 !== f3 || m2 !== h3 || Xi || null !== e3 && null !== e3.dependencies && Er(e3.dependencies) ? ("function" == typeof d3 && (At(n6, t4, d3, r4), h3 = n6.memoizedState), (i4 = Xi || Qt(n6, t4, i4, r4, m2, h3, u3) || null !== e3 && null !== e3.dependencies && Er(e3.dependencies)) ? (p3 || "function" != typeof a4.UNSAFE_componentWillUpdate && "function" != typeof a4.componentWillUpdate || ("function" == typeof a4.componentWillUpdate && a4.componentWillUpdate(r4, h3, u3), "function" == typeof a4.UNSAFE_componentWillUpdate && a4.UNSAFE_componentWillUpdate(r4, h3, u3)), "function" == typeof a4.componentDidUpdate && (n6.flags |= 4), "function" == typeof a4.getSnapshotBeforeUpdate && (n6.flags |= 1024)) : ("function" != typeof a4.componentDidUpdate || o3 === e3.memoizedProps && m2 === e3.memoizedState || (n6.flags |= 4), "function" != typeof a4.getSnapshotBeforeUpdate || o3 === e3.memoizedProps && m2 === e3.memoizedState || (n6.flags |= 1024), n6.memoizedProps = r4, n6.memoizedState = h3), a4.props = r4, a4.state = h3, a4.context = u3, a4 = i4) : ("function" != typeof a4.componentDidUpdate || o3 === e3.memoizedProps && m2 === e3.memoizedState || (n6.flags |= 4), "function" != typeof a4.getSnapshotBeforeUpdate || o3 === e3.memoizedProps && m2 === e3.memoizedState || (n6.flags |= 1024), a4 = false);
      }
      if (u3 = a4, rr(e3, n6), o3 = 0 != (128 & n6.flags), u3 || o3) {
        if (u3 = n6.stateNode, yo.getCurrentStack = null === n6 ? null : g2, zo = false, xo = n6, o3 && "function" != typeof t4.getDerivedStateFromError) t4 = null, Li = -1;
        else if (t4 = ws(u3), 8 & n6.mode) {
          U(true);
          try {
            ws(u3);
          } finally {
            U(false);
          }
        }
        n6.flags |= 1, null !== e3 && o3 ? (n6.child = Vs(n6, e3.child, null, l3), n6.child = Vs(n6, null, t4, l3)) : Kt(e3, n6, t4, l3), n6.memoizedState = u3.state, e3 = n6.child;
      } else e3 = br(e3, n6, l3);
      return l3 = n6.stateNode, a4 && l3.props !== r4 && (Xc || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", c3(n6) || "a component"), Xc = true), e3;
    }
    function ur(e3, n6) {
      n6 && n6.childContextTypes && console.error("childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...", n6.displayName || n6.name || "Component"), "function" == typeof n6.getDerivedStateFromProps && (e3 = s2(n6) || "Unknown", Kc[e3] || (console.error("%s: Function components do not support getDerivedStateFromProps.", e3), Kc[e3] = true)), "object" == typeof n6.contextType && null !== n6.contextType && (n6 = s2(n6) || "Unknown", Jc[n6] || (console.error("%s: Function components do not support contextType.", n6), Jc[n6] = true));
    }
    function ir(e3) {
      return { baseLanes: e3, cachePool: Mr() };
    }
    function sr(e3, n6, t4) {
      return e3 = null !== e3 ? e3.childLanes & ~t4 : 0, n6 && (e3 |= fd), e3;
    }
    function cr(e3, n6, t4) {
      var r4, l3, a4, o3 = n6.pendingProps, u3 = false, i4 = 0 != (128 & n6.flags);
      if ((r4 = i4) || (r4 = (null === e3 || null !== e3.memoizedState) && 0 != (Zs.current & Xs)), r4 && (u3 = true, n6.flags &= -129), r4 = 0 != (32 & n6.flags), n6.flags &= -33, null === e3) return l3 = o3.children, o3 = o3.fallback, u3 ? (fn(n6), l3 = dr({ mode: "hidden", children: l3 }, u3 = n6.mode), o3 = Da(o3, u3, t4, null), l3.return = n6, o3.return = n6, l3.sibling = o3, n6.child = l3, (u3 = n6.child).memoizedState = ir(t4), u3.childLanes = sr(e3, r4, t4), n6.memoizedState = nf, o3) : (sn(n6), fr(n6, l3));
      if (null !== (a4 = e3.memoizedState) && null !== (l3 = a4.dehydrated)) {
        if (i4) 256 & n6.flags ? (sn(n6), n6.flags &= -257, n6 = pr(e3, n6, t4)) : null !== n6.memoizedState ? (fn(n6), n6.child = e3.child, n6.flags |= 128, n6 = null) : (fn(n6), u3 = o3.fallback, l3 = n6.mode, o3 = dr({ mode: "visible", children: o3.children }, l3), (u3 = Da(u3, l3, t4, null)).flags |= 2, o3.return = n6, u3.return = n6, o3.sibling = u3, n6.child = o3, Vs(n6, e3.child, null, t4), (o3 = n6.child).memoizedState = ir(t4), o3.childLanes = sr(e3, r4, t4), n6.memoizedState = nf, n6 = u3);
        else if (sn(n6), vu(l3)) r4 = (l3 = Su(l3)).digest, u3 = l3.message, o3 = l3.stack, l3 = l3.componentStack, (u3 = u3 ? Error(u3) : Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")).stack = o3 || "", u3.digest = r4, o3 = { value: u3, source: null, stack: r4 = void 0 === l3 ? null : l3 }, "string" == typeof r4 && ai.set(u3, o3), ue(o3), n6 = pr(e3, n6, t4);
        else if (qc || Pr(e3, n6, t4, false), r4 = 0 != (t4 & e3.childLanes), qc || r4) {
          if (null !== (r4 = Bf)) {
            if (0 != (42 & (o3 = t4 & -t4))) o3 = 1;
            else switch (o3) {
              case 2:
                o3 = 1;
                break;
              case 8:
                o3 = 4;
                break;
              case 32:
                o3 = 16;
                break;
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                o3 = 64;
                break;
              case 268435456:
                o3 = 134217728;
                break;
              default:
                o3 = 0;
            }
            if (0 !== (o3 = 0 != (o3 & (r4.suspendedLanes | t4)) ? 0 : o3) && o3 !== a4.retryLane) throw a4.retryLane = o3, de(e3, o3), Vl(r4, e3, o3), $c;
          }
          bu(l3) || ra(), n6 = pr(e3, n6, t4);
        } else bu(l3) ? (n6.flags |= 128, n6.child = e3.child, n6 = wa.bind(null, e3), ku(l3, n6), n6 = null) : (e3 = a4.treeContext, (n6 = fr(n6, o3.children)).flags |= 4096);
        return n6;
      }
      return u3 ? (fn(n6), u3 = o3.fallback, l3 = n6.mode, i4 = (a4 = e3.child).sibling, (o3 = Na(a4, { mode: "hidden", children: o3.children })).subtreeFlags = 31457280 & a4.subtreeFlags, null !== i4 ? u3 = Na(i4, u3) : (u3 = Da(u3, l3, t4, null)).flags |= 2, u3.return = n6, o3.return = n6, o3.sibling = u3, n6.child = o3, o3 = u3, u3 = n6.child, null === (l3 = e3.child.memoizedState) ? l3 = ir(t4) : (null !== (a4 = l3.cachePool) ? (i4 = mf._currentValue2, a4 = a4.parent !== i4 ? { parent: i4, pool: i4 } : a4) : a4 = Mr(), l3 = { baseLanes: l3.baseLanes | t4, cachePool: a4 }), u3.memoizedState = l3, u3.childLanes = sr(e3, r4, t4), n6.memoizedState = nf, o3) : (sn(n6), e3 = (t4 = e3.child).sibling, (t4 = Na(t4, { mode: "visible", children: o3.children })).return = n6, t4.sibling = null, null !== e3 && (null === (r4 = n6.deletions) ? (n6.deletions = [e3], n6.flags |= 16) : r4.push(e3)), n6.child = t4, n6.memoizedState = null, t4);
    }
    function fr(e3, n6) {
      return (n6 = dr({ mode: "visible", children: n6 }, e3.mode)).return = e3, e3.child = n6;
    }
    function dr(e3, n6) {
      return Fa(e3, n6, 0, null);
    }
    function pr(e3, n6, t4) {
      return Vs(n6, e3.child, null, t4), (e3 = fr(n6, n6.pendingProps.children)).flags |= 2, n6.memoizedState = null, e3;
    }
    function mr(e3, n6, t4) {
      e3.lanes |= n6;
      var r4 = e3.alternate;
      null !== r4 && (r4.lanes |= n6), zr(e3.return, n6, t4);
    }
    function hr(e3, n6) {
      var t4 = Co(e3);
      return e3 = !t4 && "function" == typeof i3(e3), !t4 && !e3 || (t4 = t4 ? "array" : "iterable", console.error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", t4, n6, t4), false);
    }
    function gr(e3, n6, t4, r4, l3) {
      var a4 = e3.memoizedState;
      null === a4 ? e3.memoizedState = { isBackwards: n6, rendering: null, renderingStartTime: 0, last: r4, tail: t4, tailMode: l3 } : (a4.isBackwards = n6, a4.rendering = null, a4.renderingStartTime = 0, a4.last = r4, a4.tail = t4, a4.tailMode = l3);
    }
    function yr(e3, n6, t4) {
      var r4 = n6.pendingProps, l3 = r4.revealOrder, a4 = r4.tail;
      if (r4 = r4.children, void 0 !== l3 && "forwards" !== l3 && "backwards" !== l3 && "together" !== l3 && !Zc[l3]) if (Zc[l3] = true, "string" == typeof l3) switch (l3.toLowerCase()) {
        case "together":
        case "forwards":
        case "backwards":
          console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', l3, l3.toLowerCase());
          break;
        case "forward":
        case "backward":
          console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', l3, l3.toLowerCase());
          break;
        default:
          console.error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', l3);
      }
      else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', l3);
      void 0 === a4 || ef[a4] || ("collapsed" !== a4 && "hidden" !== a4 ? (ef[a4] = true, console.error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', a4)) : "forwards" !== l3 && "backwards" !== l3 && (ef[a4] = true, console.error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', a4)));
      e: if (("forwards" === l3 || "backwards" === l3) && null != r4 && false !== r4) if (Co(r4)) {
        for (var o3 = 0; o3 < r4.length; o3++) if (!hr(r4[o3], o3)) break e;
      } else if (o3 = i3(r4), "function" == typeof o3) {
        if (o3 = o3.call(r4)) for (var u3 = o3.next(), s3 = 0; !u3.done; u3 = o3.next()) {
          if (!hr(u3.value, s3)) break e;
          s3++;
        }
      } else console.error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', l3);
      if (Kt(e3, n6, r4, t4), 0 != ((r4 = Zs.current) & Xs)) r4 = r4 & Ks | Xs, n6.flags |= 128;
      else {
        if (null !== e3 && 0 != (128 & e3.flags)) e: for (e3 = n6.child; null !== e3; ) {
          if (13 === e3.tag) null !== e3.memoizedState && mr(e3, t4, n6);
          else if (19 === e3.tag) mr(e3, t4, n6);
          else if (null !== e3.child) {
            e3.child.return = e3, e3 = e3.child;
            continue;
          }
          if (e3 === n6) break e;
          for (; null === e3.sibling; ) {
            if (null === e3.return || e3.return === n6) break e;
            e3 = e3.return;
          }
          e3.sibling.return = e3.return, e3 = e3.sibling;
        }
        r4 &= Ks;
      }
      switch (S2(Zs, r4, n6), l3) {
        case "forwards":
          for (t4 = n6.child, l3 = null; null !== t4; ) null !== (e3 = t4.alternate) && null === pn(e3) && (l3 = t4), t4 = t4.sibling;
          null === (t4 = l3) ? (l3 = n6.child, n6.child = null) : (l3 = t4.sibling, t4.sibling = null), gr(n6, false, l3, t4, a4);
          break;
        case "backwards":
          for (t4 = null, l3 = n6.child, n6.child = null; null !== l3; ) {
            if (null !== (e3 = l3.alternate) && null === pn(e3)) {
              n6.child = l3;
              break;
            }
            e3 = l3.sibling, l3.sibling = t4, t4 = l3, l3 = e3;
          }
          gr(n6, true, t4, null, a4);
          break;
        case "together":
          gr(n6, false, null, null, void 0);
          break;
        default:
          n6.memoizedState = null;
      }
      return n6.child;
    }
    function br(e3, n6, t4) {
      if (null !== e3 && (n6.dependencies = e3.dependencies), Li = -1, id |= n6.lanes, 0 == (t4 & n6.childLanes)) {
        if (null === e3) return null;
        if (Pr(e3, n6, t4, false), 0 == (t4 & n6.childLanes)) return null;
      }
      if (null !== e3 && n6.child !== e3.child) throw Error("Resuming work not yet implemented.");
      if (null !== n6.child) {
        for (t4 = Na(e3 = n6.child, e3.pendingProps), n6.child = t4, t4.return = n6; null !== e3.sibling; ) e3 = e3.sibling, (t4 = t4.sibling = Na(e3, e3.pendingProps)).return = n6;
        t4.sibling = null;
      }
      return n6.child;
    }
    function vr(e3, n6) {
      return 0 != (e3.lanes & n6) || !(null === (e3 = e3.dependencies) || !Er(e3));
    }
    function Sr(e3, n6, t4) {
      if (n6._debugNeedsRemount && null !== e3) {
        t4 = Ua(n6.type, n6.key, n6.pendingProps, n6._debugOwner || null, n6.mode, n6.lanes);
        var r4 = n6.return;
        if (null === r4) throw Error("Cannot swap the root fiber.");
        if (e3.alternate = null, n6.alternate = null, t4.index = n6.index, t4.sibling = n6.sibling, t4.return = n6.return, t4.ref = n6.ref, t4._debugInfo = n6._debugInfo, n6 === r4.child) r4.child = t4;
        else {
          var l3 = r4.child;
          if (null === l3) throw Error("Expected parent to have a child.");
          for (; l3.sibling !== n6; ) if (null === (l3 = l3.sibling)) throw Error("Expected to find the previous sibling.");
          l3.sibling = t4;
        }
        return null === (n6 = r4.deletions) ? (r4.deletions = [e3], r4.flags |= 16) : n6.push(e3), t4.flags |= 2, t4;
      }
      if (null !== e3) if (e3.memoizedProps !== n6.pendingProps || n6.type !== e3.type) qc = true;
      else {
        if (!vr(e3, t4) && 0 == (128 & n6.flags)) return qc = false, function(e4, n7, t5) {
          switch (n7.tag) {
            case 3:
              H(n7, n7.stateNode.containerInfo), wr(n7, mf, e4.memoizedState.cache);
              break;
            case 27:
            case 5:
              O(n7);
              break;
            case 4:
              H(n7, n7.stateNode.containerInfo);
              break;
            case 10:
              wr(n7, n7.type, n7.memoizedProps.value);
              break;
            case 12:
              0 != (t5 & n7.childLanes) && (n7.flags |= 4), n7.flags |= 2048;
              var r5 = n7.stateNode;
              r5.effectDuration = -0, r5.passiveEffectDuration = -0;
              break;
            case 13:
              if (null !== (r5 = n7.memoizedState)) return null !== r5.dehydrated ? (sn(n7), n7.flags |= 128, null) : 0 != (t5 & n7.child.childLanes) ? cr(e4, n7, t5) : (sn(n7), null !== (e4 = br(e4, n7, t5)) ? e4.sibling : null);
              sn(n7);
              break;
            case 19:
              var l4 = 0 != (128 & e4.flags);
              if ((r5 = 0 != (t5 & n7.childLanes)) || (Pr(e4, n7, t5, false), r5 = 0 != (t5 & n7.childLanes)), l4) {
                if (r5) return yr(e4, n7, t5);
                n7.flags |= 128;
              }
              if (null !== (l4 = n7.memoizedState) && (l4.rendering = null, l4.tail = null, l4.lastEffect = null), S2(Zs, Zs.current, n7), r5) break;
              return null;
            case 22:
            case 23:
              return n7.lanes = 0, nr(e4, n7, t5);
            case 24:
              wr(n7, mf, e4.memoizedState.cache);
          }
          return br(e4, n7, t5);
        }(e3, n6, t4);
        qc = 0 != (131072 & e3.flags);
      }
      else qc = false, (r4 = ki) && (F(), r4 = 0 != (1048576 & n6.flags)), r4 && (r4 = n6.index, F(), function(e4, n7, t5) {
        F(), ci[fi++] = pi, ci[fi++] = mi, ci[fi++] = di, di = e4;
        var r5 = pi;
        e4 = mi;
        var l4 = 32 - ju(r5) - 1;
        r5 &= ~(1 << l4), t5 += 1;
        var a5 = 32 - ju(n7) + l4;
        if (30 < a5) {
          var o4 = l4 - l4 % 5;
          a5 = (r5 & (1 << o4) - 1).toString(32), r5 >>= o4, l4 -= o4, pi = 1 << 32 - ju(n7) + l4 | t5 << l4 | r5, mi = a5 + e4;
        } else pi = 1 << a5 | t5 << l4 | r5, mi = e4;
      }(n6, si, r4));
      switch (n6.lanes = 0, n6.tag) {
        case 16:
          e: {
            if (r4 = n6.pendingProps, e3 = Fs(n6.elementType), n6.type = e3, "function" != typeof e3) {
              if (null != e3) {
                if ((l3 = e3.$$typeof) === uo) {
                  n6.tag = 11, n6.type = e3, n6 = Xt(null, n6, e3, r4, t4);
                  break e;
                }
                if (l3 === co) {
                  n6.tag = 14, n6 = Zt(null, n6, e3, r4, t4);
                  break e;
                }
              }
              throw n6 = "", null !== e3 && "object" == typeof e3 && e3.$$typeof === fo && (n6 = " Did you wrap a component in React.lazy() more than once?"), e3 = s2(e3) || e3, Error("Element type is invalid. Received a promise that resolves to: " + e3 + ". Lazy element type must resolve to a class or function." + n6);
            }
            Ta(e3) ? (r4 = Vt(e3, r4), n6.tag = 1, n6.type = e3, n6 = or(null, n6, e3, r4, t4)) : (n6.tag = 0, ur(n6, e3), n6.type = e3, n6 = lr(null, n6, e3, r4, t4));
          }
          return n6;
        case 0:
          return lr(e3, n6, n6.type, n6.pendingProps, t4);
        case 1:
          return or(e3, n6, r4 = n6.type, l3 = Vt(r4, n6.pendingProps), t4);
        case 3:
          if (H(n6, n6.stateNode.containerInfo), null === e3) throw Error("Should have a current fiber. This is a bug in React.");
          var a4 = n6.pendingProps;
          r4 = (l3 = n6.memoizedState).element, De(e3, n6), Oe(n6, a4, null, t4);
          var o3 = n6.memoizedState;
          return a4 = o3.cache, wr(n6, mf, a4), a4 !== l3.cache && Cr(n6, [mf], t4, true), We(), (a4 = o3.element) !== r4 ? (Kt(e3, n6, a4, t4), n6 = n6.child) : n6 = br(e3, n6, t4), n6;
        case 26:
        case 27:
        case 5:
          return null === e3 && ki && (a4 = W(), r4 = Ru(n6.type, n6.pendingProps, a4), (o3 = !(l3 = Si)) || (null !== (o3 = xu(l3, n6.type, n6.pendingProps, zi)) ? (n6.stateNode = o3, null !== (a4 = Eu(o3, n6.type, n6.pendingProps, a4)) && (le(n6, 0).serverProps = a4), Si = wu(o3), zi = false, a4 = true) : a4 = false, o3 = !a4), o3 && (r4 && ae(n6, l3), oe(n6))), O(n6), l3 = n6.type, a4 = n6.pendingProps, o3 = null !== e3 ? e3.memoizedProps : null, r4 = a4.children, Io(l3, a4) ? r4 = null : null !== o3 && Io(l3, o3) && (n6.flags |= 32), null !== n6.memoizedState && (l3 = Sn(e3, n6, xn, null, null, t4), eu._currentValue2 = l3), rr(e3, n6), Kt(e3, n6, r4, t4), n6.child;
        case 6:
          return null === e3 && ki && (e3 = n6.pendingProps, t4 = W(), e3 = Tu(e3, t4), (r4 = !(t4 = Si)) || (null !== (r4 = zu(t4, n6.pendingProps, zi)) ? (n6.stateNode = r4, Si = null, r4 = true) : r4 = false, r4 = !r4), r4 && (e3 && ae(n6, t4), oe(n6))), null;
        case 13:
          return cr(e3, n6, t4);
        case 4:
          return H(n6, n6.stateNode.containerInfo), r4 = n6.pendingProps, null === e3 ? n6.child = Vs(n6, null, r4, t4) : Kt(e3, n6, r4, t4), n6.child;
        case 11:
          return Xt(e3, n6, n6.type, n6.pendingProps, t4);
        case 7:
          return Kt(e3, n6, n6.pendingProps, t4), n6.child;
        case 8:
          return Kt(e3, n6, n6.pendingProps.children, t4), n6.child;
        case 12:
          return n6.flags |= 4, n6.flags |= 2048, (r4 = n6.stateNode).effectDuration = -0, r4.passiveEffectDuration = -0, Kt(e3, n6, n6.pendingProps.children, t4), n6.child;
        case 10:
          return r4 = n6.type, a4 = (l3 = n6.pendingProps).value, "value" in l3 || tf || (tf = true, console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")), wr(n6, r4, a4), Kt(e3, n6, l3.children, t4), n6.child;
        case 9:
          return l3 = n6.type._context, "function" != typeof (r4 = n6.pendingProps.children) && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), _r(n6), l3 = Rr(l3), r4 = Ss(r4, l3, void 0), n6.flags |= 1, Kt(e3, n6, r4, t4), n6.child;
        case 14:
          return Zt(e3, n6, n6.type, n6.pendingProps, t4);
        case 15:
          return er(e3, n6, n6.type, n6.pendingProps, t4);
        case 19:
          return yr(e3, n6, t4);
        case 22:
          return nr(e3, n6, t4);
        case 24:
          return _r(n6), r4 = Rr(mf), null === e3 ? (null === (l3 = Dr()) && (l3 = Bf, a4 = Lr(), l3.pooledCache = a4, Ur(a4), null !== a4 && (l3.pooledCacheLanes |= t4), l3 = a4), n6.memoizedState = { parent: r4, cache: l3 }, Ie(n6), wr(n6, mf, l3)) : (0 != (e3.lanes & t4) && (De(e3, n6), Oe(n6, null, null, t4), We()), l3 = e3.memoizedState, a4 = n6.memoizedState, l3.parent !== r4 ? (l3 = { parent: r4, cache: r4 }, n6.memoizedState = l3, 0 === n6.lanes && (n6.memoizedState = n6.updateQueue.baseState = l3), wr(n6, mf, r4)) : (r4 = a4.cache, wr(n6, mf, r4), r4 !== l3.cache && Cr(n6, [mf], t4, true))), Kt(e3, n6, n6.pendingProps.children, t4), n6.child;
        case 29:
          throw n6.pendingProps;
      }
      throw Error("Unknown unit of work tag (" + n6.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function kr() {
      sf = uf = of = null, cf = false;
    }
    function wr(e3, n6, t4) {
      S2(rf, n6._currentValue2, e3), n6._currentValue2 = t4, S2(lf, n6._currentRenderer2, e3), void 0 !== n6._currentRenderer2 && null !== n6._currentRenderer2 && n6._currentRenderer2 !== af && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), n6._currentRenderer2 = af;
    }
    function xr(e3, n6) {
      var t4 = rf.current;
      e3._currentValue2 = t4, t4 = lf.current, v2(lf, n6), e3._currentRenderer2 = t4, v2(rf, n6);
    }
    function zr(e3, n6, t4) {
      for (; null !== e3; ) {
        var r4 = e3.alternate;
        if ((e3.childLanes & n6) !== n6 ? (e3.childLanes |= n6, null !== r4 && (r4.childLanes |= n6)) : null !== r4 && (r4.childLanes & n6) !== n6 && (r4.childLanes |= n6), e3 === t4) break;
        e3 = e3.return;
      }
      e3 !== t4 && console.error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Cr(e3, n6, t4, r4) {
      var l3 = e3.child;
      for (null !== l3 && (l3.return = e3); null !== l3; ) {
        var a4 = l3.dependencies;
        if (null !== a4) {
          var o3 = l3.child;
          a4 = a4.firstContext;
          e: for (; null !== a4; ) {
            var u3 = a4;
            a4 = l3;
            for (var i4 = 0; i4 < n6.length; i4++) if (u3.context === n6[i4]) {
              a4.lanes |= t4, null !== (u3 = a4.alternate) && (u3.lanes |= t4), zr(a4.return, t4, e3), r4 || (o3 = null);
              break e;
            }
            a4 = u3.next;
          }
        } else if (18 === l3.tag) {
          if (null === (o3 = l3.return)) throw Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          o3.lanes |= t4, null !== (a4 = o3.alternate) && (a4.lanes |= t4), zr(o3, t4, e3), o3 = null;
        } else o3 = l3.child;
        if (null !== o3) o3.return = l3;
        else for (o3 = l3; null !== o3; ) {
          if (o3 === e3) {
            o3 = null;
            break;
          }
          if (null !== (l3 = o3.sibling)) {
            l3.return = o3.return, o3 = l3;
            break;
          }
          o3 = o3.return;
        }
        l3 = o3;
      }
    }
    function Pr(e3, n6, t4, r4) {
      e3 = null;
      for (var l3 = n6, a4 = false; null !== l3; ) {
        if (!a4) {
          if (0 != (524288 & l3.flags)) a4 = true;
          else if (0 != (262144 & l3.flags)) break;
        }
        if (10 === l3.tag) {
          var o3 = l3.alternate;
          if (null === o3) throw Error("Should have a current fiber. This is a bug in React.");
          if (null !== (o3 = o3.memoizedProps)) {
            var u3 = l3.type;
            li(l3.pendingProps.value, o3.value) || (null !== e3 ? e3.push(u3) : e3 = [u3]);
          }
        } else if (l3 === bi.current) {
          if (null === (o3 = l3.alternate)) throw Error("Should have a current fiber. This is a bug in React.");
          o3.memoizedState.memoizedState !== l3.memoizedState.memoizedState && (null !== e3 ? e3.push(eu) : e3 = [eu]);
        }
        l3 = l3.return;
      }
      null !== e3 && Cr(n6, e3, t4, r4), n6.flags |= 262144;
    }
    function Er(e3) {
      for (e3 = e3.firstContext; null !== e3; ) {
        var n6 = e3.context;
        if (!li(n6._currentValue2, e3.memoizedValue)) return true;
        e3 = e3.next;
      }
      return false;
    }
    function _r(e3) {
      of = e3, sf = uf = null, null !== (e3 = e3.dependencies) && (e3.firstContext = null);
    }
    function Rr(e3) {
      return cf && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), Nr(of, e3);
    }
    function Tr(e3, n6) {
      return null === of && _r(e3), Nr(e3, n6);
    }
    function Nr(e3, n6) {
      var t4 = n6._currentValue2;
      if (sf !== n6) if (n6 = { context: n6, memoizedValue: t4, next: null }, null === uf) {
        if (null === e3) throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        uf = n6, e3.dependencies = { lanes: 0, firstContext: n6, _debugThenableState: null }, e3.flags |= 524288;
      } else uf = uf.next = n6;
      return t4;
    }
    function Lr() {
      return { controller: new ff(), data: /* @__PURE__ */ new Map(), refCount: 0 };
    }
    function Ur(e3) {
      e3.controller.signal.aborted && console.warn("A cache instance was retained after it was already freed. This likely indicates a bug in React."), e3.refCount++;
    }
    function Ir(e3) {
      e3.refCount--, 0 > e3.refCount && console.warn("A cache instance was released after it was already freed. This likely indicates a bug in React."), 0 === e3.refCount && df(pf, function() {
        e3.controller.abort();
      });
    }
    function Dr() {
      var e3 = gf.current;
      return null !== e3 ? e3 : Bf.pooledCache;
    }
    function Fr(e3, n6) {
      S2(gf, null === n6 ? gf.current : n6.pool, e3);
    }
    function Mr() {
      var e3 = Dr();
      return null === e3 ? null : { parent: mf._currentValue2, pool: e3 };
    }
    function Hr(e3) {
      e3.flags |= 4;
    }
    function jr(e3, n6) {
      null !== n6 && (e3.flags |= 4), 16384 & e3.flags && (n6 = 22 !== e3.tag ? C() : 536870912, e3.lanes |= n6);
    }
    function Wr(e3, n6) {
      switch (e3.tailMode) {
        case "hidden":
          n6 = e3.tail;
          for (var t4 = null; null !== n6; ) null !== n6.alternate && (t4 = n6), n6 = n6.sibling;
          null === t4 ? e3.tail = null : t4.sibling = null;
          break;
        case "collapsed":
          t4 = e3.tail;
          for (var r4 = null; null !== t4; ) null !== t4.alternate && (r4 = t4), t4 = t4.sibling;
          null === r4 ? n6 || null === e3.tail ? e3.tail = null : e3.tail.sibling = null : r4.sibling = null;
      }
    }
    function Or(e3) {
      var n6 = null !== e3.alternate && e3.alternate.child === e3.child, t4 = 0, r4 = 0;
      if (n6) if ((2 & e3.mode) !== Pi) {
        for (var l3 = e3.selfBaseDuration, a4 = e3.child; null !== a4; ) t4 |= a4.lanes | a4.childLanes, r4 |= 31457280 & a4.subtreeFlags, r4 |= 31457280 & a4.flags, l3 += a4.treeBaseDuration, a4 = a4.sibling;
        e3.treeBaseDuration = l3;
      } else for (l3 = e3.child; null !== l3; ) t4 |= l3.lanes | l3.childLanes, r4 |= 31457280 & l3.subtreeFlags, r4 |= 31457280 & l3.flags, l3.return = e3, l3 = l3.sibling;
      else if ((2 & e3.mode) !== Pi) {
        l3 = e3.actualDuration, a4 = e3.selfBaseDuration;
        for (var o3 = e3.child; null !== o3; ) t4 |= o3.lanes | o3.childLanes, r4 |= o3.subtreeFlags, r4 |= o3.flags, l3 += o3.actualDuration, a4 += o3.treeBaseDuration, o3 = o3.sibling;
        e3.actualDuration = l3, e3.treeBaseDuration = a4;
      } else for (l3 = e3.child; null !== l3; ) t4 |= l3.lanes | l3.childLanes, r4 |= l3.subtreeFlags, r4 |= l3.flags, l3.return = e3, l3 = l3.sibling;
      return e3.subtreeFlags |= r4, e3.childLanes = t4, n6;
    }
    function Ar(e3, n6, t4) {
      var r4 = n6.pendingProps;
      switch (D(n6), n6.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
        case 1:
          return Or(n6), null;
        case 3:
          return t4 = n6.stateNode, r4 = null, null !== e3 && (r4 = e3.memoizedState.cache), n6.memoizedState.cache !== r4 && (n6.flags |= 2048), xr(mf, n6), j(n6), t4.pendingContext && (t4.context = t4.pendingContext, t4.pendingContext = null), null !== e3 && null !== e3.child || null === e3 || e3.memoizedState.isDehydrated && 0 == (256 & n6.flags) || (n6.flags |= 1024, null !== xi && (ql(xi), xi = null)), Or(n6), null;
        case 26:
          var l3;
        case 27:
        case 5:
          if (A(n6), t4 = n6.type, null !== e3 && null != n6.stateNode) !function(e4, n7, t5, r5) {
            e4.memoizedProps !== r5 && Hr(n7);
          }(e3, n6, 0, r4);
          else {
            if (!r4) {
              if (null === n6.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Or(n6), null;
            }
            e3 = W(), l3 = M(yi.current), function(e4, n7, t5, r5) {
              for (t5 = n7.child; null !== t5; ) {
                if (5 === t5.tag || 6 === t5.tag) Lo(e4, t5.stateNode);
                else if (4 !== t5.tag && !Iu && null !== t5.child) {
                  t5.child.return = t5, t5 = t5.child;
                  continue;
                }
                if (t5 === n7) break;
                for (; null === t5.sibling; ) {
                  if (null === t5.return || t5.return === n7) return;
                  t5 = t5.return;
                }
                t5.sibling.return = t5.return, t5 = t5.sibling;
              }
            }(l3 = No(t4, r4, l3, e3, n6), n6, false), n6.stateNode = l3, Uo(l3, t4, r4, e3) && Hr(n6);
          }
          return Or(n6), function(e4, n7, t5) {
            if (Yo(n7, t5)) {
              if (e4.flags |= 16777216, !Jo(n7, t5)) {
                if (!ea()) throw ys = gs, hs;
                e4.flags |= 8192;
              }
            } else e4.flags &= -16777217;
          }(n6, n6.type, n6.pendingProps), null;
        case 6:
          if (e3 && null != n6.stateNode) (t4 = e3.memoizedProps) !== r4 && Hr(n6);
          else {
            if ("string" != typeof r4 && null === n6.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var a4;
            e3 = M(yi.current), t4 = W(), n6.stateNode = Do(r4, e3, t4, n6);
          }
          return Or(n6), null;
        case 13:
          if (r4 = n6.memoizedState, null === e3 || null !== e3.memoizedState && null !== e3.memoizedState.dehydrated) {
            if (l3 = false, null !== r4 && null !== r4.dehydrated) {
              if (null === e3) {
                if (!l3) throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                throw Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
              }
              ie(), 0 == (128 & n6.flags) && (n6.memoizedState = null), n6.flags |= 4, Or(n6), (2 & n6.mode) !== Pi && null !== r4 && null !== (l3 = n6.child) && (n6.treeBaseDuration -= l3.treeBaseDuration), l3 = false;
            } else null !== xi && (ql(xi), xi = null), l3 = true;
            if (!l3) return 256 & n6.flags ? (dn(n6), n6) : (dn(n6), null);
          }
          return dn(n6), 0 != (128 & n6.flags) ? (n6.lanes = t4, (2 & n6.mode) !== Pi && xe(n6), n6) : (t4 = null !== r4, e3 = null !== e3 && null !== e3.memoizedState, t4 && (l3 = null, null !== (r4 = n6.child).alternate && null !== r4.alternate.memoizedState && null !== r4.alternate.memoizedState.cachePool && (l3 = r4.alternate.memoizedState.cachePool.pool), a4 = null, null !== r4.memoizedState && null !== r4.memoizedState.cachePool && (a4 = r4.memoizedState.cachePool.pool), a4 !== l3 && (r4.flags |= 2048)), t4 !== e3 && t4 && (n6.child.flags |= 8192), jr(n6, n6.updateQueue), Or(n6), (2 & n6.mode) !== Pi && t4 && null !== (e3 = n6.child) && (n6.treeBaseDuration -= e3.treeBaseDuration), null);
        case 4:
          return j(n6), null === e3 && Ao(n6.stateNode.containerInfo), Or(n6), null;
        case 10:
          return xr(n6.type, n6), Or(n6), null;
        case 19:
          if (v2(Zs, n6), null === (l3 = n6.memoizedState)) return Or(n6), null;
          if (r4 = 0 != (128 & n6.flags), null === (a4 = l3.rendering)) if (r4) Wr(l3, false);
          else {
            if (ud !== Ff || null !== e3 && 0 != (128 & e3.flags)) for (e3 = n6.child; null !== e3; ) {
              if (null !== (a4 = pn(e3))) {
                for (n6.flags |= 128, Wr(l3, false), e3 = a4.updateQueue, n6.updateQueue = e3, jr(n6, e3), n6.subtreeFlags = 0, e3 = t4, t4 = n6.child; null !== t4; ) La(t4, e3), t4 = t4.sibling;
                return S2(Zs, Zs.current & Ks | Xs, n6), n6.child;
              }
              e3 = e3.sibling;
            }
            null !== l3.tail && Yu() > bd && (n6.flags |= 128, r4 = true, Wr(l3, false), n6.lanes = 4194304);
          }
          else {
            if (!r4) if (null !== (e3 = pn(a4))) {
              if (n6.flags |= 128, r4 = true, e3 = e3.updateQueue, n6.updateQueue = e3, jr(n6, e3), Wr(l3, true), null === l3.tail && "hidden" === l3.tailMode && !a4.alternate && !ki) return Or(n6), null;
            } else 2 * Yu() - l3.renderingStartTime > bd && 536870912 !== t4 && (n6.flags |= 128, r4 = true, Wr(l3, false), n6.lanes = 4194304);
            l3.isBackwards ? (a4.sibling = n6.child, n6.child = a4) : (null !== (e3 = l3.last) ? e3.sibling = a4 : n6.child = a4, l3.last = a4);
          }
          return null !== l3.tail ? (e3 = l3.tail, l3.rendering = e3, l3.tail = e3.sibling, l3.renderingStartTime = Yu(), e3.sibling = null, t4 = Zs.current, S2(Zs, t4 = r4 ? t4 & Ks | Xs : t4 & Ks, n6), e3) : (Or(n6), null);
        case 22:
        case 23:
          return dn(n6), un(n6), r4 = null !== n6.memoizedState, null !== e3 ? null !== e3.memoizedState !== r4 && (n6.flags |= 8192) : r4 && (n6.flags |= 8192), r4 ? 0 != (536870912 & t4) && 0 == (128 & n6.flags) && (Or(n6), 6 & n6.subtreeFlags && (n6.flags |= 8192)) : Or(n6), null !== (t4 = n6.updateQueue) && jr(n6, t4.retryQueue), t4 = null, null !== e3 && null !== e3.memoizedState && null !== e3.memoizedState.cachePool && (t4 = e3.memoizedState.cachePool.pool), r4 = null, null !== n6.memoizedState && null !== n6.memoizedState.cachePool && (r4 = n6.memoizedState.cachePool.pool), r4 !== t4 && (n6.flags |= 2048), null !== e3 && v2(gf, n6), null;
        case 24:
          return t4 = null, null !== e3 && (t4 = e3.memoizedState.cache), n6.memoizedState.cache !== t4 && (n6.flags |= 2048), xr(mf, n6), Or(n6), null;
        case 25:
          return null;
      }
      throw Error("Unknown unit of work tag (" + n6.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Qr(e3, n6) {
      switch (D(n6), n6.tag) {
        case 1:
          return 65536 & (e3 = n6.flags) ? (n6.flags = -65537 & e3 | 128, (2 & n6.mode) !== Pi && xe(n6), n6) : null;
        case 3:
          return xr(mf, n6), j(n6), 0 != (65536 & (e3 = n6.flags)) && 0 == (128 & e3) ? (n6.flags = -65537 & e3 | 128, n6) : null;
        case 26:
        case 27:
        case 5:
          return A(n6), null;
        case 13:
          if (dn(n6), null !== (e3 = n6.memoizedState) && null !== e3.dehydrated && null === n6.alternate) throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
          return 65536 & (e3 = n6.flags) ? (n6.flags = -65537 & e3 | 128, (2 & n6.mode) !== Pi && xe(n6), n6) : null;
        case 19:
          return v2(Zs, n6), null;
        case 4:
          return j(n6), null;
        case 10:
          return xr(n6.type, n6), null;
        case 22:
        case 23:
          return dn(n6), un(n6), null !== e3 && v2(gf, n6), 65536 & (e3 = n6.flags) ? (n6.flags = -65537 & e3 | 128, (2 & n6.mode) !== Pi && xe(n6), n6) : null;
        case 24:
          return xr(mf, n6), null;
        default:
          return null;
      }
    }
    function Br(e3, n6) {
      switch (D(n6), n6.tag) {
        case 3:
          xr(mf, n6), j(n6);
          break;
        case 26:
        case 27:
        case 5:
          A(n6);
          break;
        case 4:
          j(n6);
          break;
        case 13:
          dn(n6);
          break;
        case 19:
          v2(Zs, n6);
          break;
        case 10:
          xr(n6.type, n6);
          break;
        case 22:
        case 23:
          dn(n6), un(n6), null !== e3 && v2(gf, n6);
          break;
        case 24:
          xr(mf, n6);
      }
    }
    function Vr(e3) {
      return (2 & e3.mode) !== Pi;
    }
    function $r(e3, n6) {
      Vr(e3) ? (we(), Yr(n6, e3), ke()) : Yr(n6, e3);
    }
    function qr(e3, n6, t4) {
      Vr(e3) ? (we(), Jr(t4, e3, n6), ke()) : Jr(t4, e3, n6);
    }
    function Yr(e3, n6) {
      try {
        var t4 = n6.updateQueue, r4 = null !== t4 ? t4.lastEffect : null;
        if (null !== r4) {
          var l3 = r4.next;
          t4 = l3;
          do {
            var a4;
            (t4.tag & e3) === e3 && ((e3 & lc) !== ec ? null !== ti && "function" == typeof ti.markComponentPassiveEffectMountStarted && ti.markComponentPassiveEffectMountStarted(n6) : (e3 & rc) !== ec && null !== ti && "function" == typeof ti.markComponentLayoutEffectMountStarted && ti.markComponentLayoutEffectMountStarted(n6), r4 = void 0, (e3 & tc) !== ec && (Dd = true), r4 = y2(n6, Ls, t4), (e3 & tc) !== ec && (Dd = false), (e3 & lc) !== ec ? null !== ti && "function" == typeof ti.markComponentPassiveEffectMountStopped && ti.markComponentPassiveEffectMountStopped() : (e3 & rc) !== ec && null !== ti && "function" == typeof ti.markComponentLayoutEffectMountStopped && ti.markComponentLayoutEffectMountStopped(), void 0 !== r4 && "function" != typeof r4) && y2(n6, function(e4, n7) {
              console.error("%s must not return anything besides a function, which is used for clean-up.%s", e4, n7);
            }, a4 = 0 != (t4.tag & rc) ? "useLayoutEffect" : 0 != (t4.tag & tc) ? "useInsertionEffect" : "useEffect", null === r4 ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" == typeof r4.then ? "\n\nIt looks like you wrote " + a4 + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + a4 + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + r4), t4 = t4.next;
          } while (t4 !== l3);
        }
      } catch (e4) {
        ba(n6, n6.return, e4);
      }
    }
    function Jr(e3, n6, t4) {
      try {
        var r4 = n6.updateQueue, l3 = null !== r4 ? r4.lastEffect : null;
        if (null !== l3) {
          var a4 = l3.next;
          r4 = a4;
          do {
            if ((r4.tag & e3) === e3) {
              var o3 = r4.inst, u3 = o3.destroy;
              void 0 !== u3 && (o3.destroy = void 0, (e3 & lc) !== ec ? null !== ti && "function" == typeof ti.markComponentPassiveEffectUnmountStarted && ti.markComponentPassiveEffectUnmountStarted(n6) : (e3 & rc) !== ec && null !== ti && "function" == typeof ti.markComponentLayoutEffectUnmountStarted && ti.markComponentLayoutEffectUnmountStarted(n6), (e3 & tc) !== ec && (Dd = true), y2(n6, Is, n6, t4, u3), (e3 & tc) !== ec && (Dd = false), (e3 & lc) !== ec ? null !== ti && "function" == typeof ti.markComponentPassiveEffectUnmountStopped && ti.markComponentPassiveEffectUnmountStopped() : (e3 & rc) !== ec && null !== ti && "function" == typeof ti.markComponentLayoutEffectUnmountStopped && ti.markComponentLayoutEffectUnmountStopped());
            }
            r4 = r4.next;
          } while (r4 !== a4);
        }
      } catch (e4) {
        ba(n6, n6.return, e4);
      }
    }
    function Gr(e3, n6) {
      Vr(e3) ? (we(), Yr(n6, e3), ke()) : Yr(n6, e3);
    }
    function Kr(e3, n6, t4) {
      Vr(e3) ? (we(), Jr(t4, e3, n6), ke()) : Jr(t4, e3, n6);
    }
    function Xr(e3) {
      var n6 = e3.updateQueue;
      if (null !== n6) {
        var t4 = e3.stateNode;
        e3.type.defaultProps || "ref" in e3.memoizedProps || Xc || (t4.props !== e3.memoizedProps && console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", c3(e3) || "instance"), t4.state !== e3.memoizedState && console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", c3(e3) || "instance"));
        try {
          y2(e3, Be, n6, t4);
        } catch (n7) {
          ba(e3, e3.return, n7);
        }
      }
    }
    function Zr(e3, n6, t4) {
      return e3.getSnapshotBeforeUpdate(n6, t4);
    }
    function el(e3, n6) {
      var t4 = n6.memoizedProps, r4 = n6.memoizedState;
      n6 = e3.stateNode, e3.type.defaultProps || "ref" in e3.memoizedProps || Xc || (n6.props !== e3.memoizedProps && console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", c3(e3) || "instance"), n6.state !== e3.memoizedState && console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", c3(e3) || "instance"));
      try {
        var l3 = Vt(e3.type, t4, (e3.elementType, e3.type)), a4 = y2(e3, Zr, n6, l3, r4);
        t4 = yf, void 0 !== a4 || t4.has(e3.type) || (t4.add(e3.type), y2(e3, function() {
          console.error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", c3(e3));
        })), n6.__reactInternalSnapshotBeforeUpdate = a4;
      } catch (n7) {
        ba(e3, e3.return, n7);
      }
    }
    function nl(e3, n6, t4) {
      t4.props = Vt(e3.type, e3.memoizedProps), t4.state = e3.memoizedState, Vr(e3) ? (we(), y2(e3, Ts, e3, n6, t4), ke()) : y2(e3, Ts, e3, n6, t4);
    }
    function tl(e3) {
      var n6 = e3.ref;
      if (null !== n6) {
        var t4 = e3.stateNode;
        switch (e3.tag) {
          case 26:
          case 27:
          case 5:
            t4 = Po(t4);
        }
        if ("function" == typeof n6) if (Vr(e3)) try {
          we(), e3.refCleanup = n6(t4);
        } finally {
          ke();
        }
        else e3.refCleanup = n6(t4);
        else "string" == typeof n6 ? console.error("String refs are no longer supported.") : n6.hasOwnProperty("current") || console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", c3(e3)), n6.current = t4;
      }
    }
    function rl(e3, n6) {
      try {
        y2(e3, tl, e3);
      } catch (t4) {
        ba(e3, n6, t4);
      }
    }
    function ll(e3, n6) {
      var t4 = e3.ref, r4 = e3.refCleanup;
      if (null !== t4) if ("function" == typeof r4) try {
        if (Vr(e3)) try {
          we(), y2(e3, r4);
        } finally {
          ke();
        }
        else y2(e3, r4);
      } catch (t5) {
        ba(e3, n6, t5);
      } finally {
        e3.refCleanup = null, null != (e3 = e3.alternate) && (e3.refCleanup = null);
      }
      else if ("function" == typeof t4) try {
        if (Vr(e3)) try {
          we(), y2(e3, t4, null);
        } finally {
          ke();
        }
        else y2(e3, t4, null);
      } catch (t5) {
        ba(e3, n6, t5);
      }
      else t4.current = null;
    }
    function al(e3, n6, t4, r4) {
      var l3 = e3.memoizedProps, a4 = l3.id, o3 = l3.onCommit;
      l3 = l3.onRender, n6 = null === n6 ? "mount" : "update", Ii && (n6 = "nested-update"), "function" == typeof l3 && l3(a4, n6, e3.actualDuration, e3.treeBaseDuration, e3.actualStartTime, t4), "function" == typeof o3 && o3(e3.memoizedProps.id, n6, r4, t4);
    }
    function ol(e3, n6, t4, r4) {
      var l3 = e3.memoizedProps;
      e3 = l3.id, l3 = l3.onPostCommit, n6 = null === n6 ? "mount" : "update", Ii && (n6 = "nested-update"), "function" == typeof l3 && l3(e3, n6, r4, t4);
    }
    function ul(e3) {
      var n6 = e3.type, t4 = e3.memoizedProps, r4 = e3.stateNode;
      try {
        y2(e3, au, r4, n6, t4, e3);
      } catch (n7) {
        ba(e3, e3.return, n7);
      }
    }
    function il(e3) {
      return 5 === e3.tag || 3 === e3.tag || 4 === e3.tag;
    }
    function sl(e3) {
      e: for (; ; ) {
        for (; null === e3.sibling; ) {
          if (null === e3.return || il(e3.return)) return null;
          e3 = e3.return;
        }
        for (e3.sibling.return = e3.return, e3 = e3.sibling; 5 !== e3.tag && 6 !== e3.tag && 18 !== e3.tag; ) {
          if (2 & e3.flags) continue e;
          if (null === e3.child || 4 === e3.tag) continue e;
          e3.child.return = e3, e3 = e3.child;
        }
        if (!(2 & e3.flags)) return e3.stateNode;
      }
    }
    function cl(e3, n6, t4) {
      var r4 = e3.tag;
      if (5 === r4 || 6 === r4) e3 = e3.stateNode, n6 ? iu(t4, e3, n6) : ru(t4, e3);
      else if (4 !== r4 && !Iu && null !== (e3 = e3.child)) for (cl(e3, n6, t4), e3 = e3.sibling; null !== e3; ) cl(e3, n6, t4), e3 = e3.sibling;
    }
    function fl(e3, n6, t4) {
      var r4 = e3.tag;
      if (5 === r4 || 6 === r4) e3 = e3.stateNode, n6 ? uu(t4, e3, n6) : tu(t4, e3);
      else if (4 !== r4 && !Iu && null !== (e3 = e3.child)) for (fl(e3, n6, t4), e3 = e3.sibling; null !== e3; ) fl(e3, n6, t4), e3 = e3.sibling;
    }
    function dl(e3) {
      e: {
        for (var n6 = e3.return; null !== n6; ) {
          if (il(n6)) {
            var t4 = n6;
            break e;
          }
          n6 = n6.return;
        }
        throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      }
      switch (t4.tag) {
        case 27:
        case 5:
          n6 = t4.stateNode, 32 & t4.flags && (fu(n6), t4.flags &= -33), fl(e3, t4 = sl(e3), n6);
          break;
        case 3:
        case 4:
          n6 = t4.stateNode.containerInfo, cl(e3, t4 = sl(e3), n6);
          break;
        default:
          throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function pl(e3, n6, t4) {
      var r4 = t4.flags;
      switch (t4.tag) {
        case 0:
        case 11:
        case 15:
          wl(e3, t4), 4 & r4 && $r(t4, rc | nc);
          break;
        case 1:
          if (wl(e3, t4), 4 & r4) if (e3 = t4.stateNode, null === n6) t4.type.defaultProps || "ref" in t4.memoizedProps || Xc || (e3.props !== t4.memoizedProps && console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", c3(t4) || "instance"), e3.state !== t4.memoizedState && console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", c3(t4) || "instance")), Vr(t4) ? (we(), y2(t4, zs, t4, e3), ke()) : y2(t4, zs, t4, e3);
          else {
            var l3 = Vt(t4.type, n6.memoizedProps);
            n6 = n6.memoizedState, t4.type.defaultProps || "ref" in t4.memoizedProps || Xc || (e3.props !== t4.memoizedProps && console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", c3(t4) || "instance"), e3.state !== t4.memoizedState && console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", c3(t4) || "instance")), Vr(t4) ? (we(), y2(t4, Ps, t4, e3, l3, n6, e3.__reactInternalSnapshotBeforeUpdate), ke()) : y2(t4, Ps, t4, e3, l3, n6, e3.__reactInternalSnapshotBeforeUpdate);
          }
          64 & r4 && Xr(t4), 512 & r4 && rl(t4, t4.return);
          break;
        case 3:
          if (n6 = he(), wl(e3, t4), 64 & r4 && null !== (r4 = t4.updateQueue)) {
            if (l3 = null, null !== t4.child) switch (t4.child.tag) {
              case 27:
              case 5:
                l3 = Po(t4.child.stateNode);
                break;
              case 1:
                l3 = t4.child.stateNode;
            }
            try {
              y2(t4, Be, r4, l3);
            } catch (e4) {
              ba(t4, t4.return, e4);
            }
          }
          e3.effectDuration += ge(n6);
          break;
        case 26:
        case 27:
        case 5:
          wl(e3, t4), null === n6 && 4 & r4 && ul(t4), 512 & r4 && rl(t4, t4.return);
          break;
        case 12:
          if (4 & r4) {
            r4 = he(), wl(e3, t4), (e3 = t4.stateNode).effectDuration += ye(r4);
            try {
              y2(t4, al, t4, n6, Ni, e3.effectDuration);
            } catch (e4) {
              ba(t4, t4.return, e4);
            }
          } else wl(e3, t4);
          break;
        case 13:
        default:
          wl(e3, t4);
          break;
        case 22:
          if (!(l3 = null !== t4.memoizedState || bf)) {
            n6 = null !== n6 && null !== n6.memoizedState || vf;
            var a4 = bf, o3 = vf;
            bf = l3, (vf = n6) && !o3 ? Pl(e3, t4, 0 != (8772 & t4.subtreeFlags)) : wl(e3, t4), bf = a4, vf = o3;
          }
          512 & r4 && ("manual" === t4.memoizedProps.mode ? rl(t4, t4.return) : ll(t4, t4.return));
      }
    }
    function ml(e3) {
      var n6 = e3.alternate;
      null !== n6 && (e3.alternate = null, ml(n6)), e3.child = null, e3.deletions = null, e3.sibling = null, 5 === e3.tag && null !== (n6 = e3.stateNode) && qo(n6), e3.stateNode = null, e3._debugOwner = null, e3.return = null, e3.dependencies = null, e3.memoizedProps = null, e3.memoizedState = null, e3.pendingProps = null, e3.stateNode = null, e3.updateQueue = null;
    }
    function hl(e3, n6, t4) {
      for (t4 = t4.child; null !== t4; ) gl(e3, n6, t4), t4 = t4.sibling;
    }
    function gl(e3, n6, t4) {
      switch (t4.tag) {
        case 26:
        case 27:
          var r4, l3;
        case 5:
          vf || ll(t4, n6);
        case 6:
          if (r4 = Pf, l3 = Ef, Pf = null, hl(e3, n6, t4), Ef = l3, null !== (Pf = r4)) if (Ef) try {
            y2(t4, cu, Pf, t4.stateNode);
          } catch (e4) {
            ba(t4, n6, e4);
          }
          else try {
            y2(t4, su, Pf, t4.stateNode);
          } catch (e4) {
            ba(t4, n6, e4);
          }
          break;
        case 18:
          null !== Pf && (Ef ? Pu(Pf, t4.stateNode) : Cu(Pf, t4.stateNode));
          break;
        case 4:
          r4 = Pf, l3 = Ef, Pf = t4.stateNode.containerInfo, Ef = true, hl(e3, n6, t4), Pf = r4, Ef = l3;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          vf || Jr(tc, t4, n6), vf || qr(t4, n6, rc), hl(e3, n6, t4);
          break;
        case 1:
          vf || (ll(t4, n6), "function" == typeof (r4 = t4.stateNode).componentWillUnmount && nl(t4, n6, r4)), hl(e3, n6, t4);
          break;
        case 21:
          hl(e3, n6, t4);
          break;
        case 22:
          ll(t4, n6), vf = (r4 = vf) || null !== t4.memoizedState, hl(e3, n6, t4), vf = r4;
          break;
        default:
          hl(e3, n6, t4);
      }
    }
    function yl(e3, n6) {
      var t4 = function(e4) {
        switch (e4.tag) {
          case 13:
          case 19:
            var n7 = e4.stateNode;
            return null === n7 && (n7 = e4.stateNode = new kf()), n7;
          case 22:
            return null === (n7 = (e4 = e4.stateNode)._retryCache) && (n7 = e4._retryCache = new kf()), n7;
          default:
            throw Error("Unexpected Suspense handler tag (" + e4.tag + "). This is a bug in React.");
        }
      }(e3);
      n6.forEach(function(n7) {
        var r4 = xa.bind(null, e3, n7);
        if (!t4.has(n7)) {
          if (t4.add(n7), ri) {
            if (null === xf || null === zf) throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            _a(zf, xf);
          }
          n7.then(r4, r4);
        }
      });
    }
    function bl(e3, n6) {
      var t4 = n6.deletions;
      if (null !== t4) for (var r4 = 0; r4 < t4.length; r4++) {
        var l3 = e3, a4 = n6, o3 = t4[r4], u3 = a4;
        e: for (; null !== u3; ) {
          switch (u3.tag) {
            case 27:
            case 5:
              Pf = u3.stateNode, Ef = false;
              break e;
            case 3:
            case 4:
              Pf = u3.stateNode.containerInfo, Ef = true;
              break e;
          }
          u3 = u3.return;
        }
        if (null === Pf) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        gl(l3, a4, o3), Pf = null, Ef = false, null !== (a4 = (l3 = o3).alternate) && (a4.return = null), l3.return = null;
      }
      if (13878 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) vl(n6, e3), n6 = n6.sibling;
    }
    function vl(e3, n6) {
      var t4 = e3.alternate, r4 = e3.flags;
      switch (e3.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          bl(n6, e3), Sl(e3), 4 & r4 && (Jr(tc | nc, e3, e3.return), Yr(tc | nc, e3), qr(e3, e3.return, rc | nc));
          break;
        case 1:
          bl(n6, e3), Sl(e3), 512 & r4 && null !== t4 && ll(t4, t4.return), 64 & r4 && bf && null !== (e3 = e3.updateQueue) && null !== (r4 = e3.callbacks) && (t4 = e3.shared.hiddenCallbacks, e3.shared.hiddenCallbacks = null === t4 ? r4 : t4.concat(r4));
          break;
        case 26:
          var l3;
        case 27:
          var a4;
        case 5:
          if (bl(n6, e3), Sl(e3), 512 & r4 && null !== t4 && ll(t4, t4.return), 32 & e3.flags) {
            n6 = e3.stateNode;
            try {
              y2(e3, fu, n6);
            } catch (n7) {
              ba(e3, e3.return, n7);
            }
          }
          4 & r4 && null != e3.stateNode && function(e4, n7, t5) {
            try {
              y2(e4, ou, e4.stateNode, e4.type, t5, n7, e4);
            } catch (n8) {
              ba(e4, e4.return, n8);
            }
          }(e3, n6 = e3.memoizedProps, null !== t4 ? t4.memoizedProps : n6), 1024 & r4 && (Sf = true, "form" !== e3.type && console.error("Unexpected host component type. Expected a form. This is a bug in React."));
          break;
        case 6:
          if (bl(n6, e3), Sl(e3), 4 & r4 && jo) {
            if (null === e3.stateNode) throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            r4 = e3.memoizedProps, t4 = null !== t4 ? t4.memoizedProps : r4, n6 = e3.stateNode;
            try {
              y2(e3, lu, n6, t4, r4);
            } catch (n7) {
              ba(e3, e3.return, n7);
            }
          }
          break;
        case 3:
          l3 = he(), bl(n6, e3), Sl(e3), Sf && (Sf = false, kl(e3)), n6.effectDuration += ge(l3);
          break;
        case 4:
          bl(n6, e3), Sl(e3), 4 & r4 && Wo && function(e4, n7, t5) {
            e4 = e4.containerInfo;
            try {
              y2(n7, yu, e4, t5);
            } catch (e5) {
              ba(n7, n7.return, e5);
            }
          }(e3.stateNode, e3, e3.stateNode.pendingChildren);
          break;
        case 12:
          r4 = he(), bl(n6, e3), Sl(e3), e3.stateNode.effectDuration += ye(r4);
          break;
        case 13:
          bl(n6, e3), Sl(e3), 8192 & e3.child.flags && null !== e3.memoizedState != (null !== t4 && null !== t4.memoizedState) && (gd = Yu()), 4 & r4 && null !== (r4 = e3.updateQueue) && (e3.updateQueue = null, yl(e3, r4));
          break;
        case 22:
          512 & r4 && null !== t4 && ll(t4, t4.return), l3 = null !== e3.memoizedState;
          var o3 = null !== t4 && null !== t4.memoizedState, u3 = bf, i4 = vf;
          if (bf = u3 || l3, vf = i4 || o3, bl(n6, e3), vf = i4, bf = u3, Sl(e3), (n6 = e3.stateNode)._current = e3, n6._visibility &= -3, n6._visibility |= 2 & n6._pendingVisibility, 8192 & r4 && (n6._visibility = l3 ? -2 & n6._visibility : 1 | n6._visibility, l3 && (n6 = bf || vf, null === t4 || o3 || n6 || zl(e3)), null === e3.memoizedProps || "manual" !== e3.memoizedProps.mode)) {
            e: if (t4 = null, jo) for (n6 = e3; ; ) {
              if (5 === n6.tag || Nu || Iu) {
                if (null === t4) {
                  o3 = t4 = n6;
                  try {
                    a4 = o3.stateNode, l3 ? y2(o3, du, a4) : y2(o3, mu, o3.stateNode, o3.memoizedProps);
                  } catch (e4) {
                    ba(o3, o3.return, e4);
                  }
                }
              } else if (6 === n6.tag) {
                if (null === t4) {
                  o3 = n6;
                  try {
                    var s3 = o3.stateNode;
                    l3 ? y2(o3, pu, s3) : y2(o3, hu, s3, o3.memoizedProps);
                  } catch (e4) {
                    ba(o3, o3.return, e4);
                  }
                }
              } else if ((22 !== n6.tag && 23 !== n6.tag || null === n6.memoizedState || n6 === e3) && null !== n6.child) {
                n6.child.return = n6, n6 = n6.child;
                continue;
              }
              if (n6 === e3) break e;
              for (; null === n6.sibling; ) {
                if (null === n6.return || n6.return === e3) break e;
                t4 === n6 && (t4 = null), n6 = n6.return;
              }
              t4 === n6 && (t4 = null), n6.sibling.return = n6.return, n6 = n6.sibling;
            }
          }
          4 & r4 && null !== (r4 = e3.updateQueue) && null !== (t4 = r4.retryQueue) && (r4.retryQueue = null, yl(e3, t4));
          break;
        case 19:
          bl(n6, e3), Sl(e3), 4 & r4 && null !== (r4 = e3.updateQueue) && (e3.updateQueue = null, yl(e3, r4));
          break;
        case 21:
          break;
        default:
          bl(n6, e3), Sl(e3);
      }
    }
    function Sl(e3) {
      var n6 = e3.flags;
      if (2 & n6) {
        try {
          y2(e3, dl, e3);
        } catch (n7) {
          ba(e3, e3.return, n7);
        }
        e3.flags &= -3;
      }
      4096 & n6 && (e3.flags &= -4097);
    }
    function kl(e3) {
      if (1024 & e3.subtreeFlags) for (e3 = e3.child; null !== e3; ) {
        var n6 = e3;
        kl(n6), 5 === n6.tag && 1024 & n6.flags && nu(n6.stateNode), e3 = e3.sibling;
      }
    }
    function wl(e3, n6) {
      if (8772 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) pl(e3, n6.alternate, n6), n6 = n6.sibling;
    }
    function xl(e3) {
      switch (e3.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          qr(e3, e3.return, rc), zl(e3);
          break;
        case 1:
          ll(e3, e3.return);
          var n6 = e3.stateNode;
          "function" == typeof n6.componentWillUnmount && nl(e3, e3.return, n6), zl(e3);
          break;
        case 26:
        case 27:
        case 5:
          ll(e3, e3.return), zl(e3);
          break;
        case 22:
          ll(e3, e3.return), null === e3.memoizedState && zl(e3);
          break;
        default:
          zl(e3);
      }
    }
    function zl(e3) {
      for (e3 = e3.child; null !== e3; ) xl(e3), e3 = e3.sibling;
    }
    function Cl(e3, n6, t4, r4) {
      var l3 = t4.flags;
      switch (t4.tag) {
        case 0:
        case 11:
        case 15:
          Pl(e3, t4, r4), $r(t4, rc);
          break;
        case 1:
          if (Pl(e3, t4, r4), "function" == typeof (n6 = t4.stateNode).componentDidMount && y2(t4, zs, t4, n6), null !== (n6 = t4.updateQueue)) {
            e3 = t4.stateNode;
            try {
              y2(t4, Qe, n6, e3);
            } catch (e4) {
              ba(t4, t4.return, e4);
            }
          }
          r4 && 64 & l3 && Xr(t4), rl(t4, t4.return);
          break;
        case 26:
        case 27:
        case 5:
          Pl(e3, t4, r4), r4 && null === n6 && 4 & l3 && ul(t4), rl(t4, t4.return);
          break;
        case 12:
          if (r4 && 4 & l3) {
            l3 = he(), Pl(e3, t4, r4), (r4 = t4.stateNode).effectDuration += ye(l3);
            try {
              y2(t4, al, t4, n6, Ni, r4.effectDuration);
            } catch (e4) {
              ba(t4, t4.return, e4);
            }
          } else Pl(e3, t4, r4);
          break;
        case 13:
        default:
          Pl(e3, t4, r4);
          break;
        case 22:
          null === t4.memoizedState && Pl(e3, t4, r4), rl(t4, t4.return);
      }
    }
    function Pl(e3, n6, t4) {
      for (t4 = t4 && 0 != (8772 & n6.subtreeFlags), n6 = n6.child; null !== n6; ) Cl(e3, n6.alternate, n6, t4), n6 = n6.sibling;
    }
    function El(e3, n6) {
      var t4 = null;
      null !== e3 && null !== e3.memoizedState && null !== e3.memoizedState.cachePool && (t4 = e3.memoizedState.cachePool.pool), e3 = null, null !== n6.memoizedState && null !== n6.memoizedState.cachePool && (e3 = n6.memoizedState.cachePool.pool), e3 !== t4 && (null != e3 && Ur(e3), null != t4 && Ir(t4));
    }
    function _l(e3, n6) {
      e3 = null, null !== n6.alternate && (e3 = n6.alternate.memoizedState.cache), (n6 = n6.memoizedState.cache) !== e3 && (Ur(n6), null != e3 && Ir(e3));
    }
    function Rl(e3, n6, t4, r4) {
      if (10256 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) Tl(e3, n6, t4, r4), n6 = n6.sibling;
    }
    function Tl(e3, n6, t4, r4) {
      var l3 = n6.flags;
      switch (n6.tag) {
        case 0:
        case 11:
        case 15:
          Rl(e3, n6, t4, r4), 2048 & l3 && Gr(n6, lc | nc);
          break;
        case 3:
          var a4 = he();
          Rl(e3, n6, t4, r4), 2048 & l3 && (t4 = null, null !== n6.alternate && (t4 = n6.alternate.memoizedState.cache), (n6 = n6.memoizedState.cache) !== t4 && (Ur(n6), null != t4 && Ir(t4))), e3.passiveEffectDuration += ge(a4);
          break;
        case 12:
          if (2048 & l3) {
            a4 = he(), Rl(e3, n6, t4, r4), (e3 = n6.stateNode).passiveEffectDuration += ye(a4);
            try {
              y2(n6, ol, n6, n6.alternate, Ni, e3.passiveEffectDuration);
            } catch (e4) {
              ba(n6, n6.return, e4);
            }
          } else Rl(e3, n6, t4, r4);
          break;
        case 23:
          break;
        case 22:
          a4 = n6.stateNode, null !== n6.memoizedState ? 4 & a4._visibility ? Rl(e3, n6, t4, r4) : Ul(e3, n6) : 4 & a4._visibility ? Rl(e3, n6, t4, r4) : (a4._visibility |= 4, Nl(e3, n6, t4, r4, 0 != (10256 & n6.subtreeFlags))), 2048 & l3 && El(n6.alternate, n6);
          break;
        case 24:
          Rl(e3, n6, t4, r4), 2048 & l3 && _l(n6.alternate, n6);
          break;
        default:
          Rl(e3, n6, t4, r4);
      }
    }
    function Nl(e3, n6, t4, r4, l3) {
      for (l3 = l3 && 0 != (10256 & n6.subtreeFlags), n6 = n6.child; null !== n6; ) Ll(e3, n6, t4, r4, l3), n6 = n6.sibling;
    }
    function Ll(e3, n6, t4, r4, l3) {
      var a4 = n6.flags;
      switch (n6.tag) {
        case 0:
        case 11:
        case 15:
          Nl(e3, n6, t4, r4, l3), Gr(n6, lc);
          break;
        case 23:
          break;
        case 22:
          var o3 = n6.stateNode;
          null !== n6.memoizedState ? 4 & o3._visibility ? Nl(e3, n6, t4, r4, l3) : Ul(e3, n6) : (o3._visibility |= 4, Nl(e3, n6, t4, r4, l3)), l3 && 2048 & a4 && El(n6.alternate, n6);
          break;
        case 24:
          Nl(e3, n6, t4, r4, l3), l3 && 2048 & a4 && _l(n6.alternate, n6);
          break;
        default:
          Nl(e3, n6, t4, r4, l3);
      }
    }
    function Ul(e3, n6) {
      if (10256 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) {
        var t4 = e3, r4 = n6, l3 = r4.flags;
        switch (r4.tag) {
          case 22:
            Ul(t4, r4), 2048 & l3 && El(r4.alternate, r4);
            break;
          case 24:
            Ul(t4, r4), 2048 & l3 && _l(r4.alternate, r4);
            break;
          default:
            Ul(t4, r4);
        }
        n6 = n6.sibling;
      }
    }
    function Il(e3) {
      if (e3.subtreeFlags & Rf) for (e3 = e3.child; null !== e3; ) Dl(e3), e3 = e3.sibling;
    }
    function Dl(e3) {
      switch (e3.tag) {
        case 26:
          Il(e3), e3.flags & Rf && (null !== e3.memoizedState ? Uu(_f, e3.memoizedState, e3.memoizedProps) : Ko(e3.type, e3.memoizedProps));
          break;
        case 5:
          Il(e3), e3.flags & Rf && Ko(e3.type, e3.memoizedProps);
          break;
        case 3:
        case 4:
          var n6;
          Il(e3);
          break;
        case 22:
          null === e3.memoizedState && (null !== (n6 = e3.alternate) && null !== n6.memoizedState ? (n6 = Rf, Rf = 16777216, Il(e3), Rf = n6) : Il(e3));
          break;
        default:
          Il(e3);
      }
    }
    function Fl(e3) {
      var n6 = e3.alternate;
      if (null !== n6 && null !== (e3 = n6.child)) {
        n6.child = null;
        do {
          n6 = e3.sibling, e3.sibling = null, e3 = n6;
        } while (null !== e3);
      }
    }
    function Ml(e3) {
      var n6 = e3.deletions;
      if (0 != (16 & e3.flags)) {
        if (null !== n6) for (var t4 = 0; t4 < n6.length; t4++) {
          var r4 = n6[t4];
          wf = r4, Ol(r4, e3);
        }
        Fl(e3);
      }
      if (10256 & e3.subtreeFlags) for (e3 = e3.child; null !== e3; ) Hl(e3), e3 = e3.sibling;
    }
    function Hl(e3) {
      switch (e3.tag) {
        case 0:
        case 11:
        case 15:
          Ml(e3), 2048 & e3.flags && Kr(e3, e3.return, lc | nc);
          break;
        case 3:
          var n6 = he();
          Ml(e3), e3.stateNode.passiveEffectDuration += ge(n6);
          break;
        case 12:
          n6 = he(), Ml(e3), e3.stateNode.passiveEffectDuration += ye(n6);
          break;
        case 22:
          n6 = e3.stateNode, null !== e3.memoizedState && 4 & n6._visibility && (null === e3.return || 13 !== e3.return.tag) ? (n6._visibility &= -5, jl(e3)) : Ml(e3);
          break;
        default:
          Ml(e3);
      }
    }
    function jl(e3) {
      var n6 = e3.deletions;
      if (0 != (16 & e3.flags)) {
        if (null !== n6) for (var t4 = 0; t4 < n6.length; t4++) {
          var r4 = n6[t4];
          wf = r4, Ol(r4, e3);
        }
        Fl(e3);
      }
      for (e3 = e3.child; null !== e3; ) Wl(e3), e3 = e3.sibling;
    }
    function Wl(e3) {
      switch (e3.tag) {
        case 0:
        case 11:
        case 15:
          Kr(e3, e3.return, lc), jl(e3);
          break;
        case 22:
          var n6 = e3.stateNode;
          4 & n6._visibility && (n6._visibility &= -5, jl(e3));
          break;
        default:
          jl(e3);
      }
    }
    function Ol(e3, n6) {
      for (; null !== wf; ) {
        var t4 = wf, r4 = t4;
        switch (r4.tag) {
          case 0:
          case 11:
          case 15:
            Kr(r4, n6, lc);
            break;
          case 23:
          case 22:
            null !== r4.memoizedState && null !== r4.memoizedState.cachePool && null != (r4 = r4.memoizedState.cachePool.pool) && Ur(r4);
            break;
          case 24:
            Ir(r4.memoizedState.cache);
        }
        if (null !== (r4 = t4.child)) r4.return = t4, wf = r4;
        else e: for (t4 = e3; null !== wf; ) {
          var l3 = (r4 = wf).sibling, a4 = r4.return;
          if (ml(r4), r4 === t4) {
            wf = null;
            break e;
          }
          if (null !== l3) {
            l3.return = a4, wf = l3;
            break e;
          }
          wf = a4;
        }
      }
    }
    function Al() {
      var e3 = "undefined" != typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
      return e3 || null === yo.actQueue || console.error("The current testing environment is not configured to support act(...)"), e3;
    }
    function Ql(e3) {
      if ((Qf & If) !== Uf && 0 !== $f) return $f & -$f;
      var n6 = yo.T;
      return null !== n6 ? (n6._updatedFibers || (n6._updatedFibers = /* @__PURE__ */ new Set()), n6._updatedFibers.add(e3), 0 !== (e3 = $i) ? e3 : Le()) : Vo();
    }
    function Bl() {
      0 === fd && (fd = 0 == (536870912 & $f) || ki ? z() : 536870912);
      var e3 = Js.current;
      return null !== e3 && (e3.flags |= 32), fd;
    }
    function Vl(e3, n6, t4) {
      if (Dd && console.error("useInsertionEffect must not schedule updates."), Td && (Nd = true), (e3 === Bf && td === Jf || null !== e3.cancelPendingCommit) && (Xl(e3, 0), Gl(e3, $f, fd)), E(e3, t4), 0 != (Qf & If) && e3 === Bf) {
        if (zo) switch (n6.tag) {
          case 0:
          case 11:
          case 15:
            e3 = Vf && c3(Vf) || "Unknown", Od.has(e3) || (Od.add(e3), n6 = c3(n6) || "Unknown", console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render", n6, e3, e3));
            break;
          case 1:
            Wd || (console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), Wd = true);
        }
      } else ri && T(e3, n6, t4), function(e4) {
        Al() && null === yo.actQueue && y2(e4, function() {
          console.error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act", c3(e4));
        });
      }(n6), e3 === Bf && ((Qf & If) === Uf && (sd |= t4), ud === Wf && Gl(e3, $f, fd)), ze(e3);
    }
    function $l(e3, n6, t4) {
      if ((Qf & (If | Df)) !== Uf) throw Error("Should not already be working.");
      var r4 = (t4 = !t4 && 0 == (60 & n6) && 0 == (n6 & e3.expiredLanes)) ? function(e4, n7) {
        var t5 = Qf;
        Qf |= If;
        var r5 = na(), l4 = ta();
        if (Bf !== e4 || $f !== n7) {
          if (ri) {
            var a5 = e4.memoizedUpdaters;
            0 < a5.size && (_a(e4, $f), a5.clear()), N(e4, n7);
          }
          Sd = null, bd = Yu() + vd, Xl(e4, n7);
        }
        e: for (; ; ) try {
          if (td !== qf && null !== Vf) n: switch (n7 = Vf, a5 = rd, td) {
            case Yf:
              td = qf, rd = null, ca(e4, n7, a5);
              break;
            case Jf:
              if ($e(a5)) {
                td = qf, rd = null, ia(n7);
                break;
              }
              n7 = function() {
                td === Jf && Bf === e4 && (td = ed), ze(e4);
              }, a5.then(n7, n7);
              break e;
            case Gf:
              td = ed;
              break e;
            case Kf:
              td = Xf;
              break e;
            case ed:
              $e(a5) ? (td = qf, rd = null, ia(n7)) : (td = qf, rd = null, ca(e4, n7, a5));
              break;
            case Xf:
              var o4 = null;
              switch (Vf.tag) {
                case 26:
                  o4 = Vf.memoizedState;
                case 5:
                case 27:
                  var u4 = Vf, i4 = u4.type, s3 = u4.pendingProps;
                  if (o4 ? Lu(o4) : Jo(i4, s3)) {
                    td = qf, rd = null;
                    var c4 = u4.sibling;
                    if (null !== c4) Vf = c4;
                    else {
                      var f3 = u4.return;
                      null !== f3 ? (Vf = f3, fa(f3)) : Vf = null;
                    }
                    break n;
                  }
                  break;
                default:
                  console.error("Unexpected type of fiber triggered a suspensey commit. This is a bug in React.");
              }
              td = qf, rd = null, ca(e4, n7, a5);
              break;
            case Zf:
              td = qf, rd = null, ca(e4, n7, a5);
              break;
            case nd:
              Kl(), ud = Af;
              break e;
            default:
              throw Error("Unexpected SuspendedReason. This is a bug in React.");
          }
          null !== yo.actQueue ? aa() : oa();
          break;
        } catch (n8) {
          Zl(e4, n8);
        }
        return kr(), yo.H = r5, yo.A = l4, Qf = t5, null !== Vf ? Ff : (Bf = null, $f = 0, se(), ud);
      }(e3, n6) : la(e3, n6);
      if (r4 !== Ff) for (var l3 = t4; ; ) {
        if (r4 === Af) Gl(e3, n6, 0);
        else {
          if (t4 = e3.current.alternate, l3 && !Jl(t4)) {
            r4 = la(e3, n6), l3 = false;
            continue;
          }
          if (r4 === Hf) {
            if (l3 = n6, e3.errorRecoveryDisabledLanes & l3) var a4 = 0;
            else a4 = 0 != (a4 = -536870913 & e3.pendingLanes) ? a4 : 536870912 & a4 ? 536870912 : 0;
            if (0 !== a4) {
              n6 = a4;
              e: {
                r4 = e3;
                var o3 = a4;
                a4 = pd;
                var u3 = Oo;
                if (u3 && (Xl(r4, o3).flags |= 256), (o3 = la(r4, o3)) !== Hf) {
                  if (ad && !u3) {
                    r4.errorRecoveryDisabledLanes |= l3, sd |= l3, r4 = Wf;
                    break e;
                  }
                  r4 = md, md = a4, null !== r4 && ql(r4);
                }
                r4 = o3;
              }
              if (l3 = false, r4 !== Hf) continue;
            }
          }
          if (r4 === Mf) {
            Xl(e3, 0), Gl(e3, n6, 0);
            break;
          }
          e: {
            switch (l3 = e3, r4) {
              case Ff:
              case Mf:
                throw Error("Root did not complete. This is a bug in React.");
              case Wf:
                if ((4194176 & n6) === n6) {
                  Gl(l3, n6, fd);
                  break e;
                }
                break;
              case Hf:
                md = null;
                break;
              case jf:
              case Of:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (l3.finishedWork = t4, l3.finishedLanes = n6, null !== yo.actQueue) pa(l3, md, Sd, hd, fd);
            else {
              if ((62914560 & n6) === n6 && 10 < (r4 = gd + yd - Yu())) {
                if (Gl(l3, n6, fd), 0 !== w(l3, 0)) break e;
                l3.timeoutHandle = Fo(Yl.bind(null, l3, t4, md, Sd, hd, n6, fd, sd, dd, ld, Hd, -0, 0), r4);
                break e;
              }
              Yl(l3, t4, md, Sd, hd, n6, fd, sd, dd, ld, Fd, -0, 0);
            }
          }
        }
        break;
      }
      ze(e3);
    }
    function ql(e3) {
      null === md ? md = e3 : md.push.apply(md, e3);
    }
    function Yl(e3, n6, t4, r4, l3, a4, o3, u3, i4, s3, c4, f3, d3) {
      if ((8192 & (s3 = n6.subtreeFlags) || 16785408 == (16785408 & s3)) && (Go(), Dl(n6), null !== (n6 = Xo()))) return e3.cancelPendingCommit = n6(pa.bind(null, e3, t4, r4, l3, o3, u3, i4, Md, f3, d3)), void Gl(e3, a4, o3);
      pa(e3, t4, r4, l3, o3);
    }
    function Jl(e3) {
      for (var n6 = e3; ; ) {
        var t4 = n6.tag;
        if ((0 === t4 || 11 === t4 || 15 === t4) && 16384 & n6.flags && null !== (t4 = n6.updateQueue) && null !== (t4 = t4.stores)) for (var r4 = 0; r4 < t4.length; r4++) {
          var l3 = t4[r4], a4 = l3.getSnapshot;
          l3 = l3.value;
          try {
            if (!li(a4(), l3)) return false;
          } catch (e4) {
            return false;
          }
        }
        if (t4 = n6.child, 16384 & n6.subtreeFlags && null !== t4) t4.return = n6, n6 = t4;
        else {
          if (n6 === e3) break;
          for (; null === n6.sibling; ) {
            if (null === n6.return || n6.return === e3) return true;
            n6 = n6.return;
          }
          n6.sibling.return = n6.return, n6 = n6.sibling;
        }
      }
      return true;
    }
    function Gl(e3, n6, t4) {
      n6 &= ~cd, n6 &= ~sd, e3.suspendedLanes |= n6, e3.pingedLanes &= ~n6;
      for (var r4 = e3.expirationTimes, l3 = n6; 0 < l3; ) {
        var a4 = 31 - ju(l3), o3 = 1 << a4;
        r4[a4] = -1, l3 &= ~o3;
      }
      0 !== t4 && _(e3, t4, n6);
    }
    function Kl() {
      if (null !== Vf) {
        if (td === qf) var e3 = Vf.return;
        else e3 = Vf, kr(), Pn(e3), Ms = null, Hs = 0, e3 = Vf;
        for (; null !== e3; ) Br(e3.alternate, e3), e3 = e3.return;
        Vf = null;
      }
    }
    function Xl(e3, n6) {
      e3.finishedWork = null, e3.finishedLanes = 0;
      var t4 = e3.timeoutHandle;
      t4 !== Ho && (e3.timeoutHandle = Ho, Mo(t4)), null !== (t4 = e3.cancelPendingCommit) && (e3.cancelPendingCommit = null, t4()), Kl(), Bf = e3, Vf = t4 = Na(e3.current, null), $f = n6, td = qf, rd = null, ad = ld = false, ud = Ff, dd = fd = cd = sd = id = 0, md = pd = null, hd = false, 0 != (8 & n6) && (n6 |= 32 & n6);
      var r4 = e3.entangledLanes;
      if (0 !== r4) for (e3 = e3.entanglements, r4 &= n6; 0 < r4; ) {
        var l3 = 31 - ju(r4), a4 = 1 << l3;
        n6 |= e3[l3], r4 &= ~a4;
      }
      return od = n6, se(), rs.discardPendingWarnings(), t4;
    }
    function Zl(e3, n6) {
      cc = null, yo.H = Pc, yo.getCurrentStack = null, zo = false, xo = null, n6 === ms ? (n6 = Je(), td = ea() && 0 == (134217727 & id) && 0 == (134217727 & sd) ? Jf : Gf) : n6 === hs ? (n6 = Je(), td = Kf) : td = n6 === $c ? nd : null !== n6 && "object" == typeof n6 && "function" == typeof n6.then ? Zf : Yf, rd = n6;
      var t4 = Vf;
      null === t4 ? (ud = Mf, $t(e3, I(n6, e3.current))) : 2 & t4.mode && ve(t4);
    }
    function ea() {
      var e3 = Js.current;
      return null === e3 || ((4194176 & $f) === $f ? null === Gs : ((62914560 & $f) === $f || 0 != (536870912 & $f)) && e3 === Gs);
    }
    function na() {
      var e3 = yo.H;
      return yo.H = Pc, null === e3 ? Pc : e3;
    }
    function ta() {
      var e3 = yo.A;
      return yo.A = Tf, e3;
    }
    function ra() {
      ud = Wf, 0 == (134217727 & id) && 0 == (134217727 & sd) || null === Bf || Gl(Bf, $f, fd);
    }
    function la(e3, n6) {
      var t4 = Qf;
      Qf |= If;
      var r4 = na(), l3 = ta();
      if (Bf !== e3 || $f !== n6) {
        if (ri) {
          var a4 = e3.memoizedUpdaters;
          0 < a4.size && (_a(e3, $f), a4.clear()), N(e3, n6);
        }
        Sd = null, Xl(e3, n6);
      }
      n6 = false;
      e: for (; ; ) try {
        if (td !== qf && null !== Vf) {
          a4 = Vf;
          var o3 = rd;
          switch (td) {
            case nd:
              Kl(), ud = Af;
              break e;
            case Gf:
            case Jf:
              n6 || null !== Js.current || (n6 = true);
            default:
              td = qf, rd = null, ca(e3, a4, o3);
          }
        }
        aa();
        break;
      } catch (n7) {
        Zl(e3, n7);
      }
      if (n6 && e3.shellSuspendCounter++, kr(), Qf = t4, yo.H = r4, yo.A = l3, null !== Vf) throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Bf = null, $f = 0, se(), ud;
    }
    function aa() {
      for (; null !== Vf; ) ua(Vf);
    }
    function oa() {
      for (; null !== Vf && !$u(); ) ua(Vf);
    }
    function ua(e3) {
      var n6 = e3.alternate;
      (2 & e3.mode) !== Pi ? (be(e3), n6 = y2(e3, Sr, n6, e3, od), ve(e3)) : n6 = y2(e3, Sr, n6, e3, od), e3.memoizedProps = e3.pendingProps, null === n6 ? fa(e3) : Vf = n6;
    }
    function ia(e3) {
      var n6 = y2(e3, sa, e3);
      e3.memoizedProps = e3.pendingProps, null === n6 ? fa(e3) : Vf = n6;
    }
    function sa(e3) {
      var n6 = e3.alternate, t4 = (2 & e3.mode) !== Pi;
      switch (t4 && be(e3), e3.tag) {
        case 15:
        case 0:
          n6 = ar(n6, e3, e3.pendingProps, e3.type, void 0, $f);
          break;
        case 11:
          n6 = ar(n6, e3, e3.pendingProps, e3.type.render, e3.ref, $f);
          break;
        case 5:
          Pn(e3);
        default:
          Br(n6, e3), n6 = Sr(n6, e3 = Vf = La(e3, od), od);
      }
      return t4 && ve(e3), n6;
    }
    function ca(e3, n6, t4) {
      kr(), Pn(n6), Ms = null, Hs = 0;
      var r4 = n6.return;
      try {
        if (function(e4, n7, t5, r5, l3) {
          if (t5.flags |= 32768, ri && _a(e4, l3), null !== r5 && "object" == typeof r5 && "function" == typeof r5.then) {
            if (null !== (n7 = t5.alternate) && Pr(n7, t5, l3, true), null !== (t5 = Js.current)) {
              switch (t5.tag) {
                case 13:
                  return null === Gs ? ra() : null === t5.alternate && ud === Ff && (ud = jf), t5.flags &= -257, t5.flags |= 65536, t5.lanes = l3, r5 === gs ? t5.flags |= 16384 : (null === (n7 = t5.updateQueue) ? t5.updateQueue = /* @__PURE__ */ new Set([r5]) : n7.add(r5), va(e4, r5, l3)), false;
                case 22:
                  return t5.flags |= 65536, r5 === gs ? t5.flags |= 16384 : (null === (n7 = t5.updateQueue) ? (n7 = { transitions: null, markerInstances: null, retryQueue: /* @__PURE__ */ new Set([r5]) }, t5.updateQueue = n7) : null === (t5 = n7.retryQueue) ? n7.retryQueue = /* @__PURE__ */ new Set([r5]) : t5.add(r5), va(e4, r5, l3)), false;
              }
              throw Error("Unexpected Suspense handler tag (" + t5.tag + "). This is a bug in React.");
            }
            return va(e4, r5, l3), ra(), false;
          }
          var a4 = I(Error("There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.", { cause: r5 }), t5);
          if (null === pd ? pd = [a4] : pd.push(a4), ud !== Wf && (ud = Hf), null === n7) return true;
          r5 = I(r5, t5), t5 = n7;
          do {
            switch (t5.tag) {
              case 3:
                return t5.flags |= 65536, e4 = l3 & -l3, t5.lanes |= e4, je(t5, e4 = Yt(t5.stateNode, r5, e4)), false;
              case 1:
                if (n7 = t5.type, a4 = t5.stateNode, 0 == (128 & t5.flags) && ("function" == typeof n7.getDerivedStateFromError || null !== a4 && "function" == typeof a4.componentDidCatch && (null === kd || !kd.has(a4)))) return t5.flags |= 65536, l3 &= -l3, t5.lanes |= l3, Gt(l3 = Jt(l3), e4, t5, r5), je(t5, l3), false;
            }
            t5 = t5.return;
          } while (null !== t5);
          return false;
        }(e3, r4, n6, t4, $f)) return ud = Mf, $t(e3, I(t4, e3.current)), void (Vf = null);
      } catch (n7) {
        if (null !== r4) throw Vf = r4, n7;
        return ud = Mf, $t(e3, I(t4, e3.current)), void (Vf = null);
      }
      32768 & n6.flags ? da(n6, true) : fa(n6);
    }
    function fa(e3) {
      var n6 = e3;
      do {
        if (0 != (32768 & n6.flags)) return void da(n6, ld);
        var t4 = n6.alternate;
        if (e3 = n6.return, be(n6), t4 = y2(n6, Ar, t4, n6, od), (2 & n6.mode) !== Pi && Se(n6), null !== t4) return void (Vf = t4);
        if (null !== (n6 = n6.sibling)) return void (Vf = n6);
        Vf = n6 = e3;
      } while (null !== n6);
      ud === Ff && (ud = Of);
    }
    function da(e3, n6) {
      do {
        var t4 = Qr(e3.alternate, e3);
        if (null !== t4) return t4.flags &= 32767, void (Vf = t4);
        if ((2 & e3.mode) !== Pi) {
          Se(e3), t4 = e3.actualDuration;
          for (var r4 = e3.child; null !== r4; ) t4 += r4.actualDuration, r4 = r4.sibling;
          e3.actualDuration = t4;
        }
        if (null !== (t4 = e3.return) && (t4.flags |= 32768, t4.subtreeFlags = 0, t4.deletions = null), !n6 && null !== (e3 = e3.sibling)) return void (Vf = e3);
        Vf = e3 = t4;
      } while (null !== e3);
      ud = Af, Vf = null;
    }
    function pa(e3, n6, t4, r4, l3, a4, o3, u3, i4, s3) {
      var c4 = yo.T, f3 = Bo();
      try {
        Qo(2), yo.T = null, function(e4, n7, t5, r5, l4, a5) {
          do {
            ga();
          } while (null !== xd);
          if (rs.flushLegacyContextWarning(), rs.flushPendingUnsafeLifecycleWarnings(), (Qf & (If | Df)) !== Uf) throw Error("Should not already be working.");
          var o4 = e4.finishedWork;
          if (r5 = e4.finishedLanes, null === o4) return null;
          if (0 === r5 && console.error("root.finishedLanes should not be empty during a commit. This is a bug in React."), e4.finishedWork = null, e4.finishedLanes = 0, o4 === e4.current) throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
          e4.callbackNode = null, e4.callbackPriority = 0, e4.cancelPendingCommit = null;
          var u4, i5, s4, c5 = o4.lanes | o4.childLanes;
          if (function(e5, n8, t6, r6) {
            var l5 = e5.pendingLanes;
            e5.pendingLanes = t6, e5.suspendedLanes = 0, e5.pingedLanes = 0, e5.warmLanes = 0, e5.expiredLanes &= t6, e5.entangledLanes &= t6, e5.errorRecoveryDisabledLanes &= t6, e5.shellSuspendCounter = 0, n8 = e5.entanglements;
            var a6 = e5.expirationTimes, o5 = e5.hiddenUpdates;
            for (t6 = l5 & ~t6; 0 < t6; ) {
              var u5 = 31 - ju(t6);
              l5 = 1 << u5, n8[u5] = 0, a6[u5] = -1;
              var i6 = o5[u5];
              if (null !== i6) for (o5[u5] = null, u5 = 0; u5 < i6.length; u5++) {
                var s5 = i6[u5];
                null !== s5 && (s5.lane &= -536870913);
              }
              t6 &= ~l5;
            }
            0 !== r6 && _(e5, r6, 0);
          }(e4, r5, c5 |= Ri, a5), e4 === Bf && (Vf = Bf = null, $f = 0), 0 == (10256 & o4.subtreeFlags) && 0 == (10256 & o4.flags) || wd || (wd = true, Cd = c5, Pd = t5, u4 = Ku, i5 = function() {
            return ga(), null;
          }, null !== (s4 = yo.actQueue) ? s4.push(i5) : Bu(u4, i5)), Ni = Ti(), t5 = 0 != (15990 & o4.flags), 0 != (15990 & o4.subtreeFlags) || t5) {
            t5 = yo.T, yo.T = null, a5 = Bo(), Qo(2);
            var f4 = Qf;
            Qf |= Df, function(e5, n8) {
              for (Ro(e5.containerInfo), wf = n8; null !== wf; ) if (n8 = (e5 = wf).child, 0 != (1028 & e5.subtreeFlags) && null !== n8) n8.return = e5, wf = n8;
              else for (; null !== wf; ) {
                var t6 = (n8 = e5 = wf).alternate, r6 = n8.flags;
                switch (n8.tag) {
                  case 0:
                  case 11:
                  case 15:
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  case 1:
                    0 != (1024 & r6) && null !== t6 && el(n8, t6);
                    break;
                  case 3:
                    0 != (1024 & r6) && jo && gu(n8.stateNode.containerInfo);
                    break;
                  default:
                    if (0 != (1024 & r6)) throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                }
                if (null !== (n8 = e5.sibling)) {
                  n8.return = e5.return, wf = n8;
                  break;
                }
                wf = e5.return;
              }
              e5 = Cf, Cf = false;
            }(e4, o4), function(e5, n8, t6) {
              xf = t6, zf = e5, vl(n8, e5), zf = xf = null;
            }(e4, o4, r5), To(e4.containerInfo), e4.current = o4, function(e5, n8, t6) {
              xf = t6, zf = n8, pl(n8, e5.alternate, e5), zf = xf = null;
            }(o4, e4, r5), qu(), Qf = f4, Qo(a5), yo.T = t5;
          } else e4.current = o4;
          if ((t5 = wd) ? (wd = false, xd = e4, zd = r5) : (ha(e4, c5), Ud = 0, Id = null), 0 === (c5 = e4.pendingLanes) && (kd = null), t5 || Pa(e4), o4.stateNode, ri && e4.memoizedUpdaters.clear(), ze(e4), null !== n7) for (l4 = e4.onRecoverableError, o4 = 0; o4 < n7.length; o4++) t5 = ma((c5 = n7[o4]).stack), y2(c5.source, l4, c5.value, t5);
          0 != (3 & zd) && ga(), c5 = e4.pendingLanes, 0 != (4194218 & r5) && 0 != (42 & c5) ? (Di = true, e4 === Rd ? _d++ : (_d = 0, Rd = e4)) : _d = 0, Ce(0);
        }(e3, n6, t4, r4, f3, l3);
      } finally {
        yo.T = c4, Qo(f3);
      }
    }
    function ma(e3) {
      return e3 = { componentStack: e3 }, Object.defineProperty(e3, "digest", { get: function() {
        console.error('You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');
      } }), e3;
    }
    function ha(e3, n6) {
      0 == (e3.pooledCacheLanes &= n6) && null != (n6 = e3.pooledCache) && (e3.pooledCache = null, Ir(n6));
    }
    function ga() {
      if (null !== xd) {
        var e3 = xd, n6 = Cd;
        Cd = 0;
        var t4 = L(zd), r4 = 32 > t4 ? 32 : t4;
        t4 = yo.T;
        var l3 = Bo();
        try {
          if (Qo(r4), yo.T = null, null === xd) var a4 = false;
          else {
            r4 = Pd, Pd = null;
            var o3 = xd, u3 = zd;
            if (xd = null, zd = 0, (Qf & (If | Df)) !== Uf) throw Error("Cannot flush passive effects while already rendering.");
            Td = true, Nd = false, null !== ti && "function" == typeof ti.markPassiveEffectsStarted && ti.markPassiveEffectsStarted(u3);
            var i4 = Qf;
            Qf |= Df, Hl(o3.current), Tl(o3, o3.current, u3, r4), null !== ti && "function" == typeof ti.markPassiveEffectsStopped && ti.markPassiveEffectsStopped(), Pa(o3), Qf = i4, Ce(0), Nd ? o3 === Id ? Ud++ : (Ud = 0, Id = o3) : Ud = 0, Nd = Td = false, ni && ni.onPostCommitFiberRoot;
            var s3 = o3.current.stateNode;
            s3.effectDuration = 0, s3.passiveEffectDuration = 0, a4 = true;
          }
          return a4;
        } finally {
          Qo(l3), yo.T = t4, ha(e3, n6);
        }
      }
      return false;
    }
    function ya(e3, n6, t4) {
      n6 = I(t4, n6), null !== (e3 = Me(e3, n6 = Yt(e3.stateNode, n6, 2), 2)) && (E(e3, 2), ze(e3));
    }
    function ba(e3, n6, t4) {
      if (Dd = false, 3 === e3.tag) ya(e3, e3, t4);
      else {
        for (; null !== n6; ) {
          if (3 === n6.tag) return void ya(n6, e3, t4);
          if (1 === n6.tag) {
            var r4 = n6.stateNode;
            if ("function" == typeof n6.type.getDerivedStateFromError || "function" == typeof r4.componentDidCatch && (null === kd || !kd.has(r4))) return e3 = I(t4, e3), void (null !== (r4 = Me(n6, t4 = Jt(2), 2)) && (Gt(t4, r4, n6, e3), E(r4, 2), ze(r4)));
          }
          n6 = n6.return;
        }
        console.error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", t4);
      }
    }
    function va(e3, n6, t4) {
      var r4 = e3.pingCache;
      if (null === r4) {
        r4 = e3.pingCache = new Lf();
        var l3 = /* @__PURE__ */ new Set();
        r4.set(n6, l3);
      } else void 0 === (l3 = r4.get(n6)) && (l3 = /* @__PURE__ */ new Set(), r4.set(n6, l3));
      l3.has(t4) || (ad = true, l3.add(t4), r4 = Sa.bind(null, e3, n6, t4), ri && _a(e3, t4), n6.then(r4, r4));
    }
    function Sa(e3, n6, t4) {
      var r4 = e3.pingCache;
      null !== r4 && r4.delete(n6), e3.pingedLanes |= e3.suspendedLanes & t4, e3.warmLanes &= ~t4, Al() && null === yo.actQueue && console.error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"), Bf === e3 && ($f & t4) === t4 && (ud === Wf || ud === jf && (62914560 & $f) === $f && Yu() - gd < yd ? (Qf & If) === Uf && Xl(e3, 0) : cd |= t4, dd === $f && (dd = 0)), ze(e3);
    }
    function ka(e3, n6) {
      0 === n6 && (n6 = C()), null !== (e3 = de(e3, n6)) && (E(e3, n6), ze(e3));
    }
    function wa(e3) {
      var n6 = e3.memoizedState, t4 = 0;
      null !== n6 && (t4 = n6.retryLane), ka(e3, t4);
    }
    function xa(e3, n6) {
      var t4 = 0;
      switch (e3.tag) {
        case 13:
          var r4 = e3.stateNode, l3 = e3.memoizedState;
          null !== l3 && (t4 = l3.retryLane);
          break;
        case 19:
          r4 = e3.stateNode;
          break;
        case 22:
          r4 = e3.stateNode._retryCache;
          break;
        default:
          throw Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      null !== r4 && r4.delete(n6), ka(e3, t4);
    }
    function za(e3, n6, t4) {
      if (0 != (33562624 & n6.subtreeFlags)) for (n6 = n6.child; null !== n6; ) {
        var r4 = e3, l3 = n6, a4 = l3.type === to;
        a4 = t4 || a4, 22 !== l3.tag ? 33554432 & l3.flags ? a4 && y2(l3, Ca, r4, l3, (64 & l3.mode) === Pi) : za(r4, l3, a4) : null === l3.memoizedState && (a4 && 8192 & l3.flags ? y2(l3, Ca, r4, l3) : 33554432 & l3.subtreeFlags && y2(l3, za, r4, l3, a4)), n6 = n6.sibling;
      }
    }
    function Ca(e3, n6) {
      var t4 = !(2 < arguments.length && void 0 !== arguments[2]) || arguments[2];
      U(true);
      try {
        xl(n6), t4 && Wl(n6), Cl(e3, n6.alternate, n6, false), t4 && Ll(e3, n6, 0, null, false);
      } finally {
        U(false);
      }
    }
    function Pa(e3) {
      var n6 = true;
      24 & e3.current.mode || (n6 = false), za(e3, e3.current, n6);
    }
    function Ea(e3) {
      if ((Qf & If) === Uf) {
        var n6 = e3.tag;
        if (3 === n6 || 1 === n6 || 0 === n6 || 11 === n6 || 14 === n6 || 15 === n6) {
          if (n6 = c3(e3) || "ReactComponent", null !== jd) {
            if (jd.has(n6)) return;
            jd.add(n6);
          } else jd = /* @__PURE__ */ new Set([n6]);
          y2(e3, function() {
            console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
          });
        }
      }
    }
    function _a(e3, n6) {
      ri && e3.memoizedUpdaters.forEach(function(t4) {
        T(e3, t4, n6);
      });
    }
    function Ra(e3, n6, t4, r4) {
      this.tag = e3, this.key = t4, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = n6, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r4, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null, this.actualDuration = -0, this.actualStartTime = -1.1, this.treeBaseDuration = this.selfBaseDuration = -0, this._debugOwner = this._debugInfo = null, this._debugNeedsRemount = false, this._debugHookTypes = null, Ad || "function" != typeof Object.preventExtensions || Object.preventExtensions(this);
    }
    function Ta(e3) {
      return !(!(e3 = e3.prototype) || !e3.isReactComponent);
    }
    function Na(e3, n6) {
      var r4 = e3.alternate;
      switch (null === r4 ? ((r4 = t3(e3.tag, n6, e3.key, e3.mode)).elementType = e3.elementType, r4.type = e3.type, r4.stateNode = e3.stateNode, r4._debugOwner = e3._debugOwner, r4._debugHookTypes = e3._debugHookTypes, r4.alternate = e3, e3.alternate = r4) : (r4.pendingProps = n6, r4.type = e3.type, r4.flags = 0, r4.subtreeFlags = 0, r4.deletions = null, r4.actualDuration = -0, r4.actualStartTime = -1.1), r4.flags = 31457280 & e3.flags, r4.childLanes = e3.childLanes, r4.lanes = e3.lanes, r4.child = e3.child, r4.memoizedProps = e3.memoizedProps, r4.memoizedState = e3.memoizedState, r4.updateQueue = e3.updateQueue, n6 = e3.dependencies, r4.dependencies = null === n6 ? null : { lanes: n6.lanes, firstContext: n6.firstContext, _debugThenableState: n6._debugThenableState }, r4.sibling = e3.sibling, r4.index = e3.index, r4.ref = e3.ref, r4.refCleanup = e3.refCleanup, r4.selfBaseDuration = e3.selfBaseDuration, r4.treeBaseDuration = e3.treeBaseDuration, r4._debugInfo = e3._debugInfo, r4._debugNeedsRemount = e3._debugNeedsRemount, r4.tag) {
        case 0:
        case 15:
        case 1:
        case 11:
          r4.type = e3.type;
      }
      return r4;
    }
    function La(e3, n6) {
      e3.flags &= 31457282;
      var t4 = e3.alternate;
      return null === t4 ? (e3.childLanes = 0, e3.lanes = n6, e3.child = null, e3.subtreeFlags = 0, e3.memoizedProps = null, e3.memoizedState = null, e3.updateQueue = null, e3.dependencies = null, e3.stateNode = null, e3.selfBaseDuration = 0, e3.treeBaseDuration = 0) : (e3.childLanes = t4.childLanes, e3.lanes = t4.lanes, e3.child = t4.child, e3.subtreeFlags = 0, e3.deletions = null, e3.memoizedProps = t4.memoizedProps, e3.memoizedState = t4.memoizedState, e3.updateQueue = t4.updateQueue, e3.type = t4.type, n6 = t4.dependencies, e3.dependencies = null === n6 ? null : { lanes: n6.lanes, firstContext: n6.firstContext, _debugThenableState: n6._debugThenableState }, e3.selfBaseDuration = t4.selfBaseDuration, e3.treeBaseDuration = t4.treeBaseDuration), e3;
    }
    function Ua(e3, n6, r4, l3, a4, o3) {
      var u3 = 0, i4 = e3;
      if ("function" == typeof e3) Ta(e3) && (u3 = 1);
      else if ("string" == typeof e3) u3 = 5;
      else e: switch (e3) {
        case no:
          return Da(r4.children, a4, o3, n6);
        case to:
          u3 = 8, a4 |= 24;
          break;
        case ro:
          return l3 = a4, "string" != typeof (e3 = r4).id && console.error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof e3.id), (n6 = t3(12, e3, n6, 2 | l3)).elementType = ro, n6.lanes = o3, n6.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, n6;
        case io:
          return (n6 = t3(13, r4, n6, a4)).elementType = io, n6.lanes = o3, n6;
        case so:
          return (n6 = t3(19, r4, n6, a4)).elementType = so, n6.lanes = o3, n6;
        case po:
          return Fa(r4, a4, o3, n6);
        default:
          if ("object" == typeof e3 && null !== e3) switch (e3.$$typeof) {
            case lo:
            case oo:
              u3 = 10;
              break e;
            case ao:
              u3 = 9;
              break e;
            case uo:
              u3 = 11;
              break e;
            case co:
              u3 = 14;
              break e;
            case fo:
              u3 = 16, i4 = null;
              break e;
          }
          i4 = "", (void 0 === e3 || "object" == typeof e3 && null !== e3 && 0 === Object.keys(e3).length) && (i4 += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), null === e3 ? r4 = "null" : Co(e3) ? r4 = "array" : void 0 !== e3 && e3.$$typeof === Za ? (r4 = "<" + (s2(e3.type) || "Unknown") + " />", i4 = " Did you accidentally export a JSX literal instead of a component?") : r4 = typeof e3, (u3 = l3 ? "number" == typeof l3.tag ? c3(l3) : "string" == typeof l3.name ? l3.name : null : null) && (i4 += "\n\nCheck the render method of `" + u3 + "`."), u3 = 29, r4 = Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + r4 + "." + i4), i4 = null;
      }
      return (n6 = t3(u3, r4, n6, a4)).elementType = e3, n6.type = i4, n6.lanes = o3, n6._debugOwner = l3, n6;
    }
    function Ia(e3, n6, t4) {
      return (n6 = Ua(e3.type, e3.key, e3.props, e3._owner, n6, t4))._debugOwner = e3._owner, n6;
    }
    function Da(e3, n6, r4, l3) {
      return (e3 = t3(7, e3, l3, n6)).lanes = r4, e3;
    }
    function Fa(e3, n6, r4, l3) {
      (e3 = t3(22, e3, l3, n6)).elementType = po, e3.lanes = r4;
      var a4 = { _visibility: 1, _pendingVisibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null, _current: null, detach: function() {
        var e4 = a4, n7 = e4._current;
        if (null === n7) throw Error("Calling Offscreen.detach before instance handle has been set.");
        if (0 == (2 & e4._pendingVisibility)) {
          var t4 = de(n7, 2);
          null !== t4 && (e4._pendingVisibility |= 2, Vl(t4, n7, 2));
        }
      }, attach: function() {
        var e4 = a4, n7 = e4._current;
        if (null === n7) throw Error("Calling Offscreen.detach before instance handle has been set.");
        if (0 != (2 & e4._pendingVisibility)) {
          var t4 = de(n7, 2);
          null !== t4 && (e4._pendingVisibility &= -3, Vl(t4, n7, 2));
        }
      } };
      return e3.stateNode = a4, e3;
    }
    function Ma(e3, n6, r4) {
      return (e3 = t3(6, e3, null, n6)).lanes = r4, e3;
    }
    function Ha(e3, n6, r4) {
      return (n6 = t3(4, null !== e3.children ? e3.children : [], e3.key, n6)).lanes = r4, n6.stateNode = { containerInfo: e3.containerInfo, pendingChildren: null, implementation: e3.implementation }, n6;
    }
    function ja(e3, n6, t4, r4, l3, a4, o3, u3) {
      for (this.tag = 1, this.containerInfo = e3, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Ho, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = P(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = P(0), this.hiddenUpdates = P(null), this.identifierPrefix = r4, this.onUncaughtError = l3, this.onCaughtError = a4, this.onRecoverableError = o3, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = u3, this.incompleteTransitions = /* @__PURE__ */ new Map(), this.passiveEffectDuration = this.effectDuration = -0, this.memoizedUpdaters = /* @__PURE__ */ new Set(), e3 = this.pendingUpdatersLaneMap = [], n6 = 0; 31 > n6; n6++) e3.push(/* @__PURE__ */ new Set());
      this._debugRootType = t4 ? "hydrateRoot()" : "createRoot()";
    }
    function Wa(e3, n6, t4, r4, l3, a4) {
      l3 = function(e4) {
        return e4 ? e4 = Hu : Hu;
      }(l3), null === r4.context ? r4.context = l3 : r4.pendingContext = l3, zo && null !== xo && !Bd && (Bd = true, console.error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", c3(xo) || "Unknown")), (r4 = Fe(n6)).payload = { element: t4 }, null !== (a4 = void 0 === a4 ? null : a4) && ("function" != typeof a4 && console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", a4), r4.callback = a4), null !== (t4 = Me(e3, r4, n6)) && (Vl(t4, e3, n6), He(t4, e3, n6));
    }
    var Oa, Aa, Qa, Ba, Va, $a, qa, Ya = {}, Ja = import_react.default, Ga = u, Ka = Object.assign, Xa = Symbol.for("react.element"), Za = Symbol.for("react.transitional.element"), eo = Symbol.for("react.portal"), no = Symbol.for("react.fragment"), to = Symbol.for("react.strict_mode"), ro = Symbol.for("react.profiler"), lo = Symbol.for("react.provider"), ao = Symbol.for("react.consumer"), oo = Symbol.for("react.context"), uo = Symbol.for("react.forward_ref"), io = Symbol.for("react.suspense"), so = Symbol.for("react.suspense_list"), co = Symbol.for("react.memo"), fo = Symbol.for("react.lazy"), po = Symbol.for("react.offscreen"), mo = Symbol.for("react.memo_cache_sentinel"), ho = Symbol.iterator, go = Symbol.for("react.client.reference"), yo = Ja.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, bo = 0;
    f2.__reactDisabledLog = true;
    var vo, So, ko = false, wo = new ("function" == typeof WeakMap ? WeakMap : Map)(), xo = null, zo = false, Co = Array.isArray, Po = n5.getPublicInstance, Eo = n5.getRootHostContext, _o = n5.getChildHostContext, Ro = n5.prepareForCommit, To = n5.resetAfterCommit, No = n5.createInstance, Lo = n5.appendInitialChild, Uo = n5.finalizeInitialChildren, Io = n5.shouldSetTextContent, Do = n5.createTextInstance, Fo = null, Mo = null, Ho = n5.noTimeout, jo = true, Wo = null, Oo = null, Ao = null, Qo = n5.setCurrentUpdatePriority, Bo = n5.getCurrentUpdatePriority, Vo = n5.resolveUpdatePriority, $o = n5.shouldAttemptEagerTransition, qo = null;
    n5.requestPostPaintCallback;
    var Yo = n5.maySuspendCommit, Jo = null, Go = null, Ko = null, Xo = null, Zo = null, eu = null, nu = null, tu = n5.appendChild, ru = n5.appendChildToContainer, lu = n5.commitTextUpdate, au = null, ou = n5.commitUpdate, uu = n5.insertBefore, iu = null, su = n5.removeChild, cu = n5.removeChildFromContainer, fu = n5.resetTextContent, du = null, pu = null, mu = null, hu = null, gu = n5.clearContainer, yu = null, bu = null, vu = null, Su = null, ku = null, wu = null, xu = null, zu = null, Cu = null, Pu = null, Eu = null, _u = null, Ru = null, Tu = null, Nu = null, Lu = null, Uu = null, Iu = null, Du = [], Fu = [], Mu = -1, Hu = {};
    Object.freeze(Hu);
    var ju = Math.clz32 ? Math.clz32 : function(e3) {
      return 0 == (e3 >>>= 0) ? 32 : 31 - (Wu(e3) / Ou | 0) | 0;
    }, Wu = Math.log, Ou = Math.LN2, Au = 128, Qu = 4194304, Bu = Ga.unstable_scheduleCallback, Vu = Ga.unstable_cancelCallback, $u = Ga.unstable_shouldYield, qu = Ga.unstable_requestPaint, Yu = Ga.unstable_now, Ju = Ga.unstable_ImmediatePriority, Gu = Ga.unstable_UserBlockingPriority, Ku = Ga.unstable_NormalPriority, Xu = Ga.unstable_IdlePriority, Zu = Ga.log, ei = Ga.unstable_setDisableYieldValue, ni = null, ti = null, ri = "undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, li = "function" == typeof Object.is ? Object.is : function(e3, n6) {
      return e3 === n6 && (0 !== e3 || 1 / e3 == 1 / n6) || e3 != e3 && n6 != n6;
    }, ai = /* @__PURE__ */ new WeakMap(), oi = [], ui = 0, ii = null, si = 0, ci = [], fi = 0, di = null, pi = 1, mi = "", hi = b2(null), gi = b2(null), yi = b2(null), bi = b2(null), vi = /["'&<>\n\t]|^\s|\s$/, Si = null, ki = false, wi = null, xi = null, zi = false, Ci = Error("Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), Pi = 0, Ei = [], _i = 0, Ri = 0, Ti = Ga.unstable_now, Ni = -0, Li = -1.1, Ui = -0, Ii = false, Di = false, Fi = null, Mi = null, Hi = false, ji = false, Wi = false, Oi = false, Ai = 0, Qi = {}, Bi = null, Vi = 0, $i = 0, qi = null, Yi = 0, Ji = 1, Gi = 2, Ki = 3, Xi = false, Zi = false, es = null, ns = false, ts = Object.prototype.hasOwnProperty, rs = { recordUnsafeLifecycleWarnings: function() {
    }, flushPendingUnsafeLifecycleWarnings: function() {
    }, recordLegacyContextWarning: function() {
    }, flushLegacyContextWarning: function() {
    }, discardPendingWarnings: function() {
    } }, ls = [], as = [], os = [], us = [], is = [], ss = [], cs = /* @__PURE__ */ new Set();
    rs.recordUnsafeLifecycleWarnings = function(e3, n6) {
      cs.has(e3.type) || ("function" == typeof n6.componentWillMount && true !== n6.componentWillMount.__suppressDeprecationWarning && ls.push(e3), 8 & e3.mode && "function" == typeof n6.UNSAFE_componentWillMount && as.push(e3), "function" == typeof n6.componentWillReceiveProps && true !== n6.componentWillReceiveProps.__suppressDeprecationWarning && os.push(e3), 8 & e3.mode && "function" == typeof n6.UNSAFE_componentWillReceiveProps && us.push(e3), "function" == typeof n6.componentWillUpdate && true !== n6.componentWillUpdate.__suppressDeprecationWarning && is.push(e3), 8 & e3.mode && "function" == typeof n6.UNSAFE_componentWillUpdate && ss.push(e3));
    }, rs.flushPendingUnsafeLifecycleWarnings = function() {
      var e3 = /* @__PURE__ */ new Set();
      0 < ls.length && (ls.forEach(function(n7) {
        e3.add(c3(n7) || "Component"), cs.add(n7.type);
      }), ls = []);
      var n6 = /* @__PURE__ */ new Set();
      0 < as.length && (as.forEach(function(e4) {
        n6.add(c3(e4) || "Component"), cs.add(e4.type);
      }), as = []);
      var t4 = /* @__PURE__ */ new Set();
      0 < os.length && (os.forEach(function(e4) {
        t4.add(c3(e4) || "Component"), cs.add(e4.type);
      }), os = []);
      var r4 = /* @__PURE__ */ new Set();
      0 < us.length && (us.forEach(function(e4) {
        r4.add(c3(e4) || "Component"), cs.add(e4.type);
      }), us = []);
      var l3 = /* @__PURE__ */ new Set();
      0 < is.length && (is.forEach(function(e4) {
        l3.add(c3(e4) || "Component"), cs.add(e4.type);
      }), is = []);
      var a4 = /* @__PURE__ */ new Set();
      if (0 < ss.length && (ss.forEach(function(e4) {
        a4.add(c3(e4) || "Component"), cs.add(e4.type);
      }), ss = []), 0 < n6.size) {
        var u3 = o2(n6);
        console.error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", u3);
      }
      0 < r4.size && (u3 = o2(r4), console.error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s", u3)), 0 < a4.size && (u3 = o2(a4), console.error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", u3)), 0 < e3.size && (u3 = o2(e3), console.warn("componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", u3)), 0 < t4.size && (u3 = o2(t4), console.warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", u3)), 0 < l3.size && (u3 = o2(l3), console.warn("componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", u3));
    };
    var fs2 = /* @__PURE__ */ new Map(), ds = /* @__PURE__ */ new Set();
    rs.recordLegacyContextWarning = function(e3, n6) {
      for (var t4 = null, r4 = e3; null !== r4; ) 8 & r4.mode && (t4 = r4), r4 = r4.return;
      null === t4 ? console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.") : !ds.has(e3.type) && (r4 = fs2.get(t4), null != e3.type.contextTypes || null != e3.type.childContextTypes || null !== n6 && "function" == typeof n6.getChildContext) && (void 0 === r4 && (r4 = [], fs2.set(t4, r4)), r4.push(e3));
    }, rs.flushLegacyContextWarning = function() {
      fs2.forEach(function(e3) {
        if (0 !== e3.length) {
          var n6 = e3[0], t4 = /* @__PURE__ */ new Set();
          e3.forEach(function(e4) {
            t4.add(c3(e4) || "Component"), ds.add(e4.type);
          });
          var r4 = o2(t4);
          y2(n6, function() {
            console.error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context", r4);
          });
        }
      });
    }, rs.discardPendingWarnings = function() {
      ls = [], as = [], os = [], us = [], is = [], ss = [], fs2 = /* @__PURE__ */ new Map();
    };
    var ps, ms = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`"), hs = Error("Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), gs = { then: function() {
      console.error('Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.');
    } }, ys = null, bs = false, vs = { "react-stack-bottom-frame": function(e3, n6, t4) {
      var r4 = zo;
      zo = true;
      try {
        return e3(n6, t4);
      } finally {
        zo = r4;
      }
    } }, Ss = vs["react-stack-bottom-frame"].bind(vs), ks = { "react-stack-bottom-frame": function(e3) {
      var n6 = zo;
      zo = true;
      try {
        return e3.render();
      } finally {
        zo = n6;
      }
    } }, ws = ks["react-stack-bottom-frame"].bind(ks), xs = { "react-stack-bottom-frame": function(e3, n6) {
      try {
        n6.componentDidMount();
      } catch (n7) {
        ba(e3, e3.return, n7);
      }
    } }, zs = xs["react-stack-bottom-frame"].bind(xs), Cs = { "react-stack-bottom-frame": function(e3, n6, t4, r4, l3) {
      try {
        n6.componentDidUpdate(t4, r4, l3);
      } catch (n7) {
        ba(e3, e3.return, n7);
      }
    } }, Ps = Cs["react-stack-bottom-frame"].bind(Cs), Es = { "react-stack-bottom-frame": function(e3, n6) {
      var t4 = n6.stack;
      e3.componentDidCatch(n6.value, { componentStack: null !== t4 ? t4 : "" });
    } }, _s = Es["react-stack-bottom-frame"].bind(Es), Rs = { "react-stack-bottom-frame": function(e3, n6, t4) {
      try {
        t4.componentWillUnmount();
      } catch (t5) {
        ba(e3, n6, t5);
      }
    } }, Ts = Rs["react-stack-bottom-frame"].bind(Rs), Ns = { "react-stack-bottom-frame": function(e3) {
      var n6 = e3.create;
      return e3 = e3.inst, n6 = n6(), e3.destroy = n6;
    } }, Ls = Ns["react-stack-bottom-frame"].bind(Ns), Us = { "react-stack-bottom-frame": function(e3, n6, t4) {
      try {
        t4();
      } catch (t5) {
        ba(e3, n6, t5);
      }
    } }, Is = Us["react-stack-bottom-frame"].bind(Us), Ds = { "react-stack-bottom-frame": function(e3) {
      return (0, e3._init)(e3._payload);
    } }, Fs = Ds["react-stack-bottom-frame"].bind(Ds), Ms = null, Hs = 0, js = null, Ws = ps = false, Os = {}, As = {}, Qs = {};
    a3 = function(e3, n6, t4) {
      if (null !== t4 && "object" == typeof t4 && t4._store && (!t4._store.validated && null == t4.key || 2 === t4._store.validated)) {
        if ("object" != typeof t4._store) throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        t4._store.validated = 1;
        var r4 = c3(e3), l3 = r4 || "null";
        if (!Os[l3]) {
          Os[l3] = true, t4 = t4._owner, e3 = e3._debugOwner;
          var a4 = "";
          e3 && "number" == typeof e3.tag && (l3 = c3(e3)) && (a4 = "\n\nCheck the render method of `" + l3 + "`."), a4 || r4 && (a4 = "\n\nCheck the top-level render call using <" + r4 + ">.");
          var o3 = "";
          null != t4 && e3 !== t4 && (r4 = null, "number" == typeof t4.tag ? r4 = c3(t4) : "string" == typeof t4.name && (r4 = t4.name), r4 && (o3 = " It was passed a child from " + r4 + ".")), y2(n6, function() {
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', a4, o3);
          });
        }
      }
    };
    var Bs, Vs = ln(true), $s = ln(false), qs = b2(null), Ys = b2(0), Js = b2(null), Gs = null, Ks = 1, Xs = 2, Zs = b2(0), ec = 0, nc = 1, tc = 2, rc = 4, lc = 8, ac = /* @__PURE__ */ new Set(), oc = /* @__PURE__ */ new Set(), uc = /* @__PURE__ */ new Set(), ic = /* @__PURE__ */ new Set(), sc = 0, cc = null, fc = null, dc = null, pc = false, mc = false, hc = false, gc = 0, yc = 0, bc = null, vc = 0, Sc = 25, kc = null, wc = null, xc = -1, zc = false, Cc = function() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }, Pc = { readContext: Rr, use: Tn, useCallback: bn, useContext: bn, useEffect: bn, useImperativeHandle: bn, useLayoutEffect: bn, useInsertionEffect: bn, useMemo: bn, useReducer: bn, useRef: bn, useState: bn, useDebugValue: bn, useDeferredValue: bn, useTransition: bn, useSyncExternalStore: bn, useId: bn };
    Pc.useCacheRefresh = bn, Pc.useMemoCache = bn, Pc.useHostTransitionStatus = bn, Pc.useFormState = bn, Pc.useActionState = bn, Pc.useOptimistic = bn;
    var Ec = null, _c = null, Rc = null, Tc = null, Nc = null, Lc = null, Uc = null;
    (Ec = { readContext: function(e3) {
      return Rr(e3);
    }, use: Tn, useCallback: function(e3, n6) {
      return kc = "useCallback", mn(), gn(n6), yt(e3, n6);
    }, useContext: function(e3) {
      return kc = "useContext", mn(), Rr(e3);
    }, useEffect: function(e3, n6) {
      return kc = "useEffect", mn(), gn(n6), dt(e3, n6);
    }, useImperativeHandle: function(e3, n6, t4) {
      return kc = "useImperativeHandle", mn(), gn(t4), ht(e3, n6, t4);
    }, useInsertionEffect: function(e3, n6) {
      kc = "useInsertionEffect", mn(), gn(n6), ct(4, tc, e3, n6);
    }, useLayoutEffect: function(e3, n6) {
      return kc = "useLayoutEffect", mn(), gn(n6), pt(e3, n6);
    }, useMemo: function(e3, n6) {
      kc = "useMemo", mn(), gn(n6);
      var t4 = yo.H;
      yo.H = Nc;
      try {
        return vt(e3, n6);
      } finally {
        yo.H = t4;
      }
    }, useReducer: function(e3, n6, t4) {
      kc = "useReducer", mn();
      var r4 = yo.H;
      yo.H = Nc;
      try {
        return Un(e3, n6, t4);
      } finally {
        yo.H = r4;
      }
    }, useRef: function(e3) {
      return kc = "useRef", mn(), st(e3);
    }, useState: function(e3) {
      kc = "useState", mn();
      var n6 = yo.H;
      yo.H = Nc;
      try {
        return Vn(e3);
      } finally {
        yo.H = n6;
      }
    }, useDebugValue: function() {
      kc = "useDebugValue", mn();
    }, useDeferredValue: function(e3, n6) {
      return kc = "useDeferredValue", mn(), kt(e3, n6);
    }, useTransition: function() {
      return kc = "useTransition", mn(), Et();
    }, useSyncExternalStore: function(e3, n6, t4) {
      return kc = "useSyncExternalStore", mn(), Mn(e3, n6, t4);
    }, useId: function() {
      return kc = "useId", mn(), Nt();
    }, useCacheRefresh: function() {
      return kc = "useCacheRefresh", mn(), Lt();
    } }).useMemoCache = Nn, Ec.useHostTransitionStatus = Tt, Ec.useFormState = function(e3, n6) {
      return kc = "useFormState", mn(), yn(), rt(e3, n6);
    }, Ec.useActionState = function(e3, n6) {
      return kc = "useActionState", mn(), rt(e3, n6);
    }, Ec.useOptimistic = function(e3) {
      return kc = "useOptimistic", mn(), $n(e3);
    }, (_c = { readContext: function(e3) {
      return Rr(e3);
    }, use: Tn, useCallback: function(e3, n6) {
      return kc = "useCallback", hn(), yt(e3, n6);
    }, useContext: function(e3) {
      return kc = "useContext", hn(), Rr(e3);
    }, useEffect: function(e3, n6) {
      return kc = "useEffect", hn(), dt(e3, n6);
    }, useImperativeHandle: function(e3, n6, t4) {
      return kc = "useImperativeHandle", hn(), ht(e3, n6, t4);
    }, useInsertionEffect: function(e3, n6) {
      kc = "useInsertionEffect", hn(), ct(4, tc, e3, n6);
    }, useLayoutEffect: function(e3, n6) {
      return kc = "useLayoutEffect", hn(), pt(e3, n6);
    }, useMemo: function(e3, n6) {
      kc = "useMemo", hn();
      var t4 = yo.H;
      yo.H = Nc;
      try {
        return vt(e3, n6);
      } finally {
        yo.H = t4;
      }
    }, useReducer: function(e3, n6, t4) {
      kc = "useReducer", hn();
      var r4 = yo.H;
      yo.H = Nc;
      try {
        return Un(e3, n6, t4);
      } finally {
        yo.H = r4;
      }
    }, useRef: function(e3) {
      return kc = "useRef", hn(), st(e3);
    }, useState: function(e3) {
      kc = "useState", hn();
      var n6 = yo.H;
      yo.H = Nc;
      try {
        return Vn(e3);
      } finally {
        yo.H = n6;
      }
    }, useDebugValue: function() {
      kc = "useDebugValue", hn();
    }, useDeferredValue: function(e3, n6) {
      return kc = "useDeferredValue", hn(), kt(e3, n6);
    }, useTransition: function() {
      return kc = "useTransition", hn(), Et();
    }, useSyncExternalStore: function(e3, n6, t4) {
      return kc = "useSyncExternalStore", hn(), Mn(e3, n6, t4);
    }, useId: function() {
      return kc = "useId", hn(), Nt();
    }, useCacheRefresh: function() {
      return kc = "useCacheRefresh", hn(), Lt();
    } }).useMemoCache = Nn, _c.useHostTransitionStatus = Tt, _c.useFormState = function(e3, n6) {
      return kc = "useFormState", hn(), yn(), rt(e3, n6);
    }, _c.useActionState = function(e3, n6) {
      return kc = "useActionState", hn(), rt(e3, n6);
    }, _c.useOptimistic = function(e3) {
      return kc = "useOptimistic", hn(), $n(e3);
    }, (Rc = { readContext: function(e3) {
      return Rr(e3);
    }, use: Tn, useCallback: function(e3, n6) {
      return kc = "useCallback", hn(), bt(e3, n6);
    }, useContext: function(e3) {
      return kc = "useContext", hn(), Rr(e3);
    }, useEffect: function(e3, n6) {
      kc = "useEffect", hn(), ft(2048, lc, e3, n6);
    }, useImperativeHandle: function(e3, n6, t4) {
      return kc = "useImperativeHandle", hn(), gt(e3, n6, t4);
    }, useInsertionEffect: function(e3, n6) {
      return kc = "useInsertionEffect", hn(), ft(4, tc, e3, n6);
    }, useLayoutEffect: function(e3, n6) {
      return kc = "useLayoutEffect", hn(), ft(4, rc, e3, n6);
    }, useMemo: function(e3, n6) {
      kc = "useMemo", hn();
      var t4 = yo.H;
      yo.H = Lc;
      try {
        return St(e3, n6);
      } finally {
        yo.H = t4;
      }
    }, useReducer: function(e3, n6, t4) {
      kc = "useReducer", hn();
      var r4 = yo.H;
      yo.H = Lc;
      try {
        return In(e3);
      } finally {
        yo.H = r4;
      }
    }, useRef: function() {
      return kc = "useRef", hn(), _n().memoizedState;
    }, useState: function() {
      kc = "useState", hn();
      var e3 = yo.H;
      yo.H = Lc;
      try {
        return In(Ln);
      } finally {
        yo.H = e3;
      }
    }, useDebugValue: function() {
      kc = "useDebugValue", hn();
    }, useDeferredValue: function(e3, n6) {
      return kc = "useDeferredValue", hn(), wt(e3, n6);
    }, useTransition: function() {
      return kc = "useTransition", hn(), _t();
    }, useSyncExternalStore: function(e3, n6, t4) {
      return kc = "useSyncExternalStore", hn(), Hn(e3, n6, t4);
    }, useId: function() {
      return kc = "useId", hn(), _n().memoizedState;
    }, useCacheRefresh: function() {
      return kc = "useCacheRefresh", hn(), _n().memoizedState;
    } }).useMemoCache = Nn, Rc.useHostTransitionStatus = Tt, Rc.useFormState = function(e3) {
      return kc = "useFormState", hn(), yn(), lt(e3);
    }, Rc.useActionState = function(e3) {
      return kc = "useActionState", hn(), lt(e3);
    }, Rc.useOptimistic = function(e3, n6) {
      return kc = "useOptimistic", hn(), qn(e3, n6);
    }, (Tc = { readContext: function(e3) {
      return Rr(e3);
    }, use: Tn, useCallback: function(e3, n6) {
      return kc = "useCallback", hn(), bt(e3, n6);
    }, useContext: function(e3) {
      return kc = "useContext", hn(), Rr(e3);
    }, useEffect: function(e3, n6) {
      kc = "useEffect", hn(), ft(2048, lc, e3, n6);
    }, useImperativeHandle: function(e3, n6, t4) {
      return kc = "useImperativeHandle", hn(), gt(e3, n6, t4);
    }, useInsertionEffect: function(e3, n6) {
      return kc = "useInsertionEffect", hn(), ft(4, tc, e3, n6);
    }, useLayoutEffect: function(e3, n6) {
      return kc = "useLayoutEffect", hn(), ft(4, rc, e3, n6);
    }, useMemo: function(e3, n6) {
      kc = "useMemo", hn();
      var t4 = yo.H;
      yo.H = Uc;
      try {
        return St(e3, n6);
      } finally {
        yo.H = t4;
      }
    }, useReducer: function(e3, n6, t4) {
      kc = "useReducer", hn();
      var r4 = yo.H;
      yo.H = Uc;
      try {
        return Fn(e3);
      } finally {
        yo.H = r4;
      }
    }, useRef: function() {
      return kc = "useRef", hn(), _n().memoizedState;
    }, useState: function() {
      kc = "useState", hn();
      var e3 = yo.H;
      yo.H = Uc;
      try {
        return Fn(Ln);
      } finally {
        yo.H = e3;
      }
    }, useDebugValue: function() {
      kc = "useDebugValue", hn();
    }, useDeferredValue: function(e3, n6) {
      return kc = "useDeferredValue", hn(), xt(e3, n6);
    }, useTransition: function() {
      return kc = "useTransition", hn(), Rt();
    }, useSyncExternalStore: function(e3, n6, t4) {
      return kc = "useSyncExternalStore", hn(), Hn(e3, n6, t4);
    }, useId: function() {
      return kc = "useId", hn(), _n().memoizedState;
    }, useCacheRefresh: function() {
      return kc = "useCacheRefresh", hn(), _n().memoizedState;
    } }).useMemoCache = Nn, Tc.useHostTransitionStatus = Tt, Tc.useFormState = function(e3) {
      return kc = "useFormState", hn(), yn(), ut(e3);
    }, Tc.useActionState = function(e3) {
      return kc = "useActionState", hn(), ut(e3);
    }, Tc.useOptimistic = function(e3, n6) {
      return kc = "useOptimistic", hn(), Jn(e3, n6);
    }, (Nc = { readContext: function(e3) {
      return l2(), Rr(e3);
    }, use: function(e3) {
      return r3(), Tn(e3);
    }, useCallback: function(e3, n6) {
      return kc = "useCallback", r3(), mn(), yt(e3, n6);
    }, useContext: function(e3) {
      return kc = "useContext", r3(), mn(), Rr(e3);
    }, useEffect: function(e3, n6) {
      return kc = "useEffect", r3(), mn(), dt(e3, n6);
    }, useImperativeHandle: function(e3, n6, t4) {
      return kc = "useImperativeHandle", r3(), mn(), ht(e3, n6, t4);
    }, useInsertionEffect: function(e3, n6) {
      kc = "useInsertionEffect", r3(), mn(), ct(4, tc, e3, n6);
    }, useLayoutEffect: function(e3, n6) {
      return kc = "useLayoutEffect", r3(), mn(), pt(e3, n6);
    }, useMemo: function(e3, n6) {
      kc = "useMemo", r3(), mn();
      var t4 = yo.H;
      yo.H = Nc;
      try {
        return vt(e3, n6);
      } finally {
        yo.H = t4;
      }
    }, useReducer: function(e3, n6, t4) {
      kc = "useReducer", r3(), mn();
      var l3 = yo.H;
      yo.H = Nc;
      try {
        return Un(e3, n6, t4);
      } finally {
        yo.H = l3;
      }
    }, useRef: function(e3) {
      return kc = "useRef", r3(), mn(), st(e3);
    }, useState: function(e3) {
      kc = "useState", r3(), mn();
      var n6 = yo.H;
      yo.H = Nc;
      try {
        return Vn(e3);
      } finally {
        yo.H = n6;
      }
    }, useDebugValue: function() {
      kc = "useDebugValue", r3(), mn();
    }, useDeferredValue: function(e3, n6) {
      return kc = "useDeferredValue", r3(), mn(), kt(e3, n6);
    }, useTransition: function() {
      return kc = "useTransition", r3(), mn(), Et();
    }, useSyncExternalStore: function(e3, n6, t4) {
      return kc = "useSyncExternalStore", r3(), mn(), Mn(e3, n6, t4);
    }, useId: function() {
      return kc = "useId", r3(), mn(), Nt();
    }, useCacheRefresh: function() {
      return kc = "useCacheRefresh", mn(), Lt();
    }, useMemoCache: function(e3) {
      return r3(), Nn(e3);
    } }).useHostTransitionStatus = Tt, Nc.useFormState = function(e3, n6) {
      return kc = "useFormState", r3(), mn(), rt(e3, n6);
    }, Nc.useActionState = function(e3, n6) {
      return kc = "useActionState", r3(), mn(), rt(e3, n6);
    }, Nc.useOptimistic = function(e3) {
      return kc = "useOptimistic", r3(), mn(), $n(e3);
    }, (Lc = { readContext: function(e3) {
      return l2(), Rr(e3);
    }, use: function(e3) {
      return r3(), Tn(e3);
    }, useCallback: function(e3, n6) {
      return kc = "useCallback", r3(), hn(), bt(e3, n6);
    }, useContext: function(e3) {
      return kc = "useContext", r3(), hn(), Rr(e3);
    }, useEffect: function(e3, n6) {
      kc = "useEffect", r3(), hn(), ft(2048, lc, e3, n6);
    }, useImperativeHandle: function(e3, n6, t4) {
      return kc = "useImperativeHandle", r3(), hn(), gt(e3, n6, t4);
    }, useInsertionEffect: function(e3, n6) {
      return kc = "useInsertionEffect", r3(), hn(), ft(4, tc, e3, n6);
    }, useLayoutEffect: function(e3, n6) {
      return kc = "useLayoutEffect", r3(), hn(), ft(4, rc, e3, n6);
    }, useMemo: function(e3, n6) {
      kc = "useMemo", r3(), hn();
      var t4 = yo.H;
      yo.H = Lc;
      try {
        return St(e3, n6);
      } finally {
        yo.H = t4;
      }
    }, useReducer: function(e3, n6, t4) {
      kc = "useReducer", r3(), hn();
      var l3 = yo.H;
      yo.H = Lc;
      try {
        return In(e3);
      } finally {
        yo.H = l3;
      }
    }, useRef: function() {
      return kc = "useRef", r3(), hn(), _n().memoizedState;
    }, useState: function() {
      kc = "useState", r3(), hn();
      var e3 = yo.H;
      yo.H = Lc;
      try {
        return In(Ln);
      } finally {
        yo.H = e3;
      }
    }, useDebugValue: function() {
      kc = "useDebugValue", r3(), hn();
    }, useDeferredValue: function(e3, n6) {
      return kc = "useDeferredValue", r3(), hn(), wt(e3, n6);
    }, useTransition: function() {
      return kc = "useTransition", r3(), hn(), _t();
    }, useSyncExternalStore: function(e3, n6, t4) {
      return kc = "useSyncExternalStore", r3(), hn(), Hn(e3, n6, t4);
    }, useId: function() {
      return kc = "useId", r3(), hn(), _n().memoizedState;
    }, useCacheRefresh: function() {
      return kc = "useCacheRefresh", hn(), _n().memoizedState;
    }, useMemoCache: function(e3) {
      return r3(), Nn(e3);
    } }).useHostTransitionStatus = Tt, Lc.useFormState = function(e3) {
      return kc = "useFormState", r3(), hn(), lt(e3);
    }, Lc.useActionState = function(e3) {
      return kc = "useActionState", r3(), hn(), lt(e3);
    }, Lc.useOptimistic = function(e3, n6) {
      return kc = "useOptimistic", r3(), hn(), qn(e3, n6);
    }, (Uc = { readContext: function(e3) {
      return l2(), Rr(e3);
    }, use: function(e3) {
      return r3(), Tn(e3);
    }, useCallback: function(e3, n6) {
      return kc = "useCallback", r3(), hn(), bt(e3, n6);
    }, useContext: function(e3) {
      return kc = "useContext", r3(), hn(), Rr(e3);
    }, useEffect: function(e3, n6) {
      kc = "useEffect", r3(), hn(), ft(2048, lc, e3, n6);
    }, useImperativeHandle: function(e3, n6, t4) {
      return kc = "useImperativeHandle", r3(), hn(), gt(e3, n6, t4);
    }, useInsertionEffect: function(e3, n6) {
      return kc = "useInsertionEffect", r3(), hn(), ft(4, tc, e3, n6);
    }, useLayoutEffect: function(e3, n6) {
      return kc = "useLayoutEffect", r3(), hn(), ft(4, rc, e3, n6);
    }, useMemo: function(e3, n6) {
      kc = "useMemo", r3(), hn();
      var t4 = yo.H;
      yo.H = Lc;
      try {
        return St(e3, n6);
      } finally {
        yo.H = t4;
      }
    }, useReducer: function(e3, n6, t4) {
      kc = "useReducer", r3(), hn();
      var l3 = yo.H;
      yo.H = Lc;
      try {
        return Fn(e3);
      } finally {
        yo.H = l3;
      }
    }, useRef: function() {
      return kc = "useRef", r3(), hn(), _n().memoizedState;
    }, useState: function() {
      kc = "useState", r3(), hn();
      var e3 = yo.H;
      yo.H = Lc;
      try {
        return Fn(Ln);
      } finally {
        yo.H = e3;
      }
    }, useDebugValue: function() {
      kc = "useDebugValue", r3(), hn();
    }, useDeferredValue: function(e3, n6) {
      return kc = "useDeferredValue", r3(), hn(), xt(e3, n6);
    }, useTransition: function() {
      return kc = "useTransition", r3(), hn(), Rt();
    }, useSyncExternalStore: function(e3, n6, t4) {
      return kc = "useSyncExternalStore", r3(), hn(), Hn(e3, n6, t4);
    }, useId: function() {
      return kc = "useId", r3(), hn(), _n().memoizedState;
    }, useCacheRefresh: function() {
      return kc = "useCacheRefresh", hn(), _n().memoizedState;
    }, useMemoCache: function(e3) {
      return r3(), Nn(e3);
    } }).useHostTransitionStatus = Tt, Uc.useFormState = function(e3) {
      return kc = "useFormState", r3(), hn(), ut(e3);
    }, Uc.useActionState = function(e3) {
      return kc = "useActionState", r3(), hn(), ut(e3);
    }, Uc.useOptimistic = function(e3, n6) {
      return kc = "useOptimistic", r3(), hn(), Jn(e3, n6);
    };
    var Ic = {}, Dc = /* @__PURE__ */ new Set(), Fc = /* @__PURE__ */ new Set(), Mc = /* @__PURE__ */ new Set(), Hc = /* @__PURE__ */ new Set(), jc = /* @__PURE__ */ new Set(), Wc = /* @__PURE__ */ new Set(), Oc = /* @__PURE__ */ new Set(), Ac = /* @__PURE__ */ new Set(), Qc = /* @__PURE__ */ new Set(), Bc = /* @__PURE__ */ new Set();
    Object.freeze(Ic);
    var Vc = { isMounted: function(e3) {
      var n6 = xo;
      if (null !== n6 && zo && 1 === n6.tag) {
        var t4 = n6.stateNode;
        t4._warnedAboutRefsInRender || console.error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", c3(n6) || "A component"), t4._warnedAboutRefsInRender = true;
      }
      return !!(e3 = e3._reactInternals) && function(e4) {
        var n7 = e4, t5 = e4;
        if (e4.alternate) for (; n7.return; ) n7 = n7.return;
        else {
          e4 = n7;
          do {
            0 != (4098 & (n7 = e4).flags) && (t5 = n7.return), e4 = n7.return;
          } while (e4);
        }
        return 3 === n7.tag ? t5 : null;
      }(e3) === e3;
    }, enqueueSetState: function(e3, n6, t4) {
      var r4 = Ql(e3 = e3._reactInternals), l3 = Fe(r4);
      l3.payload = n6, null != t4 && (Ot(t4), l3.callback = t4), null !== (n6 = Me(e3, l3, r4)) && (Vl(n6, e3, r4), He(n6, e3, r4));
    }, enqueueReplaceState: function(e3, n6, t4) {
      var r4 = Ql(e3 = e3._reactInternals), l3 = Fe(r4);
      l3.tag = Ji, l3.payload = n6, null != t4 && (Ot(t4), l3.callback = t4), null !== (n6 = Me(e3, l3, r4)) && (Vl(n6, e3, r4), He(n6, e3, r4));
    }, enqueueForceUpdate: function(e3, n6) {
      var t4 = Ql(e3 = e3._reactInternals), r4 = Fe(t4);
      r4.tag = Gi, null != n6 && (Ot(n6), r4.callback = n6), null !== (n6 = Me(e3, r4, t4)) && (Vl(n6, e3, t4), He(n6, e3, t4));
    } };
    "function" == typeof reportError && reportError;
    var $c = Error("This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."), qc = false, Yc = {}, Jc = {}, Gc = {}, Kc = {}, Xc = false, Zc = {}, ef = {}, nf = { dehydrated: null, treeContext: null, retryLane: 0 }, tf = false, rf = b2(null), lf = b2(null), af = {}, of = null, uf = null, sf = null, cf = false, ff = "undefined" != typeof AbortController ? AbortController : function() {
      var e3 = [], n6 = this.signal = { aborted: false, addEventListener: function(n7, t4) {
        e3.push(t4);
      } };
      this.abort = function() {
        n6.aborted = true, e3.forEach(function(e4) {
          return e4();
        });
      };
    }, df = Ga.unstable_scheduleCallback, pf = Ga.unstable_NormalPriority, mf = { $$typeof: oo, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0, _currentRenderer: null, _currentRenderer2: null }, hf = yo.S;
    yo.S = function(e3, n6) {
      "object" == typeof n6 && null !== n6 && "function" == typeof n6.then && function(e4, n7) {
        if (null === Bi) {
          var t4 = Bi = [];
          Vi = 0, $i = Le(), qi = { status: "pending", value: void 0, then: function(e5) {
            t4.push(e5);
          } };
        }
        Vi++, n7.then(Ue, Ue);
      }(0, n6), null !== hf && hf(e3, n6);
    };
    var gf = b2(null), yf = null;
    yf = /* @__PURE__ */ new Set();
    var bf = false, vf = false, Sf = false, kf = "function" == typeof WeakSet ? WeakSet : Set, wf = null, xf = null, zf = null, Cf = false, Pf = null, Ef = false, _f = null, Rf = 8192, Tf = { getCacheForType: function(e3) {
      var n6 = Rr(mf), t4 = n6.data.get(e3);
      return void 0 === t4 && (t4 = e3(), n6.data.set(e3, t4)), t4;
    }, getOwner: function() {
      return xo;
    } };
    if ("function" == typeof Symbol && Symbol.for) {
      var Nf = Symbol.for;
      Nf("selector.component"), Nf("selector.has_pseudo_class"), Nf("selector.role"), Nf("selector.test_id"), Nf("selector.text");
    }
    var Lf = "function" == typeof WeakMap ? WeakMap : Map, Uf = 0, If = 2, Df = 4, Ff = 0, Mf = 1, Hf = 2, jf = 3, Wf = 4, Of = 5, Af = 6, Qf = Uf, Bf = null, Vf = null, $f = 0, qf = 0, Yf = 1, Jf = 2, Gf = 3, Kf = 4, Xf = 5, Zf = 6, ed = 7, nd = 8, td = qf, rd = null, ld = false, ad = false, od = 0, ud = Ff, id = 0, sd = 0, cd = 0, fd = 0, dd = 0, pd = null, md = null, hd = false, gd = 0, yd = 300, bd = 1 / 0, vd = 500, Sd = null, kd = null, wd = false, xd = null, zd = 0, Cd = 0, Pd = null, Ed = 50, _d = 0, Rd = null, Td = false, Nd = false, Ld = 50, Ud = 0, Id = null, Dd = false, Fd = 0, Md = 1, Hd = 2, jd = null, Wd = false, Od = /* @__PURE__ */ new Set(), Ad = false;
    try {
      var Qd = Object.preventExtensions({});
      /* @__PURE__ */ new Map([[Qd, null]]), /* @__PURE__ */ new Set([Qd]);
    } catch (e3) {
      Ad = true;
    }
    var Bd = false;
    return Ya.createContainer = function(e3, n6, r4, l3, a4, o3, u3, i4, s3, c4) {
      return function(e4, n7, r5, l4, a5, o4, u4, i5, s4, c5, f3, d3) {
        return e4 = new ja(e4, n7, r5, u4, i5, s4, c5, null), n7 = 1, true === o4 && (n7 |= 24), ri && (n7 |= 2), o4 = t3(3, null, null, n7), e4.current = o4, o4.stateNode = e4, Ur(n7 = Lr()), e4.pooledCache = n7, Ur(n7), o4.memoizedState = { element: l4, isDehydrated: r5, cache: n7 }, Ie(o4), e4;
      }(e3, n6, false, null, 0, l3, o3, u3, i4, s3);
    }, Ya.flushSyncWork = function() {
      return (Qf & (If | Df)) !== Uf || (Ce(0), false);
    }, Ya.updateContainer = function(e3, n6, t4, r4) {
      var l3 = n6.current, a4 = Ql(l3);
      return Wa(l3, a4, e3, n6, t4, r4), a4;
    }, Ya.updateContainerSync = function(e3, n6, t4, r4) {
      return 0 === n6.tag && ga(), Wa(n6.current, 2, e3, n6, t4, r4), 2;
    }, Ya;
  }, n4.exports.default = n4.exports, Object.defineProperty(n4.exports, "__esModule", { value: true })), c.exports;
  var n4;
}();
var d = t(a.exports);
var p = { exports: {} };
var h;
var g = {};
false ? p.exports = (f || (f = 1, m.ConcurrentRoot = 1, m.ContinuousEventPriority = 8, m.DefaultEventPriority = 32, m.DiscreteEventPriority = 2, m.IdleEventPriority = 268435456, m.LegacyRoot = 0, m.NoEventPriority = 0), m) : p.exports = (h || (h = 1, g.ConcurrentRoot = 1, g.ContinuousEventPriority = 8, g.DefaultEventPriority = 32, g.DiscreteEventPriority = 2, g.IdleEventPriority = 268435456, g.LegacyRoot = 0, g.NoEventPriority = 0), g);
var y = p.exports;
var b = (e3, n4) => {
  const t3 = Object.keys(e3), r3 = Object.keys(n4);
  if (t3.length !== r3.length) return false;
  for (let r4 = 0; r4 < t3.length; r4 += 1) {
    const l2 = t3[r4];
    if ("render" === l2 && !e3[l2] != !n4[l2]) return false;
    if ("children" !== l2 && e3[l2] !== n4[l2]) {
      if ("object" == typeof e3[l2] && "object" == typeof n4[l2] && b(e3[l2], n4[l2])) continue;
      return false;
    }
    if ("children" === l2 && ("string" == typeof e3[l2] || "string" == typeof n4[l2])) return e3[l2] === n4[l2];
  }
  return true;
};
var v = {};
var S = console.error;
var k = ({ appendChild: e3, appendChildToContainer: n4, commitTextUpdate: t3, commitUpdate: r3, createInstance: l2, createTextInstance: a3, insertBefore: o2, removeChild: u3, removeChildFromContainer: i3, resetAfterCommit: s2 }) => {
  const c3 = d({ appendChild: e3, appendChildToContainer: n4, appendInitialChild: e3, createInstance: l2, createTextInstance: a3, insertBefore: o2, commitUpdate: (e4, n5, t4, l3) => {
    b(t4, l3) || r3(e4, null, n5, t4, l3);
  }, commitTextUpdate: t3, removeChild: u3, removeChildFromContainer: i3, resetAfterCommit: s2, noTimeout: -1, shouldSetTextContent: () => false, finalizeInitialChildren: () => false, getPublicInstance: (e4) => e4, getRootHostContext: () => v, getChildHostContext: () => v, prepareForCommit() {
  }, clearContainer() {
  }, resetTextContent() {
  }, getCurrentUpdatePriority: () => y.DefaultEventPriority, maySuspendCommit: () => false, requestPostPaintCallback: () => {
  }, resolveUpdatePriority: () => y.DefaultEventPriority, setCurrentUpdatePriority: () => {
  }, shouldAttemptEagerTransition: () => false });
  return { createContainer: (e4) => c3.createContainer(e4, y.ConcurrentRoot, null, false, null, "", S, S, S, null), updateContainer: (e4, n5, t4, r4) => {
    c3.updateContainerSync(e4, n5, t4, r4), c3.flushSyncWork();
  } };
};

// node_modules/@react-pdf/reconciler/lib/reconciler-23.js
var import_object_assign = __toESM(require_object_assign(), 1);
var import_react2 = __toESM(require_react(), 1);
var n2 = __toESM(require_scheduler(), 1);
function r2(e3) {
  return e3 && e3.__esModule && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
}
function l(e3) {
  if (e3.__esModule) return e3;
  var t3 = e3.default;
  if ("function" == typeof t3) {
    var n4 = function e4() {
      return this instanceof e4 ? Reflect.construct(t3, arguments, this.constructor) : t3.apply(this, arguments);
    };
    n4.prototype = t3.prototype;
  } else n4 = {};
  return Object.defineProperty(n4, "__esModule", { value: true }), Object.keys(e3).forEach(function(t4) {
    var r3 = Object.getOwnPropertyDescriptor(e3, t4);
    Object.defineProperty(n4, t4, r3.get ? r3 : { enumerable: true, get: function() {
      return e3[t4];
    } });
  }), n4;
}
var i2;
var a2 = { exports: {} };
var u2 = l(n2);
/** @license React v0.23.0
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(i2 = a2).exports = function n3(r3) {
  var l2 = import_object_assign.default, a3 = import_react2.default, o2 = u2;
  function f2(e3) {
    for (var t3 = "https://reactjs.org/docs/error-decoder.html?invariant=" + e3, n4 = 1; n4 < arguments.length; n4++) t3 += "&args[]=" + encodeURIComponent(arguments[n4]);
    return "Minified React error #" + e3 + "; visit " + t3 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var c3 = a3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  c3.hasOwnProperty("ReactCurrentDispatcher") || (c3.ReactCurrentDispatcher = { current: null }), c3.hasOwnProperty("ReactCurrentBatchConfig") || (c3.ReactCurrentBatchConfig = { suspense: null });
  var s2 = "function" == typeof Symbol && Symbol.for, d2 = s2 ? Symbol.for("react.element") : 60103, p2 = s2 ? Symbol.for("react.portal") : 60106, m = s2 ? Symbol.for("react.fragment") : 60107, h2 = s2 ? Symbol.for("react.strict_mode") : 60108, g2 = s2 ? Symbol.for("react.profiler") : 60114, b2 = s2 ? Symbol.for("react.provider") : 60109, y2 = s2 ? Symbol.for("react.context") : 60110, v2 = s2 ? Symbol.for("react.concurrent_mode") : 60111, T = s2 ? Symbol.for("react.forward_ref") : 60112, x = s2 ? Symbol.for("react.suspense") : 60113, E = s2 ? Symbol.for("react.suspense_list") : 60120, k2 = s2 ? Symbol.for("react.memo") : 60115, S2 = s2 ? Symbol.for("react.lazy") : 60116, C = "function" == typeof Symbol && Symbol.iterator;
  function w(e3) {
    return null === e3 || "object" != typeof e3 ? null : "function" == typeof (e3 = C && e3[C] || e3["@@iterator"]) ? e3 : null;
  }
  function z(e3) {
    if (null == e3) return null;
    if ("function" == typeof e3) return e3.displayName || e3.name || null;
    if ("string" == typeof e3) return e3;
    switch (e3) {
      case m:
        return "Fragment";
      case p2:
        return "Portal";
      case g2:
        return "Profiler";
      case h2:
        return "StrictMode";
      case x:
        return "Suspense";
      case E:
        return "SuspenseList";
    }
    if ("object" == typeof e3) switch (e3.$$typeof) {
      case y2:
        return "Context.Consumer";
      case b2:
        return "Context.Provider";
      case T:
        var t3 = e3.render;
        return t3 = t3.displayName || t3.name || "", e3.displayName || ("" !== t3 ? "ForwardRef(" + t3 + ")" : "ForwardRef");
      case k2:
        return z(e3.type);
      case S2:
        if (e3 = 1 === e3._status ? e3._result : null) return z(e3);
    }
    return null;
  }
  function P(e3) {
    var t3 = e3, n4 = e3;
    if (e3.alternate) for (; t3.return; ) t3 = t3.return;
    else {
      e3 = t3;
      do {
        0 != (1026 & (t3 = e3).effectTag) && (n4 = t3.return), e3 = t3.return;
      } while (e3);
    }
    return 3 === t3.tag ? n4 : null;
  }
  function _(e3) {
    if (P(e3) !== e3) throw Error(f2(188));
  }
  function N(e3) {
    var t3 = e3.alternate;
    if (!t3) {
      if (null === (t3 = P(e3))) throw Error(f2(188));
      return t3 !== e3 ? null : e3;
    }
    for (var n4 = e3, r4 = t3; ; ) {
      var l3 = n4.return;
      if (null === l3) break;
      var i3 = l3.alternate;
      if (null === i3) {
        if (null !== (r4 = l3.return)) {
          n4 = r4;
          continue;
        }
        break;
      }
      if (l3.child === i3.child) {
        for (i3 = l3.child; i3; ) {
          if (i3 === n4) return _(l3), e3;
          if (i3 === r4) return _(l3), t3;
          i3 = i3.sibling;
        }
        throw Error(f2(188));
      }
      if (n4.return !== r4.return) n4 = l3, r4 = i3;
      else {
        for (var a4 = false, u3 = l3.child; u3; ) {
          if (u3 === n4) {
            a4 = true, n4 = l3, r4 = i3;
            break;
          }
          if (u3 === r4) {
            a4 = true, r4 = l3, n4 = i3;
            break;
          }
          u3 = u3.sibling;
        }
        if (!a4) {
          for (u3 = i3.child; u3; ) {
            if (u3 === n4) {
              a4 = true, n4 = i3, r4 = l3;
              break;
            }
            if (u3 === r4) {
              a4 = true, r4 = i3, n4 = l3;
              break;
            }
            u3 = u3.sibling;
          }
          if (!a4) throw Error(f2(189));
        }
      }
      if (n4.alternate !== r4) throw Error(f2(190));
    }
    if (3 !== n4.tag) throw Error(f2(188));
    return n4.stateNode.current === n4 ? e3 : t3;
  }
  function U(e3) {
    if (!(e3 = N(e3))) return null;
    for (var t3 = e3; ; ) {
      if (5 === t3.tag || 6 === t3.tag) return t3;
      if (t3.child) t3.child.return = t3, t3 = t3.child;
      else {
        if (t3 === e3) break;
        for (; !t3.sibling; ) {
          if (!t3.return || t3.return === e3) return null;
          t3 = t3.return;
        }
        t3.sibling.return = t3.return, t3 = t3.sibling;
      }
    }
    return null;
  }
  var R = r3.getPublicInstance, I = r3.getRootHostContext, M = r3.getChildHostContext, F = r3.prepareForCommit, Q = r3.resetAfterCommit, D = r3.createInstance, W = r3.appendInitialChild, j = r3.finalizeInitialChildren, O = r3.prepareUpdate, B = r3.shouldSetTextContent, H = r3.createTextInstance, A = null, L = null, $ = r3.noTimeout, q = true, V = null, K = r3.appendChild, G2 = r3.appendChildToContainer, Y = r3.commitTextUpdate, J = null, X = r3.commitUpdate, Z = r3.insertBefore, ee = null, te = r3.removeChild, ne = r3.removeChildFromContainer, re = r3.resetTextContent, le = null, ie = null, ae = null, ue = null, oe = null, fe = null, ce = /^(.*)[\\\/]/;
  function se(e3) {
    var t3 = "";
    do {
      e: switch (e3.tag) {
        case 3:
        case 4:
        case 6:
        case 7:
        case 10:
        case 9:
          var n4 = "";
          break e;
        default:
          var r4 = e3._debugOwner, l3 = e3._debugSource, i3 = z(e3.type);
          n4 = null, r4 && (n4 = z(r4.type)), r4 = i3, i3 = "", l3 ? i3 = " (at " + l3.fileName.replace(ce, "") + ":" + l3.lineNumber + ")" : n4 && (i3 = " (created by " + n4 + ")"), n4 = "\n    in " + (r4 || "Unknown") + i3;
      }
      t3 += n4, e3 = e3.return;
    } while (e3);
    return t3;
  }
  var de = [], pe = -1;
  function me(e3) {
    0 > pe || (e3.current = de[pe], de[pe] = null, pe--);
  }
  function he(e3, t3) {
    pe++, de[pe] = e3.current, e3.current = t3;
  }
  var ge = {}, be = { current: ge }, ye = { current: false }, ve = ge;
  function Te(e3, t3) {
    var n4 = e3.type.contextTypes;
    if (!n4) return ge;
    var r4 = e3.stateNode;
    if (r4 && r4.__reactInternalMemoizedUnmaskedChildContext === t3) return r4.__reactInternalMemoizedMaskedChildContext;
    var l3, i3 = {};
    for (l3 in n4) i3[l3] = t3[l3];
    return r4 && ((e3 = e3.stateNode).__reactInternalMemoizedUnmaskedChildContext = t3, e3.__reactInternalMemoizedMaskedChildContext = i3), i3;
  }
  function xe(e3) {
    return null != (e3 = e3.childContextTypes);
  }
  function Ee(e3) {
    me(ye), me(be);
  }
  function ke(e3) {
    me(ye), me(be);
  }
  function Se(e3, t3, n4) {
    if (be.current !== ge) throw Error(f2(168));
    he(be, t3), he(ye, n4);
  }
  function Ce(e3, t3, n4) {
    var r4 = e3.stateNode;
    if (e3 = t3.childContextTypes, "function" != typeof r4.getChildContext) return n4;
    for (var i3 in r4 = r4.getChildContext()) if (!(i3 in e3)) throw Error(f2(108, z(t3) || "Unknown", i3));
    return l2({}, n4, {}, r4);
  }
  function we(e3) {
    var t3 = e3.stateNode;
    return t3 = t3 && t3.__reactInternalMemoizedMergedChildContext || ge, ve = be.current, he(be, t3), he(ye, ye.current), true;
  }
  function ze(e3, t3, n4) {
    var r4 = e3.stateNode;
    if (!r4) throw Error(f2(169));
    n4 ? (t3 = Ce(e3, t3, ve), r4.__reactInternalMemoizedMergedChildContext = t3, me(ye), me(be), he(be, t3)) : me(ye), he(ye, n4);
  }
  var Pe = o2.unstable_runWithPriority, _e = o2.unstable_scheduleCallback, Ne = o2.unstable_cancelCallback, Ue = o2.unstable_shouldYield, Re = o2.unstable_requestPaint, Ie = o2.unstable_now, Me = o2.unstable_getCurrentPriorityLevel, Fe = o2.unstable_ImmediatePriority, Qe = o2.unstable_UserBlockingPriority, De = o2.unstable_NormalPriority, We = o2.unstable_LowPriority, je = o2.unstable_IdlePriority, Oe = {}, Be = void 0 !== Re ? Re : function() {
  }, He = null, Ae = null, Le = false, $e = Ie(), qe = 1e4 > $e ? Ie : function() {
    return Ie() - $e;
  };
  function Ve() {
    switch (Me()) {
      case Fe:
        return 99;
      case Qe:
        return 98;
      case De:
        return 97;
      case We:
        return 96;
      case je:
        return 95;
      default:
        throw Error(f2(332));
    }
  }
  function Ke(e3) {
    switch (e3) {
      case 99:
        return Fe;
      case 98:
        return Qe;
      case 97:
        return De;
      case 96:
        return We;
      case 95:
        return je;
      default:
        throw Error(f2(332));
    }
  }
  function Ge(e3, t3) {
    return e3 = Ke(e3), Pe(e3, t3);
  }
  function Ye(e3, t3, n4) {
    return e3 = Ke(e3), _e(e3, t3, n4);
  }
  function Je(e3) {
    return null === He ? (He = [e3], Ae = _e(Fe, Ze)) : He.push(e3), Oe;
  }
  function Xe() {
    if (null !== Ae) {
      var e3 = Ae;
      Ae = null, Ne(e3);
    }
    Ze();
  }
  function Ze() {
    if (!Le && null !== He) {
      Le = true;
      var e3 = 0;
      try {
        var t3 = He;
        Ge(99, function() {
          for (; e3 < t3.length; e3++) {
            var n4 = t3[e3];
            do {
              n4 = n4(true);
            } while (null !== n4);
          }
        }), He = null;
      } catch (t4) {
        throw null !== He && (He = He.slice(e3 + 1)), _e(Fe, Xe), t4;
      } finally {
        Le = false;
      }
    }
  }
  var et = 3;
  function tt(e3, t3, n4) {
    return 1073741821 - (1 + ((1073741821 - e3 + t3 / 10) / (n4 /= 10) | 0)) * n4;
  }
  var nt = "function" == typeof Object.is ? Object.is : function(e3, t3) {
    return e3 === t3 && (0 !== e3 || 1 / e3 == 1 / t3) || e3 != e3 && t3 != t3;
  }, rt = Object.prototype.hasOwnProperty;
  function lt(e3, t3) {
    if (nt(e3, t3)) return true;
    if ("object" != typeof e3 || null === e3 || "object" != typeof t3 || null === t3) return false;
    var n4 = Object.keys(e3), r4 = Object.keys(t3);
    if (n4.length !== r4.length) return false;
    for (r4 = 0; r4 < n4.length; r4++) if (!rt.call(t3, n4[r4]) || !nt(e3[n4[r4]], t3[n4[r4]])) return false;
    return true;
  }
  function it(e3, t3) {
    if (e3 && e3.defaultProps) for (var n4 in t3 = l2({}, t3), e3 = e3.defaultProps) void 0 === t3[n4] && (t3[n4] = e3[n4]);
    return t3;
  }
  var at = { current: null }, ut = null, ot = null, ft = null;
  function ct() {
    ft = ot = ut = null;
  }
  function st(e3, t3) {
    var n4 = e3.type._context;
    he(at, n4._currentValue2), n4._currentValue2 = t3;
  }
  function dt(e3) {
    var t3 = at.current;
    me(at), (e3 = e3.type._context)._currentValue2 = t3;
  }
  function pt(e3, t3) {
    for (; null !== e3; ) {
      var n4 = e3.alternate;
      if (e3.childExpirationTime < t3) e3.childExpirationTime = t3, null !== n4 && n4.childExpirationTime < t3 && (n4.childExpirationTime = t3);
      else {
        if (!(null !== n4 && n4.childExpirationTime < t3)) break;
        n4.childExpirationTime = t3;
      }
      e3 = e3.return;
    }
  }
  function mt(e3, t3) {
    ut = e3, ft = ot = null, null !== (e3 = e3.dependencies) && null !== e3.firstContext && (e3.expirationTime >= t3 && (On = true), e3.firstContext = null);
  }
  function ht(e3, t3) {
    if (ft !== e3 && false !== t3 && 0 !== t3) if ("number" == typeof t3 && 1073741823 !== t3 || (ft = e3, t3 = 1073741823), t3 = { context: e3, observedBits: t3, next: null }, null === ot) {
      if (null === ut) throw Error(f2(308));
      ot = t3, ut.dependencies = { expirationTime: 0, firstContext: t3, responders: null };
    } else ot = ot.next = t3;
    return e3._currentValue2;
  }
  var gt = false;
  function bt(e3) {
    return { baseState: e3, firstUpdate: null, lastUpdate: null, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
  }
  function yt(e3) {
    return { baseState: e3.baseState, firstUpdate: e3.firstUpdate, lastUpdate: e3.lastUpdate, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
  }
  function vt(e3, t3) {
    return { expirationTime: e3, suspenseConfig: t3, tag: 0, payload: null, callback: null, next: null, nextEffect: null };
  }
  function Tt(e3, t3) {
    null === e3.lastUpdate ? e3.firstUpdate = e3.lastUpdate = t3 : (e3.lastUpdate.next = t3, e3.lastUpdate = t3);
  }
  function xt(e3, t3) {
    var n4 = e3.alternate;
    if (null === n4) {
      var r4 = e3.updateQueue, l3 = null;
      null === r4 && (r4 = e3.updateQueue = bt(e3.memoizedState));
    } else r4 = e3.updateQueue, l3 = n4.updateQueue, null === r4 ? null === l3 ? (r4 = e3.updateQueue = bt(e3.memoizedState), l3 = n4.updateQueue = bt(n4.memoizedState)) : r4 = e3.updateQueue = yt(l3) : null === l3 && (l3 = n4.updateQueue = yt(r4));
    null === l3 || r4 === l3 ? Tt(r4, t3) : null === r4.lastUpdate || null === l3.lastUpdate ? (Tt(r4, t3), Tt(l3, t3)) : (Tt(r4, t3), l3.lastUpdate = t3);
  }
  function Et(e3, t3) {
    var n4 = e3.updateQueue;
    null === (n4 = null === n4 ? e3.updateQueue = bt(e3.memoizedState) : kt(e3, n4)).lastCapturedUpdate ? n4.firstCapturedUpdate = n4.lastCapturedUpdate = t3 : (n4.lastCapturedUpdate.next = t3, n4.lastCapturedUpdate = t3);
  }
  function kt(e3, t3) {
    var n4 = e3.alternate;
    return null !== n4 && t3 === n4.updateQueue && (t3 = e3.updateQueue = yt(t3)), t3;
  }
  function St(e3, t3, n4, r4, i3, a4) {
    switch (n4.tag) {
      case 1:
        return "function" == typeof (e3 = n4.payload) ? e3.call(a4, r4, i3) : e3;
      case 3:
        e3.effectTag = -4097 & e3.effectTag | 64;
      case 0:
        if (null == (i3 = "function" == typeof (e3 = n4.payload) ? e3.call(a4, r4, i3) : e3)) break;
        return l2({}, r4, i3);
      case 2:
        gt = true;
    }
    return r4;
  }
  function Ct(e3, t3, n4, r4, l3) {
    gt = false;
    for (var i3 = (t3 = kt(e3, t3)).baseState, a4 = null, u3 = 0, o3 = t3.firstUpdate, f3 = i3; null !== o3; ) {
      var c4 = o3.expirationTime;
      c4 < l3 ? (null === a4 && (a4 = o3, i3 = f3), u3 < c4 && (u3 = c4)) : (El(c4, o3.suspenseConfig), f3 = St(e3, 0, o3, f3, n4, r4), null !== o3.callback && (e3.effectTag |= 32, o3.nextEffect = null, null === t3.lastEffect ? t3.firstEffect = t3.lastEffect = o3 : (t3.lastEffect.nextEffect = o3, t3.lastEffect = o3))), o3 = o3.next;
    }
    for (c4 = null, o3 = t3.firstCapturedUpdate; null !== o3; ) {
      var s3 = o3.expirationTime;
      s3 < l3 ? (null === c4 && (c4 = o3, null === a4 && (i3 = f3)), u3 < s3 && (u3 = s3)) : (f3 = St(e3, 0, o3, f3, n4, r4), null !== o3.callback && (e3.effectTag |= 32, o3.nextEffect = null, null === t3.lastCapturedEffect ? t3.firstCapturedEffect = t3.lastCapturedEffect = o3 : (t3.lastCapturedEffect.nextEffect = o3, t3.lastCapturedEffect = o3))), o3 = o3.next;
    }
    null === a4 && (t3.lastUpdate = null), null === c4 ? t3.lastCapturedUpdate = null : e3.effectTag |= 32, null === a4 && null === c4 && (i3 = f3), t3.baseState = i3, t3.firstUpdate = a4, t3.firstCapturedUpdate = c4, kl(u3), e3.expirationTime = u3, e3.memoizedState = f3;
  }
  function wt(e3, t3, n4) {
    null !== t3.firstCapturedUpdate && (null !== t3.lastUpdate && (t3.lastUpdate.next = t3.firstCapturedUpdate, t3.lastUpdate = t3.lastCapturedUpdate), t3.firstCapturedUpdate = t3.lastCapturedUpdate = null), zt(t3.firstEffect, n4), t3.firstEffect = t3.lastEffect = null, zt(t3.firstCapturedEffect, n4), t3.firstCapturedEffect = t3.lastCapturedEffect = null;
  }
  function zt(e3, t3) {
    for (; null !== e3; ) {
      var n4 = e3.callback;
      if (null !== n4) {
        e3.callback = null;
        var r4 = t3;
        if ("function" != typeof n4) throw Error(f2(191, n4));
        n4.call(r4);
      }
      e3 = e3.nextEffect;
    }
  }
  var Pt = c3.ReactCurrentBatchConfig, _t = new a3.Component().refs;
  function Nt(e3, t3, n4, r4) {
    n4 = null == (n4 = n4(r4, t3 = e3.memoizedState)) ? t3 : l2({}, t3, n4), e3.memoizedState = n4, null !== (r4 = e3.updateQueue) && 0 === e3.expirationTime && (r4.baseState = n4);
  }
  var Ut = { isMounted: function(e3) {
    return !!(e3 = e3._reactInternalFiber) && P(e3) === e3;
  }, enqueueSetState: function(e3, t3, n4) {
    e3 = e3._reactInternalFiber;
    var r4 = cl(), l3 = Pt.suspense;
    (l3 = vt(r4 = sl(r4, e3, l3), l3)).payload = t3, null != n4 && (l3.callback = n4), xt(e3, l3), dl(e3, r4);
  }, enqueueReplaceState: function(e3, t3, n4) {
    e3 = e3._reactInternalFiber;
    var r4 = cl(), l3 = Pt.suspense;
    (l3 = vt(r4 = sl(r4, e3, l3), l3)).tag = 1, l3.payload = t3, null != n4 && (l3.callback = n4), xt(e3, l3), dl(e3, r4);
  }, enqueueForceUpdate: function(e3, t3) {
    e3 = e3._reactInternalFiber;
    var n4 = cl(), r4 = Pt.suspense;
    (r4 = vt(n4 = sl(n4, e3, r4), r4)).tag = 2, null != t3 && (r4.callback = t3), xt(e3, r4), dl(e3, n4);
  } };
  function Rt(e3, t3, n4, r4, l3, i3, a4) {
    return "function" == typeof (e3 = e3.stateNode).shouldComponentUpdate ? e3.shouldComponentUpdate(r4, i3, a4) : !(t3.prototype && t3.prototype.isPureReactComponent && lt(n4, r4) && lt(l3, i3));
  }
  function It(e3, t3, n4) {
    var r4 = false, l3 = ge, i3 = t3.contextType;
    return "object" == typeof i3 && null !== i3 ? i3 = ht(i3) : (l3 = xe(t3) ? ve : be.current, i3 = (r4 = null != (r4 = t3.contextTypes)) ? Te(e3, l3) : ge), t3 = new t3(n4, i3), e3.memoizedState = null !== t3.state && void 0 !== t3.state ? t3.state : null, t3.updater = Ut, e3.stateNode = t3, t3._reactInternalFiber = e3, r4 && ((e3 = e3.stateNode).__reactInternalMemoizedUnmaskedChildContext = l3, e3.__reactInternalMemoizedMaskedChildContext = i3), t3;
  }
  function Mt(e3, t3, n4, r4) {
    e3 = t3.state, "function" == typeof t3.componentWillReceiveProps && t3.componentWillReceiveProps(n4, r4), "function" == typeof t3.UNSAFE_componentWillReceiveProps && t3.UNSAFE_componentWillReceiveProps(n4, r4), t3.state !== e3 && Ut.enqueueReplaceState(t3, t3.state, null);
  }
  function Ft(e3, t3, n4, r4) {
    var l3 = e3.stateNode;
    l3.props = n4, l3.state = e3.memoizedState, l3.refs = _t;
    var i3 = t3.contextType;
    "object" == typeof i3 && null !== i3 ? l3.context = ht(i3) : (i3 = xe(t3) ? ve : be.current, l3.context = Te(e3, i3)), null !== (i3 = e3.updateQueue) && (Ct(e3, i3, n4, l3, r4), l3.state = e3.memoizedState), "function" == typeof (i3 = t3.getDerivedStateFromProps) && (Nt(e3, t3, i3, n4), l3.state = e3.memoizedState), "function" == typeof t3.getDerivedStateFromProps || "function" == typeof l3.getSnapshotBeforeUpdate || "function" != typeof l3.UNSAFE_componentWillMount && "function" != typeof l3.componentWillMount || (t3 = l3.state, "function" == typeof l3.componentWillMount && l3.componentWillMount(), "function" == typeof l3.UNSAFE_componentWillMount && l3.UNSAFE_componentWillMount(), t3 !== l3.state && Ut.enqueueReplaceState(l3, l3.state, null), null !== (i3 = e3.updateQueue) && (Ct(e3, i3, n4, l3, r4), l3.state = e3.memoizedState)), "function" == typeof l3.componentDidMount && (e3.effectTag |= 4);
  }
  var Qt = Array.isArray;
  function Dt(e3, t3, n4) {
    if (null !== (e3 = n4.ref) && "function" != typeof e3 && "object" != typeof e3) {
      if (n4._owner) {
        if (n4 = n4._owner) {
          if (1 !== n4.tag) throw Error(f2(309));
          var r4 = n4.stateNode;
        }
        if (!r4) throw Error(f2(147, e3));
        var l3 = "" + e3;
        return null !== t3 && null !== t3.ref && "function" == typeof t3.ref && t3.ref._stringRef === l3 ? t3.ref : (t3 = function(e4) {
          var t4 = r4.refs;
          t4 === _t && (t4 = r4.refs = {}), null === e4 ? delete t4[l3] : t4[l3] = e4;
        }, t3._stringRef = l3, t3);
      }
      if ("string" != typeof e3) throw Error(f2(284));
      if (!n4._owner) throw Error(f2(290, e3));
    }
    return e3;
  }
  function Wt(e3, t3) {
    if ("textarea" !== e3.type) throw Error(f2(31, "[object Object]" === Object.prototype.toString.call(t3) ? "object with keys {" + Object.keys(t3).join(", ") + "}" : t3, ""));
  }
  function jt(e3) {
    function t3(t4, n5) {
      if (e3) {
        var r5 = t4.lastEffect;
        null !== r5 ? (r5.nextEffect = n5, t4.lastEffect = n5) : t4.firstEffect = t4.lastEffect = n5, n5.nextEffect = null, n5.effectTag = 8;
      }
    }
    function n4(n5, r5) {
      if (!e3) return null;
      for (; null !== r5; ) t3(n5, r5), r5 = r5.sibling;
      return null;
    }
    function r4(e4, t4) {
      for (e4 = /* @__PURE__ */ new Map(); null !== t4; ) null !== t4.key ? e4.set(t4.key, t4) : e4.set(t4.index, t4), t4 = t4.sibling;
      return e4;
    }
    function l3(e4, t4, n5) {
      return (e4 = Al(e4, t4)).index = 0, e4.sibling = null, e4;
    }
    function i3(t4, n5, r5) {
      return t4.index = r5, e3 ? null !== (r5 = t4.alternate) ? (r5 = r5.index) < n5 ? (t4.effectTag = 2, n5) : r5 : (t4.effectTag = 2, n5) : n5;
    }
    function a4(t4) {
      return e3 && null === t4.alternate && (t4.effectTag = 2), t4;
    }
    function u3(e4, t4, n5, r5) {
      return null === t4 || 6 !== t4.tag ? ((t4 = ql(n5, e4.mode, r5)).return = e4, t4) : ((t4 = l3(t4, n5)).return = e4, t4);
    }
    function o3(e4, t4, n5, r5) {
      return null !== t4 && t4.elementType === n5.type ? ((r5 = l3(t4, n5.props)).ref = Dt(e4, t4, n5), r5.return = e4, r5) : ((r5 = Ll(n5.type, n5.key, n5.props, null, e4.mode, r5)).ref = Dt(e4, t4, n5), r5.return = e4, r5);
    }
    function c4(e4, t4, n5, r5) {
      return null === t4 || 4 !== t4.tag || t4.stateNode.containerInfo !== n5.containerInfo || t4.stateNode.implementation !== n5.implementation ? ((t4 = Vl(n5, e4.mode, r5)).return = e4, t4) : ((t4 = l3(t4, n5.children || [])).return = e4, t4);
    }
    function s3(e4, t4, n5, r5, i4) {
      return null === t4 || 7 !== t4.tag ? ((t4 = $l(n5, e4.mode, r5, i4)).return = e4, t4) : ((t4 = l3(t4, n5)).return = e4, t4);
    }
    function h3(e4, t4, n5) {
      if ("string" == typeof t4 || "number" == typeof t4) return (t4 = ql("" + t4, e4.mode, n5)).return = e4, t4;
      if ("object" == typeof t4 && null !== t4) {
        switch (t4.$$typeof) {
          case d2:
            return (n5 = Ll(t4.type, t4.key, t4.props, null, e4.mode, n5)).ref = Dt(e4, null, t4), n5.return = e4, n5;
          case p2:
            return (t4 = Vl(t4, e4.mode, n5)).return = e4, t4;
        }
        if (Qt(t4) || w(t4)) return (t4 = $l(t4, e4.mode, n5, null)).return = e4, t4;
        Wt(e4, t4);
      }
      return null;
    }
    function g3(e4, t4, n5, r5) {
      var l4 = null !== t4 ? t4.key : null;
      if ("string" == typeof n5 || "number" == typeof n5) return null !== l4 ? null : u3(e4, t4, "" + n5, r5);
      if ("object" == typeof n5 && null !== n5) {
        switch (n5.$$typeof) {
          case d2:
            return n5.key === l4 ? n5.type === m ? s3(e4, t4, n5.props.children, r5, l4) : o3(e4, t4, n5, r5) : null;
          case p2:
            return n5.key === l4 ? c4(e4, t4, n5, r5) : null;
        }
        if (Qt(n5) || w(n5)) return null !== l4 ? null : s3(e4, t4, n5, r5, null);
        Wt(e4, n5);
      }
      return null;
    }
    function b3(e4, t4, n5, r5, l4) {
      if ("string" == typeof r5 || "number" == typeof r5) return u3(t4, e4 = e4.get(n5) || null, "" + r5, l4);
      if ("object" == typeof r5 && null !== r5) {
        switch (r5.$$typeof) {
          case d2:
            return e4 = e4.get(null === r5.key ? n5 : r5.key) || null, r5.type === m ? s3(t4, e4, r5.props.children, l4, r5.key) : o3(t4, e4, r5, l4);
          case p2:
            return c4(t4, e4 = e4.get(null === r5.key ? n5 : r5.key) || null, r5, l4);
        }
        if (Qt(r5) || w(r5)) return s3(t4, e4 = e4.get(n5) || null, r5, l4, null);
        Wt(t4, r5);
      }
      return null;
    }
    function y3(l4, a5, u4, o4) {
      for (var f3 = null, c5 = null, s4 = a5, d3 = a5 = 0, p3 = null; null !== s4 && d3 < u4.length; d3++) {
        s4.index > d3 ? (p3 = s4, s4 = null) : p3 = s4.sibling;
        var m2 = g3(l4, s4, u4[d3], o4);
        if (null === m2) {
          null === s4 && (s4 = p3);
          break;
        }
        e3 && s4 && null === m2.alternate && t3(l4, s4), a5 = i3(m2, a5, d3), null === c5 ? f3 = m2 : c5.sibling = m2, c5 = m2, s4 = p3;
      }
      if (d3 === u4.length) return n4(l4, s4), f3;
      if (null === s4) {
        for (; d3 < u4.length; d3++) null !== (s4 = h3(l4, u4[d3], o4)) && (a5 = i3(s4, a5, d3), null === c5 ? f3 = s4 : c5.sibling = s4, c5 = s4);
        return f3;
      }
      for (s4 = r4(l4, s4); d3 < u4.length; d3++) null !== (p3 = b3(s4, l4, d3, u4[d3], o4)) && (e3 && null !== p3.alternate && s4.delete(null === p3.key ? d3 : p3.key), a5 = i3(p3, a5, d3), null === c5 ? f3 = p3 : c5.sibling = p3, c5 = p3);
      return e3 && s4.forEach(function(e4) {
        return t3(l4, e4);
      }), f3;
    }
    function v3(l4, a5, u4, o4) {
      var c5 = w(u4);
      if ("function" != typeof c5) throw Error(f2(150));
      if (null == (u4 = c5.call(u4))) throw Error(f2(151));
      for (var s4 = c5 = null, d3 = a5, p3 = a5 = 0, m2 = null, y4 = u4.next(); null !== d3 && !y4.done; p3++, y4 = u4.next()) {
        d3.index > p3 ? (m2 = d3, d3 = null) : m2 = d3.sibling;
        var v4 = g3(l4, d3, y4.value, o4);
        if (null === v4) {
          null === d3 && (d3 = m2);
          break;
        }
        e3 && d3 && null === v4.alternate && t3(l4, d3), a5 = i3(v4, a5, p3), null === s4 ? c5 = v4 : s4.sibling = v4, s4 = v4, d3 = m2;
      }
      if (y4.done) return n4(l4, d3), c5;
      if (null === d3) {
        for (; !y4.done; p3++, y4 = u4.next()) null !== (y4 = h3(l4, y4.value, o4)) && (a5 = i3(y4, a5, p3), null === s4 ? c5 = y4 : s4.sibling = y4, s4 = y4);
        return c5;
      }
      for (d3 = r4(l4, d3); !y4.done; p3++, y4 = u4.next()) null !== (y4 = b3(d3, l4, p3, y4.value, o4)) && (e3 && null !== y4.alternate && d3.delete(null === y4.key ? p3 : y4.key), a5 = i3(y4, a5, p3), null === s4 ? c5 = y4 : s4.sibling = y4, s4 = y4);
      return e3 && d3.forEach(function(e4) {
        return t3(l4, e4);
      }), c5;
    }
    return function(e4, r5, i4, u4) {
      var o4 = "object" == typeof i4 && null !== i4 && i4.type === m && null === i4.key;
      o4 && (i4 = i4.props.children);
      var c5 = "object" == typeof i4 && null !== i4;
      if (c5) switch (i4.$$typeof) {
        case d2:
          e: {
            for (c5 = i4.key, o4 = r5; null !== o4; ) {
              if (o4.key === c5) {
                if (7 === o4.tag ? i4.type === m : o4.elementType === i4.type) {
                  n4(e4, o4.sibling), (r5 = l3(o4, i4.type === m ? i4.props.children : i4.props)).ref = Dt(e4, o4, i4), r5.return = e4, e4 = r5;
                  break e;
                }
                n4(e4, o4);
                break;
              }
              t3(e4, o4), o4 = o4.sibling;
            }
            i4.type === m ? ((r5 = $l(i4.props.children, e4.mode, u4, i4.key)).return = e4, e4 = r5) : ((u4 = Ll(i4.type, i4.key, i4.props, null, e4.mode, u4)).ref = Dt(e4, r5, i4), u4.return = e4, e4 = u4);
          }
          return a4(e4);
        case p2:
          e: {
            for (o4 = i4.key; null !== r5; ) {
              if (r5.key === o4) {
                if (4 === r5.tag && r5.stateNode.containerInfo === i4.containerInfo && r5.stateNode.implementation === i4.implementation) {
                  n4(e4, r5.sibling), (r5 = l3(r5, i4.children || [])).return = e4, e4 = r5;
                  break e;
                }
                n4(e4, r5);
                break;
              }
              t3(e4, r5), r5 = r5.sibling;
            }
            (r5 = Vl(i4, e4.mode, u4)).return = e4, e4 = r5;
          }
          return a4(e4);
      }
      if ("string" == typeof i4 || "number" == typeof i4) return i4 = "" + i4, null !== r5 && 6 === r5.tag ? (n4(e4, r5.sibling), (r5 = l3(r5, i4)).return = e4, e4 = r5) : (n4(e4, r5), (r5 = ql(i4, e4.mode, u4)).return = e4, e4 = r5), a4(e4);
      if (Qt(i4)) return y3(e4, r5, i4, u4);
      if (w(i4)) return v3(e4, r5, i4, u4);
      if (c5 && Wt(e4, i4), void 0 === i4 && !o4) switch (e4.tag) {
        case 1:
        case 0:
          throw e4 = e4.type, Error(f2(152, e4.displayName || e4.name || "Component"));
      }
      return n4(e4, r5);
    };
  }
  var Ot = jt(true), Bt = jt(false), Ht = {}, At = { current: Ht }, Lt = { current: Ht }, $t = { current: Ht };
  function qt(e3) {
    if (e3 === Ht) throw Error(f2(174));
    return e3;
  }
  function Vt(e3, t3) {
    he($t, t3), he(Lt, e3), he(At, Ht), t3 = I(t3), me(At), he(At, t3);
  }
  function Kt(e3) {
    me(At), me(Lt), me($t);
  }
  function Gt(e3) {
    var t3 = qt($t.current), n4 = qt(At.current);
    n4 !== (t3 = M(n4, e3.type, t3)) && (he(Lt, e3), he(At, t3));
  }
  function Yt(e3) {
    Lt.current === e3 && (me(At), me(Lt));
  }
  var Jt = { current: 0 };
  function Xt(e3) {
    for (var t3 = e3; null !== t3; ) {
      if (13 === t3.tag) {
        var n4 = t3.memoizedState;
        if (null !== n4 && (null === (n4 = n4.dehydrated) || oe(n4) || fe(n4))) return t3;
      } else if (19 === t3.tag && void 0 !== t3.memoizedProps.revealOrder) {
        if (0 != (64 & t3.effectTag)) return t3;
      } else if (null !== t3.child) {
        t3.child.return = t3, t3 = t3.child;
        continue;
      }
      if (t3 === e3) break;
      for (; null === t3.sibling; ) {
        if (null === t3.return || t3.return === e3) return null;
        t3 = t3.return;
      }
      t3.sibling.return = t3.return, t3 = t3.sibling;
    }
    return null;
  }
  function Zt(e3, t3) {
    return { responder: e3, props: t3 };
  }
  var en = c3.ReactCurrentDispatcher, tn = c3.ReactCurrentBatchConfig, nn = 0, rn = null, ln = null, an = null, un = null, on3 = null, fn = null, cn = 0, sn = null, dn = 0, pn = false, mn = null, hn = 0;
  function gn() {
    throw Error(f2(321));
  }
  function bn(e3, t3) {
    if (null === t3) return false;
    for (var n4 = 0; n4 < t3.length && n4 < e3.length; n4++) if (!nt(e3[n4], t3[n4])) return false;
    return true;
  }
  function yn(e3, t3, n4, r4, l3, i3) {
    if (nn = i3, rn = t3, an = null !== e3 ? e3.memoizedState : null, en.current = null === an ? Dn : Wn, t3 = n4(r4, l3), pn) {
      do {
        pn = false, hn += 1, an = null !== e3 ? e3.memoizedState : null, fn = un, sn = on3 = ln = null, en.current = Wn, t3 = n4(r4, l3);
      } while (pn);
      mn = null, hn = 0;
    }
    if (en.current = Qn, (e3 = rn).memoizedState = un, e3.expirationTime = cn, e3.updateQueue = sn, e3.effectTag |= dn, e3 = null !== ln && null !== ln.next, nn = 0, fn = on3 = un = an = ln = rn = null, cn = 0, sn = null, dn = 0, e3) throw Error(f2(300));
    return t3;
  }
  function vn() {
    en.current = Qn, nn = 0, fn = on3 = un = an = ln = rn = null, cn = 0, sn = null, dn = 0, pn = false, mn = null, hn = 0;
  }
  function Tn() {
    var e3 = { memoizedState: null, baseState: null, queue: null, baseUpdate: null, next: null };
    return null === on3 ? un = on3 = e3 : on3 = on3.next = e3, on3;
  }
  function xn() {
    if (null !== fn) fn = (on3 = fn).next, an = null !== (ln = an) ? ln.next : null;
    else {
      if (null === an) throw Error(f2(310));
      var e3 = { memoizedState: (ln = an).memoizedState, baseState: ln.baseState, queue: ln.queue, baseUpdate: ln.baseUpdate, next: null };
      on3 = null === on3 ? un = e3 : on3.next = e3, an = ln.next;
    }
    return on3;
  }
  function En(e3, t3) {
    return "function" == typeof t3 ? t3(e3) : t3;
  }
  function kn(e3) {
    var t3 = xn(), n4 = t3.queue;
    if (null === n4) throw Error(f2(311));
    if (n4.lastRenderedReducer = e3, 0 < hn) {
      var r4 = n4.dispatch;
      if (null !== mn) {
        var l3 = mn.get(n4);
        if (void 0 !== l3) {
          mn.delete(n4);
          var i3 = t3.memoizedState;
          do {
            i3 = e3(i3, l3.action), l3 = l3.next;
          } while (null !== l3);
          return nt(i3, t3.memoizedState) || (On = true), t3.memoizedState = i3, t3.baseUpdate === n4.last && (t3.baseState = i3), n4.lastRenderedState = i3, [i3, r4];
        }
      }
      return [t3.memoizedState, r4];
    }
    r4 = n4.last;
    var a4 = t3.baseUpdate;
    if (i3 = t3.baseState, null !== a4 ? (null !== r4 && (r4.next = null), r4 = a4.next) : r4 = null !== r4 ? r4.next : null, null !== r4) {
      var u3 = l3 = null, o3 = r4, c4 = false;
      do {
        var s3 = o3.expirationTime;
        s3 < nn ? (c4 || (c4 = true, u3 = a4, l3 = i3), s3 > cn && kl(cn = s3)) : (El(s3, o3.suspenseConfig), i3 = o3.eagerReducer === e3 ? o3.eagerState : e3(i3, o3.action)), a4 = o3, o3 = o3.next;
      } while (null !== o3 && o3 !== r4);
      c4 || (u3 = a4, l3 = i3), nt(i3, t3.memoizedState) || (On = true), t3.memoizedState = i3, t3.baseUpdate = u3, t3.baseState = l3, n4.lastRenderedState = i3;
    }
    return [t3.memoizedState, n4.dispatch];
  }
  function Sn(e3) {
    var t3 = Tn();
    return "function" == typeof e3 && (e3 = e3()), t3.memoizedState = t3.baseState = e3, e3 = (e3 = t3.queue = { last: null, dispatch: null, lastRenderedReducer: En, lastRenderedState: e3 }).dispatch = Fn.bind(null, rn, e3), [t3.memoizedState, e3];
  }
  function Cn(e3) {
    return kn(En);
  }
  function wn(e3, t3, n4, r4) {
    return e3 = { tag: e3, create: t3, destroy: n4, deps: r4, next: null }, null === sn ? (sn = { lastEffect: null }).lastEffect = e3.next = e3 : null === (t3 = sn.lastEffect) ? sn.lastEffect = e3.next = e3 : (n4 = t3.next, t3.next = e3, e3.next = n4, sn.lastEffect = e3), e3;
  }
  function zn(e3, t3, n4, r4) {
    var l3 = Tn();
    dn |= e3, l3.memoizedState = wn(t3, n4, void 0, void 0 === r4 ? null : r4);
  }
  function Pn(e3, t3, n4, r4) {
    var l3 = xn();
    r4 = void 0 === r4 ? null : r4;
    var i3 = void 0;
    if (null !== ln) {
      var a4 = ln.memoizedState;
      if (i3 = a4.destroy, null !== r4 && bn(r4, a4.deps)) return void wn(0, n4, i3, r4);
    }
    dn |= e3, l3.memoizedState = wn(t3, n4, i3, r4);
  }
  function _n(e3, t3) {
    return zn(516, 192, e3, t3);
  }
  function Nn(e3, t3) {
    return Pn(516, 192, e3, t3);
  }
  function Un(e3, t3) {
    return "function" == typeof t3 ? (e3 = e3(), t3(e3), function() {
      t3(null);
    }) : null != t3 ? (e3 = e3(), t3.current = e3, function() {
      t3.current = null;
    }) : void 0;
  }
  function Rn() {
  }
  function In(e3, t3) {
    return Tn().memoizedState = [e3, void 0 === t3 ? null : t3], e3;
  }
  function Mn(e3, t3) {
    var n4 = xn();
    t3 = void 0 === t3 ? null : t3;
    var r4 = n4.memoizedState;
    return null !== r4 && null !== t3 && bn(t3, r4[1]) ? r4[0] : (n4.memoizedState = [e3, t3], e3);
  }
  function Fn(e3, t3, n4) {
    if (!(25 > hn)) throw Error(f2(301));
    var r4 = e3.alternate;
    if (e3 === rn || null !== r4 && r4 === rn) if (pn = true, e3 = { expirationTime: nn, suspenseConfig: null, action: n4, eagerReducer: null, eagerState: null, next: null }, null === mn && (mn = /* @__PURE__ */ new Map()), void 0 === (n4 = mn.get(t3))) mn.set(t3, e3);
    else {
      for (t3 = n4; null !== t3.next; ) t3 = t3.next;
      t3.next = e3;
    }
    else {
      var l3 = cl(), i3 = Pt.suspense;
      i3 = { expirationTime: l3 = sl(l3, e3, i3), suspenseConfig: i3, action: n4, eagerReducer: null, eagerState: null, next: null };
      var a4 = t3.last;
      if (null === a4) i3.next = i3;
      else {
        var u3 = a4.next;
        null !== u3 && (i3.next = u3), a4.next = i3;
      }
      if (t3.last = i3, 0 === e3.expirationTime && (null === r4 || 0 === r4.expirationTime) && null !== (r4 = t3.lastRenderedReducer)) try {
        var o3 = t3.lastRenderedState, c4 = r4(o3, n4);
        if (i3.eagerReducer = r4, i3.eagerState = c4, nt(c4, o3)) return;
      } catch (e4) {
      }
      dl(e3, l3);
    }
  }
  var Qn = { readContext: ht, useCallback: gn, useContext: gn, useEffect: gn, useImperativeHandle: gn, useLayoutEffect: gn, useMemo: gn, useReducer: gn, useRef: gn, useState: gn, useDebugValue: gn, useResponder: gn, useDeferredValue: gn, useTransition: gn }, Dn = { readContext: ht, useCallback: In, useContext: ht, useEffect: _n, useImperativeHandle: function(e3, t3, n4) {
    return n4 = null != n4 ? n4.concat([e3]) : null, zn(4, 36, Un.bind(null, t3, e3), n4);
  }, useLayoutEffect: function(e3, t3) {
    return zn(4, 36, e3, t3);
  }, useMemo: function(e3, t3) {
    var n4 = Tn();
    return t3 = void 0 === t3 ? null : t3, e3 = e3(), n4.memoizedState = [e3, t3], e3;
  }, useReducer: function(e3, t3, n4) {
    var r4 = Tn();
    return t3 = void 0 !== n4 ? n4(t3) : t3, r4.memoizedState = r4.baseState = t3, e3 = (e3 = r4.queue = { last: null, dispatch: null, lastRenderedReducer: e3, lastRenderedState: t3 }).dispatch = Fn.bind(null, rn, e3), [r4.memoizedState, e3];
  }, useRef: function(e3) {
    return e3 = { current: e3 }, Tn().memoizedState = e3;
  }, useState: Sn, useDebugValue: Rn, useResponder: Zt, useDeferredValue: function(e3, t3) {
    var n4 = Sn(e3), r4 = n4[0], l3 = n4[1];
    return _n(function() {
      o2.unstable_next(function() {
        var n5 = tn.suspense;
        tn.suspense = void 0 === t3 ? null : t3;
        try {
          l3(e3);
        } finally {
          tn.suspense = n5;
        }
      });
    }, [e3, t3]), r4;
  }, useTransition: function(e3) {
    var t3 = Sn(false), n4 = t3[0], r4 = t3[1];
    return [In(function(t4) {
      r4(true), o2.unstable_next(function() {
        var n5 = tn.suspense;
        tn.suspense = void 0 === e3 ? null : e3;
        try {
          r4(false), t4();
        } finally {
          tn.suspense = n5;
        }
      });
    }, [e3, n4]), n4];
  } }, Wn = { readContext: ht, useCallback: Mn, useContext: ht, useEffect: Nn, useImperativeHandle: function(e3, t3, n4) {
    return n4 = null != n4 ? n4.concat([e3]) : null, Pn(4, 36, Un.bind(null, t3, e3), n4);
  }, useLayoutEffect: function(e3, t3) {
    return Pn(4, 36, e3, t3);
  }, useMemo: function(e3, t3) {
    var n4 = xn();
    t3 = void 0 === t3 ? null : t3;
    var r4 = n4.memoizedState;
    return null !== r4 && null !== t3 && bn(t3, r4[1]) ? r4[0] : (e3 = e3(), n4.memoizedState = [e3, t3], e3);
  }, useReducer: kn, useRef: function() {
    return xn().memoizedState;
  }, useState: Cn, useDebugValue: Rn, useResponder: Zt, useDeferredValue: function(e3, t3) {
    var n4 = Cn(), r4 = n4[0], l3 = n4[1];
    return Nn(function() {
      o2.unstable_next(function() {
        var n5 = tn.suspense;
        tn.suspense = void 0 === t3 ? null : t3;
        try {
          l3(e3);
        } finally {
          tn.suspense = n5;
        }
      });
    }, [e3, t3]), r4;
  }, useTransition: function(e3) {
    var t3 = Cn(), n4 = t3[0], r4 = t3[1];
    return [Mn(function(t4) {
      r4(true), o2.unstable_next(function() {
        var n5 = tn.suspense;
        tn.suspense = void 0 === e3 ? null : e3;
        try {
          r4(false), t4();
        } finally {
          tn.suspense = n5;
        }
      });
    }, [e3, n4]), n4];
  } }, jn = c3.ReactCurrentOwner, On = false;
  function Bn(e3, t3, n4, r4) {
    t3.child = null === e3 ? Bt(t3, null, n4, r4) : Ot(t3, e3.child, n4, r4);
  }
  function Hn(e3, t3, n4, r4, l3) {
    n4 = n4.render;
    var i3 = t3.ref;
    return mt(t3, l3), r4 = yn(e3, t3, n4, r4, i3, l3), null === e3 || On ? (t3.effectTag |= 1, Bn(e3, t3, r4, l3), t3.child) : (t3.updateQueue = e3.updateQueue, t3.effectTag &= -517, e3.expirationTime <= l3 && (e3.expirationTime = 0), ir(e3, t3, l3));
  }
  function An(e3, t3, n4, r4, l3, i3) {
    if (null === e3) {
      var a4 = n4.type;
      return "function" != typeof a4 || Hl(a4) || void 0 !== a4.defaultProps || null !== n4.compare || void 0 !== n4.defaultProps ? ((e3 = Ll(n4.type, null, r4, null, t3.mode, i3)).ref = t3.ref, e3.return = t3, t3.child = e3) : (t3.tag = 15, t3.type = a4, Ln(e3, t3, a4, r4, l3, i3));
    }
    return a4 = e3.child, l3 < i3 && (l3 = a4.memoizedProps, (n4 = null !== (n4 = n4.compare) ? n4 : lt)(l3, r4) && e3.ref === t3.ref) ? ir(e3, t3, i3) : (t3.effectTag |= 1, (e3 = Al(a4, r4)).ref = t3.ref, e3.return = t3, t3.child = e3);
  }
  function Ln(e3, t3, n4, r4, l3, i3) {
    return null !== e3 && lt(e3.memoizedProps, r4) && e3.ref === t3.ref && (On = false, l3 < i3) ? ir(e3, t3, i3) : qn(e3, t3, n4, r4, i3);
  }
  function $n(e3, t3) {
    var n4 = t3.ref;
    (null === e3 && null !== n4 || null !== e3 && e3.ref !== n4) && (t3.effectTag |= 128);
  }
  function qn(e3, t3, n4, r4, l3) {
    var i3 = xe(n4) ? ve : be.current;
    return i3 = Te(t3, i3), mt(t3, l3), n4 = yn(e3, t3, n4, r4, i3, l3), null === e3 || On ? (t3.effectTag |= 1, Bn(e3, t3, n4, l3), t3.child) : (t3.updateQueue = e3.updateQueue, t3.effectTag &= -517, e3.expirationTime <= l3 && (e3.expirationTime = 0), ir(e3, t3, l3));
  }
  function Vn(e3, t3, n4, r4, l3) {
    if (xe(n4)) {
      var i3 = true;
      we(t3);
    } else i3 = false;
    if (mt(t3, l3), null === t3.stateNode) null !== e3 && (e3.alternate = null, t3.alternate = null, t3.effectTag |= 2), It(t3, n4, r4), Ft(t3, n4, r4, l3), r4 = true;
    else if (null === e3) {
      var a4 = t3.stateNode, u3 = t3.memoizedProps;
      a4.props = u3;
      var o3 = a4.context, f3 = n4.contextType;
      f3 = "object" == typeof f3 && null !== f3 ? ht(f3) : Te(t3, f3 = xe(n4) ? ve : be.current);
      var c4 = n4.getDerivedStateFromProps, s3 = "function" == typeof c4 || "function" == typeof a4.getSnapshotBeforeUpdate;
      s3 || "function" != typeof a4.UNSAFE_componentWillReceiveProps && "function" != typeof a4.componentWillReceiveProps || (u3 !== r4 || o3 !== f3) && Mt(t3, a4, r4, f3), gt = false;
      var d3 = t3.memoizedState;
      o3 = a4.state = d3;
      var p3 = t3.updateQueue;
      null !== p3 && (Ct(t3, p3, r4, a4, l3), o3 = t3.memoizedState), u3 !== r4 || d3 !== o3 || ye.current || gt ? ("function" == typeof c4 && (Nt(t3, n4, c4, r4), o3 = t3.memoizedState), (u3 = gt || Rt(t3, n4, u3, r4, d3, o3, f3)) ? (s3 || "function" != typeof a4.UNSAFE_componentWillMount && "function" != typeof a4.componentWillMount || ("function" == typeof a4.componentWillMount && a4.componentWillMount(), "function" == typeof a4.UNSAFE_componentWillMount && a4.UNSAFE_componentWillMount()), "function" == typeof a4.componentDidMount && (t3.effectTag |= 4)) : ("function" == typeof a4.componentDidMount && (t3.effectTag |= 4), t3.memoizedProps = r4, t3.memoizedState = o3), a4.props = r4, a4.state = o3, a4.context = f3, r4 = u3) : ("function" == typeof a4.componentDidMount && (t3.effectTag |= 4), r4 = false);
    } else a4 = t3.stateNode, u3 = t3.memoizedProps, a4.props = t3.type === t3.elementType ? u3 : it(t3.type, u3), o3 = a4.context, f3 = "object" == typeof (f3 = n4.contextType) && null !== f3 ? ht(f3) : Te(t3, f3 = xe(n4) ? ve : be.current), (s3 = "function" == typeof (c4 = n4.getDerivedStateFromProps) || "function" == typeof a4.getSnapshotBeforeUpdate) || "function" != typeof a4.UNSAFE_componentWillReceiveProps && "function" != typeof a4.componentWillReceiveProps || (u3 !== r4 || o3 !== f3) && Mt(t3, a4, r4, f3), gt = false, o3 = t3.memoizedState, d3 = a4.state = o3, null !== (p3 = t3.updateQueue) && (Ct(t3, p3, r4, a4, l3), d3 = t3.memoizedState), u3 !== r4 || o3 !== d3 || ye.current || gt ? ("function" == typeof c4 && (Nt(t3, n4, c4, r4), d3 = t3.memoizedState), (c4 = gt || Rt(t3, n4, u3, r4, o3, d3, f3)) ? (s3 || "function" != typeof a4.UNSAFE_componentWillUpdate && "function" != typeof a4.componentWillUpdate || ("function" == typeof a4.componentWillUpdate && a4.componentWillUpdate(r4, d3, f3), "function" == typeof a4.UNSAFE_componentWillUpdate && a4.UNSAFE_componentWillUpdate(r4, d3, f3)), "function" == typeof a4.componentDidUpdate && (t3.effectTag |= 4), "function" == typeof a4.getSnapshotBeforeUpdate && (t3.effectTag |= 256)) : ("function" != typeof a4.componentDidUpdate || u3 === e3.memoizedProps && o3 === e3.memoizedState || (t3.effectTag |= 4), "function" != typeof a4.getSnapshotBeforeUpdate || u3 === e3.memoizedProps && o3 === e3.memoizedState || (t3.effectTag |= 256), t3.memoizedProps = r4, t3.memoizedState = d3), a4.props = r4, a4.state = d3, a4.context = f3, r4 = c4) : ("function" != typeof a4.componentDidUpdate || u3 === e3.memoizedProps && o3 === e3.memoizedState || (t3.effectTag |= 4), "function" != typeof a4.getSnapshotBeforeUpdate || u3 === e3.memoizedProps && o3 === e3.memoizedState || (t3.effectTag |= 256), r4 = false);
    return Kn(e3, t3, n4, r4, i3, l3);
  }
  function Kn(e3, t3, n4, r4, l3, i3) {
    $n(e3, t3);
    var a4 = 0 != (64 & t3.effectTag);
    if (!r4 && !a4) return l3 && ze(t3, n4, false), ir(e3, t3, i3);
    r4 = t3.stateNode, jn.current = t3;
    var u3 = a4 && "function" != typeof n4.getDerivedStateFromError ? null : r4.render();
    return t3.effectTag |= 1, null !== e3 && a4 ? (t3.child = Ot(t3, e3.child, null, i3), t3.child = Ot(t3, null, u3, i3)) : Bn(e3, t3, u3, i3), t3.memoizedState = r4.state, l3 && ze(t3, n4, true), t3.child;
  }
  function Gn(e3) {
    var t3 = e3.stateNode;
    t3.pendingContext ? Se(0, t3.pendingContext, t3.pendingContext !== t3.context) : t3.context && Se(0, t3.context, false), Vt(e3, t3.containerInfo);
  }
  var Yn, Jn, Xn, Zn, er = { dehydrated: null, retryTime: 0 };
  function tr(e3, t3, n4) {
    var r4, l3 = t3.mode, i3 = t3.pendingProps, a4 = Jt.current, u3 = false;
    if ((r4 = 0 != (64 & t3.effectTag)) || (r4 = 0 != (2 & a4) && (null === e3 || null !== e3.memoizedState)), r4 ? (u3 = true, t3.effectTag &= -65) : null !== e3 && null === e3.memoizedState || void 0 === i3.fallback || true === i3.unstable_avoidThisFallback || (a4 |= 1), he(Jt, 1 & a4), null === e3) {
      if (i3.fallback, u3) {
        if (u3 = i3.fallback, (i3 = $l(null, l3, 0, null)).return = t3, 0 == (2 & t3.mode)) for (e3 = null !== t3.memoizedState ? t3.child.child : t3.child, i3.child = e3; null !== e3; ) e3.return = i3, e3 = e3.sibling;
        return (n4 = $l(u3, l3, n4, null)).return = t3, i3.sibling = n4, t3.memoizedState = er, t3.child = i3, n4;
      }
      return l3 = i3.children, t3.memoizedState = null, t3.child = Bt(t3, null, l3, n4);
    }
    if (null !== e3.memoizedState) {
      if (l3 = (e3 = e3.child).sibling, u3) {
        if (i3 = i3.fallback, (n4 = Al(e3, e3.pendingProps)).return = t3, 0 == (2 & t3.mode) && (u3 = null !== t3.memoizedState ? t3.child.child : t3.child) !== e3.child) for (n4.child = u3; null !== u3; ) u3.return = n4, u3 = u3.sibling;
        return (l3 = Al(l3, i3, l3.expirationTime)).return = t3, n4.sibling = l3, n4.childExpirationTime = 0, t3.memoizedState = er, t3.child = n4, l3;
      }
      return n4 = Ot(t3, e3.child, i3.children, n4), t3.memoizedState = null, t3.child = n4;
    }
    if (e3 = e3.child, u3) {
      if (u3 = i3.fallback, (i3 = $l(null, l3, 0, null)).return = t3, i3.child = e3, null !== e3 && (e3.return = i3), 0 == (2 & t3.mode)) for (e3 = null !== t3.memoizedState ? t3.child.child : t3.child, i3.child = e3; null !== e3; ) e3.return = i3, e3 = e3.sibling;
      return (n4 = $l(u3, l3, n4, null)).return = t3, i3.sibling = n4, n4.effectTag |= 2, i3.childExpirationTime = 0, t3.memoizedState = er, t3.child = i3, n4;
    }
    return t3.memoizedState = null, t3.child = Ot(t3, e3, i3.children, n4);
  }
  function nr(e3, t3) {
    e3.expirationTime < t3 && (e3.expirationTime = t3);
    var n4 = e3.alternate;
    null !== n4 && n4.expirationTime < t3 && (n4.expirationTime = t3), pt(e3.return, t3);
  }
  function rr(e3, t3, n4, r4, l3, i3) {
    var a4 = e3.memoizedState;
    null === a4 ? e3.memoizedState = { isBackwards: t3, rendering: null, last: r4, tail: n4, tailExpiration: 0, tailMode: l3, lastEffect: i3 } : (a4.isBackwards = t3, a4.rendering = null, a4.last = r4, a4.tail = n4, a4.tailExpiration = 0, a4.tailMode = l3, a4.lastEffect = i3);
  }
  function lr(e3, t3, n4) {
    var r4 = t3.pendingProps, l3 = r4.revealOrder, i3 = r4.tail;
    if (Bn(e3, t3, r4.children, n4), 0 != (2 & (r4 = Jt.current))) r4 = 1 & r4 | 2, t3.effectTag |= 64;
    else {
      if (null !== e3 && 0 != (64 & e3.effectTag)) e: for (e3 = t3.child; null !== e3; ) {
        if (13 === e3.tag) null !== e3.memoizedState && nr(e3, n4);
        else if (19 === e3.tag) nr(e3, n4);
        else if (null !== e3.child) {
          e3.child.return = e3, e3 = e3.child;
          continue;
        }
        if (e3 === t3) break e;
        for (; null === e3.sibling; ) {
          if (null === e3.return || e3.return === t3) break e;
          e3 = e3.return;
        }
        e3.sibling.return = e3.return, e3 = e3.sibling;
      }
      r4 &= 1;
    }
    if (he(Jt, r4), 0 == (2 & t3.mode)) t3.memoizedState = null;
    else switch (l3) {
      case "forwards":
        for (n4 = t3.child, l3 = null; null !== n4; ) null !== (e3 = n4.alternate) && null === Xt(e3) && (l3 = n4), n4 = n4.sibling;
        null === (n4 = l3) ? (l3 = t3.child, t3.child = null) : (l3 = n4.sibling, n4.sibling = null), rr(t3, false, l3, n4, i3, t3.lastEffect);
        break;
      case "backwards":
        for (n4 = null, l3 = t3.child, t3.child = null; null !== l3; ) {
          if (null !== (e3 = l3.alternate) && null === Xt(e3)) {
            t3.child = l3;
            break;
          }
          e3 = l3.sibling, l3.sibling = n4, n4 = l3, l3 = e3;
        }
        rr(t3, true, n4, null, i3, t3.lastEffect);
        break;
      case "together":
        rr(t3, false, null, null, void 0, t3.lastEffect);
        break;
      default:
        t3.memoizedState = null;
    }
    return t3.child;
  }
  function ir(e3, t3, n4) {
    null !== e3 && (t3.dependencies = e3.dependencies);
    var r4 = t3.expirationTime;
    if (0 !== r4 && kl(r4), t3.childExpirationTime < n4) return null;
    if (null !== e3 && t3.child !== e3.child) throw Error(f2(153));
    if (null !== t3.child) {
      for (n4 = Al(e3 = t3.child, e3.pendingProps, e3.expirationTime), t3.child = n4, n4.return = t3; null !== e3.sibling; ) e3 = e3.sibling, (n4 = n4.sibling = Al(e3, e3.pendingProps, e3.expirationTime)).return = t3;
      n4.sibling = null;
    }
    return t3.child;
  }
  function ar(e3) {
    e3.effectTag |= 4;
  }
  function ur(e3, t3) {
    switch (e3.tailMode) {
      case "hidden":
        t3 = e3.tail;
        for (var n4 = null; null !== t3; ) null !== t3.alternate && (n4 = t3), t3 = t3.sibling;
        null === n4 ? e3.tail = null : n4.sibling = null;
        break;
      case "collapsed":
        n4 = e3.tail;
        for (var r4 = null; null !== n4; ) null !== n4.alternate && (r4 = n4), n4 = n4.sibling;
        null === r4 ? t3 || null === e3.tail ? e3.tail = null : e3.tail.sibling = null : r4.sibling = null;
    }
  }
  function or(e3) {
    switch (e3.tag) {
      case 1:
        xe(e3.type) && Ee();
        var t3 = e3.effectTag;
        return 4096 & t3 ? (e3.effectTag = -4097 & t3 | 64, e3) : null;
      case 3:
        if (Kt(), ke(), 0 != (64 & (t3 = e3.effectTag))) throw Error(f2(285));
        return e3.effectTag = -4097 & t3 | 64, e3;
      case 5:
        return Yt(e3), null;
      case 13:
        return me(Jt), 4096 & (t3 = e3.effectTag) ? (e3.effectTag = -4097 & t3 | 64, e3) : null;
      case 19:
        return me(Jt), null;
      case 4:
        return Kt(), null;
      case 10:
        return dt(e3), null;
      default:
        return null;
    }
  }
  function fr(e3, t3) {
    return { value: e3, source: t3, stack: se(t3) };
  }
  Yn = function(e3, t3) {
    for (var n4 = t3.child; null !== n4; ) {
      if (5 === n4.tag || 6 === n4.tag) W(e3, n4.stateNode);
      else if (4 !== n4.tag && null !== n4.child) {
        n4.child.return = n4, n4 = n4.child;
        continue;
      }
      if (n4 === t3) break;
      for (; null === n4.sibling; ) {
        if (null === n4.return || n4.return === t3) return;
        n4 = n4.return;
      }
      n4.sibling.return = n4.return, n4 = n4.sibling;
    }
  }, Jn = function() {
  }, Xn = function(e3, t3, n4, r4, l3) {
    if ((e3 = e3.memoizedProps) !== r4) {
      var i3 = t3.stateNode, a4 = qt(At.current);
      n4 = O(i3, n4, e3, r4, l3, a4), (t3.updateQueue = n4) && ar(t3);
    }
  }, Zn = function(e3, t3, n4, r4) {
    n4 !== r4 && ar(t3);
  };
  var cr = "function" == typeof WeakSet ? WeakSet : Set;
  function sr(e3, t3) {
    var n4 = t3.source, r4 = t3.stack;
    null === r4 && null !== n4 && (r4 = se(n4)), null !== n4 && z(n4.type), t3 = t3.value, null !== e3 && 1 === e3.tag && z(e3.type);
    try {
      console.error(t3);
    } catch (e4) {
      setTimeout(function() {
        throw e4;
      });
    }
  }
  function dr(e3) {
    var t3 = e3.ref;
    if (null !== t3) if ("function" == typeof t3) try {
      t3(null);
    } catch (t4) {
      Fl(e3, t4);
    }
    else t3.current = null;
  }
  function pr(e3, t3) {
    switch (t3.tag) {
      case 0:
      case 11:
      case 15:
        mr(2, 0, t3);
        break;
      case 1:
        if (256 & t3.effectTag && null !== e3) {
          var n4 = e3.memoizedProps, r4 = e3.memoizedState;
          t3 = (e3 = t3.stateNode).getSnapshotBeforeUpdate(t3.elementType === t3.type ? n4 : it(t3.type, n4), r4), e3.__reactInternalSnapshotBeforeUpdate = t3;
        }
        break;
      case 3:
      case 5:
      case 6:
      case 4:
      case 17:
        break;
      default:
        throw Error(f2(163));
    }
  }
  function mr(e3, t3, n4) {
    if (null !== (n4 = null !== (n4 = n4.updateQueue) ? n4.lastEffect : null)) {
      var r4 = n4 = n4.next;
      do {
        if (0 != (r4.tag & e3)) {
          var l3 = r4.destroy;
          r4.destroy = void 0, void 0 !== l3 && l3();
        }
        0 != (r4.tag & t3) && (l3 = r4.create, r4.destroy = l3()), r4 = r4.next;
      } while (r4 !== n4);
    }
  }
  function hr(e3, t3, n4) {
    switch ("function" == typeof jl && jl(t3), t3.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (null !== (e3 = t3.updateQueue) && null !== (e3 = e3.lastEffect)) {
          var r4 = e3.next;
          Ge(97 < n4 ? 97 : n4, function() {
            var e4 = r4;
            do {
              var n5 = e4.destroy;
              if (void 0 !== n5) {
                var l3 = t3;
                try {
                  n5();
                } catch (e5) {
                  Fl(l3, e5);
                }
              }
              e4 = e4.next;
            } while (e4 !== r4);
          });
        }
        break;
      case 1:
        dr(t3), "function" == typeof (n4 = t3.stateNode).componentWillUnmount && function(e4, t4) {
          try {
            t4.props = e4.memoizedProps, t4.state = e4.memoizedState, t4.componentWillUnmount();
          } catch (t5) {
            Fl(e4, t5);
          }
        }(t3, n4);
        break;
      case 5:
        dr(t3);
        break;
      case 4:
        Tr(e3, t3, n4);
    }
  }
  function gr(e3, t3, n4) {
    for (var r4 = t3; ; ) if (hr(e3, r4, n4), null === r4.child || 4 === r4.tag) {
      if (r4 === t3) break;
      for (; null === r4.sibling; ) {
        if (null === r4.return || r4.return === t3) return;
        r4 = r4.return;
      }
      r4.sibling.return = r4.return, r4 = r4.sibling;
    } else r4.child.return = r4, r4 = r4.child;
  }
  function br(e3) {
    var t3 = e3.alternate;
    e3.return = null, e3.child = null, e3.memoizedState = null, e3.updateQueue = null, e3.dependencies = null, e3.alternate = null, e3.firstEffect = null, e3.lastEffect = null, e3.pendingProps = null, e3.memoizedProps = null, null !== t3 && br(t3);
  }
  function yr(e3) {
    return 5 === e3.tag || 3 === e3.tag || 4 === e3.tag;
  }
  function vr(e3) {
    e: {
      for (var t3 = e3.return; null !== t3; ) {
        if (yr(t3)) {
          var n4 = t3;
          break e;
        }
        t3 = t3.return;
      }
      throw Error(f2(160));
    }
    switch (t3 = n4.stateNode, n4.tag) {
      case 5:
        var r4 = false;
        break;
      case 3:
      case 4:
        t3 = t3.containerInfo, r4 = true;
        break;
      default:
        throw Error(f2(161));
    }
    16 & n4.effectTag && (re(t3), n4.effectTag &= -17);
    e: t: for (n4 = e3; ; ) {
      for (; null === n4.sibling; ) {
        if (null === n4.return || yr(n4.return)) {
          n4 = null;
          break e;
        }
        n4 = n4.return;
      }
      for (n4.sibling.return = n4.return, n4 = n4.sibling; 5 !== n4.tag && 6 !== n4.tag && 18 !== n4.tag; ) {
        if (2 & n4.effectTag) continue t;
        if (null === n4.child || 4 === n4.tag) continue t;
        n4.child.return = n4, n4 = n4.child;
      }
      if (!(2 & n4.effectTag)) {
        n4 = n4.stateNode;
        break e;
      }
    }
    for (var l3 = e3; ; ) {
      var i3 = 5 === l3.tag || 6 === l3.tag;
      if (i3) i3 = i3 ? l3.stateNode : l3.stateNode.instance, n4 ? r4 ? ee(t3, i3, n4) : Z(t3, i3, n4) : r4 ? G2(t3, i3) : K(t3, i3);
      else if (4 !== l3.tag && null !== l3.child) {
        l3.child.return = l3, l3 = l3.child;
        continue;
      }
      if (l3 === e3) break;
      for (; null === l3.sibling; ) {
        if (null === l3.return || l3.return === e3) return;
        l3 = l3.return;
      }
      l3.sibling.return = l3.return, l3 = l3.sibling;
    }
  }
  function Tr(e3, t3, n4) {
    for (var r4, l3, i3 = t3, a4 = false; ; ) {
      if (!a4) {
        a4 = i3.return;
        e: for (; ; ) {
          if (null === a4) throw Error(f2(160));
          switch (r4 = a4.stateNode, a4.tag) {
            case 5:
              l3 = false;
              break e;
            case 3:
            case 4:
              r4 = r4.containerInfo, l3 = true;
              break e;
          }
          a4 = a4.return;
        }
        a4 = true;
      }
      if (5 === i3.tag || 6 === i3.tag) gr(e3, i3, n4), l3 ? ne(r4, i3.stateNode) : te(r4, i3.stateNode);
      else if (4 === i3.tag) {
        if (null !== i3.child) {
          r4 = i3.stateNode.containerInfo, l3 = true, i3.child.return = i3, i3 = i3.child;
          continue;
        }
      } else if (hr(e3, i3, n4), null !== i3.child) {
        i3.child.return = i3, i3 = i3.child;
        continue;
      }
      if (i3 === t3) break;
      for (; null === i3.sibling; ) {
        if (null === i3.return || i3.return === t3) return;
        4 === (i3 = i3.return).tag && (a4 = false);
      }
      i3.sibling.return = i3.return, i3 = i3.sibling;
    }
  }
  function xr(e3, t3) {
    switch (t3.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        mr(4, 8, t3);
        break;
      case 1:
      case 3:
      case 12:
      case 17:
      case 20:
      case 21:
        break;
      case 5:
        var n4 = t3.stateNode;
        if (null != n4) {
          var r4 = t3.memoizedProps;
          e3 = null !== e3 ? e3.memoizedProps : r4;
          var l3 = t3.type, i3 = t3.updateQueue;
          t3.updateQueue = null, null !== i3 && X(n4, i3, l3, e3, r4, t3);
        }
        break;
      case 6:
        if (null === t3.stateNode) throw Error(f2(162));
        n4 = t3.memoizedProps, Y(t3.stateNode, null !== e3 ? e3.memoizedProps : n4, n4);
        break;
      case 13:
        !function(e4) {
          var t4 = e4;
          if (null === e4.memoizedState) var n5 = false;
          else n5 = true, t4 = e4.child, Jr = qe();
          if (null !== t4) {
            e: if (e4 = t4, q) for (t4 = e4; ; ) {
              if (5 === t4.tag) {
                var r5 = t4.stateNode;
                n5 ? le(r5) : ae(t4.stateNode, t4.memoizedProps);
              } else if (6 === t4.tag) r5 = t4.stateNode, n5 ? ie(r5) : ue(r5, t4.memoizedProps);
              else {
                if (13 === t4.tag && null !== t4.memoizedState && null === t4.memoizedState.dehydrated) {
                  (r5 = t4.child.sibling).return = t4, t4 = r5;
                  continue;
                }
                if (null !== t4.child) {
                  t4.child.return = t4, t4 = t4.child;
                  continue;
                }
              }
              if (t4 === e4) break e;
              for (; null === t4.sibling; ) {
                if (null === t4.return || t4.return === e4) break e;
                t4 = t4.return;
              }
              t4.sibling.return = t4.return, t4 = t4.sibling;
            }
          }
        }(t3), Er(t3);
        break;
      case 19:
        Er(t3);
        break;
      default:
        throw Error(f2(163));
    }
  }
  function Er(e3) {
    var t3 = e3.updateQueue;
    if (null !== t3) {
      e3.updateQueue = null;
      var n4 = e3.stateNode;
      null === n4 && (n4 = e3.stateNode = new cr()), t3.forEach(function(t4) {
        var r4 = Dl.bind(null, e3, t4);
        n4.has(t4) || (n4.add(t4), t4.then(r4, r4));
      });
    }
  }
  var kr = "function" == typeof WeakMap ? WeakMap : Map;
  function Sr(e3, t3, n4) {
    (n4 = vt(n4, null)).tag = 3, n4.payload = { element: null };
    var r4 = t3.value;
    return n4.callback = function() {
      el || (el = true, tl = r4), sr(e3, t3);
    }, n4;
  }
  function Cr(e3, t3, n4) {
    (n4 = vt(n4, null)).tag = 3;
    var r4 = e3.type.getDerivedStateFromError;
    if ("function" == typeof r4) {
      var l3 = t3.value;
      n4.payload = function() {
        return sr(e3, t3), r4(l3);
      };
    }
    var i3 = e3.stateNode;
    return null !== i3 && "function" == typeof i3.componentDidCatch && (n4.callback = function() {
      "function" != typeof r4 && (null === nl ? nl = /* @__PURE__ */ new Set([this]) : nl.add(this), sr(e3, t3));
      var n5 = t3.stack;
      this.componentDidCatch(t3.value, { componentStack: null !== n5 ? n5 : "" });
    }), n4;
  }
  var wr, zr = Math.ceil, Pr = c3.ReactCurrentDispatcher, _r = c3.ReactCurrentOwner, Nr = 0, Ur = 8, Rr = 16, Ir = 32, Mr = 0, Fr = 1, Qr = 2, Dr = 3, Wr = 4, jr = 5, Or = Nr, Br = null, Hr = null, Ar = 0, Lr = Mr, $r = null, qr = 1073741823, Vr = 1073741823, Kr = null, Gr = 0, Yr = false, Jr = 0, Xr = 500, Zr = null, el = false, tl = null, nl = null, rl = false, ll = null, il = 90, al = null, ul = 0, ol = null, fl = 0;
  function cl() {
    return (Or & (Rr | Ir)) !== Nr ? 1073741821 - (qe() / 10 | 0) : 0 !== fl ? fl : fl = 1073741821 - (qe() / 10 | 0);
  }
  function sl(e3, t3, n4) {
    if (0 == (2 & (t3 = t3.mode))) return 1073741823;
    var r4 = Ve();
    if (0 == (4 & t3)) return 99 === r4 ? 1073741823 : 1073741822;
    if ((Or & Rr) !== Nr) return Ar;
    if (null !== n4) e3 = tt(e3, 0 | n4.timeoutMs || 5e3, 250);
    else switch (r4) {
      case 99:
        e3 = 1073741823;
        break;
      case 98:
        e3 = tt(e3, 150, 100);
        break;
      case 97:
      case 96:
        e3 = tt(e3, 5e3, 250);
        break;
      case 95:
        e3 = 2;
        break;
      default:
        throw Error(f2(326));
    }
    return null !== Br && e3 === Ar && --e3, e3;
  }
  function dl(e3, t3) {
    if (50 < ul) throw ul = 0, ol = null, Error(f2(185));
    if (null !== (e3 = pl(e3, t3))) {
      var n4 = Ve();
      1073741823 === t3 ? (Or & Ur) !== Nr && (Or & (Rr | Ir)) === Nr ? bl(e3) : (hl(e3), Or === Nr && Xe()) : hl(e3), (4 & Or) === Nr || 98 !== n4 && 99 !== n4 || (null === al ? al = /* @__PURE__ */ new Map([[e3, t3]]) : (void 0 === (n4 = al.get(e3)) || n4 > t3) && al.set(e3, t3));
    }
  }
  function pl(e3, t3) {
    e3.expirationTime < t3 && (e3.expirationTime = t3);
    var n4 = e3.alternate;
    null !== n4 && n4.expirationTime < t3 && (n4.expirationTime = t3);
    var r4 = e3.return, l3 = null;
    if (null === r4 && 3 === e3.tag) l3 = e3.stateNode;
    else for (; null !== r4; ) {
      if (n4 = r4.alternate, r4.childExpirationTime < t3 && (r4.childExpirationTime = t3), null !== n4 && n4.childExpirationTime < t3 && (n4.childExpirationTime = t3), null === r4.return && 3 === r4.tag) {
        l3 = r4.stateNode;
        break;
      }
      r4 = r4.return;
    }
    return null !== l3 && (Br === l3 && (kl(t3), Lr === Wr && Yl(l3, Ar)), Jl(l3, t3)), l3;
  }
  function ml(e3) {
    var t3 = e3.lastExpiredTime;
    return 0 !== t3 ? t3 : Gl(e3, t3 = e3.firstPendingTime) ? (t3 = e3.lastPingedTime) > (e3 = e3.nextKnownPendingLevel) ? t3 : e3 : t3;
  }
  function hl(e3) {
    if (0 !== e3.lastExpiredTime) e3.callbackExpirationTime = 1073741823, e3.callbackPriority = 99, e3.callbackNode = Je(bl.bind(null, e3));
    else {
      var t3 = ml(e3), n4 = e3.callbackNode;
      if (0 === t3) null !== n4 && (e3.callbackNode = null, e3.callbackExpirationTime = 0, e3.callbackPriority = 90);
      else {
        var r4 = cl();
        if (r4 = 1073741823 === t3 ? 99 : 1 === t3 || 2 === t3 ? 95 : 0 >= (r4 = 10 * (1073741821 - t3) - 10 * (1073741821 - r4)) ? 99 : 250 >= r4 ? 98 : 5250 >= r4 ? 97 : 95, null !== n4) {
          var l3 = e3.callbackPriority;
          if (e3.callbackExpirationTime === t3 && l3 >= r4) return;
          n4 !== Oe && Ne(n4);
        }
        e3.callbackExpirationTime = t3, e3.callbackPriority = r4, t3 = 1073741823 === t3 ? Je(bl.bind(null, e3)) : Ye(r4, gl.bind(null, e3), { timeout: 10 * (1073741821 - t3) - qe() }), e3.callbackNode = t3;
      }
    }
  }
  function gl(e3, t3) {
    if (fl = 0, t3) return Xl(e3, t3 = cl()), hl(e3), null;
    var n4 = ml(e3);
    if (0 !== n4) {
      if (t3 = e3.callbackNode, (Or & (Rr | Ir)) !== Nr) throw Error(f2(327));
      if (Rl(), e3 === Br && n4 === Ar || vl(e3, n4), null !== Hr) {
        var r4 = Or;
        Or |= Rr;
        for (var l3 = xl(); ; ) try {
          Cl();
          break;
        } catch (t4) {
          Tl(e3, t4);
        }
        if (ct(), Or = r4, Pr.current = l3, Lr === Fr) throw t3 = $r, vl(e3, n4), Yl(e3, n4), hl(e3), t3;
        if (null === Hr) switch (l3 = e3.finishedWork = e3.current.alternate, e3.finishedExpirationTime = n4, r4 = Lr, Br = null, r4) {
          case Mr:
          case Fr:
            throw Error(f2(345));
          case Qr:
            Xl(e3, 2 < n4 ? 2 : n4);
            break;
          case Dr:
            if (Yl(e3, n4), n4 === (r4 = e3.lastSuspendedTime) && (e3.nextKnownPendingLevel = Pl(l3)), 1073741823 === qr && 10 < (l3 = Jr + Xr - qe())) {
              if (Yr) {
                var i3 = e3.lastPingedTime;
                if (0 === i3 || i3 >= n4) {
                  e3.lastPingedTime = n4, vl(e3, n4);
                  break;
                }
              }
              if (0 !== (i3 = ml(e3)) && i3 !== n4) break;
              if (0 !== r4 && r4 !== n4) {
                e3.lastPingedTime = r4;
                break;
              }
              e3.timeoutHandle = A(_l.bind(null, e3), l3);
              break;
            }
            _l(e3);
            break;
          case Wr:
            if (Yl(e3, n4), n4 === (r4 = e3.lastSuspendedTime) && (e3.nextKnownPendingLevel = Pl(l3)), Yr && (0 === (l3 = e3.lastPingedTime) || l3 >= n4)) {
              e3.lastPingedTime = n4, vl(e3, n4);
              break;
            }
            if (0 !== (l3 = ml(e3)) && l3 !== n4) break;
            if (0 !== r4 && r4 !== n4) {
              e3.lastPingedTime = r4;
              break;
            }
            if (1073741823 !== Vr ? r4 = 10 * (1073741821 - Vr) - qe() : 1073741823 === qr ? r4 = 0 : (r4 = 10 * (1073741821 - qr) - 5e3, 0 > (r4 = (l3 = qe()) - r4) && (r4 = 0), (n4 = 10 * (1073741821 - n4) - l3) < (r4 = (120 > r4 ? 120 : 480 > r4 ? 480 : 1080 > r4 ? 1080 : 1920 > r4 ? 1920 : 3e3 > r4 ? 3e3 : 4320 > r4 ? 4320 : 1960 * zr(r4 / 1960)) - r4) && (r4 = n4)), 10 < r4) {
              e3.timeoutHandle = A(_l.bind(null, e3), r4);
              break;
            }
            _l(e3);
            break;
          case jr:
            if (1073741823 !== qr && null !== Kr) {
              i3 = qr;
              var a4 = Kr;
              if (0 >= (r4 = 0 | a4.busyMinDurationMs) ? r4 = 0 : (l3 = 0 | a4.busyDelayMs, r4 = (i3 = qe() - (10 * (1073741821 - i3) - (0 | a4.timeoutMs || 5e3))) <= l3 ? 0 : l3 + r4 - i3), 10 < r4) {
                Yl(e3, n4), e3.timeoutHandle = A(_l.bind(null, e3), r4);
                break;
              }
            }
            _l(e3);
            break;
          default:
            throw Error(f2(329));
        }
        if (hl(e3), e3.callbackNode === t3) return gl.bind(null, e3);
      }
    }
    return null;
  }
  function bl(e3) {
    var t3 = e3.lastExpiredTime;
    if (t3 = 0 !== t3 ? t3 : 1073741823, e3.finishedExpirationTime === t3) _l(e3);
    else {
      if ((Or & (Rr | Ir)) !== Nr) throw Error(f2(327));
      if (Rl(), e3 === Br && t3 === Ar || vl(e3, t3), null !== Hr) {
        var n4 = Or;
        Or |= Rr;
        for (var r4 = xl(); ; ) try {
          Sl();
          break;
        } catch (t4) {
          Tl(e3, t4);
        }
        if (ct(), Or = n4, Pr.current = r4, Lr === Fr) throw n4 = $r, vl(e3, t3), Yl(e3, t3), hl(e3), n4;
        if (null !== Hr) throw Error(f2(261));
        e3.finishedWork = e3.current.alternate, e3.finishedExpirationTime = t3, Br = null, _l(e3), hl(e3);
      }
    }
    return null;
  }
  function yl(e3, t3) {
    if ((Or & (Rr | Ir)) !== Nr) throw Error(f2(187));
    var n4 = Or;
    Or |= 1;
    try {
      return Ge(99, e3.bind(null, t3));
    } finally {
      Or = n4, Xe();
    }
  }
  function vl(e3, t3) {
    e3.finishedWork = null, e3.finishedExpirationTime = 0;
    var n4 = e3.timeoutHandle;
    if (n4 !== $ && (e3.timeoutHandle = $, L(n4)), null !== Hr) for (n4 = Hr.return; null !== n4; ) {
      var r4 = n4;
      switch (r4.tag) {
        case 1:
          var l3 = r4.type.childContextTypes;
          null != l3 && Ee();
          break;
        case 3:
          Kt(), ke();
          break;
        case 5:
          Yt(r4);
          break;
        case 4:
          Kt();
          break;
        case 13:
        case 19:
          me(Jt);
          break;
        case 10:
          dt(r4);
      }
      n4 = n4.return;
    }
    Br = e3, Hr = Al(e3.current, null), Ar = t3, Lr = Mr, $r = null, Vr = qr = 1073741823, Kr = null, Gr = 0, Yr = false;
  }
  function Tl(e3, t3) {
    for (; ; ) {
      try {
        if (ct(), vn(), null === Hr || null === Hr.return) return Lr = Fr, $r = t3, null;
        e: {
          var n4 = e3, r4 = Hr.return, l3 = Hr, i3 = t3;
          if (t3 = Ar, l3.effectTag |= 2048, l3.firstEffect = l3.lastEffect = null, null !== i3 && "object" == typeof i3 && "function" == typeof i3.then) {
            var a4 = i3, u3 = 0 != (1 & Jt.current), o3 = r4;
            do {
              var f3;
              if (f3 = 13 === o3.tag) {
                var c4 = o3.memoizedState;
                if (null !== c4) f3 = null !== c4.dehydrated;
                else {
                  var s3 = o3.memoizedProps;
                  f3 = void 0 !== s3.fallback && (true !== s3.unstable_avoidThisFallback || !u3);
                }
              }
              if (f3) {
                var d3 = o3.updateQueue;
                if (null === d3) {
                  var p3 = /* @__PURE__ */ new Set();
                  p3.add(a4), o3.updateQueue = p3;
                } else d3.add(a4);
                if (0 == (2 & o3.mode)) {
                  if (o3.effectTag |= 64, l3.effectTag &= -2981, 1 === l3.tag) if (null === l3.alternate) l3.tag = 17;
                  else {
                    var m2 = vt(1073741823, null);
                    m2.tag = 2, xt(l3, m2);
                  }
                  l3.expirationTime = 1073741823;
                  break e;
                }
                i3 = void 0, l3 = t3;
                var h3 = n4.pingCache;
                if (null === h3 ? (h3 = n4.pingCache = new kr(), i3 = /* @__PURE__ */ new Set(), h3.set(a4, i3)) : void 0 === (i3 = h3.get(a4)) && (i3 = /* @__PURE__ */ new Set(), h3.set(a4, i3)), !i3.has(l3)) {
                  i3.add(l3);
                  var g3 = Ql.bind(null, n4, a4, l3);
                  a4.then(g3, g3);
                }
                o3.effectTag |= 4096, o3.expirationTime = t3;
                break e;
              }
              o3 = o3.return;
            } while (null !== o3);
            i3 = Error((z(l3.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + se(l3));
          }
          Lr !== jr && (Lr = Qr), i3 = fr(i3, l3), o3 = r4;
          do {
            switch (o3.tag) {
              case 3:
                a4 = i3, o3.effectTag |= 4096, o3.expirationTime = t3, Et(o3, Sr(o3, a4, t3));
                break e;
              case 1:
                a4 = i3;
                var b3 = o3.type, y3 = o3.stateNode;
                if (0 == (64 & o3.effectTag) && ("function" == typeof b3.getDerivedStateFromError || null !== y3 && "function" == typeof y3.componentDidCatch && (null === nl || !nl.has(y3)))) {
                  o3.effectTag |= 4096, o3.expirationTime = t3, Et(o3, Cr(o3, a4, t3));
                  break e;
                }
            }
            o3 = o3.return;
          } while (null !== o3);
        }
        Hr = zl(Hr);
      } catch (e4) {
        t3 = e4;
        continue;
      }
      break;
    }
  }
  function xl() {
    var e3 = Pr.current;
    return Pr.current = Qn, null === e3 ? Qn : e3;
  }
  function El(e3, t3) {
    e3 < qr && 2 < e3 && (qr = e3), null !== t3 && e3 < Vr && 2 < e3 && (Vr = e3, Kr = t3);
  }
  function kl(e3) {
    e3 > Gr && (Gr = e3);
  }
  function Sl() {
    for (; null !== Hr; ) Hr = wl(Hr);
  }
  function Cl() {
    for (; null !== Hr && !Ue(); ) Hr = wl(Hr);
  }
  function wl(e3) {
    var t3 = wr(e3.alternate, e3, Ar);
    return e3.memoizedProps = e3.pendingProps, null === t3 && (t3 = zl(e3)), _r.current = null, t3;
  }
  function zl(e3) {
    Hr = e3;
    do {
      var t3 = Hr.alternate;
      if (e3 = Hr.return, 0 == (2048 & Hr.effectTag)) {
        e: {
          var n4 = t3, r4 = Ar, l3 = (t3 = Hr).pendingProps;
          switch (t3.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
            case 20:
            case 21:
              break;
            case 1:
            case 17:
              xe(t3.type) && Ee();
              break;
            case 3:
              Kt(), ke(), (l3 = t3.stateNode).pendingContext && (l3.context = l3.pendingContext, l3.pendingContext = null), null === n4 || n4.child, Jn(t3);
              break;
            case 5:
              Yt(t3);
              var i3 = qt($t.current);
              if (r4 = t3.type, null !== n4 && null != t3.stateNode) Xn(n4, t3, r4, l3, i3), n4.ref !== t3.ref && (t3.effectTag |= 128);
              else if (l3) {
                n4 = qt(At.current);
                var a4 = D(r4, l3, i3, n4, t3);
                Yn(a4, t3, false, false), t3.stateNode = a4, j(a4, r4, l3, i3, n4) && ar(t3), null !== t3.ref && (t3.effectTag |= 128);
              } else if (null === t3.stateNode) throw Error(f2(166));
              break;
            case 6:
              if (n4 && null != t3.stateNode) Zn(n4, t3, n4.memoizedProps, l3);
              else {
                if ("string" != typeof l3 && null === t3.stateNode) throw Error(f2(166));
                n4 = qt($t.current), i3 = qt(At.current), t3.stateNode = H(l3, n4, i3, t3);
              }
              break;
            case 13:
              if (me(Jt), l3 = t3.memoizedState, 0 != (64 & t3.effectTag)) {
                t3.expirationTime = r4;
                break e;
              }
              l3 = null !== l3, i3 = false, null === n4 ? t3.memoizedProps.fallback : (i3 = null !== (r4 = n4.memoizedState), l3 || null === r4 || null !== (r4 = n4.child.sibling) && (null !== (a4 = t3.firstEffect) ? (t3.firstEffect = r4, r4.nextEffect = a4) : (t3.firstEffect = t3.lastEffect = r4, r4.nextEffect = null), r4.effectTag = 8)), l3 && !i3 && 0 != (2 & t3.mode) && (null === n4 && true !== t3.memoizedProps.unstable_avoidThisFallback || 0 != (1 & Jt.current) ? Lr === Mr && (Lr = Dr) : (Lr !== Mr && Lr !== Dr || (Lr = Wr), 0 !== Gr && null !== Br && (Yl(Br, Ar), Jl(Br, Gr)))), (l3 || i3) && (t3.effectTag |= 4);
              break;
            case 4:
              Kt(), Jn(t3);
              break;
            case 10:
              dt(t3);
              break;
            case 19:
              if (me(Jt), null === (l3 = t3.memoizedState)) break;
              if (i3 = 0 != (64 & t3.effectTag), null === (a4 = l3.rendering)) {
                if (i3) ur(l3, false);
                else if (Lr !== Mr || null !== n4 && 0 != (64 & n4.effectTag)) for (n4 = t3.child; null !== n4; ) {
                  if (null !== (a4 = Xt(n4))) {
                    for (t3.effectTag |= 64, ur(l3, false), null !== (n4 = a4.updateQueue) && (t3.updateQueue = n4, t3.effectTag |= 4), null === l3.lastEffect && (t3.firstEffect = null), t3.lastEffect = l3.lastEffect, n4 = r4, l3 = t3.child; null !== l3; ) r4 = n4, (i3 = l3).effectTag &= 2, i3.nextEffect = null, i3.firstEffect = null, i3.lastEffect = null, null === (a4 = i3.alternate) ? (i3.childExpirationTime = 0, i3.expirationTime = r4, i3.child = null, i3.memoizedProps = null, i3.memoizedState = null, i3.updateQueue = null, i3.dependencies = null) : (i3.childExpirationTime = a4.childExpirationTime, i3.expirationTime = a4.expirationTime, i3.child = a4.child, i3.memoizedProps = a4.memoizedProps, i3.memoizedState = a4.memoizedState, i3.updateQueue = a4.updateQueue, r4 = a4.dependencies, i3.dependencies = null === r4 ? null : { expirationTime: r4.expirationTime, firstContext: r4.firstContext, responders: r4.responders }), l3 = l3.sibling;
                    he(Jt, 1 & Jt.current | 2), t3 = t3.child;
                    break e;
                  }
                  n4 = n4.sibling;
                }
              } else {
                if (!i3) if (null !== (n4 = Xt(a4))) {
                  if (t3.effectTag |= 64, i3 = true, null !== (n4 = n4.updateQueue) && (t3.updateQueue = n4, t3.effectTag |= 4), ur(l3, true), null === l3.tail && "hidden" === l3.tailMode) {
                    null !== (t3 = t3.lastEffect = l3.lastEffect) && (t3.nextEffect = null);
                    break;
                  }
                } else qe() > l3.tailExpiration && 1 < r4 && (t3.effectTag |= 64, i3 = true, ur(l3, false), t3.expirationTime = t3.childExpirationTime = r4 - 1);
                l3.isBackwards ? (a4.sibling = t3.child, t3.child = a4) : (null !== (n4 = l3.last) ? n4.sibling = a4 : t3.child = a4, l3.last = a4);
              }
              if (null !== l3.tail) {
                0 === l3.tailExpiration && (l3.tailExpiration = qe() + 500), n4 = l3.tail, l3.rendering = n4, l3.tail = n4.sibling, l3.lastEffect = t3.lastEffect, n4.sibling = null, l3 = Jt.current, he(Jt, l3 = i3 ? 1 & l3 | 2 : 1 & l3), t3 = n4;
                break e;
              }
              break;
            default:
              throw Error(f2(156, t3.tag));
          }
          t3 = null;
        }
        if (n4 = Hr, 1 === Ar || 1 !== n4.childExpirationTime) {
          for (l3 = 0, i3 = n4.child; null !== i3; ) (r4 = i3.expirationTime) > l3 && (l3 = r4), (a4 = i3.childExpirationTime) > l3 && (l3 = a4), i3 = i3.sibling;
          n4.childExpirationTime = l3;
        }
        if (null !== t3) return t3;
        null !== e3 && 0 == (2048 & e3.effectTag) && (null === e3.firstEffect && (e3.firstEffect = Hr.firstEffect), null !== Hr.lastEffect && (null !== e3.lastEffect && (e3.lastEffect.nextEffect = Hr.firstEffect), e3.lastEffect = Hr.lastEffect), 1 < Hr.effectTag && (null !== e3.lastEffect ? e3.lastEffect.nextEffect = Hr : e3.firstEffect = Hr, e3.lastEffect = Hr));
      } else {
        if (null !== (t3 = or(Hr))) return t3.effectTag &= 2047, t3;
        null !== e3 && (e3.firstEffect = e3.lastEffect = null, e3.effectTag |= 2048);
      }
      if (null !== (t3 = Hr.sibling)) return t3;
      Hr = e3;
    } while (null !== Hr);
    return Lr === Mr && (Lr = jr), null;
  }
  function Pl(e3) {
    var t3 = e3.expirationTime;
    return t3 > (e3 = e3.childExpirationTime) ? t3 : e3;
  }
  function _l(e3) {
    var t3 = Ve();
    return Ge(99, Nl.bind(null, e3, t3)), null;
  }
  function Nl(e3, t3) {
    if (Rl(), (Or & (Rr | Ir)) !== Nr) throw Error(f2(327));
    var n4 = e3.finishedWork, r4 = e3.finishedExpirationTime;
    if (null === n4) return null;
    if (e3.finishedWork = null, e3.finishedExpirationTime = 0, n4 === e3.current) throw Error(f2(177));
    e3.callbackNode = null, e3.callbackExpirationTime = 0, e3.callbackPriority = 90, e3.nextKnownPendingLevel = 0;
    var l3 = Pl(n4);
    if (e3.firstPendingTime = l3, r4 <= e3.lastSuspendedTime ? e3.firstSuspendedTime = e3.lastSuspendedTime = e3.nextKnownPendingLevel = 0 : r4 <= e3.firstSuspendedTime && (e3.firstSuspendedTime = r4 - 1), r4 <= e3.lastPingedTime && (e3.lastPingedTime = 0), r4 <= e3.lastExpiredTime && (e3.lastExpiredTime = 0), e3 === Br && (Hr = Br = null, Ar = 0), 1 < n4.effectTag ? null !== n4.lastEffect ? (n4.lastEffect.nextEffect = n4, l3 = n4.firstEffect) : l3 = n4 : l3 = n4.firstEffect, null !== l3) {
      var i3 = Or;
      Or |= Ir, _r.current = null, F(e3.containerInfo), Zr = l3;
      do {
        try {
          Ul();
        } catch (e4) {
          if (null === Zr) throw Error(f2(330));
          Fl(Zr, e4), Zr = Zr.nextEffect;
        }
      } while (null !== Zr);
      Zr = l3;
      do {
        try {
          for (var a4 = e3, u3 = t3; null !== Zr; ) {
            var o3 = Zr.effectTag;
            if (16 & o3 && q && re(Zr.stateNode), 128 & o3) {
              var c4 = Zr.alternate;
              if (null !== c4) {
                var s3 = c4.ref;
                null !== s3 && ("function" == typeof s3 ? s3(null) : s3.current = null);
              }
            }
            switch (1038 & o3) {
              case 2:
                vr(Zr), Zr.effectTag &= -3;
                break;
              case 6:
                vr(Zr), Zr.effectTag &= -3, xr(Zr.alternate, Zr);
                break;
              case 1024:
                Zr.effectTag &= -1025;
                break;
              case 1028:
                Zr.effectTag &= -1025, xr(Zr.alternate, Zr);
                break;
              case 4:
                xr(Zr.alternate, Zr);
                break;
              case 8:
                var d3 = a4, p3 = Zr, m2 = u3;
                q ? Tr(d3, p3, m2) : gr(d3, p3, m2), br(p3);
            }
            Zr = Zr.nextEffect;
          }
        } catch (e4) {
          if (null === Zr) throw Error(f2(330));
          Fl(Zr, e4), Zr = Zr.nextEffect;
        }
      } while (null !== Zr);
      Q(e3.containerInfo), e3.current = n4, Zr = l3;
      do {
        try {
          for (o3 = r4; null !== Zr; ) {
            var h3 = Zr.effectTag;
            if (36 & h3) {
              var g3 = Zr.alternate;
              switch (s3 = o3, (c4 = Zr).tag) {
                case 0:
                case 11:
                case 15:
                  mr(16, 32, c4);
                  break;
                case 1:
                  var b3 = c4.stateNode;
                  if (4 & c4.effectTag) if (null === g3) b3.componentDidMount();
                  else {
                    var y3 = c4.elementType === c4.type ? g3.memoizedProps : it(c4.type, g3.memoizedProps);
                    b3.componentDidUpdate(y3, g3.memoizedState, b3.__reactInternalSnapshotBeforeUpdate);
                  }
                  var v3 = c4.updateQueue;
                  null !== v3 && wt(0, v3, b3);
                  break;
                case 3:
                  var T2 = c4.updateQueue;
                  if (null !== T2) {
                    if (a4 = null, null !== c4.child) switch (c4.child.tag) {
                      case 5:
                        a4 = R(c4.child.stateNode);
                        break;
                      case 1:
                        a4 = c4.child.stateNode;
                    }
                    wt(0, T2, a4);
                  }
                  break;
                case 5:
                  var x2 = c4.stateNode;
                  null === g3 && 4 & c4.effectTag && J(x2, c4.type, c4.memoizedProps, c4);
                  break;
                case 6:
                case 4:
                case 12:
                case 19:
                case 17:
                case 20:
                case 21:
                  break;
                case 13:
                  V && c4.memoizedState;
                  break;
                default:
                  throw Error(f2(163));
              }
            }
            if (128 & h3) {
              c4 = void 0;
              var E2 = Zr.ref;
              if (null !== E2) {
                var k3 = Zr.stateNode;
                c4 = 5 === Zr.tag ? R(k3) : k3, "function" == typeof E2 ? E2(c4) : E2.current = c4;
              }
            }
            Zr = Zr.nextEffect;
          }
        } catch (e4) {
          if (null === Zr) throw Error(f2(330));
          Fl(Zr, e4), Zr = Zr.nextEffect;
        }
      } while (null !== Zr);
      Zr = null, Be(), Or = i3;
    } else e3.current = n4;
    if (rl) rl = false, ll = e3, il = t3;
    else for (Zr = l3; null !== Zr; ) t3 = Zr.nextEffect, Zr.nextEffect = null, Zr = t3;
    if (0 === (t3 = e3.firstPendingTime) && (nl = null), 1073741823 === t3 ? e3 === ol ? ul++ : (ul = 0, ol = e3) : ul = 0, "function" == typeof Wl && Wl(n4.stateNode, r4), hl(e3), el) throw el = false, e3 = tl, tl = null, e3;
    return (Or & Ur) !== Nr || Xe(), null;
  }
  function Ul() {
    for (; null !== Zr; ) {
      var e3 = Zr.effectTag;
      0 != (256 & e3) && pr(Zr.alternate, Zr), 0 == (512 & e3) || rl || (rl = true, Ye(97, function() {
        return Rl(), null;
      })), Zr = Zr.nextEffect;
    }
  }
  function Rl() {
    if (90 !== il) {
      var e3 = 97 < il ? 97 : il;
      return il = 90, Ge(e3, Il);
    }
  }
  function Il() {
    if (null === ll) return false;
    var e3 = ll;
    if (ll = null, (Or & (Rr | Ir)) !== Nr) throw Error(f2(331));
    var t3 = Or;
    for (Or |= Ir, e3 = e3.current.firstEffect; null !== e3; ) {
      try {
        var n4 = e3;
        if (0 != (512 & n4.effectTag)) switch (n4.tag) {
          case 0:
          case 11:
          case 15:
            mr(128, 0, n4), mr(0, 64, n4);
        }
      } catch (t4) {
        if (null === e3) throw Error(f2(330));
        Fl(e3, t4);
      }
      n4 = e3.nextEffect, e3.nextEffect = null, e3 = n4;
    }
    return Or = t3, Xe(), true;
  }
  function Ml(e3, t3, n4) {
    xt(e3, t3 = Sr(e3, t3 = fr(n4, t3), 1073741823)), null !== (e3 = pl(e3, 1073741823)) && hl(e3);
  }
  function Fl(e3, t3) {
    if (3 === e3.tag) Ml(e3, e3, t3);
    else for (var n4 = e3.return; null !== n4; ) {
      if (3 === n4.tag) {
        Ml(n4, e3, t3);
        break;
      }
      if (1 === n4.tag) {
        var r4 = n4.stateNode;
        if ("function" == typeof n4.type.getDerivedStateFromError || "function" == typeof r4.componentDidCatch && (null === nl || !nl.has(r4))) {
          xt(n4, e3 = Cr(n4, e3 = fr(t3, e3), 1073741823)), null !== (n4 = pl(n4, 1073741823)) && hl(n4);
          break;
        }
      }
      n4 = n4.return;
    }
  }
  function Ql(e3, t3, n4) {
    var r4 = e3.pingCache;
    null !== r4 && r4.delete(t3), Br === e3 && Ar === n4 ? Lr === Wr || Lr === Dr && 1073741823 === qr && qe() - Jr < Xr ? vl(e3, Ar) : Yr = true : Gl(e3, n4) && (0 !== (t3 = e3.lastPingedTime) && t3 < n4 || (e3.lastPingedTime = n4, e3.finishedExpirationTime === n4 && (e3.finishedExpirationTime = 0, e3.finishedWork = null), hl(e3)));
  }
  function Dl(e3, t3) {
    var n4 = e3.stateNode;
    null !== n4 && n4.delete(t3), 0 == (t3 = 0) && (t3 = sl(t3 = cl(), e3, null)), null !== (e3 = pl(e3, t3)) && hl(e3);
  }
  wr = function(e3, t3, n4) {
    var r4 = t3.expirationTime;
    if (null !== e3) {
      var l3 = t3.pendingProps;
      if (e3.memoizedProps !== l3 || ye.current) On = true;
      else {
        if (r4 < n4) {
          switch (On = false, t3.tag) {
            case 3:
              Gn(t3);
              break;
            case 5:
              if (Gt(t3), 4 & t3.mode && 1 !== n4 && null(t3.type, l3)) return t3.expirationTime = t3.childExpirationTime = 1, null;
              break;
            case 1:
              xe(t3.type) && we(t3);
              break;
            case 4:
              Vt(t3, t3.stateNode.containerInfo);
              break;
            case 10:
              st(t3, t3.memoizedProps.value);
              break;
            case 13:
              if (null !== t3.memoizedState) return 0 !== (r4 = t3.child.childExpirationTime) && r4 >= n4 ? tr(e3, t3, n4) : (he(Jt, 1 & Jt.current), null !== (t3 = ir(e3, t3, n4)) ? t3.sibling : null);
              he(Jt, 1 & Jt.current);
              break;
            case 19:
              if (r4 = t3.childExpirationTime >= n4, 0 != (64 & e3.effectTag)) {
                if (r4) return lr(e3, t3, n4);
                t3.effectTag |= 64;
              }
              if (null !== (l3 = t3.memoizedState) && (l3.rendering = null, l3.tail = null), he(Jt, Jt.current), !r4) return null;
          }
          return ir(e3, t3, n4);
        }
        On = false;
      }
    } else On = false;
    switch (t3.expirationTime = 0, t3.tag) {
      case 2:
        if (r4 = t3.type, null !== e3 && (e3.alternate = null, t3.alternate = null, t3.effectTag |= 2), e3 = t3.pendingProps, l3 = Te(t3, be.current), mt(t3, n4), l3 = yn(null, t3, r4, e3, l3, n4), t3.effectTag |= 1, "object" == typeof l3 && null !== l3 && "function" == typeof l3.render && void 0 === l3.$$typeof) {
          if (t3.tag = 1, vn(), xe(r4)) {
            var i3 = true;
            we(t3);
          } else i3 = false;
          t3.memoizedState = null !== l3.state && void 0 !== l3.state ? l3.state : null;
          var a4 = r4.getDerivedStateFromProps;
          "function" == typeof a4 && Nt(t3, r4, a4, e3), l3.updater = Ut, t3.stateNode = l3, l3._reactInternalFiber = t3, Ft(t3, r4, e3, n4), t3 = Kn(null, t3, r4, true, i3, n4);
        } else t3.tag = 0, Bn(null, t3, l3, n4), t3 = t3.child;
        return t3;
      case 16:
        if (l3 = t3.elementType, null !== e3 && (e3.alternate = null, t3.alternate = null, t3.effectTag |= 2), e3 = t3.pendingProps, function(e4) {
          if (-1 === e4._status) {
            e4._status = 0;
            var t4 = e4._ctor;
            t4 = t4(), e4._result = t4, t4.then(function(t5) {
              0 === e4._status && (t5 = t5.default, e4._status = 1, e4._result = t5);
            }, function(t5) {
              0 === e4._status && (e4._status = 2, e4._result = t5);
            });
          }
        }(l3), 1 !== l3._status) throw l3._result;
        switch (l3 = l3._result, t3.type = l3, i3 = t3.tag = function(e4) {
          if ("function" == typeof e4) return Hl(e4) ? 1 : 0;
          if (null != e4) {
            if ((e4 = e4.$$typeof) === T) return 11;
            if (e4 === k2) return 14;
          }
          return 2;
        }(l3), e3 = it(l3, e3), i3) {
          case 0:
            t3 = qn(null, t3, l3, e3, n4);
            break;
          case 1:
            t3 = Vn(null, t3, l3, e3, n4);
            break;
          case 11:
            t3 = Hn(null, t3, l3, e3, n4);
            break;
          case 14:
            t3 = An(null, t3, l3, it(l3.type, e3), r4, n4);
            break;
          default:
            throw Error(f2(306, l3, ""));
        }
        return t3;
      case 0:
        return r4 = t3.type, l3 = t3.pendingProps, qn(e3, t3, r4, l3 = t3.elementType === r4 ? l3 : it(r4, l3), n4);
      case 1:
        return r4 = t3.type, l3 = t3.pendingProps, Vn(e3, t3, r4, l3 = t3.elementType === r4 ? l3 : it(r4, l3), n4);
      case 3:
        if (Gn(t3), null === (r4 = t3.updateQueue)) throw Error(f2(282));
        if (l3 = null !== (l3 = t3.memoizedState) ? l3.element : null, Ct(t3, r4, t3.pendingProps, null, n4), (r4 = t3.memoizedState.element) === l3) t3 = ir(e3, t3, n4);
        else {
          if ((l3 = t3.stateNode.hydrate) && (l3 = false), l3) for (n4 = Bt(t3, null, r4, n4), t3.child = n4; n4; ) n4.effectTag = -3 & n4.effectTag | 1024, n4 = n4.sibling;
          else Bn(e3, t3, r4, n4);
          t3 = t3.child;
        }
        return t3;
      case 5:
        return Gt(t3), r4 = t3.type, l3 = t3.pendingProps, i3 = null !== e3 ? e3.memoizedProps : null, a4 = l3.children, B(r4, l3) ? a4 = null : null !== i3 && B(r4, i3) && (t3.effectTag |= 16), $n(e3, t3), 4 & t3.mode && 1 !== n4 && null(r4, l3) ? (t3.expirationTime = t3.childExpirationTime = 1, t3 = null) : (Bn(e3, t3, a4, n4), t3 = t3.child), t3;
      case 6:
        return null;
      case 13:
        return tr(e3, t3, n4);
      case 4:
        return Vt(t3, t3.stateNode.containerInfo), r4 = t3.pendingProps, null === e3 ? t3.child = Ot(t3, null, r4, n4) : Bn(e3, t3, r4, n4), t3.child;
      case 11:
        return r4 = t3.type, l3 = t3.pendingProps, Hn(e3, t3, r4, l3 = t3.elementType === r4 ? l3 : it(r4, l3), n4);
      case 7:
        return Bn(e3, t3, t3.pendingProps, n4), t3.child;
      case 8:
      case 12:
        return Bn(e3, t3, t3.pendingProps.children, n4), t3.child;
      case 10:
        e: {
          if (r4 = t3.type._context, l3 = t3.pendingProps, a4 = t3.memoizedProps, st(t3, i3 = l3.value), null !== a4) {
            var u3 = a4.value;
            if (0 == (i3 = nt(u3, i3) ? 0 : 0 | ("function" == typeof r4._calculateChangedBits ? r4._calculateChangedBits(u3, i3) : 1073741823))) {
              if (a4.children === l3.children && !ye.current) {
                t3 = ir(e3, t3, n4);
                break e;
              }
            } else for (null !== (u3 = t3.child) && (u3.return = t3); null !== u3; ) {
              var o3 = u3.dependencies;
              if (null !== o3) {
                a4 = u3.child;
                for (var c4 = o3.firstContext; null !== c4; ) {
                  if (c4.context === r4 && 0 != (c4.observedBits & i3)) {
                    1 === u3.tag && ((c4 = vt(n4, null)).tag = 2, xt(u3, c4)), u3.expirationTime < n4 && (u3.expirationTime = n4), null !== (c4 = u3.alternate) && c4.expirationTime < n4 && (c4.expirationTime = n4), pt(u3.return, n4), o3.expirationTime < n4 && (o3.expirationTime = n4);
                    break;
                  }
                  c4 = c4.next;
                }
              } else a4 = 10 === u3.tag && u3.type === t3.type ? null : u3.child;
              if (null !== a4) a4.return = u3;
              else for (a4 = u3; null !== a4; ) {
                if (a4 === t3) {
                  a4 = null;
                  break;
                }
                if (null !== (u3 = a4.sibling)) {
                  u3.return = a4.return, a4 = u3;
                  break;
                }
                a4 = a4.return;
              }
              u3 = a4;
            }
          }
          Bn(e3, t3, l3.children, n4), t3 = t3.child;
        }
        return t3;
      case 9:
        return l3 = t3.type, r4 = (i3 = t3.pendingProps).children, mt(t3, n4), r4 = r4(l3 = ht(l3, i3.unstable_observedBits)), t3.effectTag |= 1, Bn(e3, t3, r4, n4), t3.child;
      case 14:
        return i3 = it(l3 = t3.type, t3.pendingProps), An(e3, t3, l3, i3 = it(l3.type, i3), r4, n4);
      case 15:
        return Ln(e3, t3, t3.type, t3.pendingProps, r4, n4);
      case 17:
        return r4 = t3.type, l3 = t3.pendingProps, l3 = t3.elementType === r4 ? l3 : it(r4, l3), null !== e3 && (e3.alternate = null, t3.alternate = null, t3.effectTag |= 2), t3.tag = 1, xe(r4) ? (e3 = true, we(t3)) : e3 = false, mt(t3, n4), It(t3, r4, l3), Ft(t3, r4, l3, n4), Kn(null, t3, r4, true, e3, n4);
      case 19:
        return lr(e3, t3, n4);
    }
    throw Error(f2(156, t3.tag));
  };
  var Wl = null, jl = null;
  function Ol(e3, t3, n4, r4) {
    this.tag = e3, this.key = n4, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t3, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r4, this.effectTag = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childExpirationTime = this.expirationTime = 0, this.alternate = null;
  }
  function Bl(e3, t3, n4, r4) {
    return new Ol(e3, t3, n4, r4);
  }
  function Hl(e3) {
    return !(!(e3 = e3.prototype) || !e3.isReactComponent);
  }
  function Al(e3, t3) {
    var n4 = e3.alternate;
    return null === n4 ? ((n4 = Bl(e3.tag, t3, e3.key, e3.mode)).elementType = e3.elementType, n4.type = e3.type, n4.stateNode = e3.stateNode, n4.alternate = e3, e3.alternate = n4) : (n4.pendingProps = t3, n4.effectTag = 0, n4.nextEffect = null, n4.firstEffect = null, n4.lastEffect = null), n4.childExpirationTime = e3.childExpirationTime, n4.expirationTime = e3.expirationTime, n4.child = e3.child, n4.memoizedProps = e3.memoizedProps, n4.memoizedState = e3.memoizedState, n4.updateQueue = e3.updateQueue, t3 = e3.dependencies, n4.dependencies = null === t3 ? null : { expirationTime: t3.expirationTime, firstContext: t3.firstContext, responders: t3.responders }, n4.sibling = e3.sibling, n4.index = e3.index, n4.ref = e3.ref, n4;
  }
  function Ll(e3, t3, n4, r4, l3, i3) {
    var a4 = 2;
    if (r4 = e3, "function" == typeof e3) Hl(e3) && (a4 = 1);
    else if ("string" == typeof e3) a4 = 5;
    else e: switch (e3) {
      case m:
        return $l(n4.children, l3, i3, t3);
      case v2:
        a4 = 8, l3 |= 7;
        break;
      case h2:
        a4 = 8, l3 |= 1;
        break;
      case g2:
        return (e3 = Bl(12, n4, t3, 8 | l3)).elementType = g2, e3.type = g2, e3.expirationTime = i3, e3;
      case x:
        return (e3 = Bl(13, n4, t3, l3)).type = x, e3.elementType = x, e3.expirationTime = i3, e3;
      case E:
        return (e3 = Bl(19, n4, t3, l3)).elementType = E, e3.expirationTime = i3, e3;
      default:
        if ("object" == typeof e3 && null !== e3) switch (e3.$$typeof) {
          case b2:
            a4 = 10;
            break e;
          case y2:
            a4 = 9;
            break e;
          case T:
            a4 = 11;
            break e;
          case k2:
            a4 = 14;
            break e;
          case S2:
            a4 = 16, r4 = null;
            break e;
        }
        throw Error(f2(130, null == e3 ? e3 : typeof e3, ""));
    }
    return (t3 = Bl(a4, n4, t3, l3)).elementType = e3, t3.type = r4, t3.expirationTime = i3, t3;
  }
  function $l(e3, t3, n4, r4) {
    return (e3 = Bl(7, e3, r4, t3)).expirationTime = n4, e3;
  }
  function ql(e3, t3, n4) {
    return (e3 = Bl(6, e3, null, t3)).expirationTime = n4, e3;
  }
  function Vl(e3, t3, n4) {
    return (t3 = Bl(4, null !== e3.children ? e3.children : [], e3.key, t3)).expirationTime = n4, t3.stateNode = { containerInfo: e3.containerInfo, pendingChildren: null, implementation: e3.implementation }, t3;
  }
  function Kl(e3, t3, n4) {
    this.tag = t3, this.current = null, this.containerInfo = e3, this.pingCache = this.pendingChildren = null, this.finishedExpirationTime = 0, this.finishedWork = null, this.timeoutHandle = $, this.pendingContext = this.context = null, this.hydrate = n4, this.callbackNode = null, this.callbackPriority = 90, this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;
  }
  function Gl(e3, t3) {
    var n4 = e3.firstSuspendedTime;
    return e3 = e3.lastSuspendedTime, 0 !== n4 && n4 >= t3 && e3 <= t3;
  }
  function Yl(e3, t3) {
    var n4 = e3.firstSuspendedTime, r4 = e3.lastSuspendedTime;
    n4 < t3 && (e3.firstSuspendedTime = t3), (r4 > t3 || 0 === n4) && (e3.lastSuspendedTime = t3), t3 <= e3.lastPingedTime && (e3.lastPingedTime = 0), t3 <= e3.lastExpiredTime && (e3.lastExpiredTime = 0);
  }
  function Jl(e3, t3) {
    t3 > e3.firstPendingTime && (e3.firstPendingTime = t3);
    var n4 = e3.firstSuspendedTime;
    0 !== n4 && (t3 >= n4 ? e3.firstSuspendedTime = e3.lastSuspendedTime = e3.nextKnownPendingLevel = 0 : t3 >= e3.lastSuspendedTime && (e3.lastSuspendedTime = t3 + 1), t3 > e3.nextKnownPendingLevel && (e3.nextKnownPendingLevel = t3));
  }
  function Xl(e3, t3) {
    var n4 = e3.lastExpiredTime;
    (0 === n4 || n4 > t3) && (e3.lastExpiredTime = t3);
  }
  function Zl(e3) {
    var t3 = e3._reactInternalFiber;
    if (void 0 === t3) {
      if ("function" == typeof e3.render) throw Error(f2(188));
      throw Error(f2(268, Object.keys(e3)));
    }
    return null === (e3 = U(t3)) ? null : e3.stateNode;
  }
  function ei(e3, t3) {
    null !== (e3 = e3.memoizedState) && null !== e3.dehydrated && e3.retryTime < t3 && (e3.retryTime = t3);
  }
  function ti(e3, t3) {
    ei(e3, t3), (e3 = e3.alternate) && ei(e3, t3);
  }
  var ni = { createContainer: function(e3, t3, n4) {
    return e3 = new Kl(e3, t3, n4), t3 = Bl(3, null, null, 2 === t3 ? 7 : 1 === t3 ? 3 : 0), e3.current = t3, t3.stateNode = e3;
  }, updateContainer: function(e3, t3, n4, r4) {
    var l3 = t3.current, i3 = cl(), a4 = Pt.suspense;
    i3 = sl(i3, l3, a4);
    e: if (n4) {
      t: {
        if (P(n4 = n4._reactInternalFiber) !== n4 || 1 !== n4.tag) throw Error(f2(170));
        var u3 = n4;
        do {
          switch (u3.tag) {
            case 3:
              u3 = u3.stateNode.context;
              break t;
            case 1:
              if (xe(u3.type)) {
                u3 = u3.stateNode.__reactInternalMemoizedMergedChildContext;
                break t;
              }
          }
          u3 = u3.return;
        } while (null !== u3);
        throw Error(f2(171));
      }
      if (1 === n4.tag) {
        var o3 = n4.type;
        if (xe(o3)) {
          n4 = Ce(n4, o3, u3);
          break e;
        }
      }
      n4 = u3;
    } else n4 = ge;
    return null === t3.context ? t3.context = n4 : t3.pendingContext = n4, (t3 = vt(i3, a4)).payload = { element: e3 }, null !== (r4 = void 0 === r4 ? null : r4) && (t3.callback = r4), xt(l3, t3), dl(l3, i3), i3;
  }, batchedEventUpdates: function(e3, t3) {
    var n4 = Or;
    Or |= 2;
    try {
      return e3(t3);
    } finally {
      (Or = n4) === Nr && Xe();
    }
  }, batchedUpdates: function(e3, t3) {
    var n4 = Or;
    Or |= 1;
    try {
      return e3(t3);
    } finally {
      (Or = n4) === Nr && Xe();
    }
  }, unbatchedUpdates: function(e3, t3) {
    var n4 = Or;
    Or &= -2, Or |= Ur;
    try {
      return e3(t3);
    } finally {
      (Or = n4) === Nr && Xe();
    }
  }, deferredUpdates: function(e3) {
    return Ge(97, e3);
  }, syncUpdates: function(e3, t3, n4, r4) {
    return Ge(99, e3.bind(null, t3, n4, r4));
  }, discreteUpdates: function(e3, t3, n4, r4) {
    var l3 = Or;
    Or |= 4;
    try {
      return Ge(98, e3.bind(null, t3, n4, r4));
    } finally {
      (Or = l3) === Nr && Xe();
    }
  }, flushDiscreteUpdates: function() {
    (Or & (1 | Rr | Ir)) === Nr && (function() {
      if (null !== al) {
        var e3 = al;
        al = null, e3.forEach(function(e4, t3) {
          Xl(t3, e4), hl(t3);
        }), Xe();
      }
    }(), Rl());
  }, flushControlled: function(e3) {
    var t3 = Or;
    Or |= 1;
    try {
      Ge(99, e3);
    } finally {
      (Or = t3) === Nr && Xe();
    }
  }, flushSync: yl, flushPassiveEffects: Rl, IsThisRendererActing: { current: false }, getPublicRootInstance: function(e3) {
    return (e3 = e3.current).child ? 5 === e3.child.tag ? R(e3.child.stateNode) : e3.child.stateNode : null;
  }, attemptSynchronousHydration: function(e3) {
    switch (e3.tag) {
      case 3:
        var t3 = e3.stateNode;
        t3.hydrate && function(e4, t4) {
          Xl(e4, t4), hl(e4), (Or & (Rr | Ir)) === Nr && Xe();
        }(t3, t3.firstPendingTime);
        break;
      case 13:
        yl(function() {
          return dl(e3, 1073741823);
        }), t3 = tt(cl(), 150, 100), ti(e3, t3);
    }
  }, attemptUserBlockingHydration: function(e3) {
    if (13 === e3.tag) {
      var t3 = tt(cl(), 150, 100);
      dl(e3, t3), ti(e3, t3);
    }
  }, attemptContinuousHydration: function(e3) {
    if (13 === e3.tag) {
      cl();
      var t3 = et++;
      dl(e3, t3), ti(e3, t3);
    }
  }, attemptHydrationAtCurrentPriority: function(e3) {
    if (13 === e3.tag) {
      var t3 = cl();
      dl(e3, t3 = sl(t3, e3, null)), ti(e3, t3);
    }
  }, findHostInstance: Zl, findHostInstanceWithWarning: function(e3) {
    return Zl(e3);
  }, findHostInstanceWithNoPortals: function(e3) {
    return null === (e3 = function(e4) {
      if (!(e4 = N(e4))) return null;
      for (var t3 = e4; ; ) {
        if (5 === t3.tag || 6 === t3.tag) return t3;
        if (t3.child && 4 !== t3.tag) t3.child.return = t3, t3 = t3.child;
        else {
          if (t3 === e4) break;
          for (; !t3.sibling; ) {
            if (!t3.return || t3.return === e4) return null;
            t3 = t3.return;
          }
          t3.sibling.return = t3.return, t3 = t3.sibling;
        }
      }
      return null;
    }(e3)) ? null : 20 === e3.tag ? e3.stateNode.instance : e3.stateNode;
  }, shouldSuspend: function() {
    return false;
  }, injectIntoDevTools: function(e3) {
    var t3 = e3.findFiberByHostInstance;
    return function(e4) {
      if ("undefined" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
      var t4 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (t4.isDisabled || !t4.supportsFiber) return true;
      try {
        var n4 = t4.inject(e4);
        Wl = function(e5) {
          try {
            t4.onCommitFiberRoot(n4, e5, void 0, 64 == (64 & e5.current.effectTag));
          } catch (e6) {
          }
        }, jl = function(e5) {
          try {
            t4.onCommitFiberUnmount(n4, e5);
          } catch (e6) {
          }
        };
      } catch (e5) {
      }
      return true;
    }(l2({}, e3, { overrideHookState: null, overrideProps: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: c3.ReactCurrentDispatcher, findHostInstanceByFiber: function(e4) {
      return null === (e4 = U(e4)) ? null : e4.stateNode;
    }, findFiberByHostInstance: function(e4) {
      return t3 ? t3(e4) : null;
    }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null }));
  } };
  i2.exports = ni.default || ni;
  var ri = i2.exports;
  return i2.exports = n3, ri;
};
var o = r2(a2.exports);
var f = (e3, t3) => {
  const n4 = Object.keys(e3), r3 = Object.keys(t3);
  if (n4.length !== r3.length) return false;
  for (let r4 = 0; r4 < n4.length; r4 += 1) {
    const l2 = n4[r4];
    if ("render" === l2 && !e3[l2] != !t3[l2]) return false;
    if ("children" !== l2 && e3[l2] !== t3[l2]) {
      if ("object" == typeof e3[l2] && "object" == typeof t3[l2] && f(e3[l2], t3[l2])) continue;
      return false;
    }
    if ("children" === l2 && ("string" == typeof e3[l2] || "string" == typeof t3[l2])) return e3[l2] === t3[l2];
  }
  return true;
};
var c2 = {};
var s = ({ appendChild: e3, appendChildToContainer: t3, commitTextUpdate: n4, commitUpdate: r3, createInstance: l2, createTextInstance: i3, insertBefore: a3, removeChild: u3, removeChildFromContainer: s2, resetAfterCommit: d2 }) => o({ appendChild: e3, appendChildToContainer: t3, appendInitialChild: e3, createInstance: l2, createTextInstance: i3, insertBefore: a3, commitUpdate: r3, commitTextUpdate: n4, removeChild: u3, removeChildFromContainer: s2, resetAfterCommit: d2, shouldSetTextContent: () => false, finalizeInitialChildren: () => false, getPublicInstance: (e4) => e4, getRootHostContext: () => c2, getChildHostContext: () => c2, prepareForCommit() {
}, clearContainer() {
}, resetTextContent() {
}, prepareUpdate: (e4, t4, n5, r4) => !f(n5, r4) });

// node_modules/@react-pdf/reconciler/lib/index.js
var isReact19 = import_react3.default.version.startsWith("19");
var index = isReact19 ? k : s;

// node_modules/@react-pdf/renderer/lib/react-pdf.browser.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var omitNils = (object) => Object.fromEntries(Object.entries(object).filter((_ref) => {
  let [, value2] = _ref;
  return value2 !== void 0;
}));
var createInstance = (type, _ref) => {
  let {
    style,
    children,
    ...props
  } = _ref;
  return {
    type,
    box: {},
    style: style || {},
    props: props || {},
    children: []
  };
};
var createTextInstance = (text) => ({
  type: "TEXT_INSTANCE",
  value: text
});
var appendChild = (parent, child) => {
  const isParentText = parent.type === "TEXT" || parent.type === "LINK" || parent.type === "TSPAN" || parent.type === "NOTE";
  const isChildTextInstance = child.type === "TEXT_INSTANCE";
  const isOrphanTextInstance = isChildTextInstance && !isParentText;
  if (isOrphanTextInstance) {
    console.warn(`Invalid '${child.value}' string child outside <Text> component`);
    return;
  }
  parent.children.push(child);
};
var appendChildToContainer = (parentInstance, child) => {
  if (parentInstance.type === "ROOT") {
    parentInstance.document = child;
  } else {
    appendChild(parentInstance, child);
  }
};
var insertBefore = (parentInstance, child, beforeChild) => {
  var _parentInstance$child;
  const index3 = (_parentInstance$child = parentInstance.children) === null || _parentInstance$child === void 0 ? void 0 : _parentInstance$child.indexOf(beforeChild);
  if (index3 === void 0) return;
  if (index3 !== -1 && child) parentInstance.children.splice(index3, 0, child);
};
var removeChild = (parentInstance, child) => {
  var _parentInstance$child2;
  const index3 = (_parentInstance$child2 = parentInstance.children) === null || _parentInstance$child2 === void 0 ? void 0 : _parentInstance$child2.indexOf(child);
  if (index3 === void 0) return;
  if (index3 !== -1) parentInstance.children.splice(index3, 1);
};
var removeChildFromContainer = (parentInstance, child) => {
  var _parentInstance$child3;
  const index3 = (_parentInstance$child3 = parentInstance.children) === null || _parentInstance$child3 === void 0 ? void 0 : _parentInstance$child3.indexOf(child);
  if (index3 === void 0) return;
  if (index3 !== -1) parentInstance.children.splice(index3, 1);
};
var commitTextUpdate = (textInstance, oldText, newText) => {
  textInstance.value = newText;
};
var commitUpdate = (instance, updatePayload, type, oldProps, newProps) => {
  const {
    style,
    ...props
  } = newProps;
  instance.props = props;
  instance.style = style;
};
var createRenderer = (_ref2) => {
  let {
    onChange = () => {
    }
  } = _ref2;
  return index({
    appendChild,
    appendChildToContainer,
    commitTextUpdate,
    commitUpdate,
    createInstance,
    createTextInstance,
    insertBefore,
    removeChild,
    removeChildFromContainer,
    resetAfterCommit: onChange
  });
};
var version$1 = "4.2.2";
var packageJson = {
  version: version$1
};
var {
  version: version3
} = packageJson;
var fontStore = new FontStore();
var renderer;
var events = {};
var pdf = (initialValue) => {
  const onChange = () => {
    var _events$change;
    const listeners3 = ((_events$change = events.change) === null || _events$change === void 0 ? void 0 : _events$change.slice()) || [];
    for (let i3 = 0; i3 < listeners3.length; i3 += 1) listeners3[i3]();
  };
  const container = {
    type: "ROOT",
    document: null
  };
  renderer = renderer || createRenderer({
    onChange
  });
  const mountNode = renderer.createContainer(container);
  const updateContainer = (doc, callback) => {
    renderer.updateContainer(doc, mountNode, null, callback);
  };
  if (initialValue) updateContainer(initialValue);
  const render3 = async function(compress) {
    if (compress === void 0) {
      compress = true;
    }
    const props = container.document.props || {};
    const {
      pdfVersion,
      language,
      pageLayout,
      pageMode,
      title: title3,
      author,
      subject,
      keyboards,
      creator = "react-pdf",
      producer = "react-pdf",
      creationDate = /* @__PURE__ */ new Date(),
      modificationDate
    } = props;
    const ctx = new PDFDocument({
      compress,
      pdfVersion,
      lang: language,
      displayTitle: true,
      autoFirstPage: false,
      info: omitNils({
        Title: title3,
        Author: author,
        Subject: subject,
        Keywords: keyboards,
        Creator: creator,
        Producer: producer,
        CreationDate: creationDate,
        ModificationDate: modificationDate
      })
    });
    if (pageLayout) {
      ctx._root.data.PageLayout = upperFirst(pageLayout);
    }
    if (pageMode) {
      ctx._root.data.PageMode = upperFirst(pageMode);
    }
    const layout2 = await layout(container.document, fontStore);
    const fileStream = render(ctx, layout2);
    return {
      layout: layout2,
      fileStream
    };
  };
  const callOnRender = function(params) {
    if (params === void 0) {
      params = {};
    }
    if (container.document.props.onRender) {
      container.document.props.onRender(params);
    }
  };
  const toBlob = async () => {
    const chunks = [];
    const {
      layout: _INTERNAL__LAYOUT__DATA_,
      fileStream: instance
    } = await render3();
    return new Promise((resolve3, reject) => {
      instance.on("data", (chunk) => {
        chunks.push(chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk));
      });
      instance.on("end", () => {
        try {
          const blob = new Blob(chunks, {
            type: "application/pdf"
          });
          callOnRender({
            blob,
            _INTERNAL__LAYOUT__DATA_
          });
          resolve3(blob);
        } catch (error) {
          reject(error);
        }
      });
    });
  };
  const toBuffer = async () => {
    const {
      layout: _INTERNAL__LAYOUT__DATA_,
      fileStream
    } = await render3();
    callOnRender({
      _INTERNAL__LAYOUT__DATA_
    });
    return fileStream;
  };
  const toString7 = async () => {
    if (true) {
      console.warn("`toString` is deprecated and will be removed in next major release");
    }
    let result = "";
    const {
      fileStream: instance
    } = await render3(false);
    return new Promise((resolve3, reject) => {
      try {
        instance.on("data", (buffer) => {
          result += buffer;
        });
        instance.on("end", () => {
          callOnRender();
          resolve3(result);
        });
      } catch (error) {
        reject(error);
      }
    });
  };
  const on3 = (event, listener) => {
    if (!events[event]) events[event] = [];
    events[event].push(listener);
  };
  const removeListener5 = (event, listener) => {
    if (!events[event]) return;
    const idx = events[event].indexOf(listener);
    if (idx > -1) events[event].splice(idx, 1);
  };
  return {
    on: on3,
    container,
    toBlob,
    toBuffer,
    toString: toString7,
    removeListener: removeListener5,
    updateContainer
  };
};
var Font2 = fontStore;
var StyleSheet = {
  create: (s2) => s2
};
var usePDF = function(_temp) {
  let {
    document: document2
  } = _temp === void 0 ? {} : _temp;
  const pdfInstance = (0, import_react4.useRef)(null);
  const [state2, setState] = (0, import_react4.useState)({
    url: null,
    blob: null,
    error: null,
    loading: !!document2
  });
  (0, import_react4.useEffect)(() => {
    const renderQueue = (0, import_queue.default)({
      autostart: true,
      concurrency: 1
    });
    const queueDocumentRender = () => {
      setState((prev) => ({
        ...prev,
        loading: true
      }));
      renderQueue.splice(0, renderQueue.length, () => state2.error ? Promise.resolve() : pdfInstance.current.toBlob());
    };
    const onRenderFailed = (error) => {
      console.error(error);
      setState((prev) => ({
        ...prev,
        loading: false,
        error
      }));
    };
    const onRenderSuccessful = (blob) => {
      setState({
        blob,
        error: null,
        loading: false,
        url: URL.createObjectURL(blob)
      });
    };
    pdfInstance.current = pdf();
    pdfInstance.current.on("change", queueDocumentRender);
    if (document2) {
      pdfInstance.current.updateContainer(document2);
    }
    renderQueue.on("error", onRenderFailed);
    renderQueue.on("success", onRenderSuccessful);
    return () => {
      renderQueue.end();
      pdfInstance.current.removeListener("change", queueDocumentRender);
    };
  }, []);
  (0, import_react4.useEffect)(() => {
    return () => {
      if (state2.url) {
        URL.revokeObjectURL(state2.url);
      }
    };
  }, [state2.url]);
  const update = (0, import_react4.useCallback)((newDoc) => {
    pdfInstance.current.updateContainer(newDoc);
  }, []);
  return [state2, update];
};
var PDFViewer = (_ref) => {
  let {
    title: title3,
    style,
    className,
    children,
    innerRef,
    showToolbar = true,
    ...props
  } = _ref;
  const [instance, updateInstance] = usePDF();
  (0, import_react4.useEffect)(() => updateInstance(children), [children]);
  const src = instance.url ? `${instance.url}#toolbar=${showToolbar ? 1 : 0}` : null;
  return (0, import_jsx_runtime.jsx)("iframe", {
    src,
    title: title3,
    ref: innerRef,
    style,
    className,
    ...props
  });
};
var BlobProvider = (_ref) => {
  let {
    document: doc,
    children
  } = _ref;
  const [instance, updateInstance] = usePDF();
  (0, import_react4.useEffect)(() => updateInstance(doc), [doc]);
  if (!doc) {
    console.warn("You should pass a valid document to BlobProvider");
    return null;
  }
  return children(instance);
};
var PDFDownloadLink = (_ref) => {
  let {
    fileName = "document.pdf",
    document: doc,
    children,
    onClick,
    href,
    ...rest
  } = _ref;
  const [instance, updateInstance] = usePDF();
  (0, import_react4.useEffect)(() => updateInstance(doc), [doc]);
  if (!doc) {
    console.warn("You should pass a valid document to PDFDownloadLink");
    return null;
  }
  const handleDownloadIE = () => {
    if (instance && window.navigator.msSaveBlob) {
      window.navigator.msSaveBlob(instance.blob, fileName);
    }
  };
  const handleClick = (event) => {
    handleDownloadIE();
    if (typeof onClick === "function") onClick(event, instance);
  };
  return (0, import_jsx_runtime.jsx)("a", {
    href: instance.url,
    download: fileName,
    onClick: handleClick,
    ...rest,
    children: typeof children === "function" ? children(instance) : children
  });
};
var throwEnvironmentError = (name) => {
  throw new Error(`${name} is a Node specific API. You're either using this method in a browser, or your bundler is not loading react-pdf from the appropriate web build.`);
};
var renderToStream = () => {
  throwEnvironmentError("renderToStream");
};
var renderToBuffer = () => {
  throwEnvironmentError("renderToBuffer");
};
var renderToString = () => {
  throwEnvironmentError("renderToString");
};
var renderToFile = () => {
  throwEnvironmentError("renderToFile");
};
var render2 = () => {
  throwEnvironmentError("render");
};
var index2 = {
  pdf,
  usePDF,
  Font: Font2,
  version: version3,
  StyleSheet,
  PDFViewer,
  BlobProvider,
  PDFDownloadLink,
  renderToStream,
  renderToString,
  renderToFile,
  render: render2,
  ...lib_exports
};
export {
  BlobProvider,
  Canvas,
  Checkbox,
  Circle,
  ClipPath,
  Defs,
  Document,
  Ellipse,
  FieldSet,
  Font2 as Font,
  G,
  Image,
  Line,
  LinearGradient,
  Link,
  List,
  Note,
  PDFDownloadLink,
  PDFViewer,
  Page,
  Path,
  Polygon,
  Polyline,
  RadialGradient,
  Rect,
  Select,
  Stop,
  StyleSheet,
  Svg,
  Text,
  TextInput,
  TextInstance,
  Tspan,
  View,
  createRenderer,
  index2 as default,
  pdf,
  render2 as render,
  renderToBuffer,
  renderToFile,
  renderToStream,
  renderToString,
  usePDF,
  version3 as version
};
/*! Bundled license information:

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by Cdric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@react-pdf/png-js/lib/png-js.browser.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@react-pdf/pdfkit/lib/pdfkit.browser.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@react-pdf/textkit/lib/textkit.js:
  (**
   * @param nodes
   * @param availableWidths
   * @param tolerance
   * @preserve Knuth and Plass line breaking algorithm in JavaScript
   *)

@react-pdf/image/lib/index.browser.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@react-pdf/reconciler/lib/reconciler-31.js:
  (**
   * @license React
   * react-reconciler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@react-pdf/reconciler/lib/reconciler-31.js:
  (**
   * @license React
   * react-reconciler-constants.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@react-pdf_renderer.js.map
